<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Elektra: DESIGN</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">DESIGN </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes the design of the C-API and provides hints for binding writers. It is not aimed at plugin writers, since it does not talk about the implementation details of Elektra.</p>
<p>Elektra follows two design principles:</p>
<ol type="1">
<li>Make it hard to use the API the wrong way, and</li>
<li>aim towards an easy to use API for programmers reading and writing configuration.</li>
</ol>
<p>Elektra's data structures are optimized to get, set and lookup values easily and fast.</p>
<p>The idea is, that the KDB API is not only implemented by Elektra. Elektra provides a full blown architecture to really support modern Linux Systems, but comes with some overhead. This document describes the <code>KDB</code> API. It also contains some hints about Elektra specific conventions.</p>
<h2>Data Structures</h2>
<p>The <code>Key</code>, <code>KeySet</code> and <code>KDB</code> data structures are defined in <code><a class="el" href="kdbprivate_8h.html" title="Private declarations. ">kdbprivate.h</a></code> to remain ABI compatible when one of them is changed. This means, it is not possible to put one of Elektra's data structures on the stack. You must use the memory management facilities mentioned in the next section.</p>
<h2>Memory Management</h2>
<p>Elektra manages memory itself. This means, a programmer is not allowed to use free on data, which was not allocated by himself. This avoids situation where the programmer forgets to free data, and makes the API more beginner-friendly. In addition to that, <code>elektraMalloc</code> and free must use the same libc version. <code>elektraMalloc</code> in a library linked against another libc, but freed by the application could lead to hard to find bugs.</p>
<p>Some calls that create data, have an opposite call that frees this data. For example after you call: </p><pre class="fragment">    KDB * kdbOpen();
</pre><p>you need to use: </p><pre class="fragment">    int kdbClose(KDB *handle);
</pre><p>to get rid of the resources again. The second function may also shut down connections. Therefore it really must be called at the end of a program. </p><pre class="fragment">    Key *keyNew(const char *keyName, ...);
    int keyDel(Key *key);

    KeySet *ksNew(int alloc, ...);
    int ksDel(KeySet *ks);
</pre><p>In the above pairs, the first function uses elektraMalloc to reserve the necessary amount of memory. The second function frees the allocated data segment. There are more occurrences of <code>elektraMalloc</code>, but they are invisible to the user of the API and happen implicitly within any of these 3 classes: <code>KDB</code>, <code>Key</code> and <code>KeySet</code>.</p>
<p>Names, values, and comments can't be handled as easy, because Elektra does not provide a string library. There are 2 ways to access the mentioned attributes. We show these methods here, using the comment attribute as an example. The function </p><pre class="fragment">    char *keyComment(const Key *key);
</pre><p>just returns a comment. Your are not allowed to change the size of the returned string. The function </p><pre class="fragment">    ssize_t keyGetCommentSize(const Key *key);
</pre><p>shows how long the comment is for the specified key. The returned value also specifies the minimum buffer size that <code>keyGetComment</code> will reserve for the copy of the key. The return value can be directly passed to <code>elektraMalloc</code>. </p><pre class="fragment">    ssize_t keyGetComment(const Key *key, char *returnedDesc, size_t maxSize);
</pre><p>writes the comment in a buffer maintained by you. The minimum size of this buffer is the value returned by the call to the function <code>keyGetCommentSize</code>.</p>
<h2>Variable Arguments</h2>
<p>The constructors for <code>Key</code> and <code>KeySet</code> take a variable sized list of arguments. They can be used as an alternatives to the various <code>keySet*</code> methods and <code>ksAppendKey</code>. With them you are able to generate any <code>Key</code> or <code>KeySet</code> with a single C-statement. This can be done programmatically by <code>keyGenerate</code> or <code>ksGenerate</code> in <code>xmltool</code>.</p>
<p>To just retrieve a key, use </p><pre class="fragment">    Key *k = keyNew(0);
</pre><p>To obtain a <code>keyset</code>, use </p><pre class="fragment">    KeySet *k = ksNew(0, KS_END);
</pre><p>The macros <code>va_start</code> and <code>va_end</code> will not be used then. Alternatively pass a list as described in the documentation.</p>
<h2>Off-by-one</h2>
<p>We avoid Off-by-one errors (OBOE) by starting all indizes with 0, as usual in C. The size returned by the <code>*GetSize</code> functions (<code>keyGetValueSize</code>, <code>keyGetCommentSize</code> and <code>keyGetOwnerSize</code>) is exactly the size you need to allocate. So if you add 1 to it, too much space is allocated, but no error will occur.</p>
<h2>Minimal Set</h2>
<p><code>kdb.h</code> contains a minimal set of functions to fully work with a key database. The functions are implemented in <code>src/libs/elektra</code> in ANSI C.</p>
<p>Functions used by backends are implemented in <code>src/backends/helpers</code>. They need the POSIX interface and can optionally use <code>iconv</code> to handle utf8 conversions.</p>
<h2>Value, String or Binary</h2>
<p>Sometimes people confuse the terms “value”, “string” and “binary”:</p>
<ul>
<li>Value is just a name which does not specify if data is stored as string or in binary form.</li>
<li>A string is a char array, with a terminating `'\0'`.</li>
<li>Binary data is stored in a array of type void, and not terminated by `'\0'`.</li>
</ul>
<p>Only strings may be converted to other charsets. Use the appropriate Get functions, to not be dependent on this internal fact. </p><pre class="fragment">    const void *keyValue(const Key *key);
</pre><p>does not specify whether the returned value is binary or a string. The function just returns the pointer to the value. When <code>key</code> is a string (check with <code>keyIsString</code>) at least <code>""</code> will be returned. See section “Return Values” to learn more about common values returned by Elektra's functions. For binary data a <code>NULL</code> pointer is also possible to distinguish between no data and `'\0'`. </p><pre class="fragment">    ssize_t keyGetValueSize(const Key *key);
</pre><p>does not specify whether the key type is binary or string. The function just returns the size which can be passed to <code>elektraMalloc</code> to hold the entire value. </p><pre class="fragment">    ssize_t keyGetString(const Key *key, char *returnedString, size_t maxSize);
</pre><p>stores the string into a buffer maintained by you. </p><pre class="fragment">    ssize_t keySetString(Key *key, const char *newString);
</pre><p>sets the null terminated string value for a certain key. </p><pre class="fragment">    ssize_t keyGetBinary(const Key *key, void *returnedBinary, size_t maxSize);
</pre><p>retrieves binary data which might contain `'\0'`. </p><pre class="fragment">    ssize_t keySetBinary(Key *key, const void *newBinary, size_t dataSize);
</pre><p>sets the binary data which might contain `'\0'<code>. The length is given by</code>dataSize`.</p>
<h2>Return Value</h2>
<p>Elektra's function share common error codes. Every function must return <code>-1</code> on error, if its return type is integer (like <code>int</code>, <code>ssize_t</code>). If the function returns a pointer, <code>0</code> (<code>NULL</code>) will indicate an error. This behaviour can't be used for functions that return integers, since <code>0</code> is a valid size and can also be used to represent the boolean value <code>false</code>.</p>
<p>Elektra uses integers for the length of C strings, reference counting, <code>KeySet</code> length and internal <code>KeySet</code> allocations.</p>
<p>The interface always accepts <code>size_t</code> and internally uses <code>size_t</code>, which is able to store larger numbers than <code>ssize_t</code>.</p>
<p>The real size of C strings and buffers is limited to <code>SSIZE_MAX</code> which must be checked in every function. When a string exceeds that limit <code>-1</code> or a <code>NULL</code> pointer (see above) must be returned.</p>
<p>The following functions return an internal string: </p><pre class="fragment">    const char *keyName(const Key *key);
    const char *keyBaseName(const Key *key);
    const char *keyOwner(const Key *key);
    const char *keyComment(const Key *key);
</pre><p>and in the case that <code>keyIsBinary(key)==0</code>: </p><pre class="fragment">    const void *keyValue(const Key *key);
</pre><p>does so too. If in any of the functions above <code>key</code> is a <code>NULL</code> pointer, then they also return <code>NULL</code>.</p>
<p>If there is no string you will get back <code>""</code>, that is a pointer to the value `'\0'<code>. The function to determine the size will return</code>1` in that case. That means that an empty string – nothing except the NULL terminator – has size <code>1</code>.</p>
<p>This is not true for <code>keyValue</code> in the case of binary data, because the value `'\0'<code>in the first byte is perfectly legal binary data. </code>keyGetValueSize<code>may also return</code>0` for that reason.</p>
<h2>Error Handling</h2>
<p>Elektra does not set <code>errno</code>. If a function you call sets <code>errno</code>, make sure to set it back to the old value again.</p>
<p>Additional information about error handling is available <a class="el" href="md_doc_help_elektra-error-handling.html#doc_help_elektra-error-handling_md">here</a>.</p>
<h2>Naming</h2>
<p>All function names begin with their class name, e.g. <code>kdb</code>, <code>ks</code> or <code>key</code>. We use capital letters to separate single words (CamelCase). This leads to short names, but might be not as readable as separating names by other means.</p>
<p><em>Get</em> and <em>Set</em> are used for getters/and setters. We use <em>Is</em> to ask about a flag or state and <em>Needs</em> to ask about state related to databases. For allocation/deallocation we use C++ styled names (e.g *New, *Del).</p>
<p>Macros and Enums are written in capital letters. Options start with <code>KDB_O</code>, errors with <code>KDB_ERR</code>, namespaces with <code>KEY_NS</code> and key types with <code>KEY_TYPE</code>.</p>
<p>Data structures start with a capital letter for every part of the word: </p><pre class="fragment">    KDB ... Key Data Base Handle
    KeySet ... Key Set
    Key ... Key
</pre><p><code>keyGetUID</code> and <code>keyGetGID</code> use capital letters, because the term ID is commonly written using upper case letters.</p>
<p>We use singular for all names.</p>
<p>Function names not belonging to one of the three classes are Elektra specific. They use the prefix <code>elektra*</code>. They will always be Elektra specific and won't be implemented by other KDB implementations.</p>
<h2>const</h2>
<p>Wherever possible functions should use the keyword <code>const</code> for parameters. The API uses this keyword for parameters, to show that a function does not modify a <code>Key</code> or a <code>KeySet</code>. We do not use <code>const</code> for return values, except for the following functions: </p><pre class="fragment">    const char *keyName(const Key *key);
    const char *keyBaseName(const Key *key);
    const char *keyComment(const Key *key);
    const void *keyValue(const Key *key);
    const char *keyString(const Key *key);
    const Key  *keyGetMeta(const Key *key, const char* metaName)
</pre><p>The reason behind this is, that the above functions – as their name suggest – only retrieve values. The returned value must not be modified directly. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
