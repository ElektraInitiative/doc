<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Elektra: How-To: Python kdb</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How-To: Python kdb </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>When programming in python it is possible to access the kdb database, changing values of existing keys, adding and deleting keys and a few other things.</p>
<h2>First Steps</h2>
<p>In order to being able to use kdb, obviously, you at first need to <code>import kdb</code>. You need access to an python-object of kdb. This is accomplished by calling <code><a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a></code> and saving this to a variable because later on this object will be needed for various operations. The easiest way to do this would be: ``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: print 'Hello world! I have a kdb-instance! :D' </p><h1>do all kinds of operations explained below</h1>
<p>```</p>
<h2>Keyset</h2>
<p>A keyset is basically a list of the keys that lie within the specified range of the databse. When creating an empty keyset this range is obviously zero. It is possible to load the whole database into a keyset but in a lot of cases this is not needed and you can specify which keys exactly you need (which I mean with specified range). At first it is necessary to create a new keyset. When simply calling <code><a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a></code> the keyset is of size 0. There is no restriction to the keyset's size. It is possible to specify a certain (maximum) size for a keyset. To load keys into to keyset from the database you simply call the method <code>get</code> provided by the kdb-object.</p>
<p>``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: </p><h1>create empty keyset</h1>
<p>ks = <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a> print len(ks) # should be 0 </p><h1>load an existing keyset</h1>
<p>k.get(ks, '/path/to/keys') ```</p>
<p>It is also possible to iterate as expected over a keyset and use len, reversed and copying. The elements of a keyset can be accessed by indexes and a keyset can be sliced. Another way of accessing a key is by the key-name (`keyset_name['/path/to/keys/key_name']`). If the key-name does not exist within the keyset, a KeyError exception is thrown.</p>
<p>An example that shows how to load an existing keyset and then access every key and value of the loaded keyset:</p>
<p>``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: ks = <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a> #loading an existing keyset k.get(ks, '/path/to/keys') </p><h1>if you for some reason want to loop through the keyset last key first use: for i in reversed(ks):</h1>
<p>for i in ks: </p><h1>print for every key in the keyset the key and the value</h1>
<p>print 'key: '+ str(i) + 'value: ' + str(ks[i])</p>
<p>```</p>
<p>Here an example of how you can easily check if a key exists:</p>
<p>``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: ks = <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a> k.get(ks, '/path/to/keys') try: print 'The value to the key /user/sw/pk/key_name is ' + str(ks['/user/sw/pk/key_name']) + '!' except KeyError: print 'The key does not exist!' ```</p>
<p>Ways of copying a keyset:</p>
<p>``` import kdb import copy with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: ks = <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a> k.get(ks, '/path/to/keys') </p><h1>creating a deep copy</h1>
<p>ks_deepcopy = copy.deepcopy(ks) </p><h1>creating a shallow copy</h1>
<p>ks_shallowcopy = copy.copy(ks)</p>
<p>```</p>
<p>Slicing works just like for normal lists in python. But be careful: Afterwards the result will be a list - not a keyset.</p>
<p>``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: ks = <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a> k.get(ks, '/path/to/keys') </p><h1>creating a shallow copy by slicing</h1>
<p>ks_copy_by_slicing = ks[:] </p><h1>in the following examples start &amp; end need to be replaced by integers</h1>
<h1>create keyset with keys from start to end-1</h1>
<p>a = ks[start:end] </p><h1>create keyset with keys from start to the end of the original keyset</h1>
<p>b = ks[start:] </p><h1>create keyset with keys from the beginning of the keyset to end</h1>
<p>c = ks[:end]</p>
<p>```</p>
<p>If you have changed anything in the keyset and want those changes to be saved to the database, you need to call <code>set</code> which is just like <code>get</code> provided by the kdb-object.</p>
<p>An example of everything up until now could look like this: ``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: ks = <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a> k.get(ks, '/path/to/keys') </p><h1>... any number of operations that manipulate the keyset as explained below</h1>
<h1>setting and by doing so saving the new keyset</h1>
<p>k.set(ks, '/path/to/keys') </p><h1>by changing the path here it is for instance possible to set the keyset of one user identical to another users</h1>
<p>```</p>
<p>If you have a key a very simple way to get it's name and value:</p>
<p>``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: ks = <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a> k.get(ks, '/path/to/keys') for i in ks: print 'key-name: ' + i.name print 'key-value: ' + i.value print 'key-value: ' + ks.lookup(i).string ```</p>
<p>It is possible to create new keys:</p>
<p>``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: </p><h1>the first argument is the path to the key, the third argument is the key-value</h1>
<p>new_key = <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">kdb.Key</a>('/user/sw/pk/key_name', kdb.KEY_VALUE, 'key_value') ```</p>
<p>Keys can be added to a keyset using <code>append</code>. If the key already exists, the value will be updated. Calling `keyset_name['/path/to/key'] = 'new_value` does not work for updating keys already in a keyset.</p>
<p>``` import kdb with <a class="el" href="classkdb_1_1KDB.html" title="Constructs a class KDB. ">kdb.KDB()</a> as k: ks = <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">kdb.KeySet()</a> k.get(ks, '/path/to/keys') new_key = <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">kdb.Key</a>('/user/sw/pk/key_name', kdb.KEY_VALUE, 'key_value') </p><h1>adding new_key to the existing key-set, ks['/user/sw/pk/key_name'].value == 'key_value'</h1>
<p>ks.append(new_key) newer_key = <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">kdb.Key</a>('/user/sw/pk/key_name', kdb.KEY_VALUE, 'other_key_value') </p><h1>adding newer_key to the existing key-set, by doing so replacing new_key, ks['/user/sw/pk/key_name'].value == 'other_key_value'</h1>
<p>ks.append(newer_key) ``` </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
