<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: elektra-highlevel-gen(7) &ndash; High-level API code-generation advanced features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">elektra-highlevel-gen(7) &ndash; High-level API code-generation advanced features </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_help_elektra_highlevel_gen"></a> This document focuses on the advanced features of the high-level API code-generator template. We assume you already familiarized yourself with the basic features explained in <a class="el" href="doc_help_kdb-gen-highlevel_md.html">`kdb-gen-highlevel(1)`</a>.</p>
<h1><a class="anchor" id="autotoc_md2419"></a>
Configuration Options</h1>
<p>The parameters that are relevant to the concepts described here are (for the rest see <a class="el" href="doc_help_kdb-gen-highlevel_md.html">`kdb-gen-highlevel(1)</a>):</p>
<ul>
<li><code>embeddedSpec</code>: allowed values: <code>full</code> (default), <code>defaults</code>, <code>none</code></li>
<li><code>enumConv</code>: allowed values: <code>strcmp</code>, <code>switch</code>, <code>auto</code> (default)</li>
</ul>
<p>Using <code>embeddedSpec</code> you can configure how much of the specification is embedded into your application. By default we use <code>full</code>. This means the full specification is embedded into your application's binary. Since this can drastically increase the size of the binary, you can also choose <code>defaults</code> or <code>none</code>. The <code>defaults</code> setting embeds a reduced version of the specification, which only contains the metadata required by <code>elektraOpen</code>. By setting <code>embeddedSpec=none</code> you can also remove this reduced specification.</p>
<p>The advantage of using <code>full</code> is that your application is contained in a single executable file. If you don't use <code>full</code>, the code-generator produces an additional <code>.spec.eqd</code> file and omits specload function (called <code>exitForSpecload</code> by default). This file contains the full specification in quickdump format. You can either mount it directly via <code>quickdump</code>, or if you want the features of <code>specload</code> use a <code>specload</code> configuration like this: <code>app=/usr/bin/cat args=#0 args/#0="path-to-spec-output-file"</code>.</p>
<p>Setting <code>embeddedSpec=none</code> is only recommended, if you must have the minimal binary size and you know what you are doing. In this case no defaults are passed to <code>elektraOpen</code> and defaults are only handled via the <code>spec</code> plugin. If the specification/configuration isn't mounted, the getter functions may fail.</p>
<p>The case of a misconfigured mountpoint will be detected automatically and reported as an error. It will cause the initialization function (by default named <code>loadConfiguration</code>) to fail, if the specification is not mounted at the expected mountpoint or if the specification was not <code>spec-mount</code>ed.</p>
<h1><a class="anchor" id="autotoc_md2420"></a>
Enums</h1>
<p>We support the mapping of a set of string values to a native C <code>enum</code>. To use this feature, you need to write your specification the same way that the enum part of the <code>type</code> plugin expects.</p>
<div class="fragment"><div class="line">[myenum]</div>
<div class="line">type=enum</div>
<div class="line">check/enum=#_4</div>
<div class="line">check/enum/#0=none</div>
<div class="line">check/enum/#1=red</div>
<div class="line">check/enum/#2=green</div>
<div class="line">check/enum/#4=blue</div>
<div class="line">default=blue</div>
</div><!-- fragment --><p>The above specification will generate the following C <code>enum</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></div>
<div class="line">{</div>
<div class="line">    ELEKTRA_ENUM_MYENUM_NONE = 0,</div>
<div class="line">    ELEKTRA_ENUM_MYENUM_RED = 1,</div>
<div class="line">    ELEKTRA_ENUM_MYENUM_GREEN = 2,</div>
<div class="line">    ELEKTRA_ENUM_MYENUM_BLUE = 4,</div>
<div class="line">} ElektraEnumMyenum;</div>
</div><!-- fragment --><p>As you can see the integer values of the different enum values are taken from the indices of the <code>check/enum/#</code> array. You may also use e.g. <code>gen/enum/#2/value=1 &lt;&lt; 1</code> to set a different value. The <code>gen/enum/#/value</code> values are inserted literally into the C files, so the values must be valid C code. The name of the enum may be configured via <code>gen/enum/type</code>. If you want to use an existing <code>enum</code> and map its values to strings you can turn the generation of the enum off, by adding <code>gen/enum/create=0</code>. In this case you have to add a header that defines the <code>enum</code> or <code>typedef</code>s it, to the <code>headers</code> parameter of the code-generator invocation.</p>
<p>Like with any other key, the code-generator produces <code>static inline</code> getter and setter functions for the key. Since there are no generic functions for the conversion of the strings into the enum values, we also generate those:</p>
<div class="fragment"><div class="line">ELEKTRA_KEY_TO_SIGNATURE (ElektraEnumMyenum, EnumMyenum);</div>
<div class="line">ELEKTRA_TO_STRING_SIGNATURE (ElektraEnumMyenum, EnumMyenum);</div>
<div class="line">ELEKTRA_TO_CONST_STRING_SIGNATURE (ElektraEnumMyenum, EnumMyenum);</div>
<div class="line"> </div>
<div class="line">ELEKTRA_GET_SIGNATURE (ElektraEnumMyenum, EnumMyenum);</div>
<div class="line">ELEKTRA_GET_ARRAY_ELEMENT_SIGNATURE (ElektraEnumMyenum, EnumMyenum);</div>
<div class="line">ELEKTRA_SET_SIGNATURE (ElektraEnumMyenum, EnumMyenum);</div>
<div class="line">ELEKTRA_SET_ARRAY_ELEMENT_SIGNATURE (ElektraEnumMyenum, EnumMyenum);</div>
</div><!-- fragment --><p>These functions are not generated per key, but per enum type. If multiple keys use the same enum type (both need to define the full metadata, including the full set of values), we only generate one set of these functions.</p>
<p>The getter and setter functions won't be explained here, they work like any of the other getter and setter functions of the high-level API.</p>
<p>The other three functions are used to convert between the string values and the generated <code>enum</code>. You may find these useful in your application. You can call them via e.g. <code>ELEKTRA_KEY_TO (EnumMyenum)</code>. The difference between <code>ELEKTRA_TO_STRING</code> and <code>ELEKTRA_TO_CONST_STRING</code> is that the first returns a <code>char *</code> allocated via <code>elektraMalloc</code>, while the second returns a static <code>constchar *</code>.</p>
<p>Both <code>ELEKTRA_TO_STRING</code> and <code>ELEKTRA_TO_CONST_STRING</code> are always implemented via a straightforward <code>switch</code> statement. The implementation of <code>ELEKTRA_KEY_TO</code> on the other hand can be changed via the <code>enumConv</code> parameter. If you set <code>enumConv=strcmp</code>, we will generate a code analogous to:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (strcmp (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;none&quot;</span>) == 0) { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordflow">if</span> (strcmp (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;red&quot;</span>) == 0) { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordflow">if</span> (strcmp (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;green&quot;</span>) == 0) { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordflow">if</span> (strcmp (<span class="keywordtype">string</span>, <span class="stringliteral">&quot;blue&quot;</span>) == 0) { <span class="comment">/* ... */</span> }</div>
</div><!-- fragment --><p>This code is not really optimal, since we really only need to look at the first character to determine the correct enum value. This is where <code>enumConv=switch</code> comes in. With this option, we generate a series of (nested, if necessary) switch/case statements:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (<span class="keywordtype">string</span>[0])</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">case</span> <span class="charliteral">&#39;b&#39;</span>: <span class="comment">/* blue */</span></div>
<div class="line"><span class="keywordflow">case</span> <span class="charliteral">&#39;g&#39;</span>: <span class="comment">/* green */</span></div>
<div class="line"><span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>: <span class="comment">/* none */</span></div>
<div class="line"><span class="keywordflow">case</span> <span class="charliteral">&#39;r&#39;</span>: <span class="comment">/* red */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Of course this version also has its own problems. Take for example the enum with the values: <code>blue</code>, <code>blueish</code> and <code>brown</code>. With <code>enumConv=switch</code> this would generate the following code:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (<span class="keywordtype">string</span>[0])</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">case</span> <span class="charliteral">&#39;b&#39;</span>:</div>
<div class="line">    <span class="keywordflow">switch</span> (<span class="keywordtype">string</span>[1])</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> <span class="charliteral">&#39;l&#39;</span>:</div>
<div class="line">        <span class="keywordflow">switch</span> (<span class="keywordtype">string</span>[2])</div>
<div class="line">        {</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;u&#39;</span>:</div>
<div class="line">            <span class="keywordflow">switch</span> (<span class="keywordtype">string</span>[3])</div>
<div class="line">            {</div>
<div class="line">            <span class="keywordflow">case</span> <span class="charliteral">&#39;e&#39;</span>:</div>
<div class="line">                <span class="keywordflow">switch</span> (<span class="keywordtype">string</span>[4])</div>
<div class="line">                {</div>
<div class="line">                <span class="keywordflow">case</span> <span class="charliteral">&#39;i&#39;</span>: <span class="comment">/* blueish */</span></div>
<div class="line">                }</div>
<div class="line">                <span class="comment">/* blue */</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> <span class="charliteral">&#39;r&#39;</span>: <span class="comment">/* brown */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is already quite hard to read and <code>blueish</code> isn't even that long.</p>
<p>To provide a compromise between readability and performance, we default to <code>enumConv=auto</code>. This options uses the switch version, if the depth is less than 3, and the <code>strcmp</code> version in all other cases. A depth of <code>n</code> means looking at the first <code>n</code> characters <code>string[0], string[1], ..., string[n-1]</code>. In other words a depth of <code>n</code> uses <code>n</code> switch statements.</p>
<h1><a class="anchor" id="autotoc_md2421"></a>
Structs</h1>
<p>The <code>highlevel</code> template also has support for structs. By setting <code>type = struct</code> on a key, you can enable the generation of a native C <code>struct</code> for the keys below it.</p>
<p>We will look at this simple example:</p>
<div class="fragment"><div class="line">[mystruct]</div>
<div class="line">type=struct</div>
<div class="line">check/type=any</div>
<div class="line">default=&quot;&quot;</div>
<div class="line"> </div>
<div class="line">[mystruct/a]</div>
<div class="line">type=string</div>
<div class="line">default=&quot;&quot;</div>
<div class="line"> </div>
<div class="line">[mystruct/b]</div>
<div class="line">type=long</div>
<div class="line">default=8</div>
</div><!-- fragment --><p>Note: That we set <code>check/type=any</code> and <code>default=""</code>. This is to avoid problems with the <code>type</code> plugin, which doesn't know about <code>struct</code>s.</p>
<p>The generated struct looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>ElektraStructMystruct</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * a;</div>
<div class="line">    kdb_long_t b;</div>
<div class="line">} ElektraStructMystruct;</div>
</div><!-- fragment --><p>Similar to enums, you can customise the generated struct via additional metadata:</p>
<ul>
<li>Metadata for the key with <code>type=struct</code>:<ul>
<li><code>gen/struct/type</code> can be used to set the name of the generated struct.</li>
<li><code>gen/struct/create=0</code> disables the struct generation and only generates the accessor functions. Use this to use structs defined elsewhere. Don't forget to include the needed header in the <code>headers</code> parameter.</li>
<li><code>gen/struct/alloc</code> (values <code>0</code>, <code>1</code>) sets whether the struct is <em>allocating</em>. This changes how the getter works and also has some other implications. By default structs are non-allocating.</li>
<li><code>gen/struct/depth</code> sets at how many levels below the <code>type=struct</code> key, we will include in the generated struct. Note that keys ending in <code>/#</code> (i.e. array keys) count as one level above. So <code>mystruct/x/#</code> would be included with the default <code>gen/struct/depth=1</code>.</li>
</ul>
</li>
<li>Metadata for keys corresponding to fields of the struct:<ul>
<li><code>gen/struct/field</code> sets the name of the field in the generated struct.</li>
<li><code>gen/struct/field/ignore=1</code> ignores this key during struct generation, i.e. we don't create a field for it.</li>
<li><code>gen/array/sizefield</code> sets the name of the field used to store the size of arrays. Only useful on array keys. For example, by default the size of the array key <code>mystruct/x/#</code> is stored in <code>xSize</code>, while the array is accessed via the field <code>x</code>.</li>
</ul>
</li>
</ul>
<p>We will also generate getter and setter functions:</p>
<div class="fragment"><div class="line">ELEKTRA_GET_SIGNATURE (ElektraStructMystruct *, StructMystruct);</div>
<div class="line"><span class="comment">// or ELEKTRA_GET_OUT_PTR_SIGNATURE (ElektraStructMystruct, StructMystruct);</span></div>
<div class="line">ELEKTRA_GET_ARRAY_ELEMENT_SIGNATURE (ElektraStructMystruct *, StructMystruct);</div>
<div class="line"><span class="comment">// or ELEKTRA_GET_OUT_PTR_ARRAY_ELEMENT_SIGNATURE (ElektraStructMystruct, StructMystruct);</span></div>
<div class="line"> </div>
<div class="line">ELEKTRA_SET_SIGNATURE (<span class="keyword">const</span> ElektraStructMystruct *, StructMystruct);</div>
<div class="line">ELEKTRA_SET_ARRAY_ELEMENT_SIGNATURE (<span class="keyword">const</span> ElektraStructMystruct *, StructMystruct);</div>
</div><!-- fragment --><p>The difference between <code>ELEKTRA_GET_SIGNATURE</code> and <code>ELEKTRA_GET_OUT_PTR_SIGNATURE</code> is explained in the next section. Both versions are called via <code>ELEKTRA_GET (...) (...)</code>.</p>
<p>Allocating structs also generate <code>ELEKTRA_STRUCT_FREE (/* struct name */)</code>, which is used to free the allocated memory.</p>
<h2><a class="anchor" id="autotoc_md2422"></a>
Allocating vs. Non-Allocating</h2>
<p>The main difference between allocating and non-allocating structs, is how their getter function works.</p>
<p>Allocating structs use a getter similar to the one primitive types, strings and enums use. It returns a pointer to a newly allocated struct, which has to be freed using the generated <code>ELEKTRA_STRUCT_FREE</code> function.</p>
<p>Non-allocating structs meanwhile use a different kind of getter declared via <code>ELEKTRA_GET_OUT_PTR_SIGNATURE</code> instead of <code>ELEKTRA_GET_SIGNATURE</code>. This version doesn't return a pointer, instead it takes a pointer to an existing struct and only sets its fields. This is why you have to use the convenience macros <code>elektraFillStruct</code> and <code>elektraFillStructV</code> for these structs.</p>
<p>Non-allocating structs are also more limited than their allocating counterparts. They do not support arrays or struct references. They also cannot be for unions. Their main advantage is that you can use non-allocating structs without (additional) <code>malloc</code>/<code>free</code>, by providing a stack allocated pointer to the getter function.</p>
<h2><a class="anchor" id="autotoc_md2423"></a>
Struct references</h2>
<p>Structs cannot be nested, but they can reference each other. This allows for complex and possibly recursive structures. Take for example:</p>
<div class="fragment"><div class="line">[person/#]</div>
<div class="line">type=struct</div>
<div class="line">check/type=any</div>
<div class="line">default=&quot;&quot;</div>
<div class="line">gen/struct/alloc=1</div>
<div class="line"> </div>
<div class="line">[person/#/name]</div>
<div class="line">type=string</div>
<div class="line">default=Max</div>
<div class="line"> </div>
<div class="line">[person/#/mother]</div>
<div class="line">type=struct_ref</div>
<div class="line">check/type=any</div>
<div class="line">default=&quot;&quot;</div>
<div class="line">check/reference=recursive</div>
<div class="line">check/reference/restrict=../../../person/#</div>
<div class="line"> </div>
<div class="line">[person/#/children/#]</div>
<div class="line">type=struct_ref</div>
<div class="line">check/type=any</div>
<div class="line">default=&quot;&quot;</div>
<div class="line"> </div>
<div class="line">[person/#/children]</div>
<div class="line">default=&quot;&quot;</div>
<div class="line">check/reference=recursive</div>
<div class="line">check/reference/restrict=../../../person/#</div>
</div><!-- fragment --><p>This results in a struct like this:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>ElektraStructPerson</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>ElektraStructPerson * mother;</div>
<div class="line">        kdb_long_long_t childrenSize;</div>
<div class="line">        <span class="keyword">struct </span>ElektraStructPerson ** children;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line">} ElektraStructPerson;</div>
</div><!-- fragment --><p>As you can see an instance of <code>ElektraStructPerson</code> may reference different instances. To declare this we must add a key with <code>type=struct_ref</code>. We use the metakeys of the <code>reference</code> plugin (which should be mounted to validate reference) to define what struct we want to reference. We also again set <code>check/type=any</code> and <code>default=""</code> to please the <code>type</code> plugin.</p>
<p>Struct references are also supported as arrays, in which case the <code>check/reference</code> keys must be on a different key than the rest of the metadata, because of how the <code>reference</code> plugin works. The example above shows this with <code>person/#/children</code> and <code>person/#/children/#</code>.</p>
<p>If you access an element of the <code>person/#</code> array via the getter function, we will recursively read the references structs. Writing structs that contain struct references or setting <code>struct_ref</code> keys directly is not supported.</p>
<p>Struct references can also exist outside of structs and maybe accessed directly via the generated accessor functions. Please, be careful when handling struct references, since invalid references will cause fatal errors.</p>
<h1><a class="anchor" id="autotoc_md2424"></a>
Unions</h1>
<p>The most advanced feature of the code-generator are unions. Sometimes we want a reference inside a struct, but it is not always to the same struct. For example in a menu structure, we might have a list of entries that are either submenus or actual items that execute a command.</p>
<div class="fragment"><div class="line">[menu/#]</div>
<div class="line">type=<span class="keyword">struct</span></div>
<div class="line">check/type=any</div>
<div class="line"><span class="keywordflow">default</span>=<span class="stringliteral">&quot;&quot;</span></div>
<div class="line">gen/<span class="keyword">struct</span>/alloc=1</div>
<div class="line"> </div>
<div class="line">[menu/#/name]</div>
<div class="line">type=<span class="keywordtype">string</span></div>
<div class="line"><span class="keywordflow">default</span>=<span class="stringliteral">&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">[menu/#/entries/#]</div>
<div class="line">type=struct_ref</div>
<div class="line">check/type=any</div>
<div class="line"><span class="keywordflow">default</span>=<span class="stringliteral">&quot;&quot;</span></div>
<div class="line">gen/reference/discriminator/<span class="keyword">enum</span> = MenuEntryType</div>
<div class="line">gen/reference/discriminator/<span class="keyword">union </span>= MenuEntry</div>
<div class="line">gen/reference/restrict/#0/discriminator = item</div>
<div class="line">gen/reference/restrict/#1/discriminator = menu</div>
<div class="line"> </div>
<div class="line">[menu/#/entries]</div>
<div class="line"><span class="keywordflow">default</span>=<span class="stringliteral">&quot;&quot;</span></div>
<div class="line">check/reference=recursive</div>
<div class="line">check/reference/restrict=#1</div>
<div class="line">check/reference/restrict/#0=@/menu/#</div>
<div class="line">check/reference/restrict/#1=@/item/#</div>
<div class="line"> </div>
<div class="line">[menu/#/discriminator]</div>
<div class="line">type = discriminator</div>
<div class="line">check/type = <span class="keyword">enum</span></div>
<div class="line">check/<span class="keyword">enum</span> = #1</div>
<div class="line">check/<span class="keyword">enum</span>/#0 = item</div>
<div class="line">check/<span class="keyword">enum</span>/#1 = menu</div>
<div class="line">gen/<span class="keyword">enum</span>/type=MenuEntryType</div>
<div class="line"><span class="keywordflow">default</span> = menu</div>
<div class="line"> </div>
<div class="line">[item/#]</div>
<div class="line">type=<span class="keyword">struct</span></div>
<div class="line">check/type=any</div>
<div class="line"><span class="keywordflow">default</span>=<span class="stringliteral">&quot;&quot;</span></div>
<div class="line">gen/<span class="keyword">struct</span>/alloc=1</div>
<div class="line"> </div>
<div class="line">[item/#/name]</div>
<div class="line">type=<span class="keywordtype">string</span></div>
<div class="line"><span class="keywordflow">default</span>=<span class="stringliteral">&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">[item/#/command]</div>
<div class="line">type=<span class="keywordtype">string</span></div>
<div class="line"><span class="keywordflow">default</span>=<span class="stringliteral">&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">[item/#/entries]</div>
<div class="line">check/reference/restrict=</div>
<div class="line"> </div>
<div class="line">[item/#/discriminator]</div>
<div class="line">type = discriminator</div>
<div class="line">check/type = <span class="keyword">enum</span></div>
<div class="line">check/<span class="keyword">enum</span> = #1</div>
<div class="line">check/<span class="keyword">enum</span>/#0 = item</div>
<div class="line">check/<span class="keyword">enum</span>/#1 = menu</div>
<div class="line">gen/<span class="keyword">enum</span>/type=MenuEntryType</div>
<div class="line"><span class="keywordflow">default</span> = item</div>
</div><!-- fragment --><p>As you can see the unions feature requires quite a bit more setup. We will start with <code>menu/#/entries/#</code>. It is set to <code>type=struct_ref</code> like you would do for normal struct reference, but the accompanying <code>menu/#/entries</code> uses <code>check/reference/restrict</code> as an array. This tells the <code>reference</code> plugin that any of the given reference restrictions are allowed. Therefore we could be referencing one of several structs and the code-generator has to deal with that somehow.</p>
<p>To allow alternative references, we need to define <code>gen/reference/discriminator/union</code> and <code>gen/reference/discriminator/enum</code> on the key with <code>type=struct_ref</code>. The former of these defines the name of the native C <code>union</code> the code-generator creates:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">union </span>{</div>
<div class="line">    <span class="keyword">struct </span>ElektraStructMenu * item;</div>
<div class="line">    <span class="keyword">struct </span>ElektraStructMenu * menu;</div>
<div class="line">} MenuEntry;</div>
</div><!-- fragment --><p>The other required metakey defines which enum shall be used as a discriminator between the union values:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    ELEKTRA_ENUM_MENU_ENTRY_TYPE_ITEM = 0,</div>
<div class="line">    ELEKTRA_ENUM_MENU_ENTRY_TYPE_MENU = 1</div>
<div class="line">} MenuEntryType;</div>
</div><!-- fragment --><p>Each of the possibly referenced structs must have a discriminator key. This key must be part of the struct, it must have <code>type=discriminator</code> and should have <code>check/type=enum</code>. All the discriminator keys must also set <code>gen/enum/type</code> to the same value as chosen for <code>gen/reference/discriminator/enum</code> and all of them have to define the same enum, via the <code>check/enum/#</code> array. The values also have to match the values of the <code>gen/reference/restrict/#/discriminator</code> metakeys on the <code>type=struct_ref</code> key.</p>
<p>The generated structs will then look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Menu</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line">        kdb_long_long_t entriesSize;</div>
<div class="line">        MenuEntryType * entryTypes;</div>
<div class="line">        MenuEntry * entries;</div>
<div class="line">} Menu;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>Item</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line">        <span class="keyword">const</span> cahr * command;</div>
<div class="line">} Menu;</div>
</div><!-- fragment --><p>As you can see the discriminator field is excluded from the struct itself and stored in a separate array. We do generate getter and free functions for unions, but we don't recommend using them directly. There are no setter functions for unions, because they involve struct references. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
