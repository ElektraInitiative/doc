\hypertarget{kdbhelper_8h}{}\doxysection{kdbhelper.\+h File Reference}
\label{kdbhelper_8h}\index{kdbhelper.h@{kdbhelper.h}}


Helper for memory management.  


{\ttfamily \#include $<$kdbmacros.\+h$>$}\newline
{\ttfamily \#include $<$kdbtypes.\+h$>$}\newline
{\ttfamily \#include $<$stdarg.\+h$>$}\newline
{\ttfamily \#include $<$stddef.\+h$>$}\newline
Include dependency graph for kdbhelper.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{kdbhelper_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{kdbhelper_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{group__proposal_ga93673533c4c8eb1fdfca76b98c5f49b0}{elektra\+Lookup\+Options}} \{ \newline
\mbox{\hyperlink{group__proposal_gga93673533c4c8eb1fdfca76b98c5f49b0a187bc7e52493fb8f1eb5693015478dae}{K\+D\+B\+\_\+\+O\+\_\+\+S\+P\+EC}} = 1 $<$$<$ 15, 
\mbox{\hyperlink{group__proposal_gga93673533c4c8eb1fdfca76b98c5f49b0a72155bedec545b2e96372ab28169620a}{K\+D\+B\+\_\+\+O\+\_\+\+C\+R\+E\+A\+TE}} = 1 $<$$<$ 16, 
\mbox{\hyperlink{group__proposal_gga93673533c4c8eb1fdfca76b98c5f49b0abc4c6e04823b6d684f4db8df3b84f326}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+C\+A\+S\+C\+A\+D\+I\+NG}} = 1 $<$$<$ 17, 
\mbox{\hyperlink{group__proposal_gga93673533c4c8eb1fdfca76b98c5f49b0a420d8ea3671ffea4fe8400570cfe5c8d}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+S\+P\+EC}} = 1 $<$$<$ 18, 
\newline
\mbox{\hyperlink{group__proposal_gga93673533c4c8eb1fdfca76b98c5f49b0abdcfd6d28200b5c650615fba430496bb}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+D\+E\+F\+A\+U\+LT}} = 1 $<$$<$ 19, 
\mbox{\hyperlink{group__proposal_gga93673533c4c8eb1fdfca76b98c5f49b0a70ac5d04d6f855e17e4c33dfeeddd39e}{K\+D\+B\+\_\+\+O\+\_\+\+C\+A\+L\+L\+B\+A\+CK}} = 1 $<$$<$ 20, 
\mbox{\hyperlink{group__proposal_gga93673533c4c8eb1fdfca76b98c5f49b0afe9f6ff6e374540baf600a918b07ee6e}{K\+D\+B\+\_\+\+O\+\_\+\+O\+P\+M\+P\+HM}} = 1 $<$$<$ 21, 
\mbox{\hyperlink{group__proposal_gga93673533c4c8eb1fdfca76b98c5f49b0ac67a43bd273203575090d26010f6c995}{K\+D\+B\+\_\+\+O\+\_\+\+B\+I\+N\+S\+E\+A\+R\+CH}} = 1 $<$$<$ 22
 \}
\begin{DoxyCompactList}\small\item\em More lookup options. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void $\ast$ \mbox{\hyperlink{kdbhelper_8h_a35cdc2e5caed3454cb73b4fc7f37858c}{elektra\+Malloc}} (size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Allocate memory for Elektra. \end{DoxyCompactList}\item 
void $\ast$ \mbox{\hyperlink{kdbhelper_8h_a848ed030434c76176167fac6ab79429c}{elektra\+Calloc}} (size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Allocate memory for Elektra. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{kdbhelper_8h_a7f572149d2e0bfe18023a6ac969f195c}{elektra\+Free}} (void $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Free memory of Elektra or its backends. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kdbhelper_8h_ab0432d6765c40a5408a204c43747f4d4}{elektra\+Realloc}} (void $\ast$$\ast$buffer, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Reallocate Storage in a save way. \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{kdbhelper_8h_abe50f54adaf932e177a100fe4fddad26}{elektra\+Str\+Dup}} (const char $\ast$s)
\begin{DoxyCompactList}\small\item\em Copy string into new allocated memory. \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{kdbhelper_8h_a04ad42d215b2ce5ed83e1a9354f6ba94}{elektra\+Str\+N\+Dup}} (const char $\ast$s, size\+\_\+t l)
\begin{DoxyCompactList}\small\item\em Copy buffer into new allocated memory. \end{DoxyCompactList}\item 
char char $\ast$ \mbox{\hyperlink{kdbhelper_8h_ae6d48ff4971c412f55f29e599a6639f0}{elektra\+V\+Format}} (const char $\ast$format, va\+\_\+list arg\+\_\+list)
\begin{DoxyCompactList}\small\item\em Does string formatting in fresh allocated memory. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kdbhelper_8h_a2a0aa7edaa79853ac26703f270e8f3a1}{elektra\+Str\+Cmp}} (const char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em Compare Strings. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kdbhelper_8h_ad443a7b664ade6b5ee6688570e95843a}{elektra\+Str\+N\+Cmp}} (const char $\ast$s1, const char $\ast$s2, size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Compare Strings up to a maximum length. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kdbhelper_8h_a686ccc3bc298a5b38c2bac0192551acd}{elektra\+Str\+Case\+Cmp}} (const char $\ast$s1, const char $\ast$s2)
\begin{DoxyCompactList}\small\item\em Compare Strings ignoring case. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kdbhelper_8h_ae23e483a23e6801078db43e7c533f64c}{elektra\+Str\+N\+Case\+Cmp}} (const char $\ast$s1, const char $\ast$s2, size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Compare Strings ignoring case up to a maximum length. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{kdbhelper_8h_aa39061cc72a17effc6b6777a899ae09d}{elektra\+Mem\+Case\+Cmp}} (const char $\ast$s1, const char $\ast$s2, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Compare two memory regions but make cmp chars uppercase before comparison. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{kdbhelper_8h_afd676487565d083a6ad5a1381095acd8}{elektra\+Str\+Len}} (const char $\ast$s)
\begin{DoxyCompactList}\small\item\em Calculates the length in bytes of a string. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Helper for memory management. 

Should be always preferred. Can be used for profiling and tracing.

\begin{DoxyCopyright}{Copyright}
B\+SD License (see L\+I\+C\+E\+N\+S\+E.\+md or \href{https://www.libelektra.org}{\texttt{ https\+://www.\+libelektra.\+org}}) 
\end{DoxyCopyright}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{kdbhelper_8h_a848ed030434c76176167fac6ab79429c}\label{kdbhelper_8h_a848ed030434c76176167fac6ab79429c}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraCalloc@{elektraCalloc}}
\index{elektraCalloc@{elektraCalloc}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraCalloc()}{elektraCalloc()}}
{\footnotesize\ttfamily void$\ast$ elektra\+Calloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Allocate memory for Elektra. 

Memory will be set to 0.


\begin{DoxyParams}{Parameters}
{\em size} & the requested size \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{internal_8c_a35cdc2e5caed3454cb73b4fc7f37858c}{elektra\+Malloc}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{kdbhelper_8h_a7f572149d2e0bfe18023a6ac969f195c}\label{kdbhelper_8h_a7f572149d2e0bfe18023a6ac969f195c}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraFree@{elektraFree}}
\index{elektraFree@{elektraFree}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraFree()}{elektraFree()}}
{\footnotesize\ttfamily void elektra\+Free (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr }\end{DoxyParamCaption})}



Free memory of Elektra or its backends. 


\begin{DoxyParams}{Parameters}
{\em ptr} & the pointer to free\\
\hline
\end{DoxyParams}
If ptr is N\+U\+LL, no operation is performed.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{internal_8c_a35cdc2e5caed3454cb73b4fc7f37858c}{elektra\+Malloc}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{kdbhelper_8h_a35cdc2e5caed3454cb73b4fc7f37858c}\label{kdbhelper_8h_a35cdc2e5caed3454cb73b4fc7f37858c}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraMalloc@{elektraMalloc}}
\index{elektraMalloc@{elektraMalloc}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraMalloc()}{elektraMalloc()}}
{\footnotesize\ttfamily void$\ast$ elektra\+Malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Allocate memory for Elektra. 


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if} ((buffer = \mbox{\hyperlink{internal_8c_a35cdc2e5caed3454cb73b4fc7f37858c}{elektraMalloc}} (length)) == 0) \{}
\DoxyCodeLine{        \textcolor{comment}{// here comes the failure handler}}
\DoxyCodeLine{        \textcolor{comment}{// no allocation happened here, so don't use buffer}}
\DoxyCodeLine{\textcolor{preprocessor}{\#if DEBUG}}
\DoxyCodeLine{        fprintf (stderr, \textcolor{stringliteral}{"Allocation error"});}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{        \textcolor{comment}{// return with error}}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em size} & the requested size\\
\hline
\end{DoxyParams}
This function is compatible to A\+N\+S\+I-\/C malloc \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{internal_8c_a7f572149d2e0bfe18023a6ac969f195c}{elektra\+Free}} 

\mbox{\hyperlink{internal_8c_a848ed030434c76176167fac6ab79429c}{elektra\+Calloc}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{kdbhelper_8h_aa39061cc72a17effc6b6777a899ae09d}\label{kdbhelper_8h_aa39061cc72a17effc6b6777a899ae09d}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraMemCaseCmp@{elektraMemCaseCmp}}
\index{elektraMemCaseCmp@{elektraMemCaseCmp}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraMemCaseCmp()}{elektraMemCaseCmp()}}
{\footnotesize\ttfamily int elektra\+Mem\+Case\+Cmp (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s1,  }\item[{const char $\ast$}]{s2,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Compare two memory regions but make cmp chars uppercase before comparison. 


\begin{DoxyParams}{Parameters}
{\em s1} & The first string to be compared \\
\hline
{\em s2} & The second string to be compared \\
\hline
{\em size} & to be compared\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a negative number if s1 is less than s2 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & if s1 matches s2 \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
a positive number if s1 is greater than s2 
\end{DoxyReturn}
\mbox{\Hypertarget{kdbhelper_8h_ab0432d6765c40a5408a204c43747f4d4}\label{kdbhelper_8h_ab0432d6765c40a5408a204c43747f4d4}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraRealloc@{elektraRealloc}}
\index{elektraRealloc@{elektraRealloc}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraRealloc()}{elektraRealloc()}}
{\footnotesize\ttfamily int elektra\+Realloc (\begin{DoxyParamCaption}\item[{void $\ast$$\ast$}]{buffer,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}



Reallocate Storage in a save way. 


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if} (\mbox{\hyperlink{internal_8c_ab0432d6765c40a5408a204c43747f4d4}{elektraRealloc}} ((\textcolor{keywordtype}{void} **) \& buffer, new\_length) < 0) \{}
\DoxyCodeLine{        \textcolor{comment}{// here comes the failure handler}}
\DoxyCodeLine{        \textcolor{comment}{// you can still use the old buffer}}
\DoxyCodeLine{\textcolor{preprocessor}{\#if DEBUG}}
\DoxyCodeLine{        fprintf (stderr, \textcolor{stringliteral}{"Reallocation error\(\backslash\)n"});}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{        \mbox{\hyperlink{internal_8c_a7f572149d2e0bfe18023a6ac969f195c}{elektraFree}} (buffer);}
\DoxyCodeLine{        buffer = 0;}
\DoxyCodeLine{        \textcolor{comment}{// return with error}}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em buffer} & is a pointer to a elektra\+Malloc \\
\hline
{\em size} & is the new size for the memory \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on failure \\
\hline
{\em 0} & on success \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{kdbhelper_8h_a686ccc3bc298a5b38c2bac0192551acd}\label{kdbhelper_8h_a686ccc3bc298a5b38c2bac0192551acd}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraStrCaseCmp@{elektraStrCaseCmp}}
\index{elektraStrCaseCmp@{elektraStrCaseCmp}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraStrCaseCmp()}{elektraStrCaseCmp()}}
{\footnotesize\ttfamily int elektra\+Str\+Case\+Cmp (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s1,  }\item[{const char $\ast$}]{s2 }\end{DoxyParamCaption})}



Compare Strings ignoring case. 


\begin{DoxyParams}{Parameters}
{\em s1} & The first string to be compared \\
\hline
{\em s2} & The second string to be compared\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a negative number if s1 is less than s2 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & if s1 matches s2 \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
a positive number if s1 is greater than s2 
\end{DoxyReturn}
\mbox{\Hypertarget{kdbhelper_8h_a2a0aa7edaa79853ac26703f270e8f3a1}\label{kdbhelper_8h_a2a0aa7edaa79853ac26703f270e8f3a1}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraStrCmp@{elektraStrCmp}}
\index{elektraStrCmp@{elektraStrCmp}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraStrCmp()}{elektraStrCmp()}}
{\footnotesize\ttfamily int elektra\+Str\+Cmp (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s1,  }\item[{const char $\ast$}]{s2 }\end{DoxyParamCaption})}



Compare Strings. 


\begin{DoxyParams}{Parameters}
{\em s1} & The first string to be compared \\
\hline
{\em s2} & The second string to be compared\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a negative number if s1 is less than s2 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & if s1 matches s2 \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
a positive number if s1 is greater than s2 
\end{DoxyReturn}
\mbox{\Hypertarget{kdbhelper_8h_abe50f54adaf932e177a100fe4fddad26}\label{kdbhelper_8h_abe50f54adaf932e177a100fe4fddad26}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraStrDup@{elektraStrDup}}
\index{elektraStrDup@{elektraStrDup}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraStrDup()}{elektraStrDup()}}
{\footnotesize\ttfamily char$\ast$ elektra\+Str\+Dup (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s }\end{DoxyParamCaption})}



Copy string into new allocated memory. 

You need to free the memory yourself.

\begin{DoxyNote}{Note}
that size is determined at runtime. So if you have a size information, don\textquotesingle{}t use that function.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em s} & the null-\/terminated string to duplicate\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if out of memory, a pointer otherwise 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
s must be a c-\/string. 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{internal_8c_a7f572149d2e0bfe18023a6ac969f195c}{elektra\+Free}} 

\mbox{\hyperlink{internal_8c_afd676487565d083a6ad5a1381095acd8}{elektra\+Str\+Len}} 

\mbox{\hyperlink{internal_8c_a04ad42d215b2ce5ed83e1a9354f6ba94}{elektra\+Str\+N\+Dup}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{kdbhelper_8h_afd676487565d083a6ad5a1381095acd8}\label{kdbhelper_8h_afd676487565d083a6ad5a1381095acd8}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraStrLen@{elektraStrLen}}
\index{elektraStrLen@{elektraStrLen}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraStrLen()}{elektraStrLen()}}
{\footnotesize\ttfamily size\+\_\+t elektra\+Str\+Len (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s }\end{DoxyParamCaption})}



Calculates the length in bytes of a string. 

This function differs from strlen() because it is Unicode and multibyte chars safe. While strlen() counts characters and ignores the final N\+U\+LL, \mbox{\hyperlink{internal_8c_afd676487565d083a6ad5a1381095acd8}{elektra\+Str\+Len()}} count bytes including the ending N\+U\+LL.

It must not be used to search for / in the name, because it does not consider escaping. Instead use the unescaped name.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__keyname_ga6fe6af4c27b35d911a533f4ae4d698bb}{key\+Unescaped\+Name()}}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em s} & the string to get the length from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes used by the string, including the final N\+U\+LL. 
\end{DoxyReturn}
\mbox{\Hypertarget{kdbhelper_8h_ae23e483a23e6801078db43e7c533f64c}\label{kdbhelper_8h_ae23e483a23e6801078db43e7c533f64c}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraStrNCaseCmp@{elektraStrNCaseCmp}}
\index{elektraStrNCaseCmp@{elektraStrNCaseCmp}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraStrNCaseCmp()}{elektraStrNCaseCmp()}}
{\footnotesize\ttfamily int elektra\+Str\+N\+Case\+Cmp (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s1,  }\item[{const char $\ast$}]{s2,  }\item[{size\+\_\+t}]{n }\end{DoxyParamCaption})}



Compare Strings ignoring case up to a maximum length. 


\begin{DoxyParams}{Parameters}
{\em s1} & The first string to be compared \\
\hline
{\em s2} & The second string to be compared \\
\hline
{\em n} & The maximum length to be compared\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a negative number if s1 is less than s2 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & if s1 matches s2 \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
a positive number if s1 is greater than s2 
\end{DoxyReturn}
\mbox{\Hypertarget{kdbhelper_8h_ad443a7b664ade6b5ee6688570e95843a}\label{kdbhelper_8h_ad443a7b664ade6b5ee6688570e95843a}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraStrNCmp@{elektraStrNCmp}}
\index{elektraStrNCmp@{elektraStrNCmp}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraStrNCmp()}{elektraStrNCmp()}}
{\footnotesize\ttfamily int elektra\+Str\+N\+Cmp (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s1,  }\item[{const char $\ast$}]{s2,  }\item[{size\+\_\+t}]{n }\end{DoxyParamCaption})}



Compare Strings up to a maximum length. 


\begin{DoxyParams}{Parameters}
{\em s1} & The first string to be compared \\
\hline
{\em s2} & The second string to be compared \\
\hline
{\em n} & The maximum length to be compared\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a negative number if s1 is less than s2 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & if s1 matches s2 \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
a positive number if s1 is greater than s2 
\end{DoxyReturn}
\mbox{\Hypertarget{kdbhelper_8h_a04ad42d215b2ce5ed83e1a9354f6ba94}\label{kdbhelper_8h_a04ad42d215b2ce5ed83e1a9354f6ba94}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraStrNDup@{elektraStrNDup}}
\index{elektraStrNDup@{elektraStrNDup}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraStrNDup()}{elektraStrNDup()}}
{\footnotesize\ttfamily char$\ast$ elektra\+Str\+N\+Dup (\begin{DoxyParamCaption}\item[{const char $\ast$}]{s,  }\item[{size\+\_\+t}]{l }\end{DoxyParamCaption})}



Copy buffer into new allocated memory. 

You need to free the memory yourself.

This function also works with \textbackslash{}0 characters in the buffer. The length is taken as given, it must be correct.

\begin{DoxyReturn}{Returns}
0 if out of memory, a pointer otherwise 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em s} & must be an allocated buffer \\
\hline
{\em l} & the length of s \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{kdbhelper_8h_ae6d48ff4971c412f55f29e599a6639f0}\label{kdbhelper_8h_ae6d48ff4971c412f55f29e599a6639f0}} 
\index{kdbhelper.h@{kdbhelper.h}!elektraVFormat@{elektraVFormat}}
\index{elektraVFormat@{elektraVFormat}!kdbhelper.h@{kdbhelper.h}}
\doxysubsubsection{\texorpdfstring{elektraVFormat()}{elektraVFormat()}}
{\footnotesize\ttfamily char char$\ast$ elektra\+V\+Format (\begin{DoxyParamCaption}\item[{const char $\ast$}]{format,  }\item[{va\+\_\+list}]{arg\+\_\+list }\end{DoxyParamCaption})}



Does string formatting in fresh allocated memory. 


\begin{DoxyParams}{Parameters}
{\em format} & as in vprintf() \\
\hline
{\em arg\+\_\+list} & as in vprintf()\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new allocated memory (free with elektra\+Free) 
\end{DoxyReturn}
