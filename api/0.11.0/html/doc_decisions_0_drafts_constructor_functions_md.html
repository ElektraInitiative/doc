<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Constructor Functions for &lt;tt&gt;Key&lt;/tt&gt; and &lt;tt&gt;KeySet&lt;/tt&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
$darkmode
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Add mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_color_doxygen.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Elektra<span id="projectnumber">&#160;0.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Constructor Functions for <code>Key</code> and <code>KeySet</code> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_decisions_0_drafts_constructor_functions"></a> </p>
<h1><a class="anchor" id="autotoc_md1750"></a>
Problem</h1>
<p>The structs for <code>Key</code> and <code>KeySet</code> are opaque, i.e., only the <code>typedef</code>s are part of the public headers, the actual <code>struct</code> definitions are in a private header. Because of that, <code>libelektra-core</code> must provide a way to construct a new <code>Key</code> or <code>KeySet</code>.</p>
<p>However, since both <code>Key</code> and <code>KeySet</code> are rather complex structures consisting of multiple parts (name, value, metadata, and collection of <code>Key</code>s respectively), it is not straightforward to create the best API for these functions.</p>
<h1><a class="anchor" id="autotoc_md1751"></a>
Constraints</h1>
<ul>
<li>Elektra has many bindings. The constructor functions must be callable from all these bindings, with no additional effort. In particular, that means the constructors must not use macros.</li>
<li>Constructor functions should use as little resources as feasible. <code>malloc</code> and <code>memcpy</code> calls should be kept to a minimum and temporary allocations should be avoided.</li>
<li>In accordance with the <a class="el" href="doc_decisions_4_decided_keyname_md.html">Namespace and Name of Keys</a>Namespace and Name of Keys" decision", the constructor functions must not use the escaped name. Only the unescaped name may be used, but the namespace may be passed as a separate parameter, if this has benefits.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1752"></a>
Assumptions</h1>
<ul>
<li>There will be additional <a class="el" href="doc_decisions_0_drafts_builder_functions_md.html">builder functions</a> built on top of the constructor functions. These builder functions will live outside <code>libelektra-core</code>, but user code is expected to use builders rather than calling constructors directly.</li>
<li>Sometimes, it may be desirable to have a function that can construct a <code>Key</code>, including name, value and metadata, or even whole <code>KeySet</code> in a single call. We assume these cases overlap almost entirely, with the cases where we expect builder functions to be used. Therefore, it doesn't matter much, if the constructor functions don't allow this can of <code>Key</code>/<code>KeySet</code> construction and extra calls to e.g., <code>keySetValue</code> are needed.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1753"></a>
Considered Alternatives</h1>
<h2><a class="anchor" id="autotoc_md1754"></a>
No Arguments</h2>
<p>The constructor functions are just specialized allocators:</p>
<div class="fragment"><div class="line">Key * <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="keywordtype">void</span>);</div>
<div class="line">KeySet * <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (<span class="keywordtype">void</span>);</div>
<div class="ttc" id="agroup__key_html_gad23c65b44bf48d773759e1f9a4d43b89"><div class="ttname"><a href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a></div><div class="ttdeci">Key * keyNew(const char *name,...)</div><div class="ttdoc">A practical way to fully create a Key object in one step.</div><div class="ttdef"><b>Definition:</b> key.c:144</div></div>
<div class="ttc" id="agroup__keyset_html_ga671e1aaee3ae9dc13b4834a4ddbd2c3c"><div class="ttname"><a href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a></div><div class="ttdeci">KeySet * ksNew(size_t alloc,...)</div><div class="ttdoc">Allocate, initialize and return a new KeySet object.</div><div class="ttdef"><b>Definition:</b> keyset.c:282</div></div>
</div><!-- fragment --><p>While this would work decently well for <code>ksNew</code> (don't allocate array, only allocate array on first <code>Key</code> insertion), there is an issue for <code>keyNew</code>. A <code>Key</code> must have a name. Therefore, <code>keyNew</code> must set some default name in the <code>Key</code> it returns.</p>
<p>Even if there was a suitable default name, it would still be wasteful, since in many (almost all) cases, the name will soon be replaced via a <code>keySetName</code> call.</p>
<p>A clear advantage of this option is that the very simple API means the functions are callable without issue from basically any language.</p>
<h2><a class="anchor" id="autotoc_md1755"></a>
Minimal Arguments</h2>
<p>Instead of taking no arguments at all, the constructor functions take the minimal number of arguments:</p>
<div class="fragment"><div class="line"><span class="comment">// ns is separate to allow usage of ELEKTRA_NS_* constants</span></div>
<div class="line"><span class="comment">// size is needed because name can contain \0</span></div>
<div class="line">Key * <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (ElektraNamespace ns, <span class="keyword">const</span> <span class="keywordtype">char</span> * name, <span class="keywordtype">size_t</span> size);</div>
<div class="line">KeySet * <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (<span class="keywordtype">size_t</span> alloc);</div>
</div><!-- fragment --><p>This solves the default name issue for <code>keyNew</code>. For <code>ksNew</code> there was no issue and the <code>alloc</code> parameter isn't strictly speaking needed, but it can still be helpful. For example, if the caller knows they will insert 100 keys, the can call <code>ksNew (100)</code> to avoid later allocations to resize the array in the <code>KeySet</code>.</p>
<p>The API is also still simple enough that it can be called from any binding.</p>
<h3><a class="anchor" id="autotoc_md1756"></a>
Sidenote: Bundle struct</h3>
<p>Depending on the rest of the <code>libelektra-core</code> API, it may make sense to use a public struct to bundle the arguments of <code>keyNew</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">  ElektraNamespace ns;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">} KeyName;</div>
<div class="line"> </div>
<div class="line">Key * keyNewStruct (KeyName name);</div>
<div class="line"><span class="comment">// called as e.g.: keyNew ((KeyName){.ns = ELEKTRA_NS_SYSTEM, .name = &quot;foo\0bar&quot;, .size = 7 })</span></div>
<div class="line">Key * keyNewStructAlt (<span class="keyword">const</span> KeyName * name);</div>
<div class="line"><span class="comment">// called as e.g.: keyNew (&amp;(KeyName){.ns = ELEKTRA_NS_SYSTEM, .name = &quot;foo\0bar&quot;, .size = 7 })</span></div>
</div><!-- fragment --><p>Whether the struct would be passed by value or as a pointer also depends on the rest of the API.</p>
<p>An important distinction between <code>Key</code> and <code>KeyName</code> in this solution is that <code>Key</code> can be seen as more of class, while <code>KeyName</code> is just a bundle of fields. That is why <code>Key</code> is opaque and <code>KeyName</code> would be public. The fields of a <code>Key</code> are implementation details, but <code>KeyName</code> is just a kind of alias for its fields.</p>
<h2><a class="anchor" id="autotoc_md1757"></a>
Common Arguments</h2>
<p>Lots of <code>Key</code>s will have a value from the moment they are created, e.g., <code>meta:/</code> keys are rarely created without a value. Therefore, it might make sense if <code>keyNew</code> took an optional (=nullable) argument for the value of the key:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">void</span> * value;</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">} KeyValue;</div>
<div class="line"> </div>
<div class="line">Key * <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="keyword">const</span> KeyName * name, <span class="keyword">const</span> KeyValue * value);</div>
<div class="line"><span class="comment">// called as e.g.:</span></div>
<div class="line"><span class="comment">// keyNew ((KeyName){.ns = ELEKTRA_NS_SYSTEM, .name = &quot;foo\0bar&quot;, .size = 7 }, NULL)</span></div>
<div class="line"><span class="comment">// keyNew ((KeyName){.ns = ELEKTRA_NS_SYSTEM, .name = &quot;foo\0bar&quot;, .size = 7 }, (KeyValue){.value = &quot;1234&quot;, .size = 5})</span></div>
</div><!-- fragment --><blockquote class="doxtable">
<p><b>Note</b>: Because this solution is much easier with the bundle structs, we use them here. It would work without them as well, but we'd need two optional arguments (pointer and size) for the value. Similarly, passing the bundle struct by value would mean you have to pass <code>(KeyValue){ .value = NULL, .size = 0 }</code> instead of just <code>NULL</code>. </p>
</blockquote>
<p>For <code>KeySet</code>, we can pass a list of <code>Key *</code> to initialize the <code>KeySet</code> with:</p>
<div class="fragment"><div class="line"><span class="comment">// every variadic argument must be a Key *, the last argument must be NULL</span></div>
<div class="line">KeySet * <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (<span class="keywordtype">size_t</span> alloc, ...);</div>
</div><!-- fragment --><p>This API is easy to call in C:</p>
<div class="fragment"><div class="line">KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (3, key1, key2, key3, NULL);</div>
</div><!-- fragment --><p>However, many languages for which we provide bindings can't use variadic arguments. So it would make more sense to have a function like this only in a C-specific library (<code>libelektra-lowlevel-c</code>), and have the version from above in <code>libelektra-core</code>.</p>
<p>An alternative would be to use an array argument:</p>
<div class="fragment"><div class="line"><span class="comment">// last element of `keys` must be NULL</span></div>
<div class="line">KeySet * <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (<span class="keywordtype">size_t</span> alloc, Key * keys[]);</div>
</div><!-- fragment --><p>This is easier to call from other languages, but it's slightly more cumbersome in C:</p>
<div class="fragment"><div class="line">KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (3, (Key*[]){key1, key2, key3, NULL});</div>
</div><!-- fragment --><p>The array parameter also has some other advantages. We could copy it with a single <code>memcpy</code> and use something like <code>qsort</code>, instead of copying the <code>Key *</code> one by one from the variadic arguments. Also, a <code>Key *[]</code> provides more type safety compared to a variadic arguments.</p>
<h2><a class="anchor" id="autotoc_md1758"></a>
Full Arguments</h2>
<p>For <code>ksNew</code> the above solution already uses the full set of arguments to initialize a <code>KeySet</code> fully.</p>
<p>For <code>Key</code> we'd also need to take metadata.</p>
<blockquote class="doxtable">
<p><b>Note</b>: This solution is described only for completeness's sake. We assume that <a class="el" href="doc_decisions_0_drafts_builder_functions_md.html">Builder Functions for <code>Key</code> and <code>KeySet</code></a>builder functions"" exist outside of <code>libelektra-core</code>. With this solution those builders would be superfluous. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md1759"></a>
Variadic Arguments</h3>
<p>This could be done by using a system of variadic arguments, called like so:</p>
<div class="fragment"><div class="line"><span class="comment">// system:/foo/bar with value 1234 and metadata: meta:/type=long, meta:/length/min=4</span></div>
<div class="line"><a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (ELEKTRA_NS_SYSTEM, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>, NULL, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, 5, <span class="stringliteral">&quot;1234&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;type&quot;</span>, NULL, <span class="stringliteral">&quot;long&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;min&quot;</span>, NULL, 4, NULL);</div>
<div class="line"><span class="comment">// system:/foo/bar with value 1234 and no metadata</span></div>
<div class="line"><a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (ELEKTRA_NS_SYSTEM, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>, NULL, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, 5, <span class="stringliteral">&quot;1234&quot;</span>, NULL);</div>
<div class="line"><span class="comment">// system:/foo/bar with no value and no metadata</span></div>
<div class="line"><a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (ELEKTRA_NS_SYSTEM, <span class="stringliteral">&quot;foo&quot;</span>, <span class="stringliteral">&quot;bar&quot;</span>, NULL, NULL);</div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2">KEY_META</a></div><div class="ttdeci">@ KEY_META</div><div class="ttdef"><b>Definition:</b> kdbenum.c:92</div></div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a></div><div class="ttdeci">@ KEY_VALUE</div><div class="ttdef"><b>Definition:</b> kdbenum.c:88</div></div>
</div><!-- fragment --><p>However, as discussed above, such functions are hard to call from many other languages. You also loose type safety in C and the function is not particularly intuitive to use. To emphasize this last point, consider that the signature for the above <code>keyNew</code> would likely be:</p>
<div class="fragment"><div class="line">Key * <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (ElektraNamespace ns, ...);</div>
</div><!-- fragment --><p>Things can be slightly improved, by passing the keynames as a single string, but it still a bad API, with lost of potential for misuse.</p>
<h3><a class="anchor" id="autotoc_md1760"></a>
Metadata Array</h3>
<p>A better option would be to build on the bundle structs option from above, by adding an new struct for metadata:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">  <span class="comment">// no namespace, because that is always ELEKTRA_NS_META</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> * name;</div>
<div class="line">  <span class="keywordtype">size_t</span> nameSize;</div>
<div class="line">  KeyValue value;</div>
<div class="line">} KeyMeta;</div>
<div class="line"> </div>
<div class="line">Key * <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="keyword">const</span> KeyName * name, <span class="keyword">const</span> KeyValue * value, <span class="keyword">const</span> KeyMeta metadata[]);</div>
</div><!-- fragment --><p>This could be called as:</p>
<div class="fragment"><div class="line"><span class="comment">// system:/foo/bar with value 1234 and metadata: meta:/type=long, meta:/length/min=4</span></div>
<div class="line"><a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (</div>
<div class="line">  &amp;(KeyName){.ns = ELEKTRA_NS_SYSTEM, .name = <span class="stringliteral">&quot;foo\0bar&quot;</span>, .size = 8 },</div>
<div class="line">  &amp;(KeyValue){.value = <span class="stringliteral">&quot;1234&quot;</span>, .size = 5},</div>
<div class="line">  (KeyMeta[]){</div>
<div class="line">    {.name = <span class="stringliteral">&quot;type&quot;</span>, .nameSize = 5, .value = {.value = <span class="stringliteral">&quot;long&quot;</span>, .size = 5}},</div>
<div class="line">    {.name = <span class="stringliteral">&quot;length\0min&quot;</span>, .nameSize = 11, .value = {.value = <span class="stringliteral">&quot;4&quot;</span>, .size = 2}},</div>
<div class="line">  });</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1761"></a>
Decision</h1>
<p><b>Suggestion:</b> Minimal Arguments</p>
<h1><a class="anchor" id="autotoc_md1762"></a>
Rationale</h1>
<ul>
<li>The "Minimal Arguments" solution can still be considered minimal, while the more complex solutions are not really minimal anymore.</li>
<li>For <code>libelektra-core</code> "Minimal Arguments" is enough. The more complex APIs can be provided as <a class="el" href="doc_decisions_0_drafts_builder_functions_md.html">builder functions</a> in other libraries.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1763"></a>
Implications</h1>
<ul>
<li>You need an extra library beyond <code>libelektra-core</code> to construct <code>Key</code>s and <code>KeySet</code>s in a single call.</li>
</ul>
<h1><a class="anchor" id="autotoc_md1764"></a>
Related Decisions</h1>
<ul>
<li><a class="el" href="doc_decisions_4_decided_keyname_md.html">Namespace and Name of Keys</a></li>
<li><a class="el" href="doc_decisions_0_drafts_builder_functions_md.html">Builder Functions for `Key` and `KeySet`</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md1765"></a>
Notes</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark'
  });
</script>
</body>
</html>
