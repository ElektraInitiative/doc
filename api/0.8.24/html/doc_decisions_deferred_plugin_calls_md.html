<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Deferred Plugin Calls</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.24</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Deferred Plugin Calls </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Issue</h2>
<p>Calling exported functions is a primary way for coordinating plugins in Elektra. Since some plugins encapsulate other plugins, exported functions from encapsulated plugins become unavailable.</p>
<p>Since encapsulating plugins cannot implement and forward calls for every function exported by encapsulated plugins a generic mechanism for function calls to these encapsulated plugins is needed.</p>
<p>Since some plugins also lazy-load encapsulated plugins the call mechanism is required to be able to defer these calls until the plugins are loaded.</p>
<p>For example when setting I/O bindings with <code><a class="el" href="group__kdbio.html#ga187345483bdfbb404919c6797bc2db77" title="Set I/O binding for asynchronous I/O operations for KDB instance. ">elektraIoSetBinding()</a></code> the exported function <code>setIoBinding</code> is called for all globally mounted plugins. Since global mounting is implemented using the "list" plugin which uses lazy-loading for its plugins the exported functions from the plugins are unavailable.</p>
<p>Other examples are the "dini" and "multifile" plugins which use multiple plugins to support different file formats. These plugins also "hide" functions exported by encapsulated plugins.</p>
<h2>Constraints</h2>
<ol type="1">
<li>Plugins encapsulating other plugins shall be able to lazy-load them.</li>
<li>Callers shall not be entangled in encapsulating plugin details.</li>
<li>The encapsulation of the plugins shall not be broken.</li>
<li>The mechanism shall be generic.</li>
</ol>
<h2>Assumptions</h2>
<ol type="1">
<li>The called functions do not return a value (e.g. <code>set</code>, <code>open</code>, <code>close</code>, ...). Callbacks can be used as return channel (see "Implications")</li>
</ol>
<h2>Considered Alternatives</h2>
<ul>
<li>Encapsulating plugins export a function called <code>getEncapsulatedPlugins</code>. This would break encapsulation and break lazy-loading since to return the encapsulated plugin handles they have to be loaded.</li>
<li><p class="startli">Compatible plugins export a function called <code>getInterfaces</code>. It returns a KeySet with well-known interface names like "notification" or "ioBinding" and the required functions (e.g. <code>open</code> &amp; <code>close</code> for "notification" or <code>set</code> for "ioBinding"). While normal plugins simply return their interfaces, encapsulating plugins collect interfaces from its plugins and combine them into a single KeySet.</p>
<p class="startli">The example below shows a KeySet from a plugin encapsulating two plugins "A" and "B". Both plugins implement the "notification" interface, plugin "B" also implements the "ioBinding" interface.</p><ul>
<li><code>/notification/#0/open</code>: address of <code>openNotification</code> of plugin "A"</li>
<li><code>/notification/#0/close</code>: address of <code>closeNotification</code> of plugin "A"</li>
<li><code>/notification/#1/open</code>: address of <code>openNotification</code> of plugin "B"</li>
<li><code>/notification/#1/close</code>: address of <code>closeNotification</code> of plugin "B"</li>
<li><code>/ioBinding/#0/set</code>: address of <code>setIoBinding</code> of plugin "B"</li>
</ul>
<p class="startli">The upside of this approach is that it makes encapsulating plugins transparent to the caller - it does not known whether the plugin encapsulates other plugins. This approach breaks lazy-loading since for combining all interfaces the plugins have to be loaded and their <code>getInterfaces</code> functions have to be called.</p>
</li>
</ul>
<h2>Decision</h2>
<p>Encapsulating plugins export a function called <code>deferredCall</code> with the declaration <code>void elektraDeferredCall (Plugin * plugin, char * name, KeySet * parameters)</code>. Encapsulating plugins shall save multiple deferred calls and call the exported functions specified by <code>name</code> passing the <code>parameters</code> KeySet when a plugin is initialized in the same order as received.</p>
<p>Plugins that support deferred calls shall have the following declaration for their functions <code>void somePluginFunction (Plugin * plugin, KeySet * parameters)</code>. The calling developer is responsible for ensuring that the called functions have a compatible declaration. Encapsulated plugins that do not export a specified function name are omitted.</p>
<h2>Argument</h2>
<p>The solution allows to change encapsulating plugin implementations without breaking callers.</p>
<h2>Implications</h2>
<p>The called function receive their parameters via a KeySet.</p>
<p>While called functions could return data using the <code>parameters</code> KeySet (or a separate KeySet) there is no defined moment when the data can be collected. Defining such a moment would break the lazy-loading constraint. It is recommended to use callbacks passed as <code>parameters</code>. Callback function declarations are not limited by this decision.</p>
<h2>Related decisions</h2>
<ul>
<li>Elektra's invoke functionality will be extended to also allow us to use deferred calls with new functions:</li>
<li><code>int elektraInvokeFunctionDeferred (ElektraInvokeHandle * handle, const char * elektraPluginFunctionName, KeySet * ks)</code> which defers a call if the plugin exports <code>deferredCall</code>.</li>
<li><code>void elektraInvokeExecuteDeferredCalls (ElektraInvokeHandle * handle, ElektraDeferredCallList * list)</code> which executes deferred calls for a encapsulated plugin loaded with invoke.</li>
<li>Functions supporting deferred calls should allow for multiple calls (i.e. they should be idempotent). This leaves state at affected plugins and does avoid duplicating state (e.g. "was this function called for this plugin before?") in encapsulating plugins.</li>
</ul>
<h2>Notes</h2>
<p>Utility functions that help with managing deferred calls would be nice:</p>
<ul>
<li><code>ElektraDeferredCallList * elektraDeferredCallCreateList (void)</code></li>
<li><code>void elektraDeferredCallDeleteList (ElektraDeferredCallList * list)</code></li>
<li><code>int elektraDeferredCallAdd (ElektraDeferredCallList * list, char * name, KeySet * parameters)</code></li>
<li><code>void elektraDeferredCallsExecute (Plugin * plugin, ElektraDeferredCallList * list)</code> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
