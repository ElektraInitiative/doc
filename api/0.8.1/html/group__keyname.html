<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Elektra: Key :: Name Manipulation Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Key :: Name Manipulation Methods</h1>  </div>
</div>
<div class="contents">

<p>Methods to do various operations on Key names.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (const <a class="el" href="struct__Key.html">Key</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a> (const <a class="el" href="struct__Key.html">Key</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a> (const <a class="el" href="struct__Key.html">Key</a> *key, char *returnedName, size_t maxSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (<a class="el" href="struct__Key.html">Key</a> *key, const char *newName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize</a> (const <a class="el" href="struct__Key.html">Key</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName</a> (const <a class="el" href="struct__Key.html">Key</a> *key, char *returnedName, size_t maxSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (const <a class="el" href="struct__Key.html">Key</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">keyGetBaseNameSize</a> (const <a class="el" href="struct__Key.html">Key</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName</a> (const <a class="el" href="struct__Key.html">Key</a> *key, char *returned, size_t maxSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (<a class="el" href="struct__Key.html">Key</a> *key, const char *baseName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (<a class="el" href="struct__Key.html">Key</a> *key, const char *baseName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner</a> (const <a class="el" href="struct__Key.html">Key</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga4a4561895741ba2ad10acf007c188593">keyGetOwnerSize</a> (const <a class="el" href="struct__Key.html">Key</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner</a> (const <a class="el" href="struct__Key.html">Key</a> *key, char *returnedOwner, size_t maxSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner</a> (<a class="el" href="struct__Key.html">Key</a> *key, const char *newOwner)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Methods to do various operations on Key names. </p>
<p>To use them: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;kdb.h&gt;</span>
</pre></div><p>These functions make it easier for c programmers to work with key names. Everything here can also be done with keySetName, described in key.</p>
<dl class="user"><dt><b>Rules for Key Names</b></dt><dd></dd></dl>
<p>When using Elektra to store your application's configuration and state, please keep in mind the following rules:</p>
<ul>
<li>You are not allowed to create keys right under <code>system</code> or <code>user</code>.</li>
<li>You are not allowed to create folder keys right under <code>system</code> or <code>user</code>. They are reserved for very essential OS subsystems.</li>
<li>The keys for your application, called say <em>MyApp</em>, should be created under <code>system/sw/MyApp</code> and/or <code>user/sw/MyApp</code>.</li>
<li>It is suggested to make your application look for default keys under <code>system/sw/MyApp/current</code> and/or <code>user/sw/MyApp/current</code>. This way, from a sysadmin perspective, it will be possible to copy the <code>system/sw/MyApp/current</code> tree to something like <code>system/sw/MyApp/old</code>, and keep system clean and organized.</li>
<li>\0 must not occur in names.</li>
<li>/ is the seperator. </li>
</ul>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa942091fc4bd5c2699e49ddc50829524"></a><!-- doxytag: member="keyname.c::keyAddBaseName" ref="gaa942091fc4bd5c2699e49ddc50829524" args="(Key *key, const char *baseName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyAddBaseName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>baseName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds <code>baseName</code> to the current key name.</p>
<p>Assumes that <code>key</code> is a directory. <code>baseName</code> is appended to it. The function adds <code>'/'</code> if needed while concatenating.</p>
<p>So if <code>key</code> has name <code>"system/dir1/dir2"</code> and this method is called with <code>baseName</code> <code>"mykey"</code>, the resulting key will have name <code>"system/dir1/dir2/mykey"</code>.</p>
<p>When baseName is 0 or "" nothing will happen and the size of the name is returned.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>You should not change a keys name once it belongs to a keyset. See ksSort() for more information.</dd></dl>
<p>TODO: does not recognice .. and . in the string!</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>the string to append to the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size in bytes of the new key name including the ending NULL </dd>
<dd>
-1 if the key had no name </dd>
<dd>
-1 on NULL pointers </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> to set a new name. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaff35e7ca8af5560c47e662ceb9465f5"></a><!-- doxytag: member="keyname.c::keyBaseName" ref="gaaff35e7ca8af5560c47e662ceb9465f5" args="(const Key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyBaseName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pointer to the real internal key name where the <code>basename</code> starts.</p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName()</a> and you should use it if you are responsible enough to not mess up things. The name might change or even point to a wrong place after a <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a>. If you need a copy of the basename consider to use <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName()</a>.</p>
<p><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName()</a> returns "" when there is no keyBaseName. The reason is </p>
<div class="fragment"><pre class="fragment">key=<a class="code" href="group__key.html#gaf6893c038b3ebee90c73a9ea8356bebf">keyNew</a>(0);
<a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(key,<span class="stringliteral">&quot;&quot;</span>);
<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key); <span class="comment">// you would expect &quot;&quot; here</span>
<a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(key,<span class="stringliteral">&quot;user&quot;</span>);
<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key); <span class="comment">// you would expect &quot;&quot; here</span>
<a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName()</a> method to set a new value. Use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the object to obtain the basename from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the basename </dd>
<dd>
"" when the key has no (base)name </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName()</a>, <a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">keyGetBaseNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> to get a pointer to the name </dd>
<dd>
<a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a> to get a pointer to the owner </dd></dl>

</div>
</div>
<a class="anchor" id="ga0992d26bcfca767cb8e77053a483eb64"></a><!-- doxytag: member="keyname.c::keyGetBaseName" ref="ga0992d26bcfca767cb8e77053a483eb64" args="(const Key *key, char *returned, size_t maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetBaseName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>returned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the basename of a key name and put it in <code>returned</code> finalizing the string with NULL.</p>
<p>Some examples:</p>
<ul>
<li>basename of <code>system/some/keyname</code> is <code>keyname</code> </li>
<li>basename of <code>"user/tmp/some key"</code> is <code>"some key"</code> </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key to extract basename from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>returned</em>&nbsp;</td><td>a pre-allocated buffer to store the basename </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>size of the <code>returned</code> buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes copied to <code>returned</code> </dd>
<dd>
1 on empty name </dd>
<dd>
-1 on NULL pointers </dd>
<dd>
-1 when maxSize is 0 or larger than SSIZE_MAX </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName()</a>, <a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">keyGetBaseNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>, <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a0b76c5d9e5367c7e72211e6c63d43a"></a><!-- doxytag: member="keyname.c::keyGetBaseNameSize" ref="ga1a0b76c5d9e5367c7e72211e6c63d43a" args="(const Key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetBaseNameSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates number of bytes needed to store basename of <code>key</code>.</p>
<p>Key names that have only root names (e.g. <code>"system"</code> or <code>"user"</code> or <code>"user:domain"</code> ) does not have basenames, thus the function will return 1 bytes to store "".</p>
<p>Basenames are denoted as:</p>
<ul>
<li><code>system/some/thing/basename</code> -&gt; <code>basename</code> </li>
<li><code>user:domain/some/thing/base\/name</code> &gt; <code>base\/name</code> </li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size in bytes of <code>key's</code> basename including ending NULL </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName()</a>, <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>, <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaba1494a5ffc976e0e56c43f4334a23c"></a><!-- doxytag: member="keyname.c::keyGetFullName" ref="gaaba1494a5ffc976e0e56c43f4334a23c" args="(const Key *key, char *returnedName, size_t maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetFullName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>returnedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get key full name, including the user domain name.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes written </dd>
<dd>
1 on empty name </dd>
<dd>
-1 on NULL pointers </dd>
<dd>
-1 if maxSize is 0 or larger than SSIZE_MAX </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>returnedName</em>&nbsp;</td><td>pre-allocated memory to write the key name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>maximum number of bytes that will fit in returnedName, including the final NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab65dc9d43d3ee08d5e936a20ebbddd23"></a><!-- doxytag: member="keyname.c::keyGetFullNameSize" ref="gab65dc9d43d3ee08d5e936a20ebbddd23" args="(const Key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetFullNameSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bytes needed to store the key name including user domain and ending NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes needed to store key name including user domain </dd>
<dd>
1 on empty name </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab29a850168d9b31c9529e90cf9ab68be"></a><!-- doxytag: member="keyname.c::keyGetName" ref="gab29a850168d9b31c9529e90cf9ab68be" args="(const Key *key, char *returnedName, size_t maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>returnedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get abbreviated key name (without owner name).</p>
<p>When there is not enough space to write the name, nothing will be written and -1 will be returned.</p>
<p>maxSize is limited to SSIZE_MAX. When this value is exceeded -1 will be returned. The reason for that is that any value higher is just a negative return value passed by accident. Of course malloc is not as failure tolerant and will try to allocate.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> *getBack = malloc (<a class="code" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a>(key));
<a class="code" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a>(key, getBack, <a class="code" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a>(key));
</pre></div><dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes written to <code>returnedName</code> </dd>
<dd>
1 when only a null was written </dd>
<dd>
-1 when keyname is longer then maxSize or 0 or any NULL pointer </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>returnedName</em>&nbsp;</td><td>pre-allocated memory to write the key name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>maximum number of bytes that will fit in returnedName, including the final NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabdbcfa51ed8a387e47ead207affa2d2e"></a><!-- doxytag: member="keyname.c::keyGetNameSize" ref="gabdbcfa51ed8a387e47ead207affa2d2e" args="(const Key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetNameSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bytes needed to store the key name without owner.</p>
<p>For an empty key name you need one byte to store the ending NULL. For that reason 1 is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes needed, including ending NULL, to store key name without owner </dd>
<dd>
1 if there is is no key Name </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga35922a017bee8b4bcb493bbdfad9d6f5"></a><!-- doxytag: member="keyname.c::keyGetOwner" ref="ga35922a017bee8b4bcb493bbdfad9d6f5" args="(const Key *key, char *returnedOwner, size_t maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetOwner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>returnedOwner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the owner of the key.</p>
<ul>
<li>Given <code>user:someuser/</code>..... return <code>someuser</code> </li>
<li>Given <code>user:some.user/</code>.... return <code>some.user</code> </li>
<li>Given <code>user/</code>.... return the current user</li>
</ul>
<p>Only <code>user/</code>... keys have a owner. For <code>system/</code>... keys (that doesn't have a key owner) an empty string ("") is returned.</p>
<p>Although usually the same, the owner of a key is not related to its UID. Owner are related to WHERE the key is stored on disk, while UIDs are related to mode controls of a key.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>returnedOwner</em>&nbsp;</td><td>a pre-allocated space to store the owner </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSize</em>&nbsp;</td><td>maximum number of bytes that fit returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes written to buffer </dd>
<dd>
1 if there is no owner </dd>
<dd>
-1 on NULL pointers </dd>
<dd>
-1 when maxSize is 0, larger than SSIZE_MAX or too small for ownername </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a>, <a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner()</a>, <a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a4561895741ba2ad10acf007c188593"></a><!-- doxytag: member="keyname.c::keyGetOwnerSize" ref="ga4a4561895741ba2ad10acf007c188593" args="(const Key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetOwnerSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size of the owner of the Key with concluding 0.</p>
<p>The returned number can be used to allocate a string. 1 will returned on an empty owner to store the concluding 0 on using <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> * buffer;
buffer = malloc (<a class="code" href="group__keyname.html#ga4a4561895741ba2ad10acf007c188593">keyGetOwnerSize</a> (key));
<span class="comment">// use buffer and keyGetOwnerSize (key) for maxSize</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>that -1 might be returned on null pointer, so when you directly allocate afterwards its best to check if you will pass a null pointer before.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes </dd>
<dd>
1 if there is no owner </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e805c726a60da921d3736cda7813513"></a><!-- doxytag: member="keyname.c::keyName" ref="ga8e805c726a60da921d3736cda7813513" args="(const Key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a pointer to the abbreviated real internal <code>key</code> name.</p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a> and can use it if you are responsible enough to not mess up things. You are not allowed to change anything in the returned array. The content of that string may change after <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> and similar functions. If you need a copy of the name, consider using <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>.</p>
<p>The name will be without owner, see <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a> if you need the name with its owner.</p>
<p><a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> returns "" when there is no keyName. The reason is </p>
<div class="fragment"><pre class="fragment">key=<a class="code" href="group__key.html#gaf6893c038b3ebee90c73a9ea8356bebf">keyNew</a>(0);
<a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(key,<span class="stringliteral">&quot;&quot;</span>);
<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key); <span class="comment">// you would expect &quot;&quot; here</span>
<a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> method to set a new value. Use <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the keyname which must not be changed. </dd>
<dd>
"" when there is no (a empty) keyname </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize()</a> for the string length </dd>
<dd>
<a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize()</a> to get the full name </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a> as alternative to get a copy </dd>
<dd>
<a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a> to get a pointer to owner </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6485fb8599714b6bbd830cf915ffea5"></a><!-- doxytag: member="keyname.c::keyOwner" ref="gaf6485fb8599714b6bbd830cf915ffea5" args="(const Key *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyOwner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the real internal <code>key</code> owner.</p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a> and you should use it if you are responsible enough to not mess up things. You are not allowed to modify the returned string in any way. If you need a copy of the string, consider to use <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a> instead.</p>
<p><a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a> returns "" when there is no keyOwner. The reason is </p>
<div class="fragment"><pre class="fragment">key=<a class="code" href="group__key.html#gaf6893c038b3ebee90c73a9ea8356bebf">keyNew</a>(0);
<a class="code" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner</a>(key,<span class="stringliteral">&quot;&quot;</span>);
<a class="code" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner</a>(key); <span class="comment">// you would expect &quot;&quot; here</span>
<a class="code" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner</a>(key,<span class="stringliteral">&quot;system&quot;</span>);
<a class="code" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner</a>(key); <span class="comment">// you would expect &quot;&quot; here</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a> method to set a new value. Use <a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner()</a> instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to internal owner </dd>
<dd>
"" when there is no (a empty) owner </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#ga4a4561895741ba2ad10acf007c188593">keyGetOwnerSize()</a> for the size of the string with concluding 0 </dd>
<dd>
<a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a>, <a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> for name without owner </dd>
<dd>
<a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a> for name with owner </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e804bd453f98c28b0ff51430d1df407"></a><!-- doxytag: member="keyname.c::keySetBaseName" ref="ga6e804bd453f98c28b0ff51430d1df407" args="(Key *key, const char *baseName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetBaseName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>baseName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets <code>baseName</code> as the new basename for <code>key</code>.</p>
<p>All text after the last <code>'/'</code> in the <code>key</code> keyname is erased and <code>baseName</code> is appended.</p>
<p>So lets suppose <code>key</code> has name <code>"system/dir1/dir2/key1"</code>. If <code>baseName</code> is <code>"key2"</code>, the resulting key name will be <code>"system/dir1/dir2/key2"</code>. If <code>baseName</code> is empty or NULL, the resulting key name will be <code>"system/dir1/dir2"</code>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>You should not change a keys name once it belongs to a keyset. See ksSort() for more information.</dd></dl>
<p>TODO: does not work with .. and .</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>the string used to overwrite the basename of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size in bytes of the new key name </dd>
<dd>
-1 on NULL pointers </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> to set a new name </dd></dl>

</div>
</div>
<a class="anchor" id="ga7699091610e7f3f43d2949514a4b35d9"></a><!-- doxytag: member="keyname.c::keySetName" ref="ga7699091610e7f3f43d2949514a4b35d9" args="(Key *key, const char *newName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a new name to a key.</p>
<p>A valid name is of the forms:</p>
<ul>
<li><code>system/something</code> </li>
<li><code>user/something</code> </li>
<li><code>user:username/something</code> </li>
</ul>
<p>The last form has explicitly set the owner, to let the library know in which user folder to save the key. A owner is a user name. If not defined (the second form) current user is calculated and used as default.</p>
<p>You should always follow the guidelines for key tree structure creation.</p>
<p>A private copy of the key name will be stored, and the <code>newName</code> parameter can be freed after this call.</p>
<p>.., . and / will be handled correctly. A valid name will be build out of the (valid) name what you pass, e.g. user///sw/../sw//././MyApp -&gt; user/sw/MyApp</p>
<p>On invalid names, NULL or "" the name will be "" afterwards.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>You should not change a keys name once it belongs to a keyset. See ksSort() for more information.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size in bytes of this new key name including ending NULL </dd>
<dd>
-1 if <code>newName</code> is empty or invalid or any NULL pointer </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newName</em>&nbsp;</td><td>the new key name </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__key.html#gaf6893c038b3ebee90c73a9ea8356bebf">keyNew()</a>, <a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a>, <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a>, <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName()</a> to manipulate a name </dd></dl>

</div>
</div>
<a class="anchor" id="ga88d6ec200ba0707b7c1b4a88133d2be4"></a><!-- doxytag: member="keyname.c::keySetOwner" ref="ga88d6ec200ba0707b7c1b4a88133d2be4" args="(Key *key, const char *newOwner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newOwner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the owner of a key.</p>
<p>A owner is a name of a system user related to a UID. The owner decides on which location on the disc the key goes.</p>
<p>A private copy is stored, so the passed parameter can be freed after the call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>the key object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newOwner</em>&nbsp;</td><td>the string which describes the owner of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes actually saved including final NULL </dd>
<dd>
1 when owner is freed (by setting 0 or "") </dd>
<dd>
-1 on null pointer or memory problems </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a>, <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a> </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Jun 9 2012 14:24:25 for Elektra by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
