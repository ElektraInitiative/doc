<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Elektra: Meta Data proposal+compatibility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Meta Data proposal+compatibility</div>  </div>
<div class="ingroups"><a class="el" href="group__proposal.html">Proposals for Elektra</a></div></div><!--header-->
<div class="contents">

<p>Meta data proposal+compatibility methods.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Meta Data proposal+compatibility:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__meta.png" border="0" alt="" usemap="#group____meta"/>
<map name="group____meta" id="group____meta">
<area shape="rect" id="node1" href="group__proposal.html" title="Might be added to, changed or removed from future Elektra releases." alt="" coords="5,13,147,41"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf6485fb8599714b6bbd830cf915ffea5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner</a> (const Key *key)</td></tr>
<tr class="memdesc:gaf6485fb8599714b6bbd830cf915ffea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the real internal <code>key</code> owner.  <a href="#gaf6485fb8599714b6bbd830cf915ffea5"></a><br/></td></tr>
<tr class="separator:gaf6485fb8599714b6bbd830cf915ffea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4561895741ba2ad10acf007c188593"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga4a4561895741ba2ad10acf007c188593">keyGetOwnerSize</a> (const Key *key)</td></tr>
<tr class="memdesc:ga4a4561895741ba2ad10acf007c188593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the owner of the Key with concluding 0.  <a href="#ga4a4561895741ba2ad10acf007c188593"></a><br/></td></tr>
<tr class="separator:ga4a4561895741ba2ad10acf007c188593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35922a017bee8b4bcb493bbdfad9d6f5"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner</a> (const Key *key, char *returnedOwner, size_t maxSize)</td></tr>
<tr class="memdesc:ga35922a017bee8b4bcb493bbdfad9d6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the owner of the key.  <a href="#ga35922a017bee8b4bcb493bbdfad9d6f5"></a><br/></td></tr>
<tr class="separator:ga35922a017bee8b4bcb493bbdfad9d6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d6ec200ba0707b7c1b4a88133d2be4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner</a> (Key *key, const char *newOwner)</td></tr>
<tr class="memdesc:ga88d6ec200ba0707b7c1b4a88133d2be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the owner of a key.  <a href="#ga88d6ec200ba0707b7c1b4a88133d2be4"></a><br/></td></tr>
<tr class="separator:ga88d6ec200ba0707b7c1b4a88133d2be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac89fd319783b3457db45b4c09e55274a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a">keyComment</a> (const Key *key)</td></tr>
<tr class="memdesc:gac89fd319783b3457db45b4c09e55274a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the real internal <code>key</code> comment.  <a href="#gac89fd319783b3457db45b4c09e55274a"></a><br/></td></tr>
<tr class="separator:gac89fd319783b3457db45b4c09e55274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dd737fadc16d4cf16720d17f066a9d3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3">keyGetCommentSize</a> (const Key *key)</td></tr>
<tr class="memdesc:ga0dd737fadc16d4cf16720d17f066a9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bytes needed to store a key comment, including final NULL.  <a href="#ga0dd737fadc16d4cf16720d17f066a9d3"></a><br/></td></tr>
<tr class="separator:ga0dd737fadc16d4cf16720d17f066a9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb89735689929ff717cc9f2d0d0b46a2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2">keyGetComment</a> (const Key *key, char *returnedComment, size_t maxSize)</td></tr>
<tr class="memdesc:gafb89735689929ff717cc9f2d0d0b46a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the key comment.  <a href="#gafb89735689929ff717cc9f2d0d0b46a2"></a><br/></td></tr>
<tr class="separator:gafb89735689929ff717cc9f2d0d0b46a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8863a877a84fa46e6017fe72e49b89c1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1">keySetComment</a> (Key *key, const char *newComment)</td></tr>
<tr class="memdesc:ga8863a877a84fa46e6017fe72e49b89c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a comment for a key.  <a href="#ga8863a877a84fa46e6017fe72e49b89c1"></a><br/></td></tr>
<tr class="separator:ga8863a877a84fa46e6017fe72e49b89c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa5060e67b03f50ae49a3620c54bc46"><td class="memItemLeft" align="right" valign="top">uid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gacaa5060e67b03f50ae49a3620c54bc46">keyGetUID</a> (const Key *key)</td></tr>
<tr class="memdesc:gacaa5060e67b03f50ae49a3620c54bc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the user ID of a key.  <a href="#gacaa5060e67b03f50ae49a3620c54bc46"></a><br/></td></tr>
<tr class="separator:gacaa5060e67b03f50ae49a3620c54bc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f284f5ecd261e0a290095f50ba1af7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gab5f284f5ecd261e0a290095f50ba1af7">keySetUID</a> (Key *key, uid_t uid)</td></tr>
<tr class="memdesc:gab5f284f5ecd261e0a290095f50ba1af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user ID of a key.  <a href="#gab5f284f5ecd261e0a290095f50ba1af7"></a><br/></td></tr>
<tr class="separator:gab5f284f5ecd261e0a290095f50ba1af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a95e81d7d7f4e3eb59e60e5f3738c0"><td class="memItemLeft" align="right" valign="top">gid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga46a95e81d7d7f4e3eb59e60e5f3738c0">keyGetGID</a> (const Key *key)</td></tr>
<tr class="memdesc:ga46a95e81d7d7f4e3eb59e60e5f3738c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the group ID of a key.  <a href="#ga46a95e81d7d7f4e3eb59e60e5f3738c0"></a><br/></td></tr>
<tr class="separator:ga46a95e81d7d7f4e3eb59e60e5f3738c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e3d0fb3f7ba906e067727b9155d22e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga9e3d0fb3f7ba906e067727b9155d22e3">keySetGID</a> (Key *key, gid_t gid)</td></tr>
<tr class="memdesc:ga9e3d0fb3f7ba906e067727b9155d22e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the group ID of a key.  <a href="#ga9e3d0fb3f7ba906e067727b9155d22e3"></a><br/></td></tr>
<tr class="separator:ga9e3d0fb3f7ba906e067727b9155d22e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae575bd86a628a15ee45baa860522e75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gaae575bd86a628a15ee45baa860522e75">keySetDir</a> (Key *key)</td></tr>
<tr class="memdesc:gaae575bd86a628a15ee45baa860522e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set mode so that key will be recognized as directory.  <a href="#gaae575bd86a628a15ee45baa860522e75"></a><br/></td></tr>
<tr class="separator:gaae575bd86a628a15ee45baa860522e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0cec592ce3b77e9bc33dbc8e8f6bdc"><td class="memItemLeft" align="right" valign="top">mode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gabc0cec592ce3b77e9bc33dbc8e8f6bdc">keyGetMode</a> (const Key *key)</td></tr>
<tr class="memdesc:gabc0cec592ce3b77e9bc33dbc8e8f6bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the key mode permissions.  <a href="#gabc0cec592ce3b77e9bc33dbc8e8f6bdc"></a><br/></td></tr>
<tr class="separator:gabc0cec592ce3b77e9bc33dbc8e8f6bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8803037e35b9da1ce492323a88ff6bc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga8803037e35b9da1ce492323a88ff6bc3">keySetMode</a> (Key *key, mode_t mode)</td></tr>
<tr class="memdesc:ga8803037e35b9da1ce492323a88ff6bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the key mode permissions.  <a href="#ga8803037e35b9da1ce492323a88ff6bc3"></a><br/></td></tr>
<tr class="separator:ga8803037e35b9da1ce492323a88ff6bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b05da399c3c78904969ef39f191b0eb"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga6b05da399c3c78904969ef39f191b0eb">keyGetATime</a> (const Key *key)</td></tr>
<tr class="memdesc:ga6b05da399c3c78904969ef39f191b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last time the key data was read from disk.  <a href="#ga6b05da399c3c78904969ef39f191b0eb"></a><br/></td></tr>
<tr class="separator:ga6b05da399c3c78904969ef39f191b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995d8b84731673c88c7c01f3fed538b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga995d8b84731673c88c7c01f3fed538b9">keySetATime</a> (Key *key, time_t atime)</td></tr>
<tr class="memdesc:ga995d8b84731673c88c7c01f3fed538b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the atime information for a key.  <a href="#ga995d8b84731673c88c7c01f3fed538b9"></a><br/></td></tr>
<tr class="separator:ga995d8b84731673c88c7c01f3fed538b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57689eb5691679071463b777ae786ae9"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga57689eb5691679071463b777ae786ae9">keyGetMTime</a> (const Key *key)</td></tr>
<tr class="memdesc:ga57689eb5691679071463b777ae786ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last modification time of the key on disk.  <a href="#ga57689eb5691679071463b777ae786ae9"></a><br/></td></tr>
<tr class="separator:ga57689eb5691679071463b777ae786ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481d8997187992fe4bbf288bc8ef4db7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga481d8997187992fe4bbf288bc8ef4db7">keySetMTime</a> (Key *key, time_t mtime)</td></tr>
<tr class="memdesc:ga481d8997187992fe4bbf288bc8ef4db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the mtime information for a key.  <a href="#ga481d8997187992fe4bbf288bc8ef4db7"></a><br/></td></tr>
<tr class="separator:ga481d8997187992fe4bbf288bc8ef4db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c213c120cbe02201278ef7fb8cd94be"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga2c213c120cbe02201278ef7fb8cd94be">keyGetCTime</a> (const Key *key)</td></tr>
<tr class="memdesc:ga2c213c120cbe02201278ef7fb8cd94be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last time the key metadata was changed from disk.  <a href="#ga2c213c120cbe02201278ef7fb8cd94be"></a><br/></td></tr>
<tr class="separator:ga2c213c120cbe02201278ef7fb8cd94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f502ecab8ab43f0b17220fcc95f3fa5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga9f502ecab8ab43f0b17220fcc95f3fa5">keySetCTime</a> (Key *key, time_t ctime)</td></tr>
<tr class="memdesc:ga9f502ecab8ab43f0b17220fcc95f3fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the ctime information for a key.  <a href="#ga9f502ecab8ab43f0b17220fcc95f3fa5"></a><br/></td></tr>
<tr class="separator:ga9f502ecab8ab43f0b17220fcc95f3fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b30dfabb0867bd6899e60e7bd193a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gab8b30dfabb0867bd6899e60e7bd193a2">elektraKeyCmpOrder</a> (const Key *ka, const Key *kb)</td></tr>
<tr class="memdesc:gab8b30dfabb0867bd6899e60e7bd193a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the order metadata of two keys.  <a href="#gab8b30dfabb0867bd6899e60e7bd193a2"></a><br/></td></tr>
<tr class="separator:gab8b30dfabb0867bd6899e60e7bd193a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Meta data proposal+compatibility methods. </p>
<p>In versions before Elektra 0.8 only meta data as listed here was available. Now any meta data can be added. These API methods are implementations of the 0.7 API using 0.8 meta data.</p>
<p>Additionally, new suggestions can be made here.</p>
<p>It is planned that these methods will be generated from doc/METADATA.ini and moved to a separate library. Currently, you should better avoid the methods and directly use <a class="el" href="group__keymeta.html">metainfo </a> instead. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab8b30dfabb0867bd6899e60e7bd193a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraKeyCmpOrder </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>ka</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>kb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the order metadata of two keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a number less than, equal to or greater than zero if the order of k1 is found, respectively, to be less than, to match, or be greater than the order of k2. If one key is NULL, but the other isn't, the key which is not NULL is considered to be greater. If both keys are NULL, they are considered to be equal. If one key does have an order metadata but the other has not, the key with the metadata is considered greater. If no key has metadata, they are considered to be equal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ka</td><td>key to compare with </td></tr>
    <tr><td class="paramname">kb</td><td>other key to compare with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac89fd319783b3457db45b4c09e55274a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyComment </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the real internal <code>key</code> comment. </p>
<p>This is a much more efficient version of <a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2" title="Get the key comment.">keyGetComment()</a> and you should use it if you are responsible enough to not mess up things. You are not allowed to change anything in the memory region the returned pointer points to.</p>
<p><a class="el" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a" title="Return a pointer to the real internal key comment.">keyComment()</a> returns "" when there is no keyComment. The reason is </p>
<div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step.">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a" title="Return a pointer to the real internal key comment.">keyComment</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects.">keyDel</a>(key);</div>
</div><!-- fragment --><p>See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> for more information on comments.</p>
<dl class="section note"><dt>Note</dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a" title="Return a pointer to the real internal key comment.">keyComment()</a> method to set a new value. Use <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the internal managed comment </dd>
<dd>
"" when there is no comment </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3" title="Calculates number of bytes needed to store a key comment, including final NULL.">keyGetCommentSize()</a> for size and <a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2" title="Get the key comment.">keyGetComment()</a> as alternative </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b05da399c3c78904969ef39f191b0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t keyGetATime </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get last time the key data was read from disk. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>Every <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> might update the access time of a key. You get information when the key was read the last time from the database.</p>
<p>You will get 0 when the key was not read already.</p>
<p>Beware that multiple copies of keys with <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key.">keyDup()</a> might have different atimes because you <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> one, but not the other. You can use this information to decide which key is the latest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to get information from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time you got the key with <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> </dd>
<dd>
0 on key that was never <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> </dd>
<dd>
(time_t)-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga995d8b84731673c88c7c01f3fed538b9" title="Update the atime information for a key.">keySetATime()</a> </dd>
<dd>
<a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafb89735689929ff717cc9f2d0d0b46a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetComment </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedComment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the key comment. </p>
<h1><a class="anchor" id="comment"></a>
Comments</h1>
<p>A Key comment is description for humans what this key is for. It may be a textual explanation of valid values, when and why a user or administrator changed the key or any other text that helps the user or administrator related to that key.</p>
<p>Don't depend on a comment in your program. A user is always allowed to remove or change it in any way he wants to. But you are allowed or even encouraged to always show the content of the comment to the user and allow him to change it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">returnedComment</td><td>pre-allocated memory to copy the comments to </td></tr>
    <tr><td class="paramname">maxSize</td><td>number of bytes that will fit returnedComment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually copied to <code>returnedString</code>, including final NULL </dd>
<dd>
1 if the string is empty </dd>
<dd>
-1 on NULL pointer </dd>
<dd>
-1 if maxSize is 0, not enough to store the comment or when larger then SSIZE_MAX </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3" title="Calculates number of bytes needed to store a key comment, including final NULL.">keyGetCommentSize()</a>, <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dd737fadc16d4cf16720d17f066a9d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetCommentSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of bytes needed to store a key comment, including final NULL. </p>
<p>Use this method to know to size for allocated memory to retrieve a key comment.</p>
<p>See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> for more information on comments.</p>
<p>For an empty key name you need one byte to store the ending NULL. For that reason 1 is returned.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *buffer;</div>
<div class="line">buffer = malloc (<a class="code" href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3" title="Calculates number of bytes needed to store a key comment, including final NULL.">keyGetCommentSize</a> (key));</div>
<div class="line"><span class="comment">// use this buffer to store the comment</span></div>
<div class="line"><span class="comment">// pass keyGetCommentSize (key) for maxSize</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed </dd>
<dd>
1 if there is no comment </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2" title="Get the key comment.">keyGetComment()</a>, <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c213c120cbe02201278ef7fb8cd94be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t keyGetCTime </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get last time the key metadata was changed from disk. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>You will get 0 when the key was not read already.</p>
<p>Any changed field in metadata will influence the ctime of a key.</p>
<p>This time is not updated if only value or comment are changed.</p>
<p>Not changed keys will not update this time, even after <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a>.</p>
<p>It is possible that other keys written to disc influence this time if the backend is not grained enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to get information from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga9f502ecab8ab43f0b17220fcc95f3fa5" title="Update the ctime information for a key.">keySetCTime()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>(time_t)-1 on NULL pointer </dd>
<dd>
the metadata change time </dd></dl>

</div>
</div>
<a class="anchor" id="ga46a95e81d7d7f4e3eb59e60e5f3738c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gid_t keyGetGID </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the group ID of a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<h1><a class="anchor" id="GID"></a>
GID</h1>
<p>The group ID is a unique identification for every group present on a system. Keys will belong to root (0) as long as you did not get their real GID with <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a>.</p>
<p>Unlike UID users might change their group. This makes it possible to share configuration between some users.</p>
<p>A fresh key will have (gid_t)-1 also known as the group nogroup. It means that the key is not related to a group ID at the moment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the system's GID of the key </dd>
<dd>
(gid_t)-1 on NULL key or currently unknown ID </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga9e3d0fb3f7ba906e067727b9155d22e3" title="Set the group ID of a key.">keySetGID()</a>, <a class="el" href="group__meta.html#gacaa5060e67b03f50ae49a3620c54bc46" title="Get the user ID of a key.">keyGetUID()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabc0cec592ce3b77e9bc33dbc8e8f6bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mode_t keyGetMode </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the key mode permissions. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>Default is 0664 (octal) for keys and 0775 for directory keys which used <a class="el" href="group__meta.html#gaae575bd86a628a15ee45baa860522e75" title="Set mode so that key will be recognized as directory.">keySetDir()</a>.</p>
<p>The defaults are defined with the macros KDB_FILE_MODE and KDB_DIR_MODE.</p>
<p>For more information about the mode permissions see <a class="el" href="group__meta.html#mode">Modes</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mode permissions of the key </dd>
<dd>
KDB_FILE_MODE as defaults </dd>
<dd>
(mode_t)-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga8803037e35b9da1ce492323a88ff6bc3" title="Set the key mode permissions.">keySetMode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga57689eb5691679071463b777ae786ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t keyGetMTime </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get last modification time of the key on disk. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>You will get 0 when the key was not read already.</p>
<p>Everytime you change value or comment and <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a> the key the mtime will be updated. When you <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> the key, the atime is set appropriate.</p>
<p>Not changed keys may not even passed to kdbSet_backend() so it will not update this time, even after <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a>.</p>
<p>It is possible that other keys written to disc influence this time if the backend is not grained enough.</p>
<p>If you add or remove a key the key thereunder in the hierarchy will update the mtime if written with <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a> to disc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to get information from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga481d8997187992fe4bbf288bc8ef4db7" title="Update the mtime information for a key.">keySetMTime()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the last modification time </dd>
<dd>
(time_t)-1 on NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga35922a017bee8b4bcb493bbdfad9d6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetOwner </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedOwner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the owner of the key. </p>
<ul>
<li>Given <code>user:someuser/</code>..... return <code>someuser</code> </li>
<li>Given <code>user:some.user/</code>.... return <code>some.user</code> </li>
<li>Given <code>user/</code>.... return the current user</li>
</ul>
<p>Only <code>user/</code>... keys have a owner. For <code>system/</code>... keys (that doesn't have a key owner) an empty string ("") is returned.</p>
<p>Although usually the same, the owner of a key is not related to its UID. Owner are related to WHERE the key is stored on disk, while UIDs are related to mode controls of a key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object to work with </td></tr>
    <tr><td class="paramname">returnedOwner</td><td>a pre-allocated space to store the owner </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that fit returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to buffer </dd>
<dd>
1 if there is no owner </dd>
<dd>
-1 on NULL pointers </dd>
<dd>
-1 when maxSize is 0, larger than SSIZE_MAX or too small for ownername </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key.">keySetName()</a>, <a class="el" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key.">keySetOwner()</a>, <a class="el" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner.">keyOwner()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name.">keyGetFullName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a4561895741ba2ad10acf007c188593"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetOwnerSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the owner of the Key with concluding 0. </p>
<p>The returned number can be used to allocate a string. 1 will returned on an empty owner to store the concluding 0 on using <a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5" title="Return the owner of the key.">keyGetOwner()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> * buffer;</div>
<div class="line">buffer = malloc (<a class="code" href="group__meta.html#ga4a4561895741ba2ad10acf007c188593" title="Return the size of the owner of the Key with concluding 0.">keyGetOwnerSize</a> (key));</div>
<div class="line"><span class="comment">// use buffer and keyGetOwnerSize (key) for maxSize</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>that -1 might be returned on null pointer, so when you directly allocate afterwards its best to check if you will pass a null pointer before.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd>
<dd>
1 if there is no owner </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5" title="Return the owner of the key.">keyGetOwner()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacaa5060e67b03f50ae49a3620c54bc46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uid_t keyGetUID </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the user ID of a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<h1><a class="anchor" id="UID"></a>
UID</h1>
<p>The user ID is a unique identification for every user present on a system. Keys will belong to root (0) as long as you did not get their real UID with <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a>.</p>
<p>Although usually the same, the UID of a key is not related to its owner.</p>
<p>A fresh key will have no UID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the system's UID of the key </dd>
<dd>
(uid_t)-1 on NULL key </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga46a95e81d7d7f4e3eb59e60e5f3738c0" title="Get the group ID of a key.">keyGetGID()</a>, <a class="el" href="group__meta.html#gab5f284f5ecd261e0a290095f50ba1af7" title="Set the user ID of a key.">keySetUID()</a>, <a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5" title="Return the owner of the key.">keyGetOwner()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6485fb8599714b6bbd830cf915ffea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyOwner </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the real internal <code>key</code> owner. </p>
<p>This is a much more efficient version of <a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5" title="Return the owner of the key.">keyGetOwner()</a> and you should use it if you are responsible enough to not mess up things. You are not allowed to modify the returned string in any way. If you need a copy of the string, consider to use <a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5" title="Return the owner of the key.">keyGetOwner()</a> instead.</p>
<p><a class="el" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner.">keyOwner()</a> returns "" when there is no keyOwner. The reason is </p>
<div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step.">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key.">keySetOwner</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner.">keyOwner</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
<div class="line"><a class="code" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key.">keySetOwner</a>(key,<span class="stringliteral">&quot;system&quot;</span>);</div>
<div class="line"><a class="code" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner.">keyOwner</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner.">keyOwner()</a> method to set a new value. Use <a class="el" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key.">keySetOwner()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to internal owner </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no (a empty) owner </td></tr>
    <tr><td class="paramname">0</td><td>iff key is a NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga4a4561895741ba2ad10acf007c188593" title="Return the size of the owner of the Key with concluding 0.">keyGetOwnerSize()</a> for the size of the string with concluding 0 </dd>
<dd>
<a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5" title="Return the owner of the key.">keyGetOwner()</a>, <a class="el" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key.">keySetOwner()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a> for name without owner </dd>
<dd>
<a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name.">keyGetFullName()</a> for name with owner </dd></dl>

</div>
</div>
<a class="anchor" id="ga995d8b84731673c88c7c01f3fed538b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetATime </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>atime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the atime information for a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>When you do manual sync of keys you might also update the atime to make them indistinguishable.</p>
<p>It can also be useful if you work with keys not using a keydatabase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key object to work with </td></tr>
    <tr><td class="paramname">atime</td><td>The new access time for the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga6b05da399c3c78904969ef39f191b0eb" title="Get last time the key data was read from disk.">keyGetATime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8863a877a84fa46e6017fe72e49b89c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetComment </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newComment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a comment for a key. </p>
<p>A key comment is like a configuration file comment. See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">newComment</td><td>the comment, that can be freed after this call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually saved including final NULL </dd>
<dd>
0 when the comment was freed (newComment NULL or empty string) </dd>
<dd>
-1 on NULL pointer or memory problems </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2" title="Get the key comment.">keyGetComment()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f502ecab8ab43f0b17220fcc95f3fa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetCTime </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>ctime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the ctime information for a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key object to work with </td></tr>
    <tr><td class="paramname">ctime</td><td>The new change metadata time for the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga2c213c120cbe02201278ef7fb8cd94be" title="Get last time the key metadata was changed from disk.">keyGetCTime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaae575bd86a628a15ee45baa860522e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetDir </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set mode so that key will be recognized as directory. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>The function will add all executable bits.</p>
<ul>
<li>Mode 0200 will be translated to 0311</li>
<li>Mode 0400 will be translated to 0711</li>
<li>Mode 0664 will be translated to 0775</li>
</ul>
<p>The macro KDB_DIR_MODE (defined to 0111) will be used for that.</p>
<p>The executable bits show that child keys are allowed and listable. There is no way to have child keys which are not listable for anyone, but it is possible to restrict listing the keys to the owner only.</p>
<ul>
<li>Mode 0000 means that it is a key not read or writable to anyone.</li>
<li>Mode 0111 means that it is a directory not read or writable to anyone. But it is recognized as directory to anyone.</li>
</ul>
<p>For more about mode see <a class="el" href="group__meta.html#ga8803037e35b9da1ce492323a88ff6bc3" title="Set the key mode permissions.">keySetMode()</a>.</p>
<p>It is not possible to access keys below a not executable key. If a key is not writeable and executable <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a> will fail to access the keys below. If a key is not readable and executable <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> will fail to access the keys below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to set permissions to be recognized as directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga8803037e35b9da1ce492323a88ff6bc3" title="Set the key mode permissions.">keySetMode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e3d0fb3f7ba906e067727b9155d22e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetGID </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the group ID of a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>See <a class="el" href="group__meta.html#GID">GID</a> for more information about group IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">gid</td><td>is the group ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL key </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga46a95e81d7d7f4e3eb59e60e5f3738c0" title="Get the group ID of a key.">keyGetGID()</a>, <a class="el" href="group__meta.html#gab5f284f5ecd261e0a290095f50ba1af7" title="Set the user ID of a key.">keySetUID()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8803037e35b9da1ce492323a88ff6bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetMode </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the key mode permissions. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>This API is obsolete. It is only a mapping to keySetMeta(key, "mode", str) which should be prefered.</dd></dl>
<p>The mode consists of 9 individual bits for mode permissions. In the following explanation the octal notation with leading zero will be used.</p>
<p>Default is 0664 (octal) for keys and 0775 for directory keys which used <a class="el" href="group__meta.html#gaae575bd86a628a15ee45baa860522e75" title="Set mode so that key will be recognized as directory.">keySetDir()</a>.</p>
<p>The defaults are defined with the macros KDB_FILE_MODE and KDB_DIR_MODE.</p>
<dl class="section note"><dt>Note</dt><dd>libelektra 0.7.0 only allows 0775 (directory keys) and 0664 (other keys). More will be added later in a sense of the description below.</dd></dl>
<h1><a class="anchor" id="mode"></a>
Modes</h1>
<p>0000 is the most restrictive mode. No user might read, write or execute the key.</p>
<p>Reading the key means to get the value by <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a>.</p>
<p>Writing the key means to set the value by <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a>.</p>
<p>Execute the key means to make a step deeper in the hierarchy. But you must be able to read the key to be able to list the keys below. See also <a class="el" href="group__meta.html#gaae575bd86a628a15ee45baa860522e75" title="Set mode so that key will be recognized as directory.">keySetDir()</a> in that context. But you must be able to write the key to be able to add or remove keys below.</p>
<p>0777 is the most relaxing mode. Every user is allowed to read, write and execute the key, if he is allowed to execute and read all keys below.</p>
<p>0700 allows every action for the current user, identified by the uid. See <a class="el" href="group__meta.html#gacaa5060e67b03f50ae49a3620c54bc46" title="Get the user ID of a key.">keyGetUID()</a> and <a class="el" href="group__meta.html#gab5f284f5ecd261e0a290095f50ba1af7" title="Set the user ID of a key.">keySetUID()</a>.</p>
<p>To be more specific for the user the single bits can elect the mode for read, write and execute. 0100 only allows executing which gives the information that it is a directory for that user, but not accessable. 0200 only allows reading. This information may be combined to 0300, which allows execute and reading of the directory. Last 0400 decides about the writing permissions.</p>
<p>The same as above is also valid for the 2 other octal digits. 0070 decides about the group permissions, in that case full access. Groups are identified by the gid. See <a class="el" href="group__meta.html#ga46a95e81d7d7f4e3eb59e60e5f3738c0" title="Get the group ID of a key.">keyGetGID()</a> and <a class="el" href="group__meta.html#ga9e3d0fb3f7ba906e067727b9155d22e3" title="Set the group ID of a key.">keySetGID()</a>. In that example everyone with a different uid, but the gid of the the key, has full access.</p>
<p>0007 decides about the world permissions. This is taken into account when neighter the uid nor the gid matches. So that example would allow everyone with a different uid and gid of that key gains full access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to set mode permissions </td></tr>
    <tr><td class="paramname">mode</td><td>the mode permissions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL key </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#gabc0cec592ce3b77e9bc33dbc8e8f6bdc" title="Return the key mode permissions.">keyGetMode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga481d8997187992fe4bbf288bc8ef4db7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetMTime </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>mtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the mtime information for a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key object to work with </td></tr>
    <tr><td class="paramname">mtime</td><td>The new modification time for the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga57689eb5691679071463b777ae786ae9" title="Get last modification time of the key on disk.">keyGetMTime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga88d6ec200ba0707b7c1b4a88133d2be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetOwner </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newOwner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the owner of a key. </p>
<p>A owner is a name of a system user related to a UID. The owner decides on which location on the disc the key goes.</p>
<p>A private copy is stored, so the passed parameter can be freed after the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">newOwner</td><td>the string which describes the owner of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually saved including final NULL </dd>
<dd>
1 when owner is freed (by setting 0 or "") </dd>
<dd>
-1 on null pointer or memory problems </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key.">keySetName()</a>, <a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5" title="Return the owner of the key.">keyGetOwner()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name.">keyGetFullName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab5f284f5ecd261e0a290095f50ba1af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetUID </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>uid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user ID of a key. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>See <a class="el" href="group__meta.html#UID">UID</a> for more information about user IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">uid</td><td>the user ID to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL key or conversion error </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__meta.html#ga9e3d0fb3f7ba906e067727b9155d22e3" title="Set the group ID of a key.">keySetGID()</a>, <a class="el" href="group__meta.html#gacaa5060e67b03f50ae49a3620c54bc46" title="Get the user ID of a key.">keyGetUID()</a>, <a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5" title="Return the owner of the key.">keyGetOwner()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 3 2015 13:31:49 for Elektra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
