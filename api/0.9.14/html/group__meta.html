<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Meta Data proposal+compatibility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
$darkmode
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Add mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_color_doxygen.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Elektra<span id="projectnumber">&#160;0.9.14</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Meta Data proposal+compatibility</div>  </div>
</div><!--header-->
<div class="contents">

<p>Meta data proposal+compatibility methods.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac89fd319783b3457db45b4c09e55274a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a">keyComment</a> (const Key *key)</td></tr>
<tr class="memdesc:gac89fd319783b3457db45b4c09e55274a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the real internal <code>key</code> comment.  <a href="group__meta.html#gac89fd319783b3457db45b4c09e55274a">More...</a><br /></td></tr>
<tr class="separator:gac89fd319783b3457db45b4c09e55274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dd737fadc16d4cf16720d17f066a9d3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3">keyGetCommentSize</a> (const Key *key)</td></tr>
<tr class="memdesc:ga0dd737fadc16d4cf16720d17f066a9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bytes needed to store a key comment, including final NULL.  <a href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3">More...</a><br /></td></tr>
<tr class="separator:ga0dd737fadc16d4cf16720d17f066a9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb89735689929ff717cc9f2d0d0b46a2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2">keyGetComment</a> (const Key *key, char *returnedComment, size_t maxSize)</td></tr>
<tr class="memdesc:gafb89735689929ff717cc9f2d0d0b46a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the key comment.  <a href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2">More...</a><br /></td></tr>
<tr class="separator:gafb89735689929ff717cc9f2d0d0b46a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8863a877a84fa46e6017fe72e49b89c1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1">keySetComment</a> (Key *key, const char *newComment)</td></tr>
<tr class="memdesc:ga8863a877a84fa46e6017fe72e49b89c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a comment for a key.  <a href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1">More...</a><br /></td></tr>
<tr class="separator:ga8863a877a84fa46e6017fe72e49b89c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b30dfabb0867bd6899e60e7bd193a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gab8b30dfabb0867bd6899e60e7bd193a2">elektraKeyCmpOrder</a> (const Key *ka, const Key *kb)</td></tr>
<tr class="memdesc:gab8b30dfabb0867bd6899e60e7bd193a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the order metadata of two keys.  <a href="group__meta.html#gab8b30dfabb0867bd6899e60e7bd193a2">More...</a><br /></td></tr>
<tr class="separator:gab8b30dfabb0867bd6899e60e7bd193a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166c65c4eb2d758ced57b0bd74fb9a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga166c65c4eb2d758ced57b0bd74fb9a57">elektraMetaArrayAdd</a> (Key *key, const char *metaName, const char *value)</td></tr>
<tr class="memdesc:ga166c65c4eb2d758ced57b0bd74fb9a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates an metadata array or appends another element to an existing metadata array e.g.  <a href="group__meta.html#ga166c65c4eb2d758ced57b0bd74fb9a57">More...</a><br /></td></tr>
<tr class="separator:ga166c65c4eb2d758ced57b0bd74fb9a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacee3e2d9285dd2bde975a09fdbe50502"><td class="memItemLeft" align="right" valign="top">KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gacee3e2d9285dd2bde975a09fdbe50502">elektraMetaArrayToKS</a> (Key *key, const char *metaName)</td></tr>
<tr class="memdesc:gacee3e2d9285dd2bde975a09fdbe50502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>KeySet</code> from a metakey array.  <a href="group__meta.html#gacee3e2d9285dd2bde975a09fdbe50502">More...</a><br /></td></tr>
<tr class="separator:gacee3e2d9285dd2bde975a09fdbe50502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfae80314be2415a7654fe8a0d2ee82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#gaadfae80314be2415a7654fe8a0d2ee82">elektraSortTopology</a> (KeySet *ks, Key **array)</td></tr>
<tr class="memdesc:gaadfae80314be2415a7654fe8a0d2ee82"><td class="mdescLeft">&#160;</td><td class="mdescRight">topological sorting  <a href="group__meta.html#gaadfae80314be2415a7654fe8a0d2ee82">More...</a><br /></td></tr>
<tr class="separator:gaadfae80314be2415a7654fe8a0d2ee82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40469799e2c6e9937eaf013bfc05d014"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__meta.html#ga40469799e2c6e9937eaf013bfc05d014">elektraMetaArrayToString</a> (const Key *key, const char *metaName, const char *delim)</td></tr>
<tr class="memdesc:ga40469799e2c6e9937eaf013bfc05d014"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the metakey array as a string separated by delim  <a href="group__meta.html#ga40469799e2c6e9937eaf013bfc05d014">More...</a><br /></td></tr>
<tr class="separator:ga40469799e2c6e9937eaf013bfc05d014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Meta data proposal+compatibility methods. </p>
<p>In versions before Elektra 0.8 only limited metadata was available. Now any metadata can be added. These API methods are implementations of the 0.7 API using 0.8 metadata.</p>
<p>Additionally, new suggestions can be made here.</p>
<p>It is planned that these methods will be generated from doc/METADATA.ini and moved to a separate library. Currently, you should better avoid the methods and directly use <a class="el" href="group__keymeta.html">metainfo </a> instead. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab8b30dfabb0867bd6899e60e7bd193a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8b30dfabb0867bd6899e60e7bd193a2">&#9670;&nbsp;</a></span>elektraKeyCmpOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraKeyCmpOrder </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>ka</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>kb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the order metadata of two keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a number less than, equal to or greater than zero if the order of k1 is found, respectively, to be less than, to match, or be greater than the order of k2. If one key is NULL, but the other isn't, the key which is not NULL is considered to be greater. If both keys are NULL, they are considered to be equal. If one key does have an order metadata but the other has not, the key with the metadata is considered greater. If no key has metadata, they are considered to be equal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ka</td><td>key to compare with </td></tr>
    <tr><td class="paramname">kb</td><td>other key to compare with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga166c65c4eb2d758ced57b0bd74fb9a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166c65c4eb2d758ced57b0bd74fb9a57">&#9670;&nbsp;</a></span>elektraMetaArrayAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraMetaArrayAdd </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates an metadata array or appends another element to an existing metadata array e.g. </p>
<div class="fragment"><div class="line">Key *key = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user:/test&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__meta.html#ga166c65c4eb2d758ced57b0bd74fb9a57">elektraMetaArrayAdd</a>(key, <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;val0&quot;</span>);</div>
<div class="line"><span class="comment">// key now has &quot;test/#0&quot; with value &quot;val0&quot; as metadata</span></div>
<div class="line"><a class="code" href="group__meta.html#ga166c65c4eb2d758ced57b0bd74fb9a57">elektraMetaArrayAdd</a>(key, <span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;val1&quot;</span>);</div>
<div class="line"><span class="comment">// appends &quot;test/#1&quot; with value &quot;val1&quot; to key</span></div>
<div class="ttc" id="agroup__key_html_gad23c65b44bf48d773759e1f9a4d43b89"><div class="ttname"><a href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a></div><div class="ttdeci">Key * keyNew(const char *name,...)</div><div class="ttdoc">A practical way to fully create a Key object in one step.</div><div class="ttdef"><b>Definition:</b> key.c:144</div></div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a></div><div class="ttdeci">@ KEY_END</div><div class="ttdef"><b>Definition:</b> kdbenum.c:95</div></div>
<div class="ttc" id="agroup__meta_html_ga166c65c4eb2d758ced57b0bd74fb9a57"><div class="ttname"><a href="group__meta.html#ga166c65c4eb2d758ced57b0bd74fb9a57">elektraMetaArrayAdd</a></div><div class="ttdeci">void elektraMetaArrayAdd(Key *key, const char *metaName, const char *value)</div><div class="ttdoc">creates an metadata array or appends another element to an existing metadata array e....</div><div class="ttdef"><b>Definition:</b> meta.c:296</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key the metadata should be added to </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the metakey array parent </td></tr>
    <tr><td class="paramname">value</td><td>the value of the newly appended metakey </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacee3e2d9285dd2bde975a09fdbe50502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacee3e2d9285dd2bde975a09fdbe50502">&#9670;&nbsp;</a></span>elektraMetaArrayToKS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KeySet* elektraMetaArrayToKS </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code>KeySet</code> from a metakey array. </p>
<p>For example, the following function call</p>
<div class="fragment"><div class="line"><a class="code" href="group__meta.html#gacee3e2d9285dd2bde975a09fdbe50502">elektraMetaArrayToKS</a>(</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;/a&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;b, c&quot;</span>,</div>
<div class="line">                <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;dep&quot;</span>,    <span class="stringliteral">&quot;#1&quot;</span>,</div>
<div class="line">                <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;dep/#0&quot;</span>, <span class="stringliteral">&quot;/b&quot;</span>,</div>
<div class="line">                <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;dep/#1&quot;</span>, <span class="stringliteral">&quot;/c&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">        <span class="stringliteral">&quot;dep&quot;</span>);</div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2">KEY_META</a></div><div class="ttdeci">@ KEY_META</div><div class="ttdef"><b>Definition:</b> kdbenum.c:92</div></div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a></div><div class="ttdeci">@ KEY_VALUE</div><div class="ttdef"><b>Definition:</b> kdbenum.c:88</div></div>
<div class="ttc" id="agroup__meta_html_gacee3e2d9285dd2bde975a09fdbe50502"><div class="ttname"><a href="group__meta.html#gacee3e2d9285dd2bde975a09fdbe50502">elektraMetaArrayToKS</a></div><div class="ttdeci">KeySet * elektraMetaArrayToKS(Key *key, const char *metaName)</div><div class="ttdoc">Create a KeySet from a metakey array.</div><div class="ttdef"><b>Definition:</b> meta.c:343</div></div>
</div><!-- fragment --><p>returns a <code>KeySet</code> containing the keys <code>dep</code> with value <code>#1</code>, <code>"dep/#0"</code> with value <code>"/b"</code> and <code>"dep/#1"</code> with value <code>"/c"</code>.</p>
<p>If no metakey array is found, null is returned. The returned <code>KeySet</code> must be freed with <code>ksDel</code></p>
<dl class="section return"><dt>Returns</dt><dd>a keyset containing all the metakeys of the metakey array or null if no metakey array is found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key containing the metakey array </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the metakey array parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40469799e2c6e9937eaf013bfc05d014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40469799e2c6e9937eaf013bfc05d014">&#9670;&nbsp;</a></span>elektraMetaArrayToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* elektraMetaArrayToString </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the metakey array as a string separated by delim </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key containing the metakey array </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the metakey array parent </td></tr>
    <tr><td class="paramname">delim</td><td>delimiter for the records in the returned string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing all metakey values separated by "delim" </dd></dl>

</div>
</div>
<a id="gaadfae80314be2415a7654fe8a0d2ee82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadfae80314be2415a7654fe8a0d2ee82">&#9670;&nbsp;</a></span>elektraSortTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSortTopology </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>topological sorting </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>the array where the sorted keys will be stored in topological order. Nothing will be written into an array if </td></tr>
    <tr><td class="paramname">ks</td><td>is the keyset that should be sorted. Dependencies and order is defined by metakeys.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>the "dep/#" metakeys e.g. the Key *k = keyNew ("/a", KEY_VALUE, "b, c", KEY_META, "dep", "#1", KEY_META, "dep/#0", "/b", KEY_META, "dep/#1", "/c", KEY_END), "dep"); depends on Key "/b" and Key "/c".</li>
<li>if "order" metakeys are defined for the keys the algorithm tries to resolves them by that order using lexical comparison. You should prefer <code>#0</code> array syntax.</li>
</ul>
<p>Duplicated and reflexive dep entries are ignored.</p>
<p>The algorithm used is a mixture of Kahn and BFS. Furthermore the algorithm does not use recursion.</p>
<p>First a BFS with the keys sorted by "order" is used. Then all dependencies (recursively) of every key is collected.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
    <tr><td class="paramname">0</td><td>for cycles </td></tr>
    <tr><td class="paramname">-1</td><td>for invalid dependencies </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac89fd319783b3457db45b4c09e55274a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac89fd319783b3457db45b4c09e55274a">&#9670;&nbsp;</a></span>keyComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyComment </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the real internal <code>key</code> comment. </p>
<p>This is a much more efficient version of <a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2" title="Get the key comment.">keyGetComment()</a> and you should use it if you are responsible enough to not mess up things. You are not allowed to change anything in the memory region the returned pointer points to.</p>
<p><a class="el" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a" title="Return a pointer to the real internal key comment.">keyComment()</a> returns "" when there is no keyComment. The reason is </p><div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1">keySetComment</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a">keyComment</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);</div>
<div class="ttc" id="agroup__key_html_ga3df95bbc2494e3e6703ece5639be5bb1"><div class="ttname"><a href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a></div><div class="ttdeci">int keyDel(Key *key)</div><div class="ttdoc">A destructor for Key objects.</div><div class="ttdef"><b>Definition:</b> key.c:462</div></div>
<div class="ttc" id="agroup__meta_html_ga8863a877a84fa46e6017fe72e49b89c1"><div class="ttname"><a href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1">keySetComment</a></div><div class="ttdeci">ssize_t keySetComment(Key *key, const char *newComment)</div><div class="ttdoc">Set a comment for a key.</div><div class="ttdef"><b>Definition:</b> meta.c:214</div></div>
<div class="ttc" id="agroup__meta_html_gac89fd319783b3457db45b4c09e55274a"><div class="ttname"><a href="group__meta.html#gac89fd319783b3457db45b4c09e55274a">keyComment</a></div><div class="ttdeci">const char * keyComment(const Key *key)</div><div class="ttdoc">Return a pointer to the real internal key comment.</div><div class="ttdef"><b>Definition:</b> meta.c:91</div></div>
</div><!-- fragment --><p>See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> for more information on comments.</p>
<dl class="section note"><dt>Note</dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a" title="Return a pointer to the real internal key comment.">keyComment()</a> method to set a new value. Use <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the internal managed comment </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no comment </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3" title="Calculates number of bytes needed to store a key comment, including final NULL.">keyGetCommentSize()</a> for size and <a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2" title="Get the key comment.">keyGetComment()</a> as alternative </dd></dl>

</div>
</div>
<a id="gafb89735689929ff717cc9f2d0d0b46a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb89735689929ff717cc9f2d0d0b46a2">&#9670;&nbsp;</a></span>keyGetComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetComment </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedComment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the key comment. </p>
<h1><a class="anchor" id="comment"></a>
Comments</h1>
<p>A Key comment is description for humans what this key is for. It may be a textual explanation of valid values, when and why a user or administrator changed the key or any other text that helps the user or administrator related to that key.</p>
<p>Don't depend on a comment in your program. A user is always allowed to remove or change it in any way they want to. But you are allowed or even encouraged to always show the content of the comment to the user and allow him to change it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">returnedComment</td><td>pre-allocated memory to copy the comments to </td></tr>
    <tr><td class="paramname">maxSize</td><td>number of bytes that will fit returnedComment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually copied to <code>returnedString</code>, including final NULL </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if the string is empty </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
    <tr><td class="paramname">-1</td><td>if maxSize is 0, not enough to store the comment or when larger then SSIZE_MAX </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3" title="Calculates number of bytes needed to store a key comment, including final NULL.">keyGetCommentSize()</a>, <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> </dd></dl>

</div>
</div>
<a id="ga0dd737fadc16d4cf16720d17f066a9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dd737fadc16d4cf16720d17f066a9d3">&#9670;&nbsp;</a></span>keyGetCommentSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetCommentSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of bytes needed to store a key comment, including final NULL. </p>
<p>Use this method to know to size for allocated memory to retrieve a key comment.</p>
<p>See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> for more information on comments.</p>
<p>For an empty key name you need one byte to store the ending NULL. For that reason 1 is returned.</p>
<div class="fragment"><div class="line"> <span class="keywordtype">char</span> *buffer;</div>
<div class="line"> buffer = <a class="code" href="internal_8c.html#a35cdc2e5caed3454cb73b4fc7f37858c">elektraMalloc</a> (<a class="code" href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3">keyGetCommentSize</a> (key));</div>
<div class="line"><span class="comment">// use this buffer to store the comment</span></div>
<div class="line"><span class="comment">// pass keyGetCommentSize (key) for maxSize</span></div>
<div class="ttc" id="agroup__meta_html_ga0dd737fadc16d4cf16720d17f066a9d3"><div class="ttname"><a href="group__meta.html#ga0dd737fadc16d4cf16720d17f066a9d3">keyGetCommentSize</a></div><div class="ttdeci">ssize_t keyGetCommentSize(const Key *key)</div><div class="ttdoc">Calculates number of bytes needed to store a key comment, including final NULL.</div><div class="ttdef"><b>Definition:</b> meta.c:132</div></div>
<div class="ttc" id="ainternal_8c_html_a35cdc2e5caed3454cb73b4fc7f37858c"><div class="ttname"><a href="internal_8c.html#a35cdc2e5caed3454cb73b4fc7f37858c">elektraMalloc</a></div><div class="ttdeci">void * elektraMalloc(size_t size)</div><div class="ttdoc">Allocate memory for Elektra.</div><div class="ttdef"><b>Definition:</b> internal.c:274</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if there is no comment </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2" title="Get the key comment.">keyGetComment()</a>, <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> </dd></dl>

</div>
</div>
<a id="ga8863a877a84fa46e6017fe72e49b89c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8863a877a84fa46e6017fe72e49b89c1">&#9670;&nbsp;</a></span>keySetComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetComment </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newComment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a comment for a key. </p>
<p>A key comment is like a configuration file comment. See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key.">keySetComment()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">newComment</td><td>the comment, that can be freed after this call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually saved including final NULL </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the comment was freed (newComment NULL or empty string) </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer or memory problems </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2" title="Get the key comment.">keyGetComment()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark'
  });
</script>
</body>
</html>
