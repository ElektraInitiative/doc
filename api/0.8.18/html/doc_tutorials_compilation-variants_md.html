<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Elektra: Compilation Variants</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Compilation Variants </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To create different variants of the same feature, but avoid code duplications within plugins, you have multiple options:</p><ul>
<li>Define a needs clause in a <a href="/home/markus/Projekte/Elektra/current/doc/CONTRACT.ini">contract</a> and reuse another plugin as it is. This should be preferred for filter and validation tasks.</li>
<li>Have common code together in a helper library (or core library), see the CMake function add_lib for creating such a library (in the folder libs). This should be used for rather common functionality that might be useful for many plugins or even applications.</li>
<li>Have configuration for plugins (See <a href="http://doc.libelektra.org/api/latest/html/group__plugin.html">elektraPluginGetConfig()</a> and dynamically switch with if according to the configuration. This should be preferred when you want to (de)activate some features of a plugin at runtime.</li>
<li>Or use compilation variants to compile the plugin code multiple times with different <code>COMPILE_DEFINITIONS</code> (that are Macro definitions). This should be preferred when different macro definitions lead to different plugins. It should especially be used when the resulting plugins have different dependencies: it is possible to have different <code>LINK_LIBRARIES</code>.</li>
</ul>
<p>The advantage of compilation variants are:</p><ul>
<li>No runtime overhead</li>
<li>Can be used during bootstrapping (when no configuration is available)</li>
<li>Different compilation variants can be built at once (no recompilation with different cmake flags required)</li>
<li>Different compilation variants can have different dependencies</li>
<li>Different compilation variants can be mounted without <code>#refnames</code></li>
</ul>
<h2>How to use it</h2>
<p>To use compilation variants, add your plugin in the CMake Cache Variable PLUGINS multiple times. Then there can be an arbitrary number of variants. As naming convention you should have a base name with an additional have appended with underscore, e.g.: </p><pre class="fragment">    myplugin_varianta;myplugin_variantb
</pre><p>In the CMakeLists.txt of your plugin, you have two options. Option (A): When you can easily enlist every variant you simply list all plugins one after the other (<em>outside of</em> <code>if (DEPENDENCY_PHASE)</code>): </p><pre class="fragment">    add_plugin(myplugin_varianta
            SOURCES      &lt;your sources for varianta here..&gt;
            COMPILE_DEFINITIONS   VARIANTA ELEKTRA_VARIANT=varianta
            LINK_LIBRARIES &lt;libraries for varianta&gt;
            )
    add_plugin(myplugin_variantb
            SOURCES      &lt;your sources for variantb here..&gt;
            COMPILE_DEFINITIONS   VARIANTB  ELEKTRA_VARIANT=variantb
            LINK_LIBRARIES &lt;libraries for variantb&gt;
</pre><p>Option (B): If you cannot enlist every possible compilation variant, you can iterate over all PLUGINS and check which names are requested. Then you create a plugin for every name that matches: </p><pre class="fragment">    foreach (plugin ${PLUGINS})
            if (${plugin} MATCHES "myplugin_.*")
                    # somehow process the variant names and include
                    # or change sources and compile definitions
                    # based on that.
                    add_plugin(${plugin}
                    SOURCES      &lt;your sources here..&gt;
                    COMPILE_DEFINITIONS   &lt;definitions here..&gt;
                            ELEKTRA_VARIANT=${plugin without prefix}
            LINK_LIBRARIES &lt;libraries for variantb&gt;
            if (${plugin} MATCHES "ALL")
                    # handle categories of plugins
                    add_plugin(myplugin_all1, ...
                    add_plugin(myplugin_all2, ..
</pre><p>For the categories such as <code>ALL</code>, however, you need to automatically append (using <code>add_plugin</code>) a useful set of plugins.</p>
<p>Note that every plugin needs to have <code>ELEKTRA_VARIANT</code> differently set in <code>COMPILE_DEFINITIONS</code>, otherwise you will get a linker error that <code>libelektra_&lt;pluginname&gt;_LTX_elektraPluginSymbol</code> has multiple definitions.</p>
<p>Now every public function of the plugin conflicts with itself. To avoid that, you can use:</p><ul>
<li>static functions, but they are only visible within one file. This should be preferred, when possible.</li>
<li>use helper libraries using add_lib to share code between compilation variants (only if code is also potentially useful for other plugins/applications)</li>
<li>Get a unique name for every variant using the macro <code><a class="el" href="group__plugin.html#ga34d1a66f0a6e89cfd20f4014a9975a2a" title="Declare a plugin&#39;s function name suitable for compilation variants (see doc/tutorials). ">ELEKTRA_PLUGIN_FUNCTION(myplugin, open)</a></code> where myplugin is the name of the plugin and the second argument is how the function should be called.</li>
<li>Including a readme for every variant (with #ifdef for different text) using the macro <code>#include <a class="el" href="group__plugin.html#ga78d616f68bf9fb0942f66478597467c6" title="The filename for inclusion of the readme for compilation variants (see doc/tutorials). ">ELEKTRA_README(myplugin)</a></code></li>
</ul>
<p>As a summary, you can have many plugins build out of the same source. Using pluginname_variantnames many plugins will be compiled, each with other SOURCES or <code>COMPILE_DEFINITIONS</code> and even <code>LINK_LIBRARIES</code>: If you, e.g. just set the variants name as macro you can use </p><pre class="fragment">    #ifdef varianta
    #endif
</pre><p>within the code and can have two plugins: one (called myplugin_varianta) compiled included the <code>#ifdef</code> the other (base variant called myplugin) without.</p>
<p>Currently compilation variants is used in <a href="http://libelektra.org/tree/master/src/plugins/resolver/resolver.c">the resolver plugin</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
