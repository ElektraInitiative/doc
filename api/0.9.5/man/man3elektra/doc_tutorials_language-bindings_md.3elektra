.TH "doc_tutorials_language-bindings_md" 3elektra "Mon Apr 12 2021" "Version 0.9.5" "Elektra" \" -*- nroff -*-
.ad l
.nh
.SH NAME
doc_tutorials_language-bindings_mdLanguage Bindings 
 \- In this section, we will explain the how to write a language binding for Elektra\&.
.PP
Writing bindings for the high-level API is described in a \fBdifferent document\fP, since it is a bit less straightforward and needs additional considerations\&.
.PP
.IP "1." 4
which parts of Elektra bindings make sense (application, plugin, tools, \&.\&.\&.)
.IP "2." 4
how to integrate bindings into CMake (if possible and useful)
.IP "3." 4
which parts of the bindings can and should differ for every language\&. This includes:
.IP "  1." 6
iterators
.IP "  2." 6
conversion to native types (strings, int, \&.\&.\&.)
.IP "  3." 6
operator overloading (if available)
.IP "  4." 6
other programming language integrations (streams, hash-codes, identity, \&.\&.\&.)
.IP "  5." 6
returned errors from kdb functions (what this issue here is about)
.PP

.PP
.PP
To add the subdirectory containing our binding to the build, we have to modify \fCsrc/bindings/CMakeLists\&.txt\fP\&.
.PP
.PP
.nf
check_binding_included ("our_binding" IS_INCLUDED)
if (IS_INCLUDED)
    add_subdirectory (our_binding_directory)
endif ()
.fi
.PP
.PP
At first we want to make sure that the build tools and compilers we need for the binding are installed\&. We can use \fCfind_program (BUILD_TOOL_EXECUTABLE build_tool)\fP to find our \fCbuild_tool\fP program\&. The result of the search will be stored in \fCBUILD_TOOL_EXECUTABLE\fP, so now we can use an if block to include the bindings in the build, if the program exists or exclude it, if it doesn't\&. To do that, we use \fCadd_binding\fP which adds ours to the list of bindings that will be built\&. For more provided functions, \fCsee here\fP\&.
.PP
If, for example, our bindings only support linking against a dynamic library we can express that, by using the \fCBUILD_*\fP variables in if blocks or by passing \fCONLY_SHARED\fP to \fCadd_binding\fP\&. You can read more in the \fBcompile doc\fP\&.
.PP
.PP
.nf
if (BUILD_TOOL_EXECUTABLE)
    add_binding (our_binding ONLY_SHARED)
else ()
    exclude_binding (our_binding, "build_tool not found")
    return ()
endif ()
.fi
.PP
.PP
Elektra uses out-of-source builds, so we have to copy all the needed files over to the build directory\&. The ${CMAKE_CURRENT_SOURCE_DIR} variable refers to the source directory, while ${CMAKE_CURRENT_BINARY_DIR} refers to the build directory\&. The copy is as simple as
.PP
.PP
.nf
# Inside the previous if block
file (COPY "${CMAKE_CURRENT_SOURCE_DIR}/" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}")
.fi
.PP
.PP
However for some files we may want to use some CMakes variables\&. Say we're writing a build script for our project and want to include the version number and the directory that \fClibelektra\&.so\fP resides in, so our build tool can find and link against it\&. We create our script named \fCbuild\&.script\&.in\fP\&. It looks like this
.PP
.PP
.nf
version = "@KDB_VERSION@"
link-search-path = "@CMAKE_BINARY_DIR@/lib"
.fi
.PP
.PP
Back in our CMake script, we tell CMake to replace the variables with their associated values\&.
.PP
.PP
.nf
configure_file ("${CMAKE_CURRENT_SOURCE_DIR}/build\&.script\&.in" "${CMAKE_CURRENT_BINARY_DIR}/build\&.script" @ONLY)
.fi
.PP
.PP
Note how we leave off the \fC\&.in\fP ending on the target file\&.
.PP
Since we're building a foreign language project, it will most likely have its own build tool or compiler\&. So we have to tell CMake how to invoke it, in order to build the project\&. First we specify what file we expect to be generated by that command\&. In this example it's a \fC\&.lib\fP file that is generated in some target directory\&. We then call our build tool using the variable \fCBUILD_TOOL_EXECUTABLE\fP we created earlier with the \fCbuild\fP subcommand and the \fC--release\fP option\&. We can also specify one or multiple files that this command depends on, such that CMake can make sure they are built or generated before\&. Finally, we add a custom target that depends on the \fC\&.lib\fP file\&. To built this target, CMake will invoke our custom command and build the specified file\&.
.PP
.PP
.nf
add_custom_command (OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/target/release/libelektra\&.lib"
            COMMAND ${BUILD_TOOL_EXECUTABLE} build --release
            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
            DEPENDS "${CMAKE_CURRENT_BINARY_DIR}/build\&.script" "${CMAKE_CURRENT_BINARY_DIR}/other-dependency\&.file")
add_custom_target (our_binding ALL DEPENDS "${CMAKE_CURRENT_BINARY_DIR}/target/release/libelektra\&.lib")
.fi
.PP
.PP
We can then explicitly include the bindings using \fCcmake -DBINDINGS='our_binding' \&.\&.\fP in the build directory and follow the further steps for \fBcompilation\fP\&.
.PP
To invoke our tests through CMake, we have to follow similar steps as in the build\&. We add a test by specifying a command that runs our tests\&. In our case, we're calling the same program for testing as in the building step\&.
.PP
.PP
.nf
add_test (NAME test_our_binding COMMAND ${BUILD_TOOL_EXECUTABLE} test WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}")
.fi
.PP
.PP
We may have to specify an additonal environment variable to tell the test command, where \fClibelektra\&.so\fP resides, so that the dynamic linker can find it\&.
.PP
.PP
.nf
set_property (TEST test_our_binding PROPERTY ENVIRONMENT "LD_LIBRARY_PATH=${CMAKE_BINARY_DIR}/lib")
.fi
.PP
.PP
Now our bindings can be tested through \fCctest\fP alongside all other tests\&.
.PP
See the \fBJava binding\fP for examples\&.
.PP
Since v0\&.9\&.0, Elektra has a new error code system\&. You might want to take a look in the \fBdesign decision\fP first to understand the concept of the error codes\&. These codes are hierarchically structured and are therefore perfectly suitable for inheritance if the language supports it\&.
.PP
Some error codes like the \fCPermanent Errors\fP are generalizations and used for developers who want to catch all specific types of errors (e\&.g\&., it does not matter if it is a Resource or Installation Error but the developer wants to check for both)\&. Such errors should not be able to 'instantiate' or emitted back to Elektra as we want to force developers to take a more specific category\&. In case of Java for example the \fCPermanent Error\fP is an abstract class\&. Which errors are instantiable or not can be seen in the \fBerror-categorization guideline\fP in the respective title saying either \fCabstract\fP or \fCconcrete\fP\&. Here is an example of how Java has implemented it:
.PP
.PP
.nf
public abstract class PermanentException extends Exception {\&.\&.\&.}
    public class ResourceException extends PermanentException {\&.\&.\&.}
        public class MemoryAllocationException extends ResourceException {\&.\&.\&.}
    public class InstallationException extends PermanentException {\&.\&.\&.}
\&.\&.\&.
.fi
.PP
.PP
All error codes as well as the hierarchy itself is depicted in the \fBdesign decision\fP\&.
.PP
If you have a language which does not support inheritance this way like GoLang, you can still use the error code itself since the hierarchy is integrated in it\&. For example you can check if the code starts with \fCC01\&.\&.\&.\fP to catch all \fCPermanent Errors\fP\&.
.PP
In Elektra every error has a predefined format\&. You can take a look at the \fBrelated design decision\fP to see how it looks like\&.
.PP
Every Exception/Error struct/etc\&. should have separate accessors to individual parts of the message\&. These include:
.PP
.IP "1." 4
Module (getModule())
.IP "2." 4
Error Code (getErrorCode())
.IP "3." 4
Reason (getReason())
.IP "4." 4
Configfile (getConfigFile())
.IP "5." 4
Mountpoint (getMountpoint())
.IP "6." 4
Debuginformation (text looks like 'At: file:line') (getDebugInformation())
.PP
.PP
In case of an error at least the following part has to be returned:
.PP
.PP
.nf
Sorry, module getModule() issued error getErrorCode():
getReason()
.fi
.PP
.PP
Please also keep the wording identical for consistency\&. Take a look how the Java Binding implemented it in the \fBKDBException\fP 
