<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Plugins Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Plugins Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Many component systems pass information between the various components by calling methods of each other. This is not the way Elektra’s plugin system works. Instead, the core passes a <code>KeySet</code> object in one direction from plugin to plugin. So they form a so called pipes-and-filter. Each of the plugins can modify the configuration or add any other information using metakeys. While this approach is in general less flexible, this information flow still allows powerful chaining. Because plugins do not have to bother to call other plugins, the plugin development is also easier. The ordering of plugins in backends is controlled using contracts.</p>
<h1><a class="anchor" id="autotoc_md1490"></a>
Contracts</h1>
<p>Every plugin should provide a full contract to give information how it will work with other plugins. Most parts of the contract are obligatory. Plugins cannot be loaded without this information. For example, plugins must provide the clause <code>infos/version</code>. It is vital so that the plugin loader knows which version of Elektra the plugin was built for.</p>
<h1><a class="anchor" id="autotoc_md1491"></a>
Conditions</h1>
<p>It is, however, up to the plugin not to have every clause of the contract. For example, the plugin might not tell what it provides or needs. It can also leave any description out. In this situation it is unclear what the plugin will do. Such a plugin can add or remove keys, and changes values and metadata regardless what other plugins expect. If only such plugins existed there would be chaos. It would be impossible to determine the behavior of a backend which uses a multiple of such plugins.</p>
<p>To avoid this situation, every plugin exports a contract describing how the plugin modifies the <code>KeySet</code> <code>returned</code>. Most often it is enough to state that it is a <em>storage</em> plugin or that it will <em>filter</em> keys.</p>
<p>The data structures, however, are already responsible for most of the pre- and postconditions. Every condition the data structure guarantees, takes away a concern for the plugins. All the parts that are already guaranteed by data structures do not need to be stated in the contract.</p>
<p>Plugins should not be burdened to check too many postconditions. Instead, plugins focus on their task. The plugin does not need to check the sync flag of keys or if the keys are below the mount point. The core already guarantees correct behavior as described in <a class="el" href="doc_dev_algorithm_md.html">algorithm</a>.</p>
<p>To sum up, contracts give the information how a plugin interacts with others. It describes if, and how, the <code>KeySet</code> <code>returned</code> is changed. Using contracts, we get a predictable behavior, but still support every kind of plugin.</p>
<h1><a class="anchor" id="autotoc_md1492"></a>
Exporting Contracts</h1>
<p>As already stated, some parts of the contracts are obligatory. <code>kdb mount</code> needs to know which symbols the plugin exports. Only the <code>elektraPluginGet()</code> symbol is mandatory - it is used to yield this information. Elektra’s core also uses the functions <code>elektraPluginSet()</code>, <code>elektraPluginError()</code>, <code><a class="el" href="elektra_2plugin_8c.html#a32a70a7876542c51d153164ac5108a57" title="Opens a plugin.">elektraPluginOpen()</a></code> and <code>elektraPluginClose()</code> if available. Other functions like <code>serialize</code>, <code>unserialize</code> or <code>lookup</code> which implement special features can be supported, but are ignored by the core. For the user of the library these functions can be very useful. These functions shall either belong to the concern of the plugin or be implemented within the plugin because of the dependences.</p>
<p>As described in <a href="/home/mpranj/workspace/libelektra/doc/CONTRACT.ini">infos/provides</a>, the plugin can also provide descriptive information, for example about the author and the licence. Advanced plugins can also export plugin configuration for other plugins so that the overall backend works properly. Last, but not least, as enumerated in <a href="/home/mpranj/workspace/libelektra/doc/CONTRACT.ini">infos/placement</a> dependency and placement information makes the system reliable and robust. With that information, plugins can be placed into a backend in an automatic and secure way.</p>
<p><code>system/elektra/modules</code> provides for every module the information described above. The entry exists once a plugin of that module is loaded. For each module a special <em>module backend</em> is generated and mounted at <code>system/elektra/modules/&lt;pluginname&gt;</code>. The <code>elektraPluginGet()</code> function generates this described contract on requests.</p>
<p>For example, the ccode plugin, implements:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> elektraCcodeGet(Plugin *handle, KeySet *returned, Key *parentKey)</div>
<div class="line">{</div>
<div class="line">        <span class="keywordflow">if</span> (!strcmp (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(parentKey), <span class="stringliteral">&quot;system/elektra/modules/ccode&quot;</span>))</div>
<div class="line">        {</div>
<div class="line">                KeySet *contract = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (30,</div>
<div class="line">                        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;system/elektra/modules/ccode&quot;</span>,</div>
<div class="line">                                <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;system/elektra/modules/ccode/exports&quot;</span>,</div>
<div class="line">                                <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                        <span class="comment">//...</span></div>
<div class="line">                        <a class="code" href="kdbenum_8c.html#a7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line">                <a class="code" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend</a> (returned, contract);</div>
<div class="line">                <a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (contract);</div>
<div class="line">                <span class="keywordflow">return</span> 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// implementation of elektraCcodeGet</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>We see in the listing above that the plugin generates and returns the contract if, and only if, the name of the <code>parentKey</code> is <code>system/elektra/modules/ccode</code>. The user and the contract checker can access the contract of ccode below the key <code>system/elektra/modules/ccode</code> in the same way other configuration is accessed. Note that we also have to <code>return 1</code> at the end of the contract to not execute the regular functionality of the plugin.</p>
<h1><a class="anchor" id="autotoc_md1493"></a>
Exports</h1>
<p>Plugins can also export arbitrary additional functions. To export it, simply add another <code>exports</code> symbol to the contract:</p>
<div class="fragment"><div class="line"><a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;system/elektra/modules/dump/exports/checkconf&quot;</span>, KEY_FUNC,</div>
<div class="line">        elektraCcodeCheckConf, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
</div><!-- fragment --><p><code>checkconf</code> is the most important function that is not available as built-in function. It is used to validate or even correct/finish the plugin's configuration.</p>
<p>If you want to use an exported function from a symbol, please look at <a href="/home/mpranj/workspace/libelektra/src/libs/tools/src/plugin.cpp">Plugin::parse</a>.</p>
<h1><a class="anchor" id="autotoc_md1494"></a>
Changing Plugins</h1>
<p>This configuration is static and contains the contract information. In theory, the contract can be changed without any problems in ways that it provides more and obligates less. But the problem is that it will not be checked if this is the case because a recheck of the contracts of a backend is very expensive. The contract checker doing this, only runs once during mount-time. Changing contracts in an incompatible way forces the user to remove all mount points where the plugin is and mount it again. Such actions are only sustainable in a development phase and not in a productive environment.</p>
<p>But the plugin's implementation is allowed to change without being remounted if it is a subtype of the earlier version. Only in this situation it can be a drop-in replacement. With a good testing framework the behavior can be checked to some extent.</p>
<p>We also see in the listing above that the code responsible for generating the contract and the code for the implementation are next to each other. Plugins need to satisfy those self-imposed obligations that are described in contracts. They ensure that plugins interact in predictable ways. So the process of writing individual plugins and composing them together can be described as Component-Based Software Engineering.</p>
<p>Plugins can also be viewed as framework extensions. A component abstracts plugins. But this term is misleading in our case, because components usually can choose which interfaces they implement. Elektra’s plugins, however, are restricted to implement one specific interface. Without contracts, plugins could not interact as described in this chapter.</p>
<h1><a class="anchor" id="autotoc_md1495"></a>
SEE ALSO</h1>
<ul>
<li><a class="el" href="doc_dev_plugins-ordering_md.html">plugins-ordering</a></li>
<li><a class="el" href="doc_help_elektra-contracts_md.html">elektra-contracts(7)</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="agroup__keyset_html_ga671e1aaee3ae9dc13b4834a4ddbd2c3c"><div class="ttname"><a href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a></div><div class="ttdeci">KeySet * ksNew(size_t alloc,...)</div><div class="ttdoc">Allocate, initialize and return a new KeySet object.</div><div class="ttdef"><b>Definition:</b> keyset.c:225</div></div>
<div class="ttc" id="agroup__keyset_html_ga21eb9c3a14a604ee3a8bdc779232e7b7"><div class="ttname"><a href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend</a></div><div class="ttdeci">ssize_t ksAppend(KeySet *ks, const KeySet *toAppend)</div><div class="ttdoc">Append all toAppend contained keys to the end of the ks.</div><div class="ttdef"><b>Definition:</b> keyset.c:941</div></div>
<div class="ttc" id="akdbenum_8c_html_a7a28fce3773b2c873c94ac80b8b4cd54"><div class="ttname"><a href="kdbenum_8c.html#a7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a></div><div class="ttdeci">#define KS_END</div><div class="ttdoc">End of a list of keys.</div><div class="ttdef"><b>Definition:</b> kdbenum.c:88</div></div>
<div class="ttc" id="agroup__key_html_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403"><div class="ttname"><a href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a></div><div class="ttdeci">@ KEY_END</div><div class="ttdef"><b>Definition:</b> kdbenum.c:41</div></div>
<div class="ttc" id="agroup__key_html_gad23c65b44bf48d773759e1f9a4d43b89"><div class="ttname"><a href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a></div><div class="ttdeci">Key * keyNew(const char *name,...)</div><div class="ttdoc">A practical way to fully create a Key object in one step.</div><div class="ttdef"><b>Definition:</b> key.c:167</div></div>
<div class="ttc" id="agroup__keyset_html_ga27e5c16473b02a422238c8d970db7ac8"><div class="ttname"><a href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a></div><div class="ttdeci">int ksDel(KeySet *ks)</div><div class="ttdoc">A destructor for KeySet objects.</div><div class="ttdef"><b>Definition:</b> keyset.c:437</div></div>
<div class="ttc" id="agroup__keyname_html_ga8e805c726a60da921d3736cda7813513"><div class="ttname"><a href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a></div><div class="ttdeci">const char * keyName(const Key *key)</div><div class="ttdoc">Returns a pointer to the abbreviated real internal key name.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:213</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
