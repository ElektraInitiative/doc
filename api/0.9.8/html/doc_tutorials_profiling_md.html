<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Profiling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Profiling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_tutorials_profiling"></a> </p>
<h1><a class="anchor" id="autotoc_md3712"></a>
Execution Time</h1>
<p>One of the primary resources in computing is execution time. To keep usage of this resource type low, it makes sense to profile code and check which code paths in a progamm take the longest time to execute. There exist various tools to handle this kind of profiling. For this tutorial we will use</p>
<ol type="1">
<li><a href="http://valgrind.org/docs/manual/cl-manual.html">Callgrind</a> and the graphical frontend <a href="https://kcachegrind.github.io/html/Home.html">KCacheGrind/QCacheGrind</a>, and</li>
<li><a href="https://llvm.org/docs/XRay.html">XRay</a> and <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> to visualize the data produced by <a href="https://llvm.org/docs/XRay.html">XRay</a></li>
</ol>
<h2><a class="anchor" id="autotoc_md3713"></a>
Callgrind</h2>
<h3><a class="anchor" id="autotoc_md3714"></a>
Choosing the Correct Build Type</h3>
<p>Since we want to improve the readability of the Callgrind output we choose a build type that includes debug symbols. The two obvious choices for the build type are:</p>
<ul>
<li><code>RelWithDebInfo</code> (optimized build with debug symbols), and</li>
<li><code>Debug</code> (non-optimized build with debug symbols)</li>
</ul>
<p>. We use <code>Debug</code> here, which should provide the most detailed profiling information.</p>
<h3><a class="anchor" id="autotoc_md3715"></a>
Disabling &lt;tt&gt;dlclose&lt;/tt&gt; Calls</h3>
<p>For this tutorial we decided to profile the <a class="el" href="md_src_plugins_yajl_README.html">YAJL</a> plugin. Since Elektra loads plugin code via <code>dlopen</code> and Callgrind <a href="https://stackoverflow.com/questions/16719395">does not support the function <code>dlclose</code> properly</a> we remove the <code>dlclose</code> calls in the file <a href="/home/jenkins/workspace/libelektra-release/src/libs/loader/dl.c"><code>dl.c</code></a> temporarily. At the time of writing one option to do that is deleting</p>
<ul>
<li>a single line <code>dlclose</code> statement, and</li>
<li>an <code>if</code>-statement that checks the return value of a <code>dlclose</code> call</li>
</ul>
<p>. An unfortunate effect of this code update is that Elektra will now leak memory when it unloads a plugin. On the other hand, Callgrind will be able to add source code information about the <a class="el" href="md_src_plugins_yajl_README.html">YAJL</a> plugin to the profiling output.</p>
<h3><a class="anchor" id="autotoc_md3716"></a>
Building Elektra</h3>
<p>As we already described before we use the <code>Debug</code> build type for the profiling run. To make sure we test the actual performance of the <a class="el" href="md_src_plugins_yajl_README.html">YAJL</a> plugin we disable debug code and the logger. The following commands show one option to translate Elektra using this configuration, if we use <a href="https://ninja-build.org">Ninja</a> as build tool:</p>
<div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake -GNinja ..               \</div>
<div class="line">      -DCMAKE_BUILD_TYPE=Debug \</div>
<div class="line">      -DENABLE_LOGGER=OFF      \</div>
<div class="line">      -DENABLE_DEBUG=OFF       \</div>
<div class="line">      -DPLUGINS=ALL</div>
<div class="line">ninja</div>
<div class="line">cd .. # Change working directory back to the root of repository</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md3717"></a>
Profiling the Code</h3>
<p>We use the tool `benchmark_plugingetset` to profile the execution time of <a class="el" href="md_src_plugins_yajl_README.html">YAJL</a>. The file `keyframes_complex.json` serves as input file for the plugin. Since <code>benchmark_plugingetset</code> requires a data file called</p>
<div class="fragment"><div class="line">test.$plugin.in</div>
</div><!-- fragment --><p>, we save a copy of <code>keyframes_complex.json</code> as <code>test.yajl.in</code> in the folder <code>benchmarks/data</code>:</p>
<div class="fragment"><div class="line">mkdir -p benchmarks/data</div>
<div class="line">cp src/plugins/yajl/yajl/keyframes_complex.json benchmarks/data/test.yajl.in</div>
</div><!-- fragment --><p>. After that we call <code>benchmark_plugingetset</code> directly to make sure that everything works as expected:</p>
<div class="fragment"><div class="line">build/bin/benchmark_plugingetset benchmarks/data user yajl get</div>
</div><!-- fragment --><p>. If the command above fails with a segmentation fault, then please check</p>
<ul>
<li>that the <a class="el" href="doc_COMPILE_md.html">build system</a> included <a class="el" href="md_src_plugins_yajl_README.html">YAJL</a>, and</li>
<li>that your OS is able to locate the plugin (e.g. append the <code>lib</code> directory in the build folder to <code>LD_LIBRARY_PATH</code> on Linux)</li>
</ul>
<p>. If <code>benchmark_plugingetset</code> executed successfully, then you can now use Callgrind to profile the command:</p>
<div class="fragment"><div class="line">valgrind --tool=callgrind --callgrind-out-file=callgrind.out \</div>
<div class="line">build/bin/benchmark_plugingetset benchmarks/data user yajl get</div>
</div><!-- fragment --><p>. The command above will create a file called <code>callgrind.out</code> in the root of the repository. You can now remove the input data and the folder <code>benchmarks/data</code>:</p>
<div class="fragment"><div class="line">rm benchmarks/data/test.yajl.in</div>
<div class="line">rmdir benchmarks/data</div>
</div><!-- fragment --><p>. If you use Docker to translate Elektra, then you might want to fix the paths in the file <code>callgrind.out</code> before you continue:</p>
<div class="fragment"><div class="line"># The tool `sponge` is part of the `moreutils` package: https://joeyh.name/code/moreutils</div>
<div class="line">sed -E &#39;s~/home/jenkins/workspace/(\.\./)*~~g&#39; callgrind.out | sponge callgrind.out</div>
</div><!-- fragment --><p>. Now we can analyze the file <code>callgrind.out</code> with a graphical tool such as QCacheGrind:</p>
<div class="fragment"><div class="line">qcachegrind&amp;</div>
</div><!-- fragment --><p>. If everything worked as expected QCacheGrind should open the file <code>callgrind.out</code> and display a window that look similar to the one below:</p>
<p><img src="../images/qcachegrind.png" alt="QCacheGrind" class="inline"/></p>
<p>. You can now select different parts of the call graph on the left to check which parts of the code take a long time to execute.</p>
<h2><a class="anchor" id="autotoc_md3718"></a>
XRay</h2>
<p><a href="https://llvm.org/docs/XRay.html">XRay</a> is an extension for LLVM that adds profiling code to binaries. Profiling can be dynamically enabled and disabled via the environment variable <code>XRAY_OPTIONS</code>.</p>
<h3><a class="anchor" id="autotoc_md3719"></a>
Choosing the Correct Build Type</h3>
<p>Since <a href="https://llvm.org/docs/XRay.html">XRay</a> currently requires LLVM we need to set the compiler appropriately. We use Clang 8 in our example.</p>
<div class="fragment"><div class="line">export CC=clang-8</div>
<div class="line">export CXX=clang++-8</div>
</div><!-- fragment --><p>. We enable the static build (<code>BUILD_STATIC=ON</code>) and disable the dynamic build (<code>BUILD_SHARED=OFF</code>), since <a href="https://lists.llvm.org/pipermail/cfe-dev/2018-August/059147.html">XRay currently does not support dynamic libraries</a>. To enable Xray we use the compiler switch <code>-fxray-instrument</code>. To instrument every function we set the instruction threshold to <code>1</code> with <code>-fxray-instruction-threshold=1</code>.</p>
<div class="fragment"><div class="line">export REPOSITORY_DIRECTORY=&quot;$PWD&quot;</div>
<div class="line">export BUILD_DIRECTORY=&quot;$REPOSITORY_DIRECTORY/build&quot;</div>
<div class="line">mkdir -p &quot;$BUILD_DIRECTORY&quot;</div>
<div class="line">cd &quot;$BUILD_DIRECTORY&quot;</div>
<div class="line">cmake -GNinja &quot;$REPOSITORY_DIRECTORY&quot;                                   \</div>
<div class="line">      -DCMAKE_BUILD_TYPE=Release                                        \</div>
<div class="line">      -DBUILD_SHARED=OFF                                                \</div>
<div class="line">      -DBUILD_STATIC=ON                                                 \</div>
<div class="line">      -DCOMMON_FLAGS=&#39;-fxray-instrument -fxray-instruction-threshold=1&#39; \</div>
<div class="line">      -DPLUGINS=ALL</div>
</div><!-- fragment --><p>We will analyze the <a class="el" href="md_src_plugins_yajl_README.html">YAJL plugin</a> below. Please make sure that the CMake command above includes the plugin:</p>
<div class="fragment"><div class="line">…</div>
<div class="line">-- Include plugin yajl</div>
<div class="line">…</div>
</div><!-- fragment --><p>. Now we can translate the code with <a href="https://ninja-build.org">Ninja</a> and change the current directory back to the root of the repository:</p>
<div class="fragment"><div class="line">ninja</div>
<div class="line">cd &quot;$REPOSITORY_DIRECTORY&quot;</div>
</div><!-- fragment --><p>. In the next step we use `benchmark_plugingetset` to execute <a class="el" href="md_src_plugins_yajl_README.html">YAJL</a> for the input file <a href="../../src/plugins/yajl/yajl/keyframes_complex.json"><code>keyframes_complex.json</code></a>. To do that we</p>
<ol type="1">
<li>create the folder <code>data</code> in the directory `benchmarks`, and</li>
<li>save the file <a href="../../src/plugins/yajl/yajl/keyframes_complex.json"><code>keyframes_complex.json</code></a> as <code>test.yajl.in</code></li>
</ol>
<p>. The following commands show you how to do that:</p>
<div class="fragment"><div class="line">mkdir -p benchmarks/data</div>
<div class="line">cp src/plugins/yajl/yajl/keyframes_complex.json benchmarks/data/test.yajl.in</div>
</div><!-- fragment --><p>. Now we first check if running [<code>benchmark_plugingetset</code>][] works without instrumentation:</p>
<div class="fragment"><div class="line">&quot;$BUILD_DIRECTORY/bin/benchmark_plugingetset&quot; benchmarks/data user yajl get</div>
</div><!-- fragment --><p>. If everything worked correctly, then the command above should finish successfully and not produce any output. To instrument the binary we set the environment variable <code>XRAY_OPTIONS</code> to the value <code>xray_mode=xray-basic verbosity=1</code>.</p>
<div class="fragment"><div class="line">export XRAY_OPTIONS=&#39;xray_mode=xray-basic patch_premain=true verbosity=1&#39;</div>
<div class="line">&quot;$BUILD_DIRECTORY/bin/benchmark_plugingetset&quot; benchmarks/data user yajl get</div>
</div><!-- fragment --><p>. The command above will print the location of the XRay log file to <code>stdterr</code>:</p>
<div class="fragment"><div class="line">…</div>
<div class="line">…XRay: Log file in &#39;xray-log.benchmark_plugingetset.gpcX3t&#39;</div>
<div class="line">…</div>
</div><!-- fragment --><p>. Now we can use the log file to analyze the runtime of the execution paths of the binary. To do that we first save the name of the log file in the variable <code>LOGFILE</code>. This way we do not need to repeat the filename every time in the commands below.</p>
<div class="fragment"><div class="line">LOGFILE=$(&quot;$BUILD_DIRECTORY/bin/benchmark_plugingetset&quot; benchmarks/data user yajl get 2&gt;&amp;1 |</div>
<div class="line">          sed -nE &quot;s/.*Log file in &#39;(.*)&#39;.*/\1/p&quot;)</div>
</div><!-- fragment --><p>. To list the 10 functions with the longest runtime we use the command <code>llvm-xray account</code>:</p>
<div class="fragment"><div class="line">llvm-xray account &quot;$LOGFILE&quot; -top=10 -sort=sum -sortorder=dsc -instr_map &quot;$BUILD_DIRECTORY/bin/benchmark_plugingetset&quot;</div>
<div class="line">#&gt; Functions with latencies: 35</div>
<div class="line">#&gt;    funcid      count [      min,       med,       90p,       99p,       max]       sum  function</div>
<div class="line">#&gt;         1          1 [ 0.004791,  0.004791,  0.004791,  0.004791,  0.004791]  0.004791  &lt;invalid&gt;:0:0: main</div>
<div class="line">#&gt;      1333          1 [ 0.002007,  0.002007,  0.002007,  0.002007,  0.002007]  0.002007  &lt;invalid&gt;:0:0: elektraYajlGet</div>
<div class="line">#&gt; …</div>
</div><!-- fragment --><p>. We can also use the log file to create a <a href="http://www.brendangregg.com/flamegraphs.html">Flame Graph</a>. To do that we use the <code>llvm-xray stack</code> to create an input file for the tool <a href="https://github.com/brendangregg/FlameGraph"><code>flamegraph.pl</code></a></p>
<div class="fragment"><div class="line">llvm-xray stack &quot;$LOGFILE&quot; -stack-format=flame -aggregation-type=time -all-stacks \</div>
<div class="line">                -instr_map &quot;$BUILD_DIRECTORY/bin/benchmark_plugingetset&quot; &gt; flamegraph.txt</div>
</div><!-- fragment --><p>. We then create the Flame Graph with the following command:</p>
<div class="fragment"><div class="line"># Depending on how you installed Flame Graph the executable</div>
<div class="line"># might also be called `flamegraph.pl` instead of `flamegraph`.</div>
<div class="line">flamegraph flamegraph.txt &gt; flamegraph.svg</div>
</div><!-- fragment --><p>. The image below shows one example how the picture could look like:</p>
<p><img src="../images/flamegraph.svg" alt="Flame Graph" style="pointer-events: none;" class="inline"/></p>
<p>. Additional information on how to use the data produced by <a href="https://llvm.org/docs/XRay.html">XRay</a> is available <a href="https://llvm.org/docs/XRayExample.html">here</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
