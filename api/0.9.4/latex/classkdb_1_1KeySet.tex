\hypertarget{classkdb_1_1KeySet}{}\section{kdb\+:\+:Key\+Set Class Reference}
\label{classkdb_1_1KeySet}\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}


A keyset holds together a set of keys.  




{\ttfamily \#include $<$keyset.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classkdb_1_1KeySet_a4eac9850fa4f06c07a5306befc3e4377}{Key\+Set} ()
\begin{DoxyCompactList}\small\item\em Creates a new empty keyset with no keys. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1KeySet_a21f651ff310178951402038e590743e0}{Key\+Set} (ckdb\+::\+Key\+Set $\ast$k)
\begin{DoxyCompactList}\small\item\em Takes ownership of keyset! \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1KeySet_ad8d6df839ab852fded1739ff3398d0b1}{Key\+Set} (const \hyperlink{classkdb_1_1KeySet}{Key\+Set} \&other)
\begin{DoxyCompactList}\small\item\em Duplicate a keyset. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1KeySet_a6191e93cdd67bbca63df934498d191ba}{Key\+Set} (size\+\_\+t alloc,...) E\+L\+E\+K\+T\+R\+A\+\_\+\+S\+E\+N\+T\+I\+N\+EL
\begin{DoxyCompactList}\small\item\em Create a new keyset. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1KeySet_ae0b2996803b9c9124cf791a1d738855c}{Key\+Set} (\hyperlink{structkdb_1_1VaAlloc}{Va\+Alloc} alloc, va\+\_\+list ap)
\begin{DoxyCompactList}\small\item\em Create a new keyset. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1KeySet_ade654f92bddec24abad1b651e828f2b8}{$\sim$\+Key\+Set} ()
\begin{DoxyCompactList}\small\item\em Deconstruct a keyset. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classkdb_1_1KeySet_a2987b3fb1b12196399650726f1c18f02}\label{classkdb_1_1KeySet_a2987b3fb1b12196399650726f1c18f02}} 
ckdb\+::\+Key\+Set $\ast$ \hyperlink{classkdb_1_1KeySet_a2987b3fb1b12196399650726f1c18f02}{release} ()
\begin{DoxyCompactList}\small\item\em If you don\textquotesingle{}t want destruction of keyset at the end you can release the pointer. \end{DoxyCompactList}\item 
ckdb\+::\+Key\+Set $\ast$ \hyperlink{classkdb_1_1KeySet_a4e9a3906e0b18a783f8a6e8bdbec9ed0}{get\+Key\+Set} () const
\begin{DoxyCompactList}\small\item\em Passes out the raw keyset pointer. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1KeySet_a9f3ec4eebe304185527b08a6fa01b77c}{set\+Key\+Set} (ckdb\+::\+Key\+Set $\ast$k)
\begin{DoxyCompactList}\small\item\em Take ownership of passed keyset. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1KeySet}{Key\+Set} \& \hyperlink{classkdb_1_1KeySet_a1c54736b7206bc2253d02a5bf4b3ccfb}{operator=} (\hyperlink{classkdb_1_1KeySet}{Key\+Set} const \&other)
\begin{DoxyCompactList}\small\item\em Duplicate a keyset. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1KeySet_ab01c5c46e4c0802560b8f15886af89c4}{size} () const
\begin{DoxyCompactList}\small\item\em The size of the keyset. \end{DoxyCompactList}\item 
ckdb\+::\+Key\+Set $\ast$ \hyperlink{classkdb_1_1KeySet_ad3f2b936d66729690e8a8a45b5074baa}{dup} () const
\begin{DoxyCompactList}\small\item\em Duplicate a keyset. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1KeySet_a28fd33fdaecf1d57d4dddac7058f5d38}{copy} (const \hyperlink{classkdb_1_1KeySet}{Key\+Set} \&other)
\begin{DoxyCompactList}\small\item\em Copy a keyset. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1KeySet_a38f5159e39758aa632421d2fe7440633}{clear} ()
\begin{DoxyCompactList}\small\item\em Clear the keyset. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1KeySet_a0d4b2f3aa9f58d10053561135b50233e}{append} (const \hyperlink{classkdb_1_1Key}{Key} \&to\+Append)
\begin{DoxyCompactList}\small\item\em append a key \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1KeySet_ac9cbdc933d7171037d47c6d4d78595d1}{append} (const \hyperlink{classkdb_1_1KeySet}{Key\+Set} \&to\+Append)
\begin{DoxyCompactList}\small\item\em append a keyset \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1KeySet_a1aca3689ed08cbc909976cdf874cfb59}{head} () const
\begin{DoxyCompactList}\small\item\em Return the first key in the \hyperlink{classkdb_1_1KeySet}{Key\+Set}. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1KeySet_a16deed50e0d8cfee023d4423a119df51}{tail} () const
\begin{DoxyCompactList}\small\item\em Return the last key in the \hyperlink{classkdb_1_1KeySet}{Key\+Set}. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1KeySet_a5bc5a16a726e959adaf3cf8506e7b849}{rewind} () const
\begin{DoxyCompactList}\small\item\em Rewinds the \hyperlink{classkdb_1_1KeySet}{Key\+Set} internal cursor. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1KeySet_affd52d130faf184361297f9e7f0c9f16}{next} () const
\begin{DoxyCompactList}\small\item\em Returns the next \hyperlink{classkdb_1_1Key}{Key} in a \hyperlink{classkdb_1_1KeySet}{Key\+Set}. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1KeySet_a0a0fc4efecd6dcbfde5fc35301b60349}{current} () const
\begin{DoxyCompactList}\small\item\em Return the current \hyperlink{classkdb_1_1Key}{Key}. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1KeySet_aa36d35d8f12233a4c8f88d9bb13429c3}{set\+Cursor} (elektra\+Cursor cursor) const
\begin{DoxyCompactList}\small\item\em Set the \hyperlink{classkdb_1_1KeySet}{Key\+Set} internal cursor. \end{DoxyCompactList}\item 
elektra\+Cursor \hyperlink{classkdb_1_1KeySet_accc11bcf2a4b5937ce9f0787c011c2d9}{get\+Cursor} () const
\begin{DoxyCompactList}\small\item\em Get the \hyperlink{classkdb_1_1KeySet}{Key\+Set} internal cursor. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1KeySet_a7f207457a1c12633a1a5301a3a1bbaed}{pop} ()
\begin{DoxyCompactList}\small\item\em Remove and return the last key of {\ttfamily ks}. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1KeySet_a40e32f2d9f34f03fa8ec85945f49b630}{at} (elektra\+Cursor pos) const
\begin{DoxyCompactList}\small\item\em Lookup a key by index. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1KeySet}{Key\+Set} \hyperlink{classkdb_1_1KeySet_ab283da798a7670d5c3f0e1a5b821e666}{cut} (\hyperlink{classkdb_1_1Key}{Key} k)
\begin{DoxyCompactList}\small\item\em Cuts out a keyset at the cutpoint. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1KeySet_a2b8537e388edfbb6941d771106c0ae3a}{lookup} (const \hyperlink{classkdb_1_1Key}{Key} \&k, const \hyperlink{group__keyset_gada05f4bbf46fde81d0d57df86e73d914}{elektra\+Lookup\+Flags} options=\hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+NE}) const
\begin{DoxyCompactList}\small\item\em Look for a \hyperlink{classkdb_1_1Key}{Key} contained in {\ttfamily ks} that matches the name of the {\ttfamily key}. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1KeySet_a0ef071747608900be478219e4a040612}{lookup} (std\+::string const \&name, const \hyperlink{group__keyset_gada05f4bbf46fde81d0d57df86e73d914}{elektra\+Lookup\+Flags} options=\hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+NE}) const
\begin{DoxyCompactList}\small\item\em Lookup a key by name. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T \hyperlink{classkdb_1_1KeySet_a65208974b44da0162ef70dd7a173748f}{get} (std\+::string const \&name, const \hyperlink{group__keyset_gada05f4bbf46fde81d0d57df86e73d914}{elektra\+Lookup\+Flags} options=\hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+NE}) const
\begin{DoxyCompactList}\small\item\em Generic lookup+get for keysets. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A keyset holds together a set of keys. 

Methods to manipulate Key\+Sets. A \hyperlink{classkdb_1_1KeySet}{Key\+Set} is a set of keys.

Most important properties of a \hyperlink{classkdb_1_1KeySet}{Key\+Set}\+:


\begin{DoxyItemize}
\item Allows us to iterate over all keys (in any depth)
\item Iteration is always sorted
\item Fast key lookup
\item A \hyperlink{classkdb_1_1Key}{Key} may be shared among many Key\+Sets.
\end{DoxyItemize}

The most important methods of \hyperlink{classkdb_1_1KeySet}{Key\+Set}\+:


\begin{DoxyItemize}
\item With \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ks\+New()} you can create a new \hyperlink{classkdb_1_1KeySet}{Key\+Set}.
\item You can append keys with \hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()} or with \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()} you can append a whole keyset.
\item Using \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} you can lookup (or pop with \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984}{K\+D\+B\+\_\+\+O\+\_\+\+P\+OP}) a key.
\item With \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()} and \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} you can iterate through the keyset. Be assured that you will get every key of the set in a stable order (parents before children).
\end{DoxyItemize}

\begin{DoxyNote}{Note}
Because the key is not copied, also the pointer to the current metadata \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()} will be shared.
\end{DoxyNote}
Key\+Sets have an \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{internal cursor }. Methods should avoid to change this cursor, unless they want to communicate something with it. The internal cursor is used\+:


\begin{DoxyItemize}
\item in \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()}\+: points to the found key
\item in \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdb\+Set()}\+: points to the key which caused an error
\end{DoxyItemize}

\hyperlink{classkdb_1_1KeySet}{Key\+Set} is the most important data structure in Elektra. It makes it possible to get and store many keys at once inside the database. In addition to that, the class can be used as high level datastructure in applications and it can be used in plugins to manipulate or check configuration.

With \hyperlink{group__keyset_gad65d2cdcbb5381194a1688e169af8a83}{ks\+Lookup\+By\+Name()} it is possible to fetch easily specific keys out of the list of keys.

You can easily create and iterate keys\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{// create a new keyset with 3 keys}
\textcolor{comment}{// with a hint that about 20 keys will be inside}
KeySet * myConfig = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (20, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/name1"}, 0), \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/name2"}, 0), 
      \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/name3"}, 0), \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// append a key in the keyset}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey} (myConfig, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/name4"}, 0));

Key * \hyperlink{classkdb_1_1KeySet_a0a0fc4efecd6dcbfde5fc35301b60349}{current};
\hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ksRewind} (myConfig);
\textcolor{keywordflow}{while} ((current = \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ksNext} (myConfig)) != 0)
\{
        printf (\textcolor{stringliteral}{"Key name is %s.\(\backslash\)n"}, \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (current));
\}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (myConfig); \textcolor{comment}{// delete keyset and all keys appended}
\end{DoxyCodeInclude}
 \begin{DoxyInvariant}{Invariant}
always holds an underlying elektra keyset.
\end{DoxyInvariant}
\begin{DoxyNote}{Note}
that the cursor is mutable, so it might be changed even in const functions as described. 
\end{DoxyNote}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classkdb_1_1KeySet_a4eac9850fa4f06c07a5306befc3e4377}\label{classkdb_1_1KeySet_a4eac9850fa4f06c07a5306befc3e4377}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!Key\+Set@{Key\+Set}}
\index{Key\+Set@{Key\+Set}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{Key\+Set()}{KeySet()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily kdb\+::\+Key\+Set\+::\+Key\+Set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Creates a new empty keyset with no keys. 

Allocate, initialize and return a new \hyperlink{classkdb_1_1KeySet}{Key\+Set} object. Objects created with \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ks\+New()} must be destroyed with \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()}.

You can use an arbitrary long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be K\+S\+\_\+\+E\+ND.

So, terminate with ks\+New(0, K\+S\+\_\+\+E\+N\+D) or ks\+New(20, ..., K\+S\+\_\+\+E\+ND)

\begin{DoxyWarning}{Warning}
Never use ks\+New(0, key\+New(...), K\+S\+\_\+\+E\+ND). If the first parameter is 0, other arguments are ignored.
\end{DoxyWarning}
The first parameter {\ttfamily alloc} defines how many keys can be added without reallocation. If you pass any alloc size greater than 0, but less than 16, it will default to 16.

For most uses


\begin{DoxyCodeInclude}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (1, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// enough memory for up to 16 keys, without needing reallocation}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 will be fine. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large keysets.

You can defer the allocation of the internal array that holds the keys, by passing 0 as the alloc size. This is useful if it is unclear whether your keyset will actually hold any keys and you want to avoid a malloc call.


\begin{DoxyCodeInclude}
\textcolor{comment}{// Create KeySet without allocating memory for keys}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (0, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// The first allocation will happen in ksAppendKey}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey}(keys, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key02"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value02"}, 0));
\textcolor{comment}{// work with the KeySet}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 But if you have any clue how large your keyset may be, you should read the next statements.

If you want a keyset with length 15 (because you know of your application that you only need up to 15 keys), use\+:


\begin{DoxyCodeInclude}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (15, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key01"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value01"}, 0),
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key02"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value02"}, 0),
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key03"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value03"}, 0),
                       \textcolor{comment}{// ...}
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key15"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value15"}, 0), \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// work with it}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 If you start having 3 keys, and your application needs approximately 200 up to 500 keys, you can use\+:


\begin{DoxyCodeInclude}
KeySet * config = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (500, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key1"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value1"}, 0),
                         \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key2"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value2"}, 0),
                         \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key3"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value3"}, 0),
                         \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END}); \textcolor{comment}{// don't forget the KS\_END at the end!}
\textcolor{comment}{// work with it}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (config);
\end{DoxyCodeInclude}
 Alloc size is 500, the size of the keyset will be 3 after ks\+New. This means the keyset will reallocate when appending more than 497 keys.

The main benefit of taking a list of variant length parameters is to be able to have one C-\/\+Statement for any possible \hyperlink{classkdb_1_1KeySet}{Key\+Set}. If you prefer, you can always create an empty \hyperlink{classkdb_1_1KeySet}{Key\+Set} and use \hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}.

\begin{DoxyPostcond}{Postcondition}
the keyset is rewinded properly
\end{DoxyPostcond}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()} to free the \hyperlink{group__keyset}{Key\+Set} afterwards 

\hyperlink{group__keyset_gac59e4b328245463f1451f68d5106151c}{ks\+Dup()} to duplicate an existing \hyperlink{group__keyset}{Key\+Set} 

\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()} to \hyperlink{classkdb_1_1KeySet_a0d4b2f3aa9f58d10053561135b50233e}{append} individual keys 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em alloc} & gives a hint for the size how many Keys may be stored initially \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a ready to use \hyperlink{classkdb_1_1KeySet}{Key\+Set} object 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on memory error \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classkdb_1_1KeySet_a21f651ff310178951402038e590743e0}\label{classkdb_1_1KeySet_a21f651ff310178951402038e590743e0}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!Key\+Set@{Key\+Set}}
\index{Key\+Set@{Key\+Set}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{Key\+Set()}{KeySet()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily kdb\+::\+Key\+Set\+::\+Key\+Set (\begin{DoxyParamCaption}\item[{ckdb\+::\+Key\+Set $\ast$}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Takes ownership of keyset! 

Keyset will be destroyed at destructor you cant continue to use keyset afterwards!

Use \hyperlink{classkdb_1_1KeySet_a2987b3fb1b12196399650726f1c18f02}{Key\+Set\+::release()} to avoid destruction.


\begin{DoxyParams}{Parameters}
{\em k} & the keyset to take the ownership from \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1KeySet_a2987b3fb1b12196399650726f1c18f02}{release()} 

\hyperlink{classkdb_1_1KeySet_a9f3ec4eebe304185527b08a6fa01b77c}{set\+Key\+Set()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_ad8d6df839ab852fded1739ff3398d0b1}\label{classkdb_1_1KeySet_ad8d6df839ab852fded1739ff3398d0b1}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!Key\+Set@{Key\+Set}}
\index{Key\+Set@{Key\+Set}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{Key\+Set()}{KeySet()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily kdb\+::\+Key\+Set\+::\+Key\+Set (\begin{DoxyParamCaption}\item[{const \hyperlink{classkdb_1_1KeySet}{Key\+Set} \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Duplicate a keyset. 

This keyset will be a duplicate of the other afterwards.

\begin{DoxyNote}{Note}
that they still reference to the same Keys, so if you change key values also the keys in the original keyset will be changed.
\end{DoxyNote}
So it is shallow copy, to create a deep copy you have to \hyperlink{classkdb_1_1KeySet_ad3f2b936d66729690e8a8a45b5074baa}{dup()} every key (it still won\textquotesingle{}t copy metadata, but they are C\+OW)\+: 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1KeySet}{kdb::KeySet} ksDeepCopy (\hyperlink{classkdb_1_1KeySet}{kdb::KeySet} orig)
\{
        \hyperlink{classkdb_1_1KeySet}{kdb::KeySet} deepCopy;
        orig.\hyperlink{classkdb_1_1KeySet_a5bc5a16a726e959adaf3cf8506e7b849}{rewind} ();
        \textcolor{keywordflow}{while} (orig.\hyperlink{classkdb_1_1KeySet_affd52d130faf184361297f9e7f0c9f16}{next} ())
        \{
                deepCopy.\hyperlink{classkdb_1_1KeySet_a0d4b2f3aa9f58d10053561135b50233e}{append} (orig.\hyperlink{classkdb_1_1KeySet_a0a0fc4efecd6dcbfde5fc35301b60349}{current} ().\hyperlink{classkdb_1_1Key_ababb1ccd9f18db379eb4a62f8db87bf5}{dup} ());
        \}
        \textcolor{keywordflow}{return} deepCopy;
\}
\end{DoxyCodeInclude}
 \begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1KeySet_ad3f2b936d66729690e8a8a45b5074baa}{dup} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a6191e93cdd67bbca63df934498d191ba}\label{classkdb_1_1KeySet_a6191e93cdd67bbca63df934498d191ba}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!Key\+Set@{Key\+Set}}
\index{Key\+Set@{Key\+Set}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{Key\+Set()}{KeySet()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily kdb\+::\+Key\+Set\+::\+Key\+Set (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{alloc,  }\item[{}]{... }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Create a new keyset. 


\begin{DoxyParams}{Parameters}
{\em alloc} & minimum number of keys to allocate \\
\hline
{\em ...} & variable argument list\\
\hline
\end{DoxyParams}
Allocate, initialize and return a new \hyperlink{classkdb_1_1KeySet}{Key\+Set} object. Objects created with \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ks\+New()} must be destroyed with \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()}.

You can use an arbitrary long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be K\+S\+\_\+\+E\+ND.

So, terminate with ks\+New(0, K\+S\+\_\+\+E\+N\+D) or ks\+New(20, ..., K\+S\+\_\+\+E\+ND)

\begin{DoxyWarning}{Warning}
Never use ks\+New(0, key\+New(...), K\+S\+\_\+\+E\+ND). If the first parameter is 0, other arguments are ignored.
\end{DoxyWarning}
The first parameter {\ttfamily alloc} defines how many keys can be added without reallocation. If you pass any alloc size greater than 0, but less than 16, it will default to 16.

For most uses


\begin{DoxyCodeInclude}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (1, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// enough memory for up to 16 keys, without needing reallocation}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 will be fine. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large keysets.

You can defer the allocation of the internal array that holds the keys, by passing 0 as the alloc size. This is useful if it is unclear whether your keyset will actually hold any keys and you want to avoid a malloc call.


\begin{DoxyCodeInclude}
\textcolor{comment}{// Create KeySet without allocating memory for keys}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (0, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// The first allocation will happen in ksAppendKey}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey}(keys, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key02"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value02"}, 0));
\textcolor{comment}{// work with the KeySet}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 But if you have any clue how large your keyset may be, you should read the next statements.

If you want a keyset with length 15 (because you know of your application that you only need up to 15 keys), use\+:


\begin{DoxyCodeInclude}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (15, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key01"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value01"}, 0),
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key02"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value02"}, 0),
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key03"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value03"}, 0),
                       \textcolor{comment}{// ...}
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key15"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value15"}, 0), \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// work with it}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 If you start having 3 keys, and your application needs approximately 200 up to 500 keys, you can use\+:


\begin{DoxyCodeInclude}
KeySet * config = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (500, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key1"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value1"}, 0),
                         \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key2"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value2"}, 0),
                         \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key3"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value3"}, 0),
                         \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END}); \textcolor{comment}{// don't forget the KS\_END at the end!}
\textcolor{comment}{// work with it}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (config);
\end{DoxyCodeInclude}
 Alloc size is 500, the size of the keyset will be 3 after ks\+New. This means the keyset will reallocate when appending more than 497 keys.

The main benefit of taking a list of variant length parameters is to be able to have one C-\/\+Statement for any possible \hyperlink{classkdb_1_1KeySet}{Key\+Set}. If you prefer, you can always create an empty \hyperlink{classkdb_1_1KeySet}{Key\+Set} and use \hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}.

\begin{DoxyPostcond}{Postcondition}
the keyset is rewinded properly
\end{DoxyPostcond}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()} to free the \hyperlink{group__keyset}{Key\+Set} afterwards 

\hyperlink{group__keyset_gac59e4b328245463f1451f68d5106151c}{ks\+Dup()} to duplicate an existing \hyperlink{group__keyset}{Key\+Set} 

\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()} to \hyperlink{classkdb_1_1KeySet_a0d4b2f3aa9f58d10053561135b50233e}{append} individual keys 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em alloc} & gives a hint for the size how many Keys may be stored initially \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a ready to use \hyperlink{classkdb_1_1KeySet}{Key\+Set} object 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on memory error\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
caller must call va\+\_\+start and va\+\_\+end 
\end{DoxyPrecond}
\begin{DoxyParagraph}{va the list of arguments}

\end{DoxyParagraph}

\begin{DoxyParams}{Parameters}
{\em alloc} & the allocation size \\
\hline
{\em va} & the list of variable arguments \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classkdb_1_1KeySet_ae0b2996803b9c9124cf791a1d738855c}\label{classkdb_1_1KeySet_ae0b2996803b9c9124cf791a1d738855c}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!Key\+Set@{Key\+Set}}
\index{Key\+Set@{Key\+Set}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{Key\+Set()}{KeySet()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily kdb\+::\+Key\+Set\+::\+Key\+Set (\begin{DoxyParamCaption}\item[{\hyperlink{structkdb_1_1VaAlloc}{Va\+Alloc}}]{alloc,  }\item[{va\+\_\+list}]{av }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Create a new keyset. 


\begin{DoxyParams}{Parameters}
{\em alloc} & minimum number of keys to allocate \\
\hline
{\em ap} & variable arguments list\\
\hline
\end{DoxyParams}
Use va as first argument to use this constructor, e.\+g.\+: 
\begin{DoxyCode}
KeySet ks(va, 23, ...);
\end{DoxyCode}


Allocate, initialize and return a new \hyperlink{classkdb_1_1KeySet}{Key\+Set} object. Objects created with \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ks\+New()} must be destroyed with \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()}.

You can use an arbitrary long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be K\+S\+\_\+\+E\+ND.

So, terminate with ks\+New(0, K\+S\+\_\+\+E\+N\+D) or ks\+New(20, ..., K\+S\+\_\+\+E\+ND)

\begin{DoxyWarning}{Warning}
Never use ks\+New(0, key\+New(...), K\+S\+\_\+\+E\+ND). If the first parameter is 0, other arguments are ignored.
\end{DoxyWarning}
The first parameter {\ttfamily alloc} defines how many keys can be added without reallocation. If you pass any alloc size greater than 0, but less than 16, it will default to 16.

For most uses


\begin{DoxyCodeInclude}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (1, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// enough memory for up to 16 keys, without needing reallocation}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 will be fine. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large keysets.

You can defer the allocation of the internal array that holds the keys, by passing 0 as the alloc size. This is useful if it is unclear whether your keyset will actually hold any keys and you want to avoid a malloc call.


\begin{DoxyCodeInclude}
\textcolor{comment}{// Create KeySet without allocating memory for keys}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (0, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// The first allocation will happen in ksAppendKey}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey}(keys, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key02"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value02"}, 0));
\textcolor{comment}{// work with the KeySet}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 But if you have any clue how large your keyset may be, you should read the next statements.

If you want a keyset with length 15 (because you know of your application that you only need up to 15 keys), use\+:


\begin{DoxyCodeInclude}
KeySet * keys = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (15, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key01"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value01"}, 0),
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key02"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value02"}, 0),
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key03"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value03"}, 0),
                       \textcolor{comment}{// ...}
                       \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key15"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value15"}, 0), \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\textcolor{comment}{// work with it}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (keys);
\end{DoxyCodeInclude}
 If you start having 3 keys, and your application needs approximately 200 up to 500 keys, you can use\+:


\begin{DoxyCodeInclude}
KeySet * config = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (500, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key1"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value1"}, 0),
                         \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key2"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value2"}, 0),
                         \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/sw/org/app/#0/current/fixedConfiguration/key3"}, 
      \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"value3"}, 0),
                         \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END}); \textcolor{comment}{// don't forget the KS\_END at the end!}
\textcolor{comment}{// work with it}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (config);
\end{DoxyCodeInclude}
 Alloc size is 500, the size of the keyset will be 3 after ks\+New. This means the keyset will reallocate when appending more than 497 keys.

The main benefit of taking a list of variant length parameters is to be able to have one C-\/\+Statement for any possible \hyperlink{classkdb_1_1KeySet}{Key\+Set}. If you prefer, you can always create an empty \hyperlink{classkdb_1_1KeySet}{Key\+Set} and use \hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}.

\begin{DoxyPostcond}{Postcondition}
the keyset is rewinded properly
\end{DoxyPostcond}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()} to free the \hyperlink{group__keyset}{Key\+Set} afterwards 

\hyperlink{group__keyset_gac59e4b328245463f1451f68d5106151c}{ks\+Dup()} to duplicate an existing \hyperlink{group__keyset}{Key\+Set} 

\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()} to \hyperlink{classkdb_1_1KeySet_a0d4b2f3aa9f58d10053561135b50233e}{append} individual keys 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em alloc} & gives a hint for the size how many Keys may be stored initially \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a ready to use \hyperlink{classkdb_1_1KeySet}{Key\+Set} object 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on memory error\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
caller must call va\+\_\+start and va\+\_\+end 
\end{DoxyPrecond}
\begin{DoxyParagraph}{va the list of arguments}

\end{DoxyParagraph}

\begin{DoxyParams}{Parameters}
{\em alloc} & the allocation size \\
\hline
{\em va} & the list of variable arguments \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classkdb_1_1KeySet_ade654f92bddec24abad1b651e828f2b8}\label{classkdb_1_1KeySet_ade654f92bddec24abad1b651e828f2b8}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!````~Key\+Set@{$\sim$\+Key\+Set}}
\index{````~Key\+Set@{$\sim$\+Key\+Set}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{$\sim$\+Key\+Set()}{~KeySet()}}
{\footnotesize\ttfamily kdb\+::\+Key\+Set\+::$\sim$\+Key\+Set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deconstruct a keyset. 

A destructor for \hyperlink{classkdb_1_1KeySet}{Key\+Set} objects. Cleans all internal dynamic attributes, decrement all reference pointers to all keys and then \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} all contained Keys, and elektra\+Free ()s the release the \hyperlink{classkdb_1_1KeySet}{Key\+Set} object memory (that was previously allocated by \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ks\+New()}).


\begin{DoxyParams}{Parameters}
{\em ks} & the keyset object to work with \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & when the keyset was freed \\
\hline
{\em -\/1} & on null pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ks\+New()} 
\end{DoxySeeAlso}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classkdb_1_1KeySet_a0d4b2f3aa9f58d10053561135b50233e}\label{classkdb_1_1KeySet_a0d4b2f3aa9f58d10053561135b50233e}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!append@{append}}
\index{append@{append}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{append()}{append()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily ssize\+\_\+t kdb\+::\+Key\+Set\+::append (\begin{DoxyParamCaption}\item[{const \hyperlink{classkdb_1_1Key}{Key} \&}]{to\+Append }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



append a key 


\begin{DoxyParams}{Parameters}
{\em to\+Append} & key to append\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of keys in the keyset
\end{DoxyReturn}
Appends a \hyperlink{classkdb_1_1Key}{Key} to the end of {\ttfamily ks}. Hands the ownership of the key {\ttfamily to\+Append} to the \hyperlink{classkdb_1_1KeySet}{Key\+Set} {\ttfamily ks}. ks\+Del(ks) uses key\+Del(k) to delete every key unless it got its refcount incremented by \hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()}, e.\+g. by another keyset that contains this key.

The reference counter of the key will be incremented to show this ownership, and thus {\ttfamily to\+Append} is not const.

\begin{DoxyNote}{Note}
Because the key is not copied, also the pointer to the current metadata \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()} will be shared.
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga4aabc4272506dd63161db2bbb42de8ae}{key\+Get\+Ref()}.
\end{DoxySeeAlso}
If the keyname already existed in the keyset, it will be replaced with the new key.

\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()} will also lock the key\textquotesingle{}s name from {\ttfamily to\+Append}. This is necessary so that the order of the \hyperlink{classkdb_1_1KeySet}{Key\+Set} cannot be destroyed via calls to \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()}.

The \hyperlink{classkdb_1_1KeySet}{Key\+Set} internal cursor will be set to the new key.

It is safe to directly append newly created keys\+: 
\begin{DoxyCodeInclude}
KeySet * ks = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (1, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey} (ks, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/my/new/key"}, \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}));
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (ks);
\textcolor{comment}{// key deleted, too!}
\end{DoxyCodeInclude}
 If you want the key to outlive the keyset, make sure to do proper ref counting\+: 
\begin{DoxyCodeInclude}
KeySet * ks = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (1, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
Key * k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/ref/key"}, \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{keyIncRef} (k);
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey} (ks, k);
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (ks);
\textcolor{comment}{// now we still can work with the key k!}
\hyperlink{group__key_ga2c6433ca22109e4e141946057eccb283}{keyDecRef} (k);
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 Or if you want to avoid aliasing at all, you can duplicate the key. But then key in the keyset has another identity\+: 
\begin{DoxyCodeInclude}
KeySet * ks = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (1, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
Key * k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user:/ref/key"}, \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey} (ks, \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{keyDup} (k));
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (ks);
\textcolor{comment}{// now we still can work with the key k!}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}


\begin{DoxyReturn}{Returns}
the size of the \hyperlink{classkdb_1_1KeySet}{Key\+Set} after appending 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on N\+U\+LL pointers \\
\hline
{\em -\/1} & if appending failed (only on memory problems), the key will be deleted then. \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em ks} & \hyperlink{classkdb_1_1KeySet}{Key\+Set} that will receive the key \\
\hline
{\em to\+Append} & \hyperlink{classkdb_1_1Key}{Key} that will be appended to ks or deleted \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()}, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()} 

\hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_ac9cbdc933d7171037d47c6d4d78595d1}\label{classkdb_1_1KeySet_ac9cbdc933d7171037d47c6d4d78595d1}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!append@{append}}
\index{append@{append}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{append()}{append()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily ssize\+\_\+t kdb\+::\+Key\+Set\+::append (\begin{DoxyParamCaption}\item[{const \hyperlink{classkdb_1_1KeySet}{Key\+Set} \&}]{to\+Append }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



append a keyset 


\begin{DoxyParams}{Parameters}
{\em to\+Append} & keyset to append\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of keys in the keyset
\end{DoxyReturn}
Append all {\ttfamily to\+Append} contained keys to the end of the {\ttfamily ks}. {\ttfamily to\+Append} \hyperlink{classkdb_1_1KeySet}{Key\+Set} will be left unchanged.

If a key is both in to\+Append and ks, the \hyperlink{classkdb_1_1Key}{Key} in ks will be overridden.

\begin{DoxyNote}{Note}
Because the key is not copied, also the pointer to the current metadata \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()} will be shared.
\end{DoxyNote}
\begin{DoxyPostcond}{Postcondition}
Sorted \hyperlink{classkdb_1_1KeySet}{Key\+Set} ks with all keys it had before and additionally the keys from to\+Append 
\end{DoxyPostcond}
\begin{DoxyReturn}{Returns}
the size of the \hyperlink{classkdb_1_1KeySet}{Key\+Set} after transfer 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on N\+U\+LL pointers \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em ks} & the \hyperlink{classkdb_1_1KeySet}{Key\+Set} that will receive the keys \\
\hline
{\em to\+Append} & the \hyperlink{classkdb_1_1KeySet}{Key\+Set} that provides the keys that will be transferred \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a40e32f2d9f34f03fa8ec85945f49b630}\label{classkdb_1_1KeySet_a40e32f2d9f34f03fa8ec85945f49b630}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!at@{at}}
\index{at@{at}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{at()}{at()}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1Key}{Key} kdb\+::\+Key\+Set\+::at (\begin{DoxyParamCaption}\item[{elektra\+Cursor}]{pos }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Lookup a key by index. 


\begin{DoxyParams}{Parameters}
{\em pos} & cursor position\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the found key 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdb_1_1KeySet_a38f5159e39758aa632421d2fe7440633}\label{classkdb_1_1KeySet_a38f5159e39758aa632421d2fe7440633}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!clear@{clear}}
\index{clear@{clear}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily void kdb\+::\+Key\+Set\+::clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Clear the keyset. 

Keyset will have no keys afterwards. \mbox{\Hypertarget{classkdb_1_1KeySet_a28fd33fdaecf1d57d4dddac7058f5d38}\label{classkdb_1_1KeySet_a28fd33fdaecf1d57d4dddac7058f5d38}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!copy@{copy}}
\index{copy@{copy}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily void kdb\+::\+Key\+Set\+::copy (\begin{DoxyParamCaption}\item[{const \hyperlink{classkdb_1_1KeySet}{Key\+Set} \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy a keyset. 


\begin{DoxyParams}{Parameters}
{\em other} & other keyset to copy\\
\hline
\end{DoxyParams}
This is only a shallow copy. For a deep copy you need to dup every key.

Replace the content of a keyset with another one. Most often you may want a duplicate of a keyset, see \hyperlink{group__keyset_gac59e4b328245463f1451f68d5106151c}{ks\+Dup()} or append keys, see \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()}. But in some situations you need to copy a keyset to an existing keyset, for which this function exists.

\begin{DoxyNote}{Note}
You can also use it to clear a keyset when you pass a N\+U\+LL pointer as {\ttfamily source}.
\end{DoxyNote}
\begin{DoxyParagraph}{Implementation\+:}
First all keys in {\ttfamily dest} will be deleted. Afterwards the content of the source will be added to the destination and the \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} is set properly in {\ttfamily dest}.
\end{DoxyParagraph}
A flat copy is made, so the keys will not be duplicated, but there reference counter is updated, so both keysets need to be \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()}.

\begin{DoxyNote}{Note}
Because the key is not copied, also the pointer to the current metadata \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()} will be shared.
\end{DoxyNote}

\begin{DoxyCode}
\textcolor{keywordtype}{int} f (KeySet *ks)
\{
        KeySet *c = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (20, ..., \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
        \textcolor{comment}{// c receives keys}
        \hyperlink{group__keyset_gaba1f1dbea191f4d7e7eb3e4296ae7d5e}{ksCopy} (ks, c); \textcolor{comment}{// pass the keyset to the caller}

        \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (c);
\}       \textcolor{comment}{// caller needs to ksDel (ks)}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em source} & has to be an initialized source \hyperlink{classkdb_1_1KeySet}{Key\+Set} or N\+U\+LL \\
\hline
{\em dest} & has to be an initialized \hyperlink{classkdb_1_1KeySet}{Key\+Set} where to write the keys \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & on success \\
\hline
{\em 0} & if dest was cleared successfully (source is N\+U\+LL) \\
\hline
{\em -\/1} & on N\+U\+LL pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ks\+New()}, \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()}, \hyperlink{group__keyset_gac59e4b328245463f1451f68d5106151c}{ks\+Dup()} 

\hyperlink{group__key_ga6a12cbbe656a1ad9f41b8c681d7a2f92}{key\+Copy()} for copying keys 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a0a0fc4efecd6dcbfde5fc35301b60349}\label{classkdb_1_1KeySet_a0a0fc4efecd6dcbfde5fc35301b60349}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!current@{current}}
\index{current@{current}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{current()}{current()}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1Key}{Key} kdb\+::\+Key\+Set\+::current (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the current \hyperlink{classkdb_1_1Key}{Key}. 

The pointer is N\+U\+LL if you reached the end or after \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}.

\begin{DoxyNote}{Note}
You must not delete the key or change the key, use \hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ks\+Pop()} if you want to delete it.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em ks} & the keyset object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the \hyperlink{classkdb_1_1Key}{Key} pointed by {\ttfamily ks\textquotesingle{}s} cursor 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on N\+U\+LL pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()}, \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_ab283da798a7670d5c3f0e1a5b821e666}\label{classkdb_1_1KeySet_ab283da798a7670d5c3f0e1a5b821e666}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!cut@{cut}}
\index{cut@{cut}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{cut()}{cut()}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1KeySet}{Key\+Set} kdb\+::\+Key\+Set\+::cut (\begin{DoxyParamCaption}\item[{\hyperlink{classkdb_1_1Key}{Key}}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Cuts out a keyset at the cutpoint. 

Searches for the cutpoint inside the \hyperlink{classkdb_1_1KeySet}{Key\+Set} ks. If found it cuts out everything which is below (see \hyperlink{group__keytest_ga03332b5d97c76a4fd2640aca4762b8df}{key\+Is\+Below()}) this key. These keys will be missing in the keyset {\ttfamily ks}. Instead, they will be moved to the returned keyset. If {\ttfamily cutpoint} is not found an empty keyset is returned and {\ttfamily ks} is not changed.

The cursor will stay at the same key as it was before. If the cursor was inside the region of cut (moved) keys, the cursor will be set to the key before the cutpoint.

If you use \hyperlink{group__keyset_ga6b00cf82b59af4d883a9bad6cf4a4a4a}{ks\+Cut()} on a keyset you got from \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} and plan to make a \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdb\+Set()} later, make sure that you keep all keys that should not be removed permanently. You have to keep the \hyperlink{classkdb_1_1KeySet}{Key\+Set} that was returned and the \hyperlink{classkdb_1_1KeySet}{Key\+Set} {\ttfamily ks}.

\begin{DoxyParagraph}{Example\+:}

\end{DoxyParagraph}
You have the keyset {\ttfamily ks\+:} 
\begin{DoxyItemize}
\item {\ttfamily system\+:/mountpoint/interest} 
\item {\ttfamily system\+:/mountpoint/interest/folder} 
\item {\ttfamily system\+:/mountpoint/interest/folder/key1} 
\item {\ttfamily system\+:/mountpoint/interest/folder/key2} 
\item {\ttfamily system\+:/mountpoint/other/key1} 
\end{DoxyItemize}

When you use 
\begin{DoxyCodeInclude}
        Key * parentKey = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"system:/mountpoint/interest"}, \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
        KDB * kdb = \hyperlink{group__kdb_ga6808defe5870f328dd17910aacbdc6ca}{kdbOpen} (parentKey);
        KeySet * ks = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (0, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
        \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdbGet} (kdb, ks, parentKey);
        KeySet * returned = \hyperlink{group__keyset_ga6b00cf82b59af4d883a9bad6cf4a4a4a}{ksCut} (ks, parentKey);
        \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdbSet} (kdb, ks, parentKey); \textcolor{comment}{// all keys below cutpoint are now removed}
        \hyperlink{group__kdb_gadb54dc9fda17ee07deb9444df745c96f}{kdbClose} (kdb, parentKey);
\end{DoxyCodeInclude}
 Then in {\ttfamily returned} are\+:
\begin{DoxyItemize}
\item {\ttfamily system\+:/mountpoint/interest} 
\item {\ttfamily system\+:/mountpoint/interest/folder} 
\item {\ttfamily system\+:/mountpoint/interest/folder/key1} 
\item {\ttfamily system\+:/mountpoint/interest/folder/key2} 
\end{DoxyItemize}

And in {\ttfamily ks} are\+:
\begin{DoxyItemize}
\item {\ttfamily system\+:/mountpoint/other/key1} 
\end{DoxyItemize}

So \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdb\+Set()} permanently removes all keys below {\ttfamily system\+:/mountpoint/interest}.

\begin{DoxySeeAlso}{See also}
\hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} for explanation why you might \hyperlink{classkdb_1_1KeySet_a65208974b44da0162ef70dd7a173748f}{get} more keys than you requested.
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
a new allocated \hyperlink{classkdb_1_1KeySet}{Key\+Set} which needs to deleted with \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()}. The keyset consists of all keys (of the original keyset ks) below the cutpoint. If the key cutpoint exists, it will also be appended. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on null pointers, no key name or allocation problems \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em ks} & the keyset to cut. It will be modified by removing all keys below the cutpoint. The cutpoint itself will also be removed. \\
\hline
{\em cutpoint} & the point where to cut out the keyset \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classkdb_1_1KeySet_ad3f2b936d66729690e8a8a45b5074baa}\label{classkdb_1_1KeySet_ad3f2b936d66729690e8a8a45b5074baa}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!dup@{dup}}
\index{dup@{dup}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{dup()}{dup()}}
{\footnotesize\ttfamily ckdb\+::\+Key\+Set $\ast$ kdb\+::\+Key\+Set\+::dup (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Duplicate a keyset. 

\begin{DoxyReturn}{Returns}
a copy of the keys
\end{DoxyReturn}
This is only a shallow copy. For a deep copy you need to dup every key.

Return a duplicate of a keyset. Objects created with \hyperlink{group__keyset_gac59e4b328245463f1451f68d5106151c}{ks\+Dup()} must be destroyed with \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()}.

Memory will be allocated as needed for dynamic properties, so you need to \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()} the returned pointer.

A flat copy is made, so the keys will not be duplicated, but their reference counter is updated, so both keysets need \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()}.


\begin{DoxyParams}{Parameters}
{\em source} & has to be an initialized source \hyperlink{classkdb_1_1KeySet}{Key\+Set} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a flat copy of source on success 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on N\+U\+LL pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ks\+New()}, \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ks\+Del()} 

\hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} for \hyperlink{group__key}{Key} duplication 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a65208974b44da0162ef70dd7a173748f}\label{classkdb_1_1KeySet_a65208974b44da0162ef70dd7a173748f}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!get@{get}}
\index{get@{get}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T kdb\+::\+Key\+Set\+::get (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{name,  }\item[{const \hyperlink{group__keyset_gada05f4bbf46fde81d0d57df86e73d914}{elektra\+Lookup\+Flags}}]{options = {\ttfamily \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+NE}} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Generic lookup+get for keysets. 


\begin{DoxyParams}{Parameters}
{\em name} & the key name to get \\
\hline
{\em options} & the options to be passed to \hyperlink{classkdb_1_1KeySet_a2b8537e388edfbb6941d771106c0ae3a}{lookup()}\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Not\+Found\+Exception} & if no key found\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
To specialize more complex types (which are generic themselves) you can also specialize Key\+Set\+Type\+Wrapper$<$\+T$>$.
\end{DoxyNote}
Use 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <\hyperlink{keysetget_8hpp}{keysetget.hpp}>}
\end{DoxyCode}
 to include specializations for std types.

\begin{DoxyReturn}{Returns}
the requested type 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdb_1_1KeySet_accc11bcf2a4b5937ce9f0787c011c2d9}\label{classkdb_1_1KeySet_accc11bcf2a4b5937ce9f0787c011c2d9}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!get\+Cursor@{get\+Cursor}}
\index{get\+Cursor@{get\+Cursor}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{get\+Cursor()}{getCursor()}}
{\footnotesize\ttfamily elektra\+Cursor kdb\+::\+Key\+Set\+::get\+Cursor (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the \hyperlink{classkdb_1_1KeySet}{Key\+Set} internal cursor. 

Use it to get the cursor of the actual position.

\begin{DoxyWarning}{Warning}
Cursors are getting invalid when the key was \hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ks\+Pop()}ed or \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} with K\+D\+B\+\_\+\+O\+\_\+\+P\+OP was used.
\end{DoxyWarning}
\hypertarget{group__keyset_readahead}{}\subsection{Read ahead}\label{group__keyset_readahead}
With the cursors it is possible to read ahead in a keyset\+:


\begin{DoxyCode}
elektraCursor jump;
\hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ksRewind} (ks);
\textcolor{keywordflow}{while} ((key = \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{keyNextMeta} (ks))!=0)
\{
        \textcolor{comment}{// now mark this key}
        jump = \hyperlink{group__keyset_gace0444eb8ec958a429794f8586fc72e7}{ksGetCursor}(ks);

        \textcolor{comment}{//code..}
        \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{keyNextMeta} (ks); \textcolor{comment}{// now browse on}
        \textcolor{comment}{// use ksCurrent(ks) to check the keys}
        \textcolor{comment}{//code..}

        \textcolor{comment}{// jump back to the position marked before}
        \hyperlink{group__keyset_ga28b2a7d13c620b3c9d4815a0608c738f}{ksSetCursor}(ks, jump);
\}
\end{DoxyCode}
\hypertarget{group__keyset_restore}{}\subsection{Restoring state}\label{group__keyset_restore}
It can also be used to restore the state of a keyset in a function


\begin{DoxyCode}
\textcolor{keywordtype}{int} f (KeySet *ks)
\{
        elektraCursor state = \hyperlink{group__keyset_gace0444eb8ec958a429794f8586fc72e7}{ksGetCursor}(ks);

        \textcolor{comment}{// work with keyset}

        \textcolor{comment}{// now bring the keyset to the state before}
        \hyperlink{group__keyset_ga28b2a7d13c620b3c9d4815a0608c738f}{ksSetCursor} (ks, state);
\}
\end{DoxyCode}


It is of course possible to make the \hyperlink{classkdb_1_1KeySet}{Key\+Set} const and cast its const away to set the cursor. Another way to achieve the same is to \hyperlink{group__keyset_gac59e4b328245463f1451f68d5106151c}{ks\+Dup()} the keyset, but it is not as efficient.

An invalid cursor will be returned directly after \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}. When you set an invalid cursor \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} is 0 and \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} == \hyperlink{group__keyset_gae7dbf3aef70e67b5328475eb3d1f92f5}{ks\+Head()}.\hypertarget{group__keyset_cursor_directly}{}\subsection{Using Cursor directly}\label{group__keyset_cursor_directly}
You can also use the cursor directly by initializing it to some index in the Keyset and then incrementing or decrementing it, to iterate over the keyset.


\begin{DoxyCodeInclude}
        Key * cur;
        \textcolor{keywordflow}{for} (elektraCursor cursor = 0; (cur = \hyperlink{group__keyset_ga12b8fefaa20546e4790d60338b0db836}{ksAtCursor} (ks, cursor)) != NULL; ++cursor)
        \{
                printf (\textcolor{stringliteral}{"%s\(\backslash\)n"}, \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (cur));
        \}
\end{DoxyCodeInclude}
 You can also use a while loop if you need access to the last cursor position.


\begin{DoxyCodeInclude}
        elektraCursor cursor = 0;
        Key * cur;

        \textcolor{keywordflow}{while} ((cur = \hyperlink{group__keyset_ga12b8fefaa20546e4790d60338b0db836}{ksAtCursor} (ks, cursor)) != 0)
        \{
                printf (\textcolor{stringliteral}{"%s\(\backslash\)n"}, \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (cur));
                ++cursor;
        \}
\end{DoxyCodeInclude}
 \begin{DoxyNote}{Note}
Only use a cursor for the same keyset which it was made for.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em ks} & the keyset object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a valid cursor on success 

an invalid cursor on N\+U\+LL pointer or after \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()} 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()}, \hyperlink{group__keyset_ga28b2a7d13c620b3c9d4815a0608c738f}{ks\+Set\+Cursor()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a4e9a3906e0b18a783f8a6e8bdbec9ed0}\label{classkdb_1_1KeySet_a4e9a3906e0b18a783f8a6e8bdbec9ed0}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!get\+Key\+Set@{get\+Key\+Set}}
\index{get\+Key\+Set@{get\+Key\+Set}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{get\+Key\+Set()}{getKeySet()}}
{\footnotesize\ttfamily ckdb\+::\+Key\+Set $\ast$ kdb\+::\+Key\+Set\+::get\+Key\+Set (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Passes out the raw keyset pointer. 

\begin{DoxyReturn}{Returns}
pointer to internal ckdb \hyperlink{classkdb_1_1KeySet}{Key\+Set}
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1KeySet_a2987b3fb1b12196399650726f1c18f02}{release()} 

\hyperlink{classkdb_1_1KeySet_a9f3ec4eebe304185527b08a6fa01b77c}{set\+Key\+Set()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a1aca3689ed08cbc909976cdf874cfb59}\label{classkdb_1_1KeySet_a1aca3689ed08cbc909976cdf874cfb59}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!head@{head}}
\index{head@{head}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{head()}{head()}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1Key}{Key} kdb\+::\+Key\+Set\+::head (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the first key in the \hyperlink{classkdb_1_1KeySet}{Key\+Set}. 

\begin{DoxyReturn}{Returns}
alphabetical first key
\end{DoxyReturn}
The Key\+Sets cursor will not be affected.

If \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()}==\hyperlink{group__keyset_gae7dbf3aef70e67b5328475eb3d1f92f5}{ks\+Head()} you know you are on the first key.


\begin{DoxyParams}{Parameters}
{\em ks} & the keyset object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the first \hyperlink{classkdb_1_1Key}{Key} of a keyset 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on N\+U\+LL pointer or empty keyset \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gadca442c4ab43cf532b15091d7711559e}{ks\+Tail()} for the last \hyperlink{group__key}{Key} 

\hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}, \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} and \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} for iterating over the \hyperlink{group__keyset}{Key\+Set} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a2b8537e388edfbb6941d771106c0ae3a}\label{classkdb_1_1KeySet_a2b8537e388edfbb6941d771106c0ae3a}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!lookup@{lookup}}
\index{lookup@{lookup}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{lookup()}{lookup()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1Key}{Key} kdb\+::\+Key\+Set\+::lookup (\begin{DoxyParamCaption}\item[{const \hyperlink{classkdb_1_1Key}{Key} \&}]{key,  }\item[{const \hyperlink{group__keyset_gada05f4bbf46fde81d0d57df86e73d914}{elektra\+Lookup\+Flags}}]{options = {\ttfamily \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+NE}} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Look for a \hyperlink{classkdb_1_1Key}{Key} contained in {\ttfamily ks} that matches the name of the {\ttfamily key}. 

\begin{DoxyNote}{Note}
Applications should only use \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} with cascading keys (key name starting with {\ttfamily /}). Furthermore, a lookup should be done for every key (also when iterating over keys) so that the specifications are honored correctly. Keys of all namespaces need to be present so that \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} can work correctly, so make sure to also use \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} with a cascading key.
\end{DoxyNote}
{\ttfamily \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()}} is designed to let you work with a \hyperlink{classkdb_1_1KeySet}{Key\+Set} containing all keys of the application. The idea is to fully \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} the whole configuration of your application and process it all at once with many {\ttfamily \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()}}.

This function is efficient (at least using binary search). Together with \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} which can you load the whole configuration you can write very effective but short code for configuration\+:


\begin{DoxyCodeInclude}
Key * key = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"/sw/tests/myapp/#0/current/"},  \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
KDB * handle = \hyperlink{group__kdb_ga6808defe5870f328dd17910aacbdc6ca}{kdbOpen} (key);
\hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdbGet} (handle, myConfig, key);
Key * result = \hyperlink{group__keyset_gad65d2cdcbb5381194a1688e169af8a83}{ksLookupByName} (myConfig, \textcolor{stringliteral}{"/sw/tests/myapp/#0/current/testkey1"}, 0);
\end{DoxyCodeInclude}
 This is the way programs should get their configuration and search after the values. It is guaranteed that more namespaces can be added easily and that all values can be set by admin and user. Furthermore, using the kdb-\/tool, it is possible to introspect which values an application will get (by doing the same cascading lookup).

If found, {\ttfamily ks} internal cursor will be positioned in the matched key (also accessible by \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()}), and a pointer to the \hyperlink{classkdb_1_1Key}{Key} is returned. If not found, {\ttfamily ks} internal cursor will not move, and a N\+U\+LL pointer is returned.

Cascading lookups will by default search in all namespaces (proc\+:/, dir\+:/, user\+:/ and system\+:/), but will also correctly consider the specification (=metadata) in spec\+:/\+:


\begin{DoxyItemize}
\item {\ttfamily override/\#} will make sure that another key is considered before
\item {\ttfamily namespace/\#} will change the number and/or order in which the namespaces are searched
\item {\ttfamily fallback/\#} will search for other keys when the other possibilities up to now were not successful
\item {\ttfamily default} to return the given value when not even {\ttfamily fallback} keys were found.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
override and fallback work recursively, while default does not.
\end{DoxyNote}
This process is very flexible, but it would be boring to manually follow all this links to find out which key will be taken in the end. Use {\ttfamily kdb get -\/v} to trace the keys.

\begin{DoxyParagraph}{K\+D\+B\+\_\+\+O\+\_\+\+P\+OP}
When \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984}{K\+D\+B\+\_\+\+O\+\_\+\+P\+OP} is set the key which was found will be \hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ks\+Pop()}ed. \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} will not be changed, only iff \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} is the searched key, then the keyset will be \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}ed.
\end{DoxyParagraph}
\begin{DoxyNote}{Note}
Like in \hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ks\+Pop()} the popped key always needs to be \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} afterwards, even if it is appended to another keyset.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
All cursors on the keyset will be invalid iff you use \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984}{K\+D\+B\+\_\+\+O\+\_\+\+P\+OP}, so don\textquotesingle{}t use this if you rely on a cursor, see \hyperlink{group__keyset_gace0444eb8ec958a429794f8586fc72e7}{ks\+Get\+Cursor()}.
\end{DoxyWarning}
The invalidation of cursors does not matter if you use multiple keysets, e.\+g. by using \hyperlink{group__keyset_gac59e4b328245463f1451f68d5106151c}{ks\+Dup()}. E.\+g., to separate \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} with \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984}{K\+D\+B\+\_\+\+O\+\_\+\+P\+OP} and \hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}\+:


\begin{DoxyCodeInclude}
\textcolor{keywordtype}{void} f (KeySet * iterator, KeySet * lookup)
\{
        KeySet * append = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (\hyperlink{group__keyset_ga7474ad6b0a0fa969dbdf267ba5770eee}{ksGetSize} (lookup), \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
        Key * \hyperlink{classkdb_1_1KeySet_a0a0fc4efecd6dcbfde5fc35301b60349}{current};

        \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ksRewind} (iterator);
        \textcolor{keywordflow}{while} ((current = \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ksNext} (iterator)))
        \{
                Key * key = \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ksLookup} (lookup, current, \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984}{KDB\_O\_POP});
                \textcolor{comment}{// do something...}
                \hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey} (append, key); \textcolor{comment}{// now append it to append, not lookup!}
                \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (key);                \textcolor{comment}{// make sure to ALWAYS delete poped keys.}
        \}
        \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ksAppend} (lookup, append);
        \textcolor{comment}{// now lookup needs to be sorted only once, append never}
        \hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (append);
\}
\end{DoxyCodeInclude}
 This is also a nice example how a complete application with \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} can look like.

\begin{DoxyParagraph}{K\+D\+B\+\_\+\+O\+\_\+\+D\+EL}
Passing \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a66a5380c120f25f28f49848c4a863ead}{K\+D\+B\+\_\+\+O\+\_\+\+D\+EL} will cause the deletion of the parameter {\ttfamily key} using \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()}.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Hybrid search}
When Elektra is compiled with {\ttfamily E\+N\+A\+B\+L\+E\+\_\+\+O\+P\+T\+I\+M\+I\+Z\+A\+T\+I\+O\+NS=ON} a hybrid search decides dynamically between the binary search and the \href{https://master.libelektra.org/doc/dev/data-structures.md#order-preserving-minimal-perfect-hash-map-aka-opmphm}{\tt O\+P\+M\+P\+HM}. The hybrid search can be overruled by passing \hyperlink{kdbhelper_8h_a93673533c4c8eb1fdfca76b98c5f49b0afe9f6ff6e374540baf600a918b07ee6e}{K\+D\+B\+\_\+\+O\+\_\+\+O\+P\+M\+P\+HM} or \hyperlink{kdbhelper_8h_a93673533c4c8eb1fdfca76b98c5f49b0ac67a43bd273203575090d26010f6c995}{K\+D\+B\+\_\+\+O\+\_\+\+B\+I\+N\+S\+E\+A\+R\+CH} in the options to \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()}.
\end{DoxyParagraph}

\begin{DoxyParams}{Parameters}
{\em ks} & where to look for \\
\hline
{\em key} & the key object you are looking for \\
\hline
{\em options} & of type \hyperlink{group__keyset_gada05f4bbf46fde81d0d57df86e73d914}{elektra\+Lookup\+Flags} with some {\ttfamily K\+D\+B\+\_\+\+O\+\_\+$\ast$} option bits as explained above \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the \hyperlink{classkdb_1_1Key}{Key} found, 0 otherwise 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on N\+U\+LL pointers \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gad65d2cdcbb5381194a1688e169af8a83}{ks\+Lookup\+By\+Name()} to search by a name given by a string 

\hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()}, \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}, \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} for iterating over a \hyperlink{group__keyset}{Key\+Set}
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
That the internal key cursor will point to the found key 
\end{DoxyNote}
\mbox{\Hypertarget{classkdb_1_1KeySet_a0ef071747608900be478219e4a040612}\label{classkdb_1_1KeySet_a0ef071747608900be478219e4a040612}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!lookup@{lookup}}
\index{lookup@{lookup}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{lookup()}{lookup()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1Key}{Key} kdb\+::\+Key\+Set\+::lookup (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{name,  }\item[{const \hyperlink{group__keyset_gada05f4bbf46fde81d0d57df86e73d914}{elektra\+Lookup\+Flags}}]{options = {\ttfamily \hyperlink{group__keyset_ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370}{K\+D\+B\+\_\+\+O\+\_\+\+N\+O\+NE}} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Lookup a key by name. 


\begin{DoxyParams}{Parameters}
{\em name} & the name to look for \\
\hline
{\em options} & some options to pass\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the found key 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1KeySet_a2b8537e388edfbb6941d771106c0ae3a}{lookup} (const \hyperlink{classkdb_1_1Key}{Key} \&\hyperlink{group__key}{Key}, const \hyperlink{group__keyset_gada05f4bbf46fde81d0d57df86e73d914}{elektra\+Lookup\+Flags} options)
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
That the internal key cursor will point to the found key 
\end{DoxyNote}
\mbox{\Hypertarget{classkdb_1_1KeySet_affd52d130faf184361297f9e7f0c9f16}\label{classkdb_1_1KeySet_affd52d130faf184361297f9e7f0c9f16}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!next@{next}}
\index{next@{next}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{next()}{next()}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1Key}{Key} kdb\+::\+Key\+Set\+::next (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the next \hyperlink{classkdb_1_1Key}{Key} in a \hyperlink{classkdb_1_1KeySet}{Key\+Set}. 

Key\+Sets have an internal cursor that can be reset with \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}. Every time \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} is called the cursor is incremented and the new current \hyperlink{classkdb_1_1Key}{Key} is returned.

You\textquotesingle{}ll get a N\+U\+LL pointer if the key after the end of the \hyperlink{classkdb_1_1KeySet}{Key\+Set} was reached. On subsequent calls of \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} it will still return the N\+U\+LL pointer.

The {\ttfamily ks} internal cursor will be changed, so it is not const.

\begin{DoxyNote}{Note}
You must not delete or change the key, use \hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ks\+Pop()} if you want to delete it.

That applications must do \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} with an cascading key for every single key before using it, because specifications allow to hide or override keys.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em ks} & the keyset object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new current \hyperlink{classkdb_1_1Key}{Key} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & when the end is reached \\
\hline
{\em 0} & on N\+U\+LL pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}, \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} 

\hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} to honor specifications 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a1c54736b7206bc2253d02a5bf4b3ccfb}\label{classkdb_1_1KeySet_a1c54736b7206bc2253d02a5bf4b3ccfb}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!operator=@{operator=}}
\index{operator=@{operator=}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1KeySet}{Key\+Set} \& kdb\+::\+Key\+Set\+::operator= (\begin{DoxyParamCaption}\item[{\hyperlink{classkdb_1_1KeySet}{Key\+Set} const \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Duplicate a keyset. 

This keyset will be a duplicate of the other afterwards.

\begin{DoxyNote}{Note}
that they still reference to the same Keys, so if you change key values also the keys in the original keyset will be changed. 
\end{DoxyNote}
\mbox{\Hypertarget{classkdb_1_1KeySet_a7f207457a1c12633a1a5301a3a1bbaed}\label{classkdb_1_1KeySet_a7f207457a1c12633a1a5301a3a1bbaed}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!pop@{pop}}
\index{pop@{pop}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{pop()}{pop()}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1Key}{Key} kdb\+::\+Key\+Set\+::pop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Remove and return the last key of {\ttfamily ks}. 

The reference counter will be decremented by one.

The Key\+Sets cursor will not be affected if it did not point to the popped key.

\begin{DoxyNote}{Note}
You need to \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} the key afterwards, if you don\textquotesingle{}t append it to another keyset. It has the same semantics like a key allocated with \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} or \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()}.
\end{DoxyNote}

\begin{DoxyCode}
ks1=\hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew}(0, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
ks2=\hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew}(0, \hyperlink{group__keyset_ga7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});

k1=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user:/name"}, \hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}); \textcolor{comment}{// ref counter 0}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey}(ks1, k1); \textcolor{comment}{// ref counter 1}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey}(ks2, k1); \textcolor{comment}{// ref counter 2}

k1=\hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ksPop} (ks1); \textcolor{comment}{// ref counter 1}
k1=\hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ksPop} (ks2); \textcolor{comment}{// ref counter 0, like after keyNew()}

\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey}(ks1, k1); \textcolor{comment}{// ref counter 1}

\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (ks1); \textcolor{comment}{// key is deleted too}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (ks2);
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
the last key of {\ttfamily ks} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em N\+U\+LL} & if {\ttfamily ks} is empty or on N\+U\+LL pointer \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em ks} & \hyperlink{classkdb_1_1KeySet}{Key\+Set} to work with \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} to \hyperlink{classkdb_1_1KeySet_a7f207457a1c12633a1a5301a3a1bbaed}{pop} keys by name 

\hyperlink{group__keyset_gaba1f1dbea191f4d7e7eb3e4296ae7d5e}{ks\+Copy()} to \hyperlink{classkdb_1_1KeySet_a7f207457a1c12633a1a5301a3a1bbaed}{pop} all keys 

command\+List() for an example 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a5bc5a16a726e959adaf3cf8506e7b849}\label{classkdb_1_1KeySet_a5bc5a16a726e959adaf3cf8506e7b849}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!rewind@{rewind}}
\index{rewind@{rewind}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{rewind()}{rewind()}}
{\footnotesize\ttfamily void kdb\+::\+Key\+Set\+::rewind (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Rewinds the \hyperlink{classkdb_1_1KeySet}{Key\+Set} internal cursor. 

Use it to set the cursor to the beginning of the \hyperlink{classkdb_1_1KeySet}{Key\+Set}. \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} will then always return N\+U\+LL afterwards. So you want to \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} first.


\begin{DoxyCode}
\hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ksRewind} (ks);
\textcolor{keywordflow}{while} ((key = \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ksNext} (ks))!=0) \{\}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em ks} & the keyset object to work with \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & on success \\
\hline
{\em -\/1} & on N\+U\+LL pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()}, \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_aa36d35d8f12233a4c8f88d9bb13429c3}\label{classkdb_1_1KeySet_aa36d35d8f12233a4c8f88d9bb13429c3}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!set\+Cursor@{set\+Cursor}}
\index{set\+Cursor@{set\+Cursor}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{set\+Cursor()}{setCursor()}}
{\footnotesize\ttfamily void kdb\+::\+Key\+Set\+::set\+Cursor (\begin{DoxyParamCaption}\item[{elektra\+Cursor}]{cursor }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Set the \hyperlink{classkdb_1_1KeySet}{Key\+Set} internal cursor. 

Use it to set the cursor to a stored position. \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} will then return the key at the position of the supplied cursor.

\begin{DoxyWarning}{Warning}
Cursors may get invalid when the key was \hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ks\+Pop()}ed or \hyperlink{group__keyset_ga60f1ddcf23272f2b29b90e92ebe9b56f}{ks\+Lookup()} was used together with K\+D\+B\+\_\+\+O\+\_\+\+P\+OP.
\end{DoxyWarning}

\begin{DoxyCode}
elektraCursor cursor;
..
\textcolor{comment}{// key now in any position here}
cursor = \hyperlink{group__keyset_gace0444eb8ec958a429794f8586fc72e7}{ksGetCursor} (ks);
\textcolor{keywordflow}{while} ((key = \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{keyNextMeta} (ks))!=0) \{\}
\hyperlink{group__keyset_ga28b2a7d13c620b3c9d4815a0608c738f}{ksSetCursor} (ks, cursor); \textcolor{comment}{// reset state}
\hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ksCurrent}(ks); \textcolor{comment}{// in same position as before}
\end{DoxyCode}


An invalid cursor will set the keyset to its beginning like \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}. When you set an invalid cursor \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} is 0 and \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} == \hyperlink{group__keyset_gae7dbf3aef70e67b5328475eb3d1f92f5}{ks\+Head()}.


\begin{DoxyParams}{Parameters}
{\em cursor} & the cursor to use \\
\hline
{\em ks} & the keyset object to work with \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & when the keyset is \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}ed \\
\hline
{\em 1} & otherwise \\
\hline
{\em -\/1} & on N\+U\+LL pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()}, \hyperlink{group__keyset_gace0444eb8ec958a429794f8586fc72e7}{ks\+Get\+Cursor()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_a9f3ec4eebe304185527b08a6fa01b77c}\label{classkdb_1_1KeySet_a9f3ec4eebe304185527b08a6fa01b77c}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!set\+Key\+Set@{set\+Key\+Set}}
\index{set\+Key\+Set@{set\+Key\+Set}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{set\+Key\+Set()}{setKeySet()}}
{\footnotesize\ttfamily void kdb\+::\+Key\+Set\+::set\+Key\+Set (\begin{DoxyParamCaption}\item[{ckdb\+::\+Key\+Set $\ast$}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Take ownership of passed keyset. 


\begin{DoxyParams}{Parameters}
{\em k} & the keyset to take ownership from \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1KeySet_a2987b3fb1b12196399650726f1c18f02}{release()} 

\hyperlink{classkdb_1_1KeySet_a4e9a3906e0b18a783f8a6e8bdbec9ed0}{get\+Key\+Set()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classkdb_1_1KeySet_ab01c5c46e4c0802560b8f15886af89c4}\label{classkdb_1_1KeySet_ab01c5c46e4c0802560b8f15886af89c4}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!size@{size}}
\index{size@{size}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily ssize\+\_\+t kdb\+::\+Key\+Set\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



The size of the keyset. 

\begin{DoxyReturn}{Returns}
the number of keys in the keyset 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdb_1_1KeySet_a16deed50e0d8cfee023d4423a119df51}\label{classkdb_1_1KeySet_a16deed50e0d8cfee023d4423a119df51}} 
\index{kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}!tail@{tail}}
\index{tail@{tail}!kdb\+::\+Key\+Set@{kdb\+::\+Key\+Set}}
\subsubsection{\texorpdfstring{tail()}{tail()}}
{\footnotesize\ttfamily \hyperlink{classkdb_1_1Key}{Key} kdb\+::\+Key\+Set\+::tail (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the last key in the \hyperlink{classkdb_1_1KeySet}{Key\+Set}. 

\begin{DoxyReturn}{Returns}
alphabetical last key
\end{DoxyReturn}
The Key\+Sets cursor will not be affected.

If \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()}==\hyperlink{group__keyset_gadca442c4ab43cf532b15091d7711559e}{ks\+Tail()} you know you are on the last key. \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} will return a N\+U\+LL pointer afterwards.


\begin{DoxyParams}{Parameters}
{\em ks} & the keyset object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the last \hyperlink{classkdb_1_1Key}{Key} of a keyset 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on N\+U\+LL pointer or empty keyset \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gae7dbf3aef70e67b5328475eb3d1f92f5}{ks\+Head()} for the first \hyperlink{group__key}{Key} 

\hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}, \hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} and \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} for iterating over the \hyperlink{group__keyset}{Key\+Set} 
\end{DoxySeeAlso}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{keyset_8hpp}{keyset.\+hpp}\end{DoxyCompactItemize}
