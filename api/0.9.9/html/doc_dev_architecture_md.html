<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_dev_architecture"></a> In this document we start to explain the implementation of Elektra. There are several follow-up documents which explain all details of:</p>
<ul>
<li><a class="el" href="doc_dev_error-handling_md.html">error handling</a>,</li>
<li><a class="el" href="doc_dev_data-structures_md.html">data structures</a>, and</li>
<li>finally the <a class="el" href="doc_dev_algorithm_md.html">core algorithm</a>.</li>
</ul>
<p>We discuss problems and the solution space so that the reader can understand the rationale of how problems were solved.</p>
<p>To help readers to understand the algorithm that glues together the plugins, we first describe some details of the <a class="el" href="doc_dev_data-structures_md.html">data structures</a>. Full knowledge of the <a class="el" href="doc_dev_algorithm_md.html">algorithm</a> is not presumed to be able to develop most plugins (with the exception of the resolver).</p>
<p>Further important concepts are explained in:</p>
<ul>
<li><a class="el" href="doc_help_elektra-bootstrapping_md.html">bootstrapping</a></li>
<li><a class="el" href="doc_help_elektra-granularity_md.html">granularity</a></li>
<li><a class="el" href="doc_help_elektra-sync-flag_md.html">sync-flag</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2236"></a>
API</h1>
<p>The aim of the Elektra Initiative is to design and implement a powerful API for configuration. When the project started, we assumed that this goal was easy to achieve, but dealing with the semantics turned out to be a difficult problem. For the implementation, an ambitious solution is required because of the necessary modularity to implement flexible backends as introduced in Elektra. But also the design of a good API has proved to be much more difficult than expected.</p>
<h2><a class="anchor" id="autotoc_md2237"></a>
Changes in the APIs</h2>
<p>From Elektra 0.7 to Elektra 0.8, we changed the API of Elektra as little as possible. It should be mentioned that <code>KeySet</code> is now always sorted by name. The function <code>ksSort()</code> is now depreciated and was removed. The handling of removed keys was modified. Additionally, the API for metadata has fundamentally changed, but the old interface still works. These changes will be described in <a class="el" href="doc_dev_metadata_md.html">implementation of metadata</a>. However, the implementation of Elektra changed radically as discussed in <a class="el" href="doc_dev_algorithm_md.html">algorithm</a>.</p>
<h2><a class="anchor" id="autotoc_md2238"></a>
API Design</h2>
<p>API Design presents a critical craft every programmer should be aware of. We will shortly present some of the main design issues that matter and show how Elektra has solved them.</p>
<p>A design goal is to detect errors early. As easy as it sounds, as difficult it is to actually achieve this goal. Elektra tries to avoid the problem by checking data being inserted into <code>Key</code> and <code>KeySet</code>. Elektra catches many errors like invalid key names soon. Elektra allows plugins to check the configuration before it is written into the key database so that problematic values are never stored.</p>
<p>"Hard to use it wrong" tends to be a more important design objective than "Easy to use it right". Searching for a stupid bug costs more time than falling into some standard traps which are explained in documentation. In Elektra, the data structures are robust and some efforts were taken to make misuse unlikely.</p>
<p>Another fundamental principle is that the API must hide implementation details and should not be optimized towards speed. In Elektra, the actual process of making configuration permanent is completely hidden.</p>
<p>"Off-by-one confusion" is a topic of its own. The best is to stick to the conventions the programming language gives. For returning sizes of strings, it must be clear whether a terminating &lsquo;&rsquo;\0'` is included or not. All such decisions must be consistent. In Elektra the terminating null is always included in the size.</p>
<p>The interface must be as small as possible to tackle problems addressed by the library. Internal and external APIs must be separated. Internal APIs in libraries shall be declared as <code>static</code> to prevent its export. In Elektra, internal names start with <code>elektra</code> opposed to the external names starting with <code>key</code>, <code>ks</code> or <code>kdb</code>.</p>
<p>Elektra always passes user context pointers, but never passes or receives a full data structure by value. It is impossible to be ABI compatible otherwise. Elektra is restrictive in what it returns (strong postconditions), but as liberal as possible for what comes in (preconditions are avoided where possible). In Elektra even null pointers are accepted for any argument.</p>
<p>"Free everything you allocate" is a difficult topic in some cases. If Elektra cannot free space or other resources after every call, it provides a <code>close()</code> function. Everything will be freed. The tool <b>Valgrind</b> with <b>Memcheck</b> helps us locate problems. The whole test suite runs without any memory problems. The user is responsible for deleting all created <code>Key</code> and <code>KeySet</code> objects and closing the <code>KDB</code> handle.</p>
<p>As a final statement, we note that the Unix philosophy should always be considered: "Do only one thing, but do it in the best way. Write it
that way that programs work together well."</p>
<h1><a class="anchor" id="autotoc_md2239"></a>
Modules</h1>
<p>Elektraâ€™s core can be compiled with a C compiler conforming to the ISO/IEC 9899:1999 standard:</p>
<ul>
<li>One line comments,</li>
<li>inline functions,</li>
<li><code>snprintf()</code></li>
<li>inttypes.h and</li>
<li>variable declaration at any place</li>
</ul>
<p>are used in addition to what is already defined in the standard ISO/IEC 9899:1990, called <b>C99</b> in the following text. Functions not conforming to C99 are considered to be not portable enough for Elektra and are separated into plugins. But there is one notable exception: it must be the core's task to load plugins. Unfortunately, C99 does not know anything about modules. <b>POSIX</b> (Portable Operating System Interface) provides <code>dlopen()</code>, but other operating systems have dissimilar APIs for that purpose. They sometimes behave differently, use other names for the libraries and have incompatible error reporting systems. Because of these requirements Elektra provides a small internal API to load such modules independently from the operating system. This API also hides the fact that modules must be loaded dynamically if they are not available statically.</p>
<p>Plugins are usually realized with modules. Modules and libraries are technically the same in most systems. (One exception is macOS.) After the module is loaded, the special function plugin factory is searched for. This function returns a new plugin. With the plugin factory the actual plugins are created.</p>
<h2><a class="anchor" id="autotoc_md2240"></a>
Static Loading</h2>
<p>For the static loading of modules, the modules must be built-in. With <code>dlopen(const char* file)</code> POSIX provides a solution to look up such symbols by passing a null pointer for the parameter <code>file</code>. Non-POSIX operating systems may not support this kind of static loading. Therefore, Elektra provides a C99 conforming solution for that problem: a data structure stores the pointers to the plugin factory of every plugin. The build system generates the source file of this data structure because it depends on built-in plugins.</p>
<p>Elektra distinguishes internally between modules and plugins. Several plugins can be created out of a single module. During the creation process of the plugin, dynamic information - like the configuration or the data handle - is added.</p>
<h2><a class="anchor" id="autotoc_md2241"></a>
API</h2>
<p>The API of <b>libloader</b> consists of the following functions:</p>
<p>Interface of Module System:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> elektraModulesInit (KeySet *modules, Key *error);</div>
<div class="line">elektraPluginFactory elektraModulesLoad (KeySet *modules,</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">char</span> *name, Key *error);</div>
<div class="line"><span class="keywordtype">int</span> elektraModulesClose (KeySet *modules, Key *error);</div>
</div><!-- fragment --><p><code>elektraModulesInit()</code> initializes the module cache and calls necessary operating system facilities if needed. <code>elektraModulesLoad()</code> does the main work by either returning a pointer to the plugin factory from cache or loading it from the operating system. The plugin factory creates plugins that do not have references to the module anymore. <code>elektraModulesClose()</code> cleans up the cache and finalises all connections with the operating system.</p>
<p>Not every plugin is loaded by <code>libloader</code>. For example, the <em>version plugin</em>, which exports version information, is implemented internally.</p>
<h1><a class="anchor" id="autotoc_md2242"></a>
Mount Point Configuration</h1>
<p><code>kdb mount</code> creates a <b>mount point configuration</b> as shown in the example below. <code>fstab</code> is a unique name within the mount point configuration provided by the administrator.</p>
<p>Example for a mount point configuration:</p>
<div class="fragment"><div class="line">system:/elektra/mountpoints</div>
<div class="line">system:/elektra/mountpoints/fstab</div>
<div class="line">system:/elektra/mountpoints/fstab/config</div>
<div class="line">system:/elektra/mountpoints/fstab/config/path=fstab</div>
<div class="line">system:/elektra/mountpoints/fstab/config/struct=list FStab</div>
<div class="line">system:/elektra/mountpoints/fstab/config/struct/FStab</div>
<div class="line">system:/elektra/mountpoints/fstab/config/struct/FStab/device</div>
<div class="line">system:/elektra/mountpoints/fstab/config/struct/FStab/dumpfreq</div>
<div class="line">system:/elektra/mountpoints/fstab/config/struct/FStab/mpoint</div>
<div class="line">system:/elektra/mountpoints/fstab/config/struct/FStab/options</div>
<div class="line">system:/elektra/mountpoints/fstab/config/struct/FStab/passno</div>
<div class="line">system:/elektra/mountpoints/fstab/config/struct/FStab/type</div>
<div class="line">system:/elektra/mountpoints/fstab/errorplugins</div>
<div class="line">system:/elektra/mountpoints/fstab/errorplugins/#5#resolver#resolver#</div>
<div class="line">system:/elektra/mountpoints/fstab/getplugins</div>
<div class="line">system:/elektra/mountpoints/fstab/getplugins/#0#resolver</div>
<div class="line">system:/elektra/mountpoints/fstab/getplugins/#5#fstab#fstab#</div>
<div class="line">system:/elektra/mountpoints/fstab/mountpoint /fstab</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins/#0#resolver</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins/#1#struct#struct#</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins/#2#type#type#</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins/#3#path#path#</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins/#3#path#path#/config</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins/#3#path#path#/config/path/allow=proc tmpfs none</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins/#5#fstab</div>
<div class="line">system:/elektra/mountpoints/fstab/setplugins/#7#resolver</div>
</div><!-- fragment --><p>Let us look at the subkeys below the key <code>system:/elektra/mountpoints/fstab</code>:</p>
<ul>
<li><b>config</b>: Everything below <code>config</code> is the system's configuration of the backend. Every plugin within the backend will find this configuration directly below <code>system</code> in its <b>plugin configuration</b>. For example,</li>
</ul>
<div class="fragment"><div class="line">system:/elektra/mountpoints/fstab/config/struct/FStab/mpoint</div>
</div><!-- fragment --><p>will be translated to</p>
<div class="fragment"><div class="line">system:/struct/FStab/mpoint</div>
</div><!-- fragment --><p>and inserted into the plugin configuration for all plugins in the <code>fstab</code> backend.</p>
<p>It is the place where configuration can be provided for every plugin of a backend. The contract checker deduces this configuration to satisfy the contract for a plugin. Fstab, for example, claims in a contract that it needs "struct". But the struct plugin needs a configuration to work properly. Fstab will provide this configuration. The <b>contract checker</b> writes out the configuration looking like the one in this example.</p>
<ul>
<li><b>config/path</b>: is a common setting needed by the resolver plugin. It is the relative path to a filename that is used by this backend. On Unix systems, the resolver would determine the name <code>/etc/fstab</code> for system configuration.</li>
<li><b>mount point</b>: is a key that represents the mount point. Its value is the location where the backend is mounted. If a mount point has an entry for both the user and the system hierarchy, it is called <b>cascading mount point</b>. A cascading mount point differs from two separate mount points because internally only one backend is created. In the example, the mount point <code>/fstab</code> means that the backend handles both <code>user:/fstab</code> and <code>system:/fstab</code>. If the mount point is <code>/</code>, the backend will be mounted to all namespaces except <code>spec</code>, including both <code>user</code> and <code>system</code>.</li>
<li><b>errorplugins</b>: presents a list of all plugins to be executed in the error case of <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> which will be explained in <b>error situation</b>.</li>
<li><b>getplugins</b>: is a list of all plugins used when reading the configuration from the key database. They are executed in <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code>.</li>
<li><b>setplugins</b>: contains a list of all plugins used when storing configuration. They are executed in <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>.</li>
</ul>
<p>Each of the plugins inside the three lists may have the subkey <code>config</code>. The configuration below this subkey provides plugin specific configuration. This configuration appears in the user's configuration of the plugin. Configuration is renamed properly. For example, the key</p>
<div class="fragment"><div class="line">system:/elektra/mountpoints/fstab/setplugins/#3#path#path#/config/path/allow</div>
</div><!-- fragment --><p>is transformed to</p>
<div class="fragment"><div class="line">user:/path/allow</div>
</div><!-- fragment --><p>and appears in the plugin configuration of the path plugin inside the fstab backend.</p>
<h2><a class="anchor" id="autotoc_md2243"></a>
Referencing</h2>
<p>The same plugin often must occur in more than one place within a backend. The most common use case is a plugin that has to be executed for both <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> and <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>. It must be the same plugin if it preserves state between the executions.</p>
<p>Other plugins additionally have to handle error or success situations. One example of exceptional intensive use is the resolver plugin. It is executed twice in <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>. In <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> it is also used as shown above.</p>
<ul>
<li><code>#n&lt;name&gt;</code>: introduces a new plugin from the module <code>name</code> which cannot be referenced later. The cypher <code>n</code> appoints the actual placement of the plugin.</li>
<li><code>#n#&lt;name&gt;#&lt;label&gt;#</code>: also introduces a new plugin from the module <code>name</code> and gives it the name <code>label</code>. The last <code>#</code> shows that a new name is being introduced.</li>
<li><code>#n#&lt;ref&gt;</code>: references back to a label which was introduced before. This configuration does not create a new plugin.</li>
</ul>
<p><code>kdb mount</code> implements the generation of these names as described above.</p>
<h2><a class="anchor" id="autotoc_md2244"></a>
Changing Mount Point Configuration</h2>
<p>When the user changes the mount point configuration, without countermeasures, applications already started will continue to run with the old configuration. This could lead to a problem if backends in use are changed or removed. It is necessary to restart all such programs. Notification is the best way to deal with the situation. Changes of the mount point configuration, however, do not occur often. For some systems, the manual restart may also be appropriate.</p>
<p>In this situation, applications can receive warning or error information if the configuration files are moved or removed. The most adverse situation occurs if the sequence of locking multiple files produces a <em>dead lock</em>. Under normal circumstances, the sequence of locking the files is deterministic, so either all locks can be requested or another program will be served first. But several programs with different mountpoint configurations running at the same time can cause a disaster. The problem gets even worse, because <code>kdb mount</code> is unable to detect such situations. Every specific mount point configuration for itself is trouble-free.</p>
<p>But still a dead lock can arise when multiple programs run with different mountpoint configurations. Suppose we have a program <code>A</code> which uses the backends <code>B1</code> and <code>B2</code> that requests locks for the files <code>F1</code> and <code>F2</code>. Then the mount point configuration is changed. The user removes <code>B1</code> and introduces <code>B3</code>. <code>B3</code> is in a different path mounted after <code>B2</code>, but also accesses the same file <code>F1</code>. The program <code>B</code> starts after the mount point configuration is changed. So it uses the backends <code>B2</code> and <code>B3</code>. If the scheduler decides that first <code>A</code> and then <code>B</code> both successfully lock the files <code>F1</code> and <code>F2</code>, a dead lock situation happens because in the afterwards the applications <code>A</code> and <code>B</code> try to lock <code>F2</code> and <code>F1</code>.</p>
<p>A manual solution for this problem is to enable <code>kdb</code> to output a list of processes that still use old mount point configuration. The administrator can restart these processes. The preferred solution is to use notification for mount point configuration changes or simply to use a lock-free resolver.</p>
<p>Continue reading <a class="el" href="doc_dev_data-structures_md.html">with the data structures</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
