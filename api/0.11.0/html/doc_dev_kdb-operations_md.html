<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: KDB Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
$darkmode
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Add mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_color_doxygen.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Elektra<span id="projectnumber">&#160;0.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">KDB Operations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_dev_kdb_operations"></a> There are four main <em>operations</em> in <code>libelektra-kdb</code>: <code>open</code>, <code>get</code>, <code>set</code> and <code>close</code>. For each of these there is a <code>kdb*</code> function the user calls to trigger the operation and plugins export a function for each of the operations they support (at least <code>get</code>).</p>
<p>Additionally, plugins may implement <code>commit</code> and <code>error</code>. These are part of the <code>set</code> operation and there is no corresponding <code>kdbCommit</code> or <code>kdbError</code> function available in <code>libelektra-kdb</code>.</p>
<p>The operations <code>get</code> and <code>set</code> also have different <em>phases</em>:</p>
<ul>
<li>The <code>get</code> operation has: <code>init</code>, <code>resolver</code>, <code>cachecheck</code>, <code>prestorage</code>, <code>storage</code> and <code>poststorage</code>.</li>
<li>The <code>set</code> operation has: <code>resolver</code>, <code>prestorage</code>, <code>storage</code> and <code>poststorage</code> followed by <code>precommit</code>, <code>commit</code> and <code>postcommit</code> if the previous phases where successful or by <code>prerollback</code>, <code>rollback</code> and <code>postrollback</code> if the previous phases failed.</li>
</ul>
<p>These phases are implemented by a backend plugin. Read the Documentation on Backend Plugins for more information on what backend plugins do.</p>
<blockquote class="doxtable">
<p><b>Note</b> The steps of the operations described below, are referenced in the source code with <code>// Step X</code> comments. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md2697"></a>
&lt;tt&gt;open&lt;/tt&gt; Operation</h1>
<p>The <code>open</code> operation implemented in <code>kdbOpen</code> is the first thing that happens to all <code>KDB</code> instances.</p>
<p>The basic flow of this operation is:</p>
<ol type="1">
<li>Create empty <code>KDB</code> instance</li>
<li>Configure <code>KDB</code> instance for bootstrap</li>
<li>Run bootstrap <code>get</code> operation: This loads the contents of <code>system:/elektra/mountpoints</code> so that the mountpoints can be configured.</li>
<li>Process contract and set up plugins for hooks (see <a class="el" href="doc_dev_hooks_md.html">Hooks</a>)</li>
<li>Parse mountpoints: This transforms the contents of <code>system:/elektra/mountpoints</code> into the internal state stored in a <code>KDB</code> instance.</li>
<li>Reconfigure <code>KDB</code> with real mountpoints: This switches the <code>KDB</code> instance from bootstrap mode to use the real mountpoint state created above.</li>
<li>Add hard coded mountpoints to <code>KDB</code> instance: There are a few hard coded mountpoints (root mountpoints, <code>system:/elektra/modules</code>, <code>system:/elektra/version</code>, etc.) that are always present. They are added in this step.</li>
</ol>
<p>Namespaces in mountpoint configs:</p>
<ul>
<li><code>dir:/</code>, <code>user:/</code> and <code>system:/</code> mountpoints can be created without restrictions, except for the reserved sections listed below.</li>
<li><code>spec:/</code> mountpoints can be created with the same restrictions, but they are also treated specially during <code>get</code> and <code>set</code>.</li>
<li><code>proc:/</code> mountpoints are always read-only and receive special treatment during <code>get</code></li>
<li><code>default:/</code> mountpoints are read-only and receive special treatment during <code>get</code>, specifically they only go through the <code>poststorage</code> phase</li>
<li>mountpoints in all other namespaces are entirely illegal</li>
</ul>
<blockquote class="doxtable">
<p><b>Note</b> The special treatments of the various namespaces are explained below in the sections for the <code>get</code> and <code>set</code> operation. </p>
</blockquote>
<p>Reserved sections:</p>
<ul>
<li>Creating a mountpoint for <code>/elektra</code> or below in <em>any namespace</em> is forbidden. This section of the KDB is reserved for Elektra's own config.</li>
<li><code>system:/elektra/mountpoints</code>, <code>user:/elektra/mountpoints</code> and <code>dir:/elektra/mountpoints</code> are all required for the bootstrap process and use a hard coded backend. The backends are implemented by a standard file-based backend plugin that is defined at compile-time of <code>libelektra-kdb</code>.</li>
<li><code>system:/elektra/version</code> and <code>system:/elektra/modules</code> will always use hard coded read-only backends containing information about this Elektra installation. The backends are implemented by special purpose backend plugins.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2698"></a>
&lt;tt&gt;get&lt;/tt&gt; Operation</h1>
<p>The purpose of the <code>get</code> operation is to read data stored in backends into a <code>KDB</code> instance.</p>
<blockquote class="doxtable">
<p><b>Note:</b> Some details of a <code>get</code> operation are defined in the contract with backend plugins. </p>
</blockquote>
<p>Properties of <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from the Key database in an atomic and universal way.">kdbGet()</a></code>:</p>
<ul>
<li>After calling <code>kdbGet (kdb, ks, parentKey)</code>, the KeySet <code>ks</code> will contain <em>all keys</em> (including their values) that are stored in <em>any backend</em> with a mountpoint that is <em>below <code>parentKey</code></em>.</li>
<li>After calling <code>kdbGet (kdb, ks, parentKey)</code>, below <code>parentKey</code> the KeySet <code>ks</code> will <em>mostly</em> contain keys that are stored in a backend. The exception here are <code>proc:/</code> and <code>spec:/</code> keys. For other namespaces, all keys below <code>parentKey</code> will be removed from <code>ks</code>. For <code>proc:/</code> and <code>spec:/</code> only keys that overlap with a backend that was loaded will be removed from <code>ks</code>.</li>
<li>The KeySet <code>ks</code> <em>may</em> contain other keys not below <code>parentKey</code>:<ol type="1">
<li>Keys that are not below <code>parentKey</code>, but are stored in a backend that contains other keys which are below <code>parentKey</code>. These keys are returned, because backends are treated as one atomic unit. Either all keys within a backend are read, or none of them are.</li>
<li>Keys that were already present in <code>ks</code> when <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from the Key database in an atomic and universal way.">kdbGet()</a></code> was called and do not conflict with the goal of representing the current state of the KDB below <code>parentKey</code>.</li>
</ol>
</li>
<li>After calling <code>kdbGet (kdb, ks, parentKey)</code>, the Key <code>parentKey</code> will only have the <code>meta:/error/*</code> or <code>meta:/warnings/#/*</code> metakeys, if the errors/warnings originate from this <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from the Key database in an atomic and universal way.">kdbGet()</a></code> call. In other words, <code>kdbGet ()</code> first clears any existing errors/warnings and only then starts doing the actual work.</li>
<li>It is an error to use a <code>parentKey</code> with a namespace other than: <code>default:/</code>, <code>proc:/</code>, <code>spec:</code>, <code>dir:/</code>, <code>user:/</code>, <code>system:/</code> or cascading</li>
</ul>
<p>To the caller it looks as if <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from the Key database in an atomic and universal way.">kdbGet()</a></code> had removed all keys below <code>parentKey</code>, as well as some others, from <code>ks</code> and then loaded the data from the backends. Which backends are actually read is an implementation detail. Which keys are removed from <code>ks</code> depends on the backends that are read.</p>
<p><code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from the Key database in an atomic and universal way.">kdbGet()</a></code> will always try to be efficient in achieving its goal of reading the keys below <code>parentKey</code>. It is only guaranteed that below <code>parentKey</code> the KeySet <code>ks</code> correctly represents the state of the KDB. For the rest of <code>ks</code> there are no such guarantees.</p>
<blockquote class="doxtable">
<p><b>Note:</b> In the list below "phase" always refers to a phase of the <code>get</code> operation as described in <a class="el" href="doc_dev_backend-plugins_md.html">the backend plugin contract</a>. </p>
</blockquote>
<p>The flow of this operation is:</p>
<ol type="1">
<li>Determine the backends needed to read all keys below <code>parentKey</code></li>
<li>Run the <code>open</code> operation for all required backends that haven't been opened</li>
<li>Run the <code>init</code> phase on all the backends that haven't been initialized</li>
<li>Run the <code>resolver</code> phase on all backends</li>
<li>From now on ignore all backends, which indicated that there is no update.</li>
<li>If all backends are now ignored, <b>return</b>.</li>
<li>If a global cache plugin is enabled: Ask the global cache plugin for the cache handles (normally modification times) for all backends.</li>
<li>If all backends have an existing cache entry: Run the <code>cachecheck</code> phase on all backends</li>
<li>If all backends indicated the cache is still valid: Ask the global cache plugin for the cached data and <b>return</b>.</li>
<li>Run the <code>prestorage</code> and <code>storage</code> phase on all backends.</li>
<li>Run the <code>poststorage</code> phase of all <code>spec:/</code> backends.</li>
<li>Merge the data from all backends</li>
<li>If enabled, run the <code>gopts/get</code> hook.</li>
<li>Run the <code>spec/copy</code> hook.</li>
<li>Split data back into individual backends.</li>
<li>Run the <code>poststorage</code> phase for all non-<code>spec:/</code> backends.</li>
<li>Remove all keys which are below the parent key of any backend that has been read from <code>ks</code>.</li>
<li>Merge the data from all backends into <code>ks</code>.</li>
<li>If a global cache plugin is enabled, update cache.</li>
<li>Run the <code>notification/send</code> hook. Then <b>return</b>.</li>
</ol>
<blockquote class="doxtable">
<p><b>Note:</b> In case of error, we abort immediately, restore <code>ks</code> to its original state and return. </p>
</blockquote>
<p>Influence of namespaces:</p>
<ul>
<li><code>spec:/</code> backends go through <code>init</code>, <code>resolver</code>, <code>cache</code>, <code>presetstorage</code> and <code>storage</code> phases as normal, but their <code>poststorage</code> phase is called earlier. This is required, because any validation and post-processing of <code>spec:/</code> keys needs to happen, before they are used as the specification for other keys in the actual <code>poststorage</code> phase.</li>
<li><code>dir:/</code>, <code>user:/</code> and <code>system:/</code> go through all phases as described above.</li>
<li><code>proc:/</code> mountpoints go through all the phases as described above, but they are not stored in the cache.</li>
<li><code>default:/</code> backends only go through the <code>poststorage</code> phase. This is because <code>default:/</code> keys are generated from the specification (stored as <code>spec:/</code> keys). Therefore, no <code>default:/</code> keys can exist before the specification is processed by the <code>spec/copy</code> hook.</li>
<li>keys with other namespaces are always illegal in <code>ks</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md2699"></a>
&lt;tt&gt;set&lt;/tt&gt; Operation</h1>
<p>The purpose of the <code>set</code> operation is to write data from a <code>KDB</code> instance into backends.</p>
<blockquote class="doxtable">
<p><b>Note:</b> Some details of a <code>set</code> operation are defined in the contract with backend plugins. </p>
</blockquote>
<p>Properties of <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to the Key database in an atomic and universal way.">kdbSet()</a></code>:</p>
<ul>
<li>When calling <code>kdbSet (kdb, ks, parentKey)</code> the contents (key names, values and metadata) of <code>ks</code> will <em>mostly</em> not be modified. The only modifications that are made to <code>ks</code> are those that originate from the <code>spec/copy</code> hook.</li>
<li><em>All keys</em> in <code>ks</code> that are below <code>parentKey</code> will be persisted in the KDB, when a <code>kdbSet (kdb, ks, parentKey)</code> call returns successfully. Additionally, any key in <code>ks</code> that shares a backend with another key which is below <code>parentKey</code> will also be persisted.</li>
<li>Calling <code>kdbSet</code> may result in an error, if <code>kdbGet</code> wasn't called on this <code>KDB</code> instance with the same <code>parentKey</code> at least once.</li>
<li>After calling <code>kdbSet (kdb, ks, parentKey)</code>, the Key <code>parentKey</code> will only have the <code>meta:/error/*</code> or <code>meta:/warnings/#/*</code> metakeys, if the errors/warnings originate from this <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to the Key database in an atomic and universal way.">kdbSet()</a></code> call. In other words, <code>kdbSet ()</code> first clears any existing errors/warnings and only then starts doing the actual work.</li>
<li>It is an error to use a <code>parentKey</code> with a namespace other than: <code>default:/</code>, <code>proc:/</code>, <code>spec:</code>, <code>dir:/</code>, <code>user:/</code>, <code>system:/</code> or cascading</li>
</ul>
<p>The flow of this operation is:</p>
<ol type="1">
<li>Determine the backends needed to write all keys below <code>parentKey</code>.</li>
<li>Check that all backends are opened and initialized (i.e. <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from the Key database in an atomic and universal way.">kdbGet()</a></code> was called).</li>
<li>Run the <code>spec/copy</code> hook on <code>ks</code> (to add metakeys to newly created keys).</li>
<li>Deep-Copy <code>ks</code> (below <code>parentKey</code>) into a new KeySet <code>set_ks</code></li>
<li>Split <code>set_ks</code> into individual backends</li>
<li>Determine which backends contain changed data. Any backend that contains a key that needs sync (via <code>KEY_FLAG_SYNC</code>) could contain changed data. From now on ignore all backends that have not changed. From now on also ignore all backends that were initialized as read-only. Issue a warning, if a change was detected (via <code>KEY_FLAG_SYNC</code>) in a read-only backend. <blockquote class="doxtable">
<p><b>Note</b>: Steps 4-6 might be combined into a single procedure that deep-copies only keys from changed backends into separate KeySets per backend </p>
</blockquote>
7. Run the <code>resolver</code> and <code>prestorage</code> on all backends (abort immediately on error and go to e).</li>
<li>Merge the results into a new version of <code>set_ks</code>.</li>
<li>Run the <code>spec/remove</code> hook on <code>set_ks</code> (to remove copied metakeys).</li>
<li>Split <code>set_ks</code> into individual backends again.</li>
<li>Run the <code>storage</code> and <code>poststorage</code> phases on all backends (abort immediately on error and go to e).</li>
<li>If everything was successful: Run the <code>precommit</code> and <code>commit</code> phases on all backends (abort immediately on error and go to e), then run the <code>postcommit</code> phase on all backends (record all errors as warnings and ignore them) and <b>return</b>.</li>
</ol>
<ol type="a" start="5">
<li>
If there was an error: Run the <code>prerollback</code>, <code>rollback</code> and <code>postrollback</code> phases on all backends and <b>return</b>.  </li>
</ol>
<p>Influence of namespaces:</p>
<ul>
<li><code>default:/</code> and <code>proc:/</code> keys are completely ignored by <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to the Key database in an atomic and universal way.">kdbSet()</a></code></li>
<li><code>spec:/</code>, <code>dir:/</code>, <code>user:/</code> and <code>system:/</code> go through all phases as described above.</li>
<li>keys with other namespaces are always illegal in <code>ks</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md2700"></a>
&lt;tt&gt;close&lt;/tt&gt; Operation</h1>
<p>The <code>close</code> operation is very simple. It simply frees up all resources used by a <code>KDB</code> instance. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark'
  });
</script>
</body>
</html>
