<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Elektra: Split :: Represents splitted keysets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Split :: Represents splitted keysets</h1>  </div>
</div>
<div class="contents">

<p>used internally for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a>  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#gad2245a38809f28e325cd9b32089b4c68">elektraSplitNew</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#gae569ef1bc4cd8e931b4a7840d8ce48e6">elektraSplitDel</a> (<a class="el" href="struct__Split.html">Split</a> *keysets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#ga9816931521a6a16bd553c08abb957c62">elektraSplitResize</a> (<a class="el" href="struct__Split.html">Split</a> *split)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#ga0c8c5c6c26aa42404d8aa06e6476a0f6">elektraSplitAppend</a> (<a class="el" href="struct__Split.html">Split</a> *split, <a class="el" href="struct__Backend.html">Backend</a> *backend, <a class="el" href="struct__Key.html">Key</a> *parentKey, int syncbits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#ga887dd183bf21c635c6993cd480ff3b21">elektraSplitSearchBackend</a> (<a class="el" href="struct__Split.html">Split</a> *split, <a class="el" href="struct__Backend.html">Backend</a> *backend, <a class="el" href="struct__Key.html">Key</a> *parent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#gafb25e1f946f07e5490a962a42320a0cc">elektraSplitSearchRoot</a> (<a class="el" href="struct__Split.html">Split</a> *split, <a class="el" href="struct__Key.html">Key</a> *parentKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#gaabebbc4b0e47527f59942fcf95b9fcb5">elektraSplitBuildup</a> (<a class="el" href="struct__Split.html">Split</a> *split, <a class="el" href="struct__KDB.html">KDB</a> *kdb, <a class="el" href="struct__Key.html">Key</a> *parentKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#ga447e430a045cef7b107762171fbdc104">elektraSplitDivide</a> (<a class="el" href="struct__Split.html">Split</a> *split, <a class="el" href="struct__KDB.html">KDB</a> *handle, <a class="el" href="struct__KeySet.html">KeySet</a> *ks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#gafee68d5935a6875ece69945e32242895">elektraSplitAppoint</a> (<a class="el" href="struct__Split.html">Split</a> *split, <a class="el" href="struct__KDB.html">KDB</a> *handle, <a class="el" href="struct__KeySet.html">KeySet</a> *ks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#ga311af3d964c45fc273dc1db5b5944895">elektraSplitGet</a> (<a class="el" href="struct__Split.html">Split</a> *split, <a class="el" href="struct__KDB.html">KDB</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#gaf3b1e5f1810964dddc3bd3a00822bca6">elektraSplitMerge</a> (<a class="el" href="struct__Split.html">Split</a> *split, <a class="el" href="struct__KeySet.html">KeySet</a> *dest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#ga3176eff9c1b5a9bfcf3d2e648f537993">elektraSplitSync</a> (<a class="el" href="struct__Split.html">Split</a> *split)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__split.html#ga24cf74dcf95614923099bbccab3dd2c8">elektraSplitPrepare</a> (<a class="el" href="struct__Split.html">Split</a> *split)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>used internally for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> </p>
<p>Splits up a keyset into multiple keysets where each of them will passed to the correct <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0c8c5c6c26aa42404d8aa06e6476a0f6"></a><!-- doxytag: member="split.c::elektraSplitAppend" ref="ga0c8c5c6c26aa42404d8aa06e6476a0f6" args="(Split *split, Backend *backend, Key *parentKey, int syncbits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t elektraSplitAppend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Backend.html">Backend</a> *&nbsp;</td>
          <td class="paramname"> <em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>parentKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>syncbits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increases the size of split and appends a new empty keyset.</p>
<p>Initializes the element with the given parameters at size-1 to be used.</p>
<p>Will automatically resize split if needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>backend</em>&nbsp;</td><td>the backend which should be appended </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentKey</em>&nbsp;</td><td>the parentKey which should be appended </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>syncbits</em>&nbsp;</td><td>the initial syncstate which should be appended</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>if no split is found </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of split - 1 </dd></dl>

</div>
</div>
<a class="anchor" id="gafee68d5935a6875ece69945e32242895"></a><!-- doxytag: member="split.c::elektraSplitAppoint" ref="gafee68d5935a6875ece69945e32242895" args="(Split *split, KDB *handle, KeySet *ks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitAppoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KDB.html">KDB</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KeySet.html">KeySet</a> *&nbsp;</td>
          <td class="paramname"> <em>ks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appoints all keys from ks to yet unsynced splits.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__split.html#gaabebbc4b0e47527f59942fcf95b9fcb5">elektraSplitBuildup()</a> need to be executed before.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>to determine to which backend a key belongs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ks</em>&nbsp;</td><td>the keyset to appoint to split</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success </dd>
<dd>
-1 if no backend was found for a key </dd></dl>

</div>
</div>
<a class="anchor" id="gaabebbc4b0e47527f59942fcf95b9fcb5"></a><!-- doxytag: member="split.c::elektraSplitBuildup" ref="gaabebbc4b0e47527f59942fcf95b9fcb5" args="(Split *split, KDB *kdb, Key *parentKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitBuildup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KDB.html">KDB</a> *&nbsp;</td>
          <td class="paramname"> <em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>parentKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Walks through the trie and adds all backends below parentKey.</p>
<p>Sets syncbits to 2 if it is a default or root backend (which needs splitting).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>split needs to be empty, directly after creation with <a class="el" href="group__split.html#gad2245a38809f28e325cd9b32089b4c68">elektraSplitNew()</a>.</dd>
<dd>
there needs to be a valid defaultBackend but its ok not to have a trie inside KDB.</dd>
<dd>
parentKey must be a valid key! (could be implemented more generally, but that would require splitting up of keysets of the same backend)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kdb</em>&nbsp;</td><td>the handle to get information about backends </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentKey</em>&nbsp;</td><td>the information below which key the backends are from interest</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>always 1 </dd></dl>

</div>
</div>
<a class="anchor" id="gae569ef1bc4cd8e931b4a7840d8ce48e6"></a><!-- doxytag: member="split.c::elektraSplitDel" ref="gae569ef1bc4cd8e931b4a7840d8ce48e6" args="(Split *keysets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraSplitDel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>keysets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a split object.</p>
<p>Will free all allocated resources of a splitted keyset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keysets</em>&nbsp;</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga447e430a045cef7b107762171fbdc104"></a><!-- doxytag: member="split.c::elektraSplitDivide" ref="ga447e430a045cef7b107762171fbdc104" args="(Split *split, KDB *handle, KeySet *ks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitDivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KDB.html">KDB</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KeySet.html">KeySet</a> *&nbsp;</td>
          <td class="paramname"> <em>ks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Splits up the keysets and search for a sync bit.</p>
<p>It does not check if there were removed keys, see elektraSplitRemove() for the next step.</p>
<p>It does not create new backends, this has to be done by buildup before.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__split.html#gaabebbc4b0e47527f59942fcf95b9fcb5">elektraSplitBuildup()</a> need to be executed before.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>to get information where the individual keys belong </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ks</em>&nbsp;</td><td>the keyset to divide</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if there were no sync bits </dd>
<dd>
1 if there were sync bits </dd>
<dd>
-1 if no backend was found for a key </dd></dl>

</div>
</div>
<a class="anchor" id="ga311af3d964c45fc273dc1db5b5944895"></a><!-- doxytag: member="split.c::elektraSplitGet" ref="ga311af3d964c45fc273dc1db5b5944895" args="(Split *split, KDB *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KDB.html">KDB</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does some work after getting of backends is finished.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="group__split.html#gafee68d5935a6875ece69945e32242895">elektraSplitAppoint()</a> needs to be executed before.</dd></dl>
<ul>
<li>check if keys are in correct backend</li>
<li>remove syncbits</li>
<li>update usersize and systemsize</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle to preprocess the keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success </dd>
<dd>
-1 if no backend was found for a key </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3b1e5f1810964dddc3bd3a00822bca6"></a><!-- doxytag: member="split.c::elektraSplitMerge" ref="gaf3b1e5f1810964dddc3bd3a00822bca6" args="(Split *split, KeySet *dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitMerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KeySet.html">KeySet</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Merges together all parts of split into dest.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>the destination keyset where all keysets are appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success </dd></dl>

</div>
</div>
<a class="anchor" id="gad2245a38809f28e325cd9b32089b4c68"></a><!-- doxytag: member="split.c::elektraSplitNew" ref="gad2245a38809f28e325cd9b32089b4c68" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Split.html">Split</a>* elektraSplitNew </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a new split object.</p>
<p>Initially the size is APPROXIMATE_NR_OF_BACKENDS.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a fresh allocated split object</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__split.html#gae569ef1bc4cd8e931b4a7840d8ce48e6">elektraSplitDel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga24cf74dcf95614923099bbccab3dd2c8"></a><!-- doxytag: member="split.c::elektraSplitPrepare" ref="ga24cf74dcf95614923099bbccab3dd2c8" args="(Split *split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitPrepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepares for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> mainloop afterwards.</p>
<p>All splits which do not need sync are removed and a deep copy of the remaining keysets is done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9816931521a6a16bd553c08abb957c62"></a><!-- doxytag: member="split.c::elektraSplitResize" ref="ga9816931521a6a16bd553c08abb957c62" args="(Split *split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraSplitResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Doubles the size of how many parts of keysets can be appended.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga887dd183bf21c635c6993cd480ff3b21"></a><!-- doxytag: member="split.c::elektraSplitSearchBackend" ref="ga887dd183bf21c635c6993cd480ff3b21" args="(Split *split, Backend *backend, Key *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t elektraSplitSearchBackend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Backend.html">Backend</a> *&nbsp;</td>
          <td class="paramname"> <em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determines if the backend is already inserted or not.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If no parent Key is given, the default/root backends won't be searched.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>backend</em>&nbsp;</td><td>the backend to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>the key to check for domains in default/root backends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pos of backend if it already exist </dd>
<dd>
-1 if it does not exist </dd></dl>

</div>
</div>
<a class="anchor" id="gafb25e1f946f07e5490a962a42320a0cc"></a><!-- doxytag: member="split.c::elektraSplitSearchRoot" ref="gafb25e1f946f07e5490a962a42320a0cc" args="(Split *split, Key *parentKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitSearchRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>parentKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if one of the backends in split has all keys below parentKey </dd>
<dd>
0 if parentKey == 0 or there are keys below or same than parentKey which do not fit in any of splitted keysets </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentKey</em>&nbsp;</td><td>the key which relation is searched for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3176eff9c1b5a9bfcf3d2e648f537993"></a><!-- doxytag: member="split.c::elektraSplitSync" ref="ga3176eff9c1b5a9bfcf3d2e648f537993" args="(Split *split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Split.html">Split</a> *&nbsp;</td>
          <td class="paramname"> <em>split</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add sync bits everywhere keys were removed.</p>
<p>Only this function can really decide if sync is needed or not.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>split needs to be processed with <a class="el" href="group__split.html#ga447e430a045cef7b107762171fbdc104">elektraSplitDivide()</a> before.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> is not needed </dd>
<dd>
1 if <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> is needed </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>user/system was splitted before. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>split</em>&nbsp;</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Oct 1 2012 22:22:48 for Elektra by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
