\hypertarget{classkdb_1_1Key}{\section{kdb\+:\+:Key Class Reference}
\label{classkdb_1_1Key}\index{kdb\+::\+Key@{kdb\+::\+Key}}
}


\hyperlink{classkdb_1_1Key}{Key} is an essential class that encapsulates key \hyperlink{group__keyname}{name }, \hyperlink{group__keyvalue}{value } and \hyperlink{group__keymeta}{metainfo }.  




{\ttfamily \#include $<$key.\+hpp$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} ()
\begin{DoxyCompactList}\small\item\em Constructs an empty, invalid key. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key_a41ada34fa45a270e63444267621b59c9}{Key} (ckdb\+::\+Key $\ast$k)
\begin{DoxyCompactList}\small\item\em Constructs a key out of a C key. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key_a33f63e153a7d832a54e02c0cba569feb}{Key} (\hyperlink{classkdb_1_1Key}{Key} \&k)
\begin{DoxyCompactList}\small\item\em Takes a reference of another key. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key_ab68da8be743b2f635ff8e28dfaeaaea6}{Key} (\hyperlink{classkdb_1_1Key}{Key} const \&k)
\begin{DoxyCompactList}\small\item\em Takes a reference of another key. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key_a15b2e9e1cc323cde05b0d1d3805656e0}{Key} (const char $\ast$\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name},...)
\begin{DoxyCompactList}\small\item\em A practical way to fully create a \hyperlink{classkdb_1_1Key}{Key} object in one step. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key_acbf7642258d46da2c4427f4104cf01ee}{Key} (const std\+::string \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name},...)
\begin{DoxyCompactList}\small\item\em A practical way to fully create a \hyperlink{classkdb_1_1Key}{Key} object in one step. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key_aa0dc94c7e676a0d280e5817e4c6238d3}{Key} (const char $\ast$\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name}, va\+\_\+list ap)
\begin{DoxyCompactList}\small\item\em A practical way to fully create a \hyperlink{classkdb_1_1Key}{Key} object in one step. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_a31f7139c5378b3fde4dfab4955208d23}{operator++} (int) const 
\begin{DoxyCompactList}\small\item\em Increment the viability of a key object. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_ab017ed5e104e441d86725f61439d1f24}{operator++} () const 
\begin{DoxyCompactList}\small\item\em Increment the viability of a key object. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_acbb63da4ab49c66c851228511c000ec7}{operator-\/-\/} (int) const 
\begin{DoxyCompactList}\small\item\em Decrement the viability of a key object. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_afa095fe7021b7ca01e6224b976449b3f}{operator-\/-\/} () const 
\begin{DoxyCompactList}\small\item\em Decrement the viability of a key object. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1Key_a213fb46e13b669cc862fce06ac361b79}{get\+Reference\+Counter} () const 
\begin{DoxyCompactList}\small\item\em Return how many references the key has. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \& \hyperlink{classkdb_1_1Key_a628f3ee543a1d71d4488233018eddd86}{operator=} (ckdb\+::\+Key $\ast$k)
\begin{DoxyCompactList}\small\item\em Assign a C key. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} \& \hyperlink{classkdb_1_1Key_a63a006c140cfd2a633c6fdf3f9eb9d1a}{operator=} (const \hyperlink{classkdb_1_1Key}{Key} \&k)
\begin{DoxyCompactList}\small\item\em Assign a key. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_ab5bc93e22f4cf40b9d2b1fc32cc260be}{copy} (const \hyperlink{classkdb_1_1Key}{Key} \&other)
\begin{DoxyCompactList}\small\item\em Copy or Clear a key. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_a33a112681b0b2e94e6d369c0f89e361b}{clear} ()
\begin{DoxyCompactList}\small\item\em Clears/\+Invalidates a key. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key}{Key} $\ast$ \hyperlink{classkdb_1_1Key_ab64ec9d578e083dad3e43322535cf108}{operator-\/$>$} ()
\item 
ckdb\+::\+Key $\ast$ \hyperlink{classkdb_1_1Key_ae81381365a7c159f070e74a7b7bd8688}{get\+Key} () const 
\begin{DoxyCompactList}\small\item\em Passes out the raw key pointer. \end{DoxyCompactList}\item 
ckdb\+::\+Key $\ast$ \hyperlink{classkdb_1_1Key_a6e0dd36c31cc7c46ee1cda0decc6e884}{operator$\ast$} () const 
\begin{DoxyCompactList}\small\item\em Is a abbreviation for get\+Key. \end{DoxyCompactList}\item 
ckdb\+::\+Key $\ast$ \hyperlink{classkdb_1_1Key_a9ae719043e6e99f5f3d6fb85837306f8}{release} ()
\begin{DoxyCompactList}\small\item\em Passes out the raw key pointer and resets internal key handle. \end{DoxyCompactList}\item 
ckdb\+::\+Key $\ast$ \hyperlink{classkdb_1_1Key_a43a1f28d7a0d40f0ded8473d480931ff}{dup} () const 
\begin{DoxyCompactList}\small\item\em Return a duplicate of a key. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key_a35dd6ae58d125a298e30aed13b15c1f4}{$\sim$\+Key} ()
\begin{DoxyCompactList}\small\item\em Destructs the key. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classkdb_1_1Key_aa3903afe9a4b7aebf427a74612a803cd}{get\+Name} () const 
\begin{DoxyCompactList}\small\item\em Returns a pointer to the abbreviated real internal {\ttfamily key} name. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1Key_aee1d42f22eda4d84d78ab72cd60cc005}{get\+Name\+Size} () const 
\begin{DoxyCompactList}\small\item\em Bytes needed to store the key name without owner. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classkdb_1_1Key_a43d3efd13e01624c520346a19984750b}{get\+Base\+Name} () const 
\begin{DoxyCompactList}\small\item\em Returns a pointer to the internal unescaped key name where the {\ttfamily basename} starts. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1Key_a92fde543f3fbfaa0f8af80dad12a9fe7}{get\+Base\+Name\+Size} () const 
\begin{DoxyCompactList}\small\item\em Calculates number of bytes needed to store basename of {\ttfamily key}. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_aac3b5d3a854d02187484bfbdbdf975af}{set\+Name} (const std\+::string \&new\+Name)
\begin{DoxyCompactList}\small\item\em Set a new name to a key. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_a0c8c7cef03d6482d89973be72fb3c8b8}{set\+Base\+Name} (const std\+::string \&base\+Name)
\begin{DoxyCompactList}\small\item\em Sets a base name for a key. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_ad2f72ce0985413ce588dc33a575ea306}{add\+Base\+Name} (const std\+::string \&base\+Name)
\begin{DoxyCompactList}\small\item\em Adds a base name for a key. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1Key_a4b5c13b86402dffa0845a6044cd57b39}{get\+Full\+Name\+Size} () const 
\begin{DoxyCompactList}\small\item\em Bytes needed to store the key name including user domain and ending N\+U\+L\+L. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classkdb_1_1Key_ab94686ea0b459e5a383942ec322d9c6e}{get\+Full\+Name} () const 
\begin{DoxyCompactList}\small\item\em Get key full name, including the user domain name. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_abaff8356eb91a6d3aed2b6d282269da2}{operator==} (const \hyperlink{classkdb_1_1Key}{Key} \&k) const 
\begin{DoxyCompactList}\small\item\em Compare the name of two keys. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_a313a84b686a72769ecf4c368a79d492c}{operator!=} (const \hyperlink{classkdb_1_1Key}{Key} \&k) const 
\begin{DoxyCompactList}\small\item\em Compare the name of two keys. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_aace409efd393ae21f08d333f45da2769}{operator$<$} (const \hyperlink{classkdb_1_1Key}{Key} \&other) const 
\begin{DoxyCompactList}\small\item\em Compare the name of two keys. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_a3b466f59870b989aa9ec41558bba4d19}{operator$<$=} (const \hyperlink{classkdb_1_1Key}{Key} \&other) const 
\begin{DoxyCompactList}\small\item\em Compare the name of two keys. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_a1bd2b165eeade6a71401b9b122864bad}{operator$>$} (const \hyperlink{classkdb_1_1Key}{Key} \&other) const 
\begin{DoxyCompactList}\small\item\em Compare the name of two keys. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_aa1258657e3dbddf4aed3716dd63d2a3c}{operator$>$=} (const \hyperlink{classkdb_1_1Key}{Key} \&other) const 
\begin{DoxyCompactList}\small\item\em Compare the name of two keys. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{is\+Null} () const 
\begin{DoxyCompactList}\small\item\em Checks if C++ wrapper has an underlying key. \end{DoxyCompactList}\item 
\hyperlink{classkdb_1_1Key_ac203d41896988df49dd149c2a6ad91d8}{operator bool} () const 
\begin{DoxyCompactList}\small\item\em This is for loops and lookups only. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_ab727b6254fec01a129d3e6ac681a5fe5}{need\+Sync} () const 
\begin{DoxyCompactList}\small\item\em Test if a key needs to be synced to backend storage. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\T \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} () const 
\begin{DoxyCompactList}\small\item\em Get a key value. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{classkdb_1_1Key_a615124f0a2b291e03975b49c233654d7}{set} (T x)
\begin{DoxyCompactList}\small\item\em Set a key value. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classkdb_1_1Key_afbad98e920ffb6d65d5d690be73ae6d9}{get\+String} () const 
\item 
void \hyperlink{classkdb_1_1Key_ab97ef37aa235f0ae04dc6e6c21109d1a}{set\+String} (std\+::string new\+String)
\begin{DoxyCompactList}\small\item\em Set the value for {\ttfamily key} as {\ttfamily new\+String\+Value}. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1Key_af3032a91f0fbf111b6b5e42dd35865db}{get\+String\+Size} () const 
\begin{DoxyCompactList}\small\item\em Returns the number of bytes needed to store the key value, including the N\+U\+L\+L terminator. \end{DoxyCompactList}\item 
func\+\_\+t \hyperlink{classkdb_1_1Key_a9e4f81dae7370976dad75030e8c0d084}{get\+Func} () const 
\begin{DoxyCompactList}\small\item\em Elektra can store function pointers as binary. \end{DoxyCompactList}\item 
const void $\ast$ \hyperlink{classkdb_1_1Key_a3e0bbc6b746b89db7abb73a4cc2fff39}{get\+Value} () const 
\begin{DoxyCompactList}\small\item\em Return a pointer to the real internal {\ttfamily key} value. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classkdb_1_1Key_a16b64fd6db0a743e2e4ab08daf6fba73}{get\+Binary} () const 
\begin{DoxyCompactList}\small\item\em Get the value of a key as a binary. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1Key_af173c1c4ab4104c5bc48a98cf011ca8d}{get\+Binary\+Size} () const 
\begin{DoxyCompactList}\small\item\em Returns the number of bytes needed to store the key value, including the N\+U\+L\+L terminator. \end{DoxyCompactList}\item 
ssize\+\_\+t \hyperlink{classkdb_1_1Key_af7211129a4b95f4d1e335dcd06e9bf0a}{set\+Binary} (const void $\ast$new\+Binary, size\+\_\+t data\+Size)
\begin{DoxyCompactList}\small\item\em Set the value of a key as a binary. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_abb2c472e514ecef5fedb63ecae7c0f54}{has\+Meta} (const std\+::string \&meta\+Name) const 
\item 
{\footnotesize template$<$class T $>$ }\\T \hyperlink{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}{get\+Meta} (const std\+::string \&meta\+Name) const 
\begin{DoxyCompactList}\small\item\em Returns the Value of a Meta-\/\+Information given by name. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{classkdb_1_1Key_a4c5a3d463127ade0b766c4298002daa3}{set\+Meta} (const std\+::string \&meta\+Name, T x)
\begin{DoxyCompactList}\small\item\em Set metadata for key. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_a2305da805095605aca38d53f2733fb57}{del\+Meta} (const std\+::string \&meta\+Name)
\begin{DoxyCompactList}\small\item\em Delete metadata for key. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_a53f6d2196a7f17c4bdc544207bdc5f4c}{copy\+Meta} (const \hyperlink{classkdb_1_1Key}{Key} \&other, const std\+::string \&meta\+Name)
\begin{DoxyCompactList}\small\item\em Do a shallow copy of meta data from source to dest. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_aec0910bf293db33deac6a3f81359cb48}{copy\+All\+Meta} (const \hyperlink{classkdb_1_1Key}{Key} \&other)
\begin{DoxyCompactList}\small\item\em Do a shallow copy of all meta data from source to dest. \end{DoxyCompactList}\item 
void \hyperlink{classkdb_1_1Key_adf6171b76e01c2b84c6050d43673dd97}{rewind\+Meta} () const 
\begin{DoxyCompactList}\small\item\em Rewind the internal iterator to first meta data. \end{DoxyCompactList}\item 
const \hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1Key_a855f37fef58a4ea4006d9e281f66cfe1}{next\+Meta} ()
\begin{DoxyCompactList}\small\item\em Iterate to the next meta information. \end{DoxyCompactList}\item 
const \hyperlink{classkdb_1_1Key}{Key} \hyperlink{classkdb_1_1Key_a2be586ccd64cd280561ba5cd23f6ff1e}{current\+Meta} () const 
\begin{DoxyCompactList}\small\item\em Returns the Value of a Meta-\/\+Information which is current. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{is\+Valid} () const 
\item 
std\+::string \hyperlink{classkdb_1_1Key_a2cf2b97f404d5808f46a9a5c4b8b93e1}{get\+Namespace} () const 
\item 
bool \hyperlink{classkdb_1_1Key_ac0f21b82a3d851eb3dfae53ddcfdbe48}{is\+System} () const 
\begin{DoxyCompactList}\small\item\em Name starts with \char`\"{}system\char`\"{}. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_ab6103772c702b400eaefbc4665f5c0cf}{is\+User} () const 
\begin{DoxyCompactList}\small\item\em Name starts with \char`\"{}user\char`\"{}. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_aa60e37609593de715c342740c76040cc}{is\+String} () const 
\begin{DoxyCompactList}\small\item\em Check if a key is string type. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_aad92210fe2389ad950a47a4eca428574}{is\+Binary} () const 
\begin{DoxyCompactList}\small\item\em Check if a key is binary type. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_adcd75cc13e9d766eaac72beb7d748bdb}{is\+Inactive} () const 
\begin{DoxyCompactList}\small\item\em Check whether a key is inactive. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_a493893308d5b4c54d646cc0df5a076ae}{is\+Below} (const \hyperlink{classkdb_1_1Key}{Key} \&k) const 
\begin{DoxyCompactList}\small\item\em Check if the key check is below the key key or not. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_a0d4d2d50f9e3624ade560b0f74267d86}{is\+Below\+Or\+Same} (const \hyperlink{classkdb_1_1Key}{Key} \&k) const 
\begin{DoxyCompactList}\small\item\em Check if a key is below or same or not. \end{DoxyCompactList}\item 
bool \hyperlink{classkdb_1_1Key_a3cc66b309bd42e67d7bc0e4234aa76a1}{is\+Direct\+Below} (const \hyperlink{classkdb_1_1Key}{Key} \&k) const 
\begin{DoxyCompactList}\small\item\em Check if the key check is direct below the key key or not. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{classkdb_1_1Key}{Key} is an essential class that encapsulates key \hyperlink{group__keyname}{name }, \hyperlink{group__keyvalue}{value } and \hyperlink{group__keymeta}{metainfo }. 

To use it include\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <kdb.h>}
\end{DoxyCode}


\hyperlink{classkdb_1_1Key}{Key} properties are\+:
\begin{DoxyItemize}
\item \hyperlink{group__keyname}{Key name }
\item \hyperlink{group__keyvalue}{Key value }
\item \hyperlink{group__keymeta}{Key meta data }, including but not limited to\+:
\begin{DoxyItemize}
\item \hyperlink{group__meta_gafb89735689929ff717cc9f2d0d0b46a2}{Key comment }
\item \hyperlink{owner_8c_a35922a017bee8b4bcb493bbdfad9d6f5}{Key owner }
\item \hyperlink{group__keymeta}{U\+I\+D, G\+I\+D and filesystem-\/like mode permissions }
\item \hyperlink{group__keymeta}{Mode, change and modification times }
\end{DoxyItemize}
\end{DoxyItemize}

\begin{DoxyParagraph}{A\+B\+I}
Due to A\+B\+I compatibility, the {\ttfamily \hyperlink{classkdb_1_1Key}{Key}} structure is not defined in kdb.\+h, only declared. So you can only declare {\ttfamily pointers} to {\ttfamily Keys} in your program, and allocate and free memory for them with \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} and \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} respectively.
\end{DoxyParagraph}
\begin{DoxyParagraph}{Reference Counting}
Every key has its reference counter (see \hyperlink{group__key_ga4aabc4272506dd63161db2bbb42de8ae}{key\+Get\+Ref()} for longer explanation) that will be initialized with 0, that means a subsequent call of \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} will delete the key. If you append the key to a keyset the reference counter will be incremented by one (see \hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()}) and the key can't be deleted by a \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()}.
\end{DoxyParagraph}
\begin{DoxyParagraph}{}
As you can imagine this refcounting allows you to put the \hyperlink{classkdb_1_1Key}{Key} in your own datastructures. It can be a very powerful feature, e.\+g. if you need your own-\/defined ordering or different Models of your configuration.
\end{DoxyParagraph}
This class is an wrapper for an optional, refcounted ckdb\+::\+Key. It is like an shared\+\_\+ptr$<$ckdb\+::\+Key$>$, but the shared\+\_\+ptr functionality is already within the \hyperlink{classkdb_1_1Key}{Key} and exposed with this wrapper.

\begin{DoxyParagraph}{optional}
A key can be constructed with an null pointer, by using \hyperlink{classkdb_1_1Key}{Key} (static\+\_\+cast$<$ckdb\+::\+Key$\ast$$>$(0)); or made empty afterwards by using \hyperlink{classkdb_1_1Key_a9ae719043e6e99f5f3d6fb85837306f8}{release()} or assign a null key. To check if there is an associated managed object the user can use \hyperlink{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{is\+Null()}.
\end{DoxyParagraph}
\begin{DoxyParagraph}{references}
Copies of keys are cheap because they are only flat. If you really need a deep copy, you can use \hyperlink{classkdb_1_1Key_ab5bc93e22f4cf40b9d2b1fc32cc260be}{copy()} or \hyperlink{classkdb_1_1Key_a43a1f28d7a0d40f0ded8473d480931ff}{dup()}. If you \hyperlink{classkdb_1_1Key_a9ae719043e6e99f5f3d6fb85837306f8}{release()} an object, the reference counter will stay All other operations operate on references.
\end{DoxyParagraph}
\begin{DoxyParagraph}{documentation}
Note that the documentation is typically copied from the underlying function which is wrapped and sometimes extended with C++ specific details. So you might find C examples within the C++ documentation.
\end{DoxyParagraph}
\begin{DoxyInvariant}{Invariant}
\hyperlink{classkdb_1_1Key}{Key} either has a working underlying Elektra \hyperlink{classkdb_1_1Key}{Key} object or a null pointer. The \hyperlink{classkdb_1_1Key}{Key}, however, might be invalid (see \hyperlink{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{is\+Valid()}) or null (see \hyperlink{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{is\+Null()}).
\end{DoxyInvariant}
\begin{DoxyNote}{Note}
that the reference counting in the keys is mutable, so that const keys can be passed around by value. 
\end{DoxyNote}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{\index{kdb\+::\+Key@{kdb\+::\+Key}!Key@{Key}}
\index{Key@{Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{Key}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::\+Key (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}


Constructs an empty, invalid key. 

\begin{DoxyNote}{Note}
That this is not a null key, so the key will evaluate to true.
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{is\+Valid()}, \hyperlink{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{is\+Null()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a41ada34fa45a270e63444267621b59c9}{\index{kdb\+::\+Key@{kdb\+::\+Key}!Key@{Key}}
\index{Key@{Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{Key}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::\+Key (
\begin{DoxyParamCaption}
\item[{ckdb\+::\+Key $\ast$}]{k}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a41ada34fa45a270e63444267621b59c9}


Constructs a key out of a C key. 

\begin{DoxyNote}{Note}
If you pass a null pointer here, the key will evaluate to false.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em k} & the key to work with\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{is\+Valid()}, \hyperlink{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{is\+Null()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a33f63e153a7d832a54e02c0cba569feb}{\index{kdb\+::\+Key@{kdb\+::\+Key}!Key@{Key}}
\index{Key@{Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{Key}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::\+Key (
\begin{DoxyParamCaption}
\item[{{\bf Key} \&}]{k}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a33f63e153a7d832a54e02c0cba569feb}


Takes a reference of another key. 

The key will not be copied, but the reference counter will be increased.


\begin{DoxyParams}{Parameters}
{\em k} & the key to work with \\
\hline
\end{DoxyParams}
\hypertarget{classkdb_1_1Key_ab68da8be743b2f635ff8e28dfaeaaea6}{\index{kdb\+::\+Key@{kdb\+::\+Key}!Key@{Key}}
\index{Key@{Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{Key}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::\+Key (
\begin{DoxyParamCaption}
\item[{{\bf Key} const \&}]{k}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ab68da8be743b2f635ff8e28dfaeaaea6}


Takes a reference of another key. 

The key will not be copied, but the reference counter will be increased.


\begin{DoxyParams}{Parameters}
{\em k} & the key to work with \\
\hline
\end{DoxyParams}
\hypertarget{classkdb_1_1Key_a15b2e9e1cc323cde05b0d1d3805656e0}{\index{kdb\+::\+Key@{kdb\+::\+Key}!Key@{Key}}
\index{Key@{Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{Key}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::\+Key (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{key\+Name, }
\item[{}]{...}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}}\label{classkdb_1_1Key_a15b2e9e1cc323cde05b0d1d3805656e0}


A practical way to fully create a \hyperlink{classkdb_1_1Key}{Key} object in one step. 

To just get a key object, simple do\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(0);
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 If you want the key object to contain a name, value, comment and other meta info read on.

\begin{DoxyNote}{Note}
When you already have a key with similar properties its easier to \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} the key.
\end{DoxyNote}
You can call it in many different ways depending on the attribute tags you pass as parameters. Tags are represented as \hyperlink{group__key_ga91fb3178848bd682000958089abbaf40}{keyswitch\+\_\+t} values, and tell \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} which \hyperlink{classkdb_1_1Key}{Key} attribute comes next.

We can also give an empty key name and a K\+E\+Y\+\_\+\+E\+N\+D tag with the same effect as before\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k =\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{""}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}); \textcolor{comment}{// Has the same effect as above}
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 But we can also give the key a proper name right from the start\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/some/example"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 So, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} allocates memory for a key object and \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} cleans everything up.

\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} processes the given argument list even further. The \hyperlink{classkdb_1_1Key}{Key} attribute tags are the following\+:
\begin{DoxyItemize}
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{K\+E\+Y\+\_\+\+V\+A\+L\+U\+E} ~\newline
 Next parameter is a pointer to the value that will be used. If no \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{K\+E\+Y\+\_\+\+B\+I\+N\+A\+R\+Y} was used before, a string is assumed. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex0"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// set a string value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{K\+E\+Y\+\_\+\+S\+I\+Z\+E} ~\newline
 Define a maximum length of the value. This is only used when setting a binary key. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex1"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 4,               \textcolor{comment}{// has no effect on strings}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// set a string value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{K\+E\+Y\+\_\+\+M\+E\+T\+A} ~\newline
 Next two parameter is a meta name and a meta value. See \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"comment"}, \textcolor{stringliteral}{"a comment"},  \textcolor{comment}{// with a comment}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"owner"}, \textcolor{stringliteral}{"root"},         \textcolor{comment}{// and an owner}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"special"}, \textcolor{stringliteral}{"yes"},        \textcolor{comment}{// and any other meta data}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{K\+E\+Y\+\_\+\+E\+N\+D} ~\newline
 Must be the last parameter passed to \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}. It is always required, unless the {\ttfamily key\+Name} is 0.
\item \+::\+K\+E\+Y\+\_\+\+F\+L\+A\+G\+S ~\newline
 Bitwise disjunction of flags, which don't require one or more values. recommended way to set multiple flags. overrides previously defined flags. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        KEY\_FLAGS, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY} | KEY\_CASCADING\_NAME, \textcolor{comment}{// flags}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 7,                    \textcolor{comment}{// assume binary length 7}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},                \textcolor{comment}{// value that will be truncated in 7 bytes}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                        \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{K\+E\+Y\+\_\+\+B\+I\+N\+A\+R\+Y} ~\newline
 Allows one to change the key to a binary key. Make sure that you also pass \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{K\+E\+Y\+\_\+\+S\+I\+Z\+E} before you set the value. Otherwise it will be cut off with first \textbackslash{}0 in the string. So this flag toggle from \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{key\+Set\+String()} to \hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{key\+Set\+Binary()}. If no value (nor size) is given, it will be a N\+U\+L\+L key. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex2"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 4,               \textcolor{comment}{// now the size is important}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// sets the binary value ("some")}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \+::\+K\+E\+Y\+\_\+\+C\+A\+S\+C\+A\+D\+I\+N\+G\+\_\+\+N\+A\+M\+E allow the name to start with / useful for \hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} and \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} parent/lookup keys
\item \+::\+K\+E\+Y\+\_\+\+M\+E\+T\+A\+\_\+\+N\+A\+M\+E allow the name to start with arbitrary namespaces useful to compare with meta keys
\end{DoxyItemize}

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000008}{Deprecated}]These other flags deprecated and \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{K\+E\+Y\+\_\+\+M\+E\+T\+A} should be preferred. They remain some time, however, for compatibility\+:
\begin{DoxyItemize}
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a9e43e47c8a21478538e2d20e049981d5}{K\+E\+Y\+\_\+\+D\+I\+R} ~\newline
 Define that the key is a directory rather than a ordinary key. This means its executable bits in its mode are set. But even without this option the key can have subkeys. See \hyperlink{group__meta_gaae575bd86a628a15ee45baa860522e75}{key\+Set\+Dir()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{K\+E\+Y\+\_\+\+O\+W\+N\+E\+R} ~\newline
 Next parameter is the owner. See \hyperlink{owner_8c_a88d6ec200ba0707b7c1b4a88133d2be4}{key\+Set\+Owner()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e}{K\+E\+Y\+\_\+\+U\+I\+D}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac0628bbaba7c837ca73323681393d15f}{K\+E\+Y\+\_\+\+G\+I\+D} ~\newline
 Next parameter is taken as the U\+I\+D (uid\+\_\+t) or G\+I\+D (gid\+\_\+t) that will be defined on the key. See \hyperlink{group__meta_gab5f284f5ecd261e0a290095f50ba1af7}{key\+Set\+U\+I\+D()} and \hyperlink{group__meta_ga9e3d0fb3f7ba906e067727b9155d22e3}{key\+Set\+G\+I\+D()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518}{K\+E\+Y\+\_\+\+M\+O\+D\+E} ~\newline
 Next parameter is taken as mode permissions (int) to the key. See \hyperlink{group__meta_ga8803037e35b9da1ce492323a88ff6bc3}{key\+Set\+Mode()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// with a simple value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518}{KEY\_MODE}, 0777,            \textcolor{comment}{// permissions}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3}{K\+E\+Y\+\_\+\+C\+O\+M\+M\+E\+N\+T} ~\newline
 Next parameter is a comment. See \hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex4"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY},                   \textcolor{comment}{// key type}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 7,                    \textcolor{comment}{// assume binary length 7}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},                \textcolor{comment}{// value that will be truncated in 7 bytes}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3}{KEY\_COMMENT}, \textcolor{stringliteral}{"value is truncated"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"root"},             \textcolor{comment}{// owner (not uid) is root}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e}{KEY\_UID}, 0,                      \textcolor{comment}{// root uid}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                        \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\end{DoxyItemize}\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em name} & a valid name to the key, or N\+U\+L\+L to get a simple initialized, but really empty, object \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
a pointer to a new allocated and initialized \hyperlink{classkdb_1_1Key}{Key} object. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em N\+U\+L\+L} & on allocation error or if an invalid {\ttfamily name} was passed (see \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()}).\\
\hline
\end{DoxyRetVals}

\begin{DoxyExceptions}{Exceptions}
{\em bad\+\_\+alloc} & if key could not be constructed (allocation problems)\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{Parameters}
{\em key\+Name} & the name of the new key \\
\hline
\end{DoxyParams}
\hypertarget{classkdb_1_1Key_acbf7642258d46da2c4427f4104cf01ee}{\index{kdb\+::\+Key@{kdb\+::\+Key}!Key@{Key}}
\index{Key@{Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{Key}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::\+Key (
\begin{DoxyParamCaption}
\item[{const std\+::string}]{key\+Name, }
\item[{}]{...}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}}\label{classkdb_1_1Key_acbf7642258d46da2c4427f4104cf01ee}


A practical way to fully create a \hyperlink{classkdb_1_1Key}{Key} object in one step. 

To just get a key object, simple do\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(0);
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 If you want the key object to contain a name, value, comment and other meta info read on.

\begin{DoxyNote}{Note}
When you already have a key with similar properties its easier to \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} the key.
\end{DoxyNote}
You can call it in many different ways depending on the attribute tags you pass as parameters. Tags are represented as \hyperlink{group__key_ga91fb3178848bd682000958089abbaf40}{keyswitch\+\_\+t} values, and tell \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} which \hyperlink{classkdb_1_1Key}{Key} attribute comes next.

We can also give an empty key name and a K\+E\+Y\+\_\+\+E\+N\+D tag with the same effect as before\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k =\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{""}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}); \textcolor{comment}{// Has the same effect as above}
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 But we can also give the key a proper name right from the start\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/some/example"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 So, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} allocates memory for a key object and \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} cleans everything up.

\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} processes the given argument list even further. The \hyperlink{classkdb_1_1Key}{Key} attribute tags are the following\+:
\begin{DoxyItemize}
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{K\+E\+Y\+\_\+\+V\+A\+L\+U\+E} ~\newline
 Next parameter is a pointer to the value that will be used. If no \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{K\+E\+Y\+\_\+\+B\+I\+N\+A\+R\+Y} was used before, a string is assumed. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex0"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// set a string value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{K\+E\+Y\+\_\+\+S\+I\+Z\+E} ~\newline
 Define a maximum length of the value. This is only used when setting a binary key. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex1"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 4,               \textcolor{comment}{// has no effect on strings}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// set a string value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{K\+E\+Y\+\_\+\+M\+E\+T\+A} ~\newline
 Next two parameter is a meta name and a meta value. See \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"comment"}, \textcolor{stringliteral}{"a comment"},  \textcolor{comment}{// with a comment}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"owner"}, \textcolor{stringliteral}{"root"},         \textcolor{comment}{// and an owner}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"special"}, \textcolor{stringliteral}{"yes"},        \textcolor{comment}{// and any other meta data}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{K\+E\+Y\+\_\+\+E\+N\+D} ~\newline
 Must be the last parameter passed to \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}. It is always required, unless the {\ttfamily key\+Name} is 0.
\item \+::\+K\+E\+Y\+\_\+\+F\+L\+A\+G\+S ~\newline
 Bitwise disjunction of flags, which don't require one or more values. recommended way to set multiple flags. overrides previously defined flags. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        KEY\_FLAGS, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY} | KEY\_CASCADING\_NAME, \textcolor{comment}{// flags}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 7,                    \textcolor{comment}{// assume binary length 7}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},                \textcolor{comment}{// value that will be truncated in 7 bytes}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                        \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{K\+E\+Y\+\_\+\+B\+I\+N\+A\+R\+Y} ~\newline
 Allows one to change the key to a binary key. Make sure that you also pass \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{K\+E\+Y\+\_\+\+S\+I\+Z\+E} before you set the value. Otherwise it will be cut off with first \textbackslash{}0 in the string. So this flag toggle from \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{key\+Set\+String()} to \hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{key\+Set\+Binary()}. If no value (nor size) is given, it will be a N\+U\+L\+L key. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex2"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 4,               \textcolor{comment}{// now the size is important}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// sets the binary value ("some")}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \+::\+K\+E\+Y\+\_\+\+C\+A\+S\+C\+A\+D\+I\+N\+G\+\_\+\+N\+A\+M\+E allow the name to start with / useful for \hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} and \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} parent/lookup keys
\item \+::\+K\+E\+Y\+\_\+\+M\+E\+T\+A\+\_\+\+N\+A\+M\+E allow the name to start with arbitrary namespaces useful to compare with meta keys
\end{DoxyItemize}

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000008}{Deprecated}]These other flags deprecated and \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{K\+E\+Y\+\_\+\+M\+E\+T\+A} should be preferred. They remain some time, however, for compatibility\+:
\begin{DoxyItemize}
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a9e43e47c8a21478538e2d20e049981d5}{K\+E\+Y\+\_\+\+D\+I\+R} ~\newline
 Define that the key is a directory rather than a ordinary key. This means its executable bits in its mode are set. But even without this option the key can have subkeys. See \hyperlink{group__meta_gaae575bd86a628a15ee45baa860522e75}{key\+Set\+Dir()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{K\+E\+Y\+\_\+\+O\+W\+N\+E\+R} ~\newline
 Next parameter is the owner. See \hyperlink{owner_8c_a88d6ec200ba0707b7c1b4a88133d2be4}{key\+Set\+Owner()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e}{K\+E\+Y\+\_\+\+U\+I\+D}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac0628bbaba7c837ca73323681393d15f}{K\+E\+Y\+\_\+\+G\+I\+D} ~\newline
 Next parameter is taken as the U\+I\+D (uid\+\_\+t) or G\+I\+D (gid\+\_\+t) that will be defined on the key. See \hyperlink{group__meta_gab5f284f5ecd261e0a290095f50ba1af7}{key\+Set\+U\+I\+D()} and \hyperlink{group__meta_ga9e3d0fb3f7ba906e067727b9155d22e3}{key\+Set\+G\+I\+D()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518}{K\+E\+Y\+\_\+\+M\+O\+D\+E} ~\newline
 Next parameter is taken as mode permissions (int) to the key. See \hyperlink{group__meta_ga8803037e35b9da1ce492323a88ff6bc3}{key\+Set\+Mode()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// with a simple value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518}{KEY\_MODE}, 0777,            \textcolor{comment}{// permissions}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3}{K\+E\+Y\+\_\+\+C\+O\+M\+M\+E\+N\+T} ~\newline
 Next parameter is a comment. See \hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex4"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY},                   \textcolor{comment}{// key type}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 7,                    \textcolor{comment}{// assume binary length 7}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},                \textcolor{comment}{// value that will be truncated in 7 bytes}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3}{KEY\_COMMENT}, \textcolor{stringliteral}{"value is truncated"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"root"},             \textcolor{comment}{// owner (not uid) is root}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e}{KEY\_UID}, 0,                      \textcolor{comment}{// root uid}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                        \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\end{DoxyItemize}\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em name} & a valid name to the key, or N\+U\+L\+L to get a simple initialized, but really empty, object \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
a pointer to a new allocated and initialized \hyperlink{classkdb_1_1Key}{Key} object. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em N\+U\+L\+L} & on allocation error or if an invalid {\ttfamily name} was passed (see \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()}).\\
\hline
\end{DoxyRetVals}

\begin{DoxyExceptions}{Exceptions}
{\em bad\+\_\+alloc} & if key could not be constructed (allocation problems)\\
\hline
\end{DoxyExceptions}
\begin{DoxyWarning}{Warning}
Not supported on some compilers, e.\+g. clang which require you to only pass non-\/\+P\+O\+D in varg lists.
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
{\em key\+Name} & the name of the new key \\
\hline
\end{DoxyParams}
\hypertarget{classkdb_1_1Key_aa0dc94c7e676a0d280e5817e4c6238d3}{\index{kdb\+::\+Key@{kdb\+::\+Key}!Key@{Key}}
\index{Key@{Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{Key}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::\+Key (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{key\+Name, }
\item[{va\+\_\+list}]{ap}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}}\label{classkdb_1_1Key_aa0dc94c7e676a0d280e5817e4c6238d3}


A practical way to fully create a \hyperlink{classkdb_1_1Key}{Key} object in one step. 

To just get a key object, simple do\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(0);
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 If you want the key object to contain a name, value, comment and other meta info read on.

\begin{DoxyNote}{Note}
When you already have a key with similar properties its easier to \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} the key.
\end{DoxyNote}
You can call it in many different ways depending on the attribute tags you pass as parameters. Tags are represented as \hyperlink{group__key_ga91fb3178848bd682000958089abbaf40}{keyswitch\+\_\+t} values, and tell \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} which \hyperlink{classkdb_1_1Key}{Key} attribute comes next.

We can also give an empty key name and a K\+E\+Y\+\_\+\+E\+N\+D tag with the same effect as before\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k =\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{""}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}); \textcolor{comment}{// Has the same effect as above}
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 But we can also give the key a proper name right from the start\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/some/example"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\textcolor{comment}{// work with it}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 So, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} allocates memory for a key object and \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} cleans everything up.

\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} processes the given argument list even further. The \hyperlink{classkdb_1_1Key}{Key} attribute tags are the following\+:
\begin{DoxyItemize}
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{K\+E\+Y\+\_\+\+V\+A\+L\+U\+E} ~\newline
 Next parameter is a pointer to the value that will be used. If no \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{K\+E\+Y\+\_\+\+B\+I\+N\+A\+R\+Y} was used before, a string is assumed. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex0"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// set a string value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{K\+E\+Y\+\_\+\+S\+I\+Z\+E} ~\newline
 Define a maximum length of the value. This is only used when setting a binary key. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex1"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 4,               \textcolor{comment}{// has no effect on strings}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// set a string value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{K\+E\+Y\+\_\+\+M\+E\+T\+A} ~\newline
 Next two parameter is a meta name and a meta value. See \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"comment"}, \textcolor{stringliteral}{"a comment"},  \textcolor{comment}{// with a comment}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"owner"}, \textcolor{stringliteral}{"root"},         \textcolor{comment}{// and an owner}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{KEY\_META}, \textcolor{stringliteral}{"special"}, \textcolor{stringliteral}{"yes"},        \textcolor{comment}{// and any other meta data}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{K\+E\+Y\+\_\+\+E\+N\+D} ~\newline
 Must be the last parameter passed to \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}. It is always required, unless the {\ttfamily key\+Name} is 0.
\item \+::\+K\+E\+Y\+\_\+\+F\+L\+A\+G\+S ~\newline
 Bitwise disjunction of flags, which don't require one or more values. recommended way to set multiple flags. overrides previously defined flags. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        KEY\_FLAGS, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY} | KEY\_CASCADING\_NAME, \textcolor{comment}{// flags}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 7,                    \textcolor{comment}{// assume binary length 7}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},                \textcolor{comment}{// value that will be truncated in 7 bytes}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                        \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{K\+E\+Y\+\_\+\+B\+I\+N\+A\+R\+Y} ~\newline
 Allows one to change the key to a binary key. Make sure that you also pass \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{K\+E\+Y\+\_\+\+S\+I\+Z\+E} before you set the value. Otherwise it will be cut off with first \textbackslash{}0 in the string. So this flag toggle from \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{key\+Set\+String()} to \hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{key\+Set\+Binary()}. If no value (nor size) is given, it will be a N\+U\+L\+L key. 
\begin{DoxyCodeInclude}
\textcolor{comment}{// Create and initialize a key with a name and nothing else}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex2"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 4,               \textcolor{comment}{// now the size is important}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// sets the binary value ("some")}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \+::\+K\+E\+Y\+\_\+\+C\+A\+S\+C\+A\+D\+I\+N\+G\+\_\+\+N\+A\+M\+E allow the name to start with / useful for \hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} and \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} parent/lookup keys
\item \+::\+K\+E\+Y\+\_\+\+M\+E\+T\+A\+\_\+\+N\+A\+M\+E allow the name to start with arbitrary namespaces useful to compare with meta keys
\end{DoxyItemize}

\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000008}{Deprecated}]These other flags deprecated and \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2}{K\+E\+Y\+\_\+\+M\+E\+T\+A} should be preferred. They remain some time, however, for compatibility\+:
\begin{DoxyItemize}
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a9e43e47c8a21478538e2d20e049981d5}{K\+E\+Y\+\_\+\+D\+I\+R} ~\newline
 Define that the key is a directory rather than a ordinary key. This means its executable bits in its mode are set. But even without this option the key can have subkeys. See \hyperlink{group__meta_gaae575bd86a628a15ee45baa860522e75}{key\+Set\+Dir()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{K\+E\+Y\+\_\+\+O\+W\+N\+E\+R} ~\newline
 Next parameter is the owner. See \hyperlink{owner_8c_a88d6ec200ba0707b7c1b4a88133d2be4}{key\+Set\+Owner()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e}{K\+E\+Y\+\_\+\+U\+I\+D}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac0628bbaba7c837ca73323681393d15f}{K\+E\+Y\+\_\+\+G\+I\+D} ~\newline
 Next parameter is taken as the U\+I\+D (uid\+\_\+t) or G\+I\+D (gid\+\_\+t) that will be defined on the key. See \hyperlink{group__meta_gab5f284f5ecd261e0a290095f50ba1af7}{key\+Set\+U\+I\+D()} and \hyperlink{group__meta_ga9e3d0fb3f7ba906e067727b9155d22e3}{key\+Set\+G\+I\+D()}.
\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518}{K\+E\+Y\+\_\+\+M\+O\+D\+E} ~\newline
 Next parameter is taken as mode permissions (int) to the key. See \hyperlink{group__meta_ga8803037e35b9da1ce492323a88ff6bc3}{key\+Set\+Mode()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex3"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},    \textcolor{comment}{// with a simple value}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518}{KEY\_MODE}, 0777,            \textcolor{comment}{// permissions}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                  \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\item \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3}{K\+E\+Y\+\_\+\+C\+O\+M\+M\+E\+N\+T} ~\newline
 Next parameter is a comment. See \hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}. 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/tmp/ex4"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff}{KEY\_BINARY},                   \textcolor{comment}{// key type}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01}{KEY\_SIZE}, 7,                    \textcolor{comment}{// assume binary length 7}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}, \textcolor{stringliteral}{"some data"},                \textcolor{comment}{// value that will be truncated in 7 bytes}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3}{KEY\_COMMENT}, \textcolor{stringliteral}{"value is truncated"},
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"root"},             \textcolor{comment}{// owner (not uid) is root}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e}{KEY\_UID}, 0,                      \textcolor{comment}{// root uid}
        \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});                        \textcolor{comment}{// end of args}
\end{DoxyCodeInclude}

\end{DoxyItemize}\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em name} & a valid name to the key, or N\+U\+L\+L to get a simple initialized, but really empty, object \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
a pointer to a new allocated and initialized \hyperlink{classkdb_1_1Key}{Key} object. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em N\+U\+L\+L} & on allocation error or if an invalid {\ttfamily name} was passed (see \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()}).\\
\hline
\end{DoxyRetVals}

\begin{DoxyExceptions}{Exceptions}
{\em bad\+\_\+alloc} & if key could not be constructed (allocation problems)\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{Parameters}
{\em key\+Name} & the name of the new key \\
\hline
{\em ap} & the variable argument list pointer \\
\hline
\end{DoxyParams}
\hypertarget{classkdb_1_1Key_a35dd6ae58d125a298e30aed13b15c1f4}{\index{kdb\+::\+Key@{kdb\+::\+Key}!````~Key@{$\sim$\+Key}}
\index{````~Key@{$\sim$\+Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{$\sim$\+Key}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::$\sim$\+Key (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a35dd6ae58d125a298e30aed13b15c1f4}


Destructs the key. 

\begin{DoxySeeAlso}{See also}
del() 
\end{DoxySeeAlso}


\subsection{Member Function Documentation}
\hypertarget{classkdb_1_1Key_ad2f72ce0985413ce588dc33a575ea306}{\index{kdb\+::\+Key@{kdb\+::\+Key}!add\+Base\+Name@{add\+Base\+Name}}
\index{add\+Base\+Name@{add\+Base\+Name}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{add\+Base\+Name}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::add\+Base\+Name (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{base\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ad2f72ce0985413ce588dc33a575ea306}


Adds a base name for a key. 

Adds {\ttfamily base\+Name} (that will be escaped) to the current key name. A new base\+Name will be added, no other part of the key name will be affected.

Assumes that {\ttfamily key} is a directory and will append {\ttfamily base\+Name} to it. The function adds the path separator for concatenating.

So if {\ttfamily key} has name {\ttfamily \char`\"{}system/dir1/dir2\char`\"{}} and this method is called with {\ttfamily base\+Name} {\ttfamily \char`\"{}mykey\char`\"{}}, the resulting key will have the name {\ttfamily \char`\"{}system/dir1/dir2/mykey\char`\"{}}.

When {\ttfamily base\+Name} is 0 nothing will happen and the size of the name is returned.

The escaping rules apply as in \hyperlink{group__keyname}{above }.

A simple example is\+: 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user/my/long"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{group__keyname_gaa942091fc4bd5c2699e49ddc50829524}{keyAddBaseName} (k, \textcolor{stringliteral}{"myname"});
printf (\textcolor{stringliteral}{"%s\(\backslash\)n"}, \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (k)); \textcolor{comment}{// will print user/my/long/myname}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 E.\+g. if you add . it will be escaped\+: 
\begin{DoxyCodeInclude}
        \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{keySetName} (k, \textcolor{stringliteral}{"system/valid"});
        succeed\_if (\hyperlink{group__keyname_gaa942091fc4bd5c2699e49ddc50829524}{keyAddBaseName} (k, \textcolor{stringliteral}{"."}) >= 0, \textcolor{stringliteral}{"could not add a base name"});
        succeed\_if\_same\_string (\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (k), \textcolor{stringliteral}{"system/valid/\(\backslash\)\(\backslash\)."});
        succeed\_if\_same\_string (\hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{keyBaseName} (k), \textcolor{stringliteral}{"."});
\end{DoxyCodeInclude}
 \begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname_ga6e804bd453f98c28b0ff51430d1df407}{key\+Set\+Base\+Name()} to \hyperlink{classkdb_1_1Key_a615124f0a2b291e03975b49c233654d7}{set} a base name 

\hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()} to \hyperlink{classkdb_1_1Key_a615124f0a2b291e03975b49c233654d7}{set} a new name.
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em base\+Name} & the string to append to the name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the size in bytes of the new key name including the ending N\+U\+L\+L 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & if the key had no name \\
\hline
{\em -\/1} & on N\+U\+L\+L pointers \\
\hline
{\em -\/1} & if key was inserted to a keyset before\\
\hline
\end{DoxyRetVals}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Invalid\+Name} & if the name is not valid \\
\hline
\end{DoxyExceptions}
\hypertarget{classkdb_1_1Key_a33a112681b0b2e94e6d369c0f89e361b}{\index{kdb\+::\+Key@{kdb\+::\+Key}!clear@{clear}}
\index{clear@{clear}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a33a112681b0b2e94e6d369c0f89e361b}


Clears/\+Invalidates a key. 

Afterwards the object is empty again.

\begin{DoxyNote}{Note}
This is not a null key, so it will evaluate to true. \hyperlink{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{is\+Valid()} will, however, be false.
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_a9ae719043e6e99f5f3d6fb85837306f8}{release()} 

\hyperlink{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{is\+Valid()}, \hyperlink{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{is\+Null()}
\end{DoxySeeAlso}
\hyperlink{classkdb_1_1Key}{Key} Object Cleaner. Will reset all internal data.

After this call you will receive a fresh key.

The reference counter will stay unmodified.

\begin{DoxyNote}{Note}
that you might also \hyperlink{classkdb_1_1Key_a33a112681b0b2e94e6d369c0f89e361b}{clear()} all aliases with this operation.
\end{DoxyNote}

\begin{DoxyCode}
\textcolor{keywordtype}{int} f (\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k)
\{
        \hyperlink{group__key_gab2242311a36bbc0520e0d36895107ec1}{keyClear} (k);
        \textcolor{comment}{// you have a fresh key k here}
        \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{keySetString} (k, \textcolor{stringliteral}{"value"});
        \textcolor{comment}{// the caller will get an empty key k with an value}
\}
\end{DoxyCode}



\begin{DoxyRetVals}{Return values}
{\em returns} & 0 on success \\
\hline
{\em -\/1} & on null pointer\\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\hypertarget{classkdb_1_1Key_ab5bc93e22f4cf40b9d2b1fc32cc260be}{\index{kdb\+::\+Key@{kdb\+::\+Key}!copy@{copy}}
\index{copy@{copy}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{copy}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::copy (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ab5bc93e22f4cf40b9d2b1fc32cc260be}


Copy or Clear a key. 

Most often you may prefer \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} which allocates a new key and returns a duplication of another key.

But when you need to copy into an existing key, e.\+g. because it was passed by a pointer in a function you can do so\+:


\begin{DoxyCodeInclude}
\textcolor{keywordtype}{void} h (\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * k)
\{
        \textcolor{comment}{// receive key c}
        \hyperlink{group__key_ga6a12cbbe656a1ad9f41b8c681d7a2f92}{keyCopy} (k, c);
        \textcolor{comment}{// the caller will see the changed key k}
\}
\end{DoxyCodeInclude}
 The reference counter will not be changed for both keys. Affiliation to keysets are also not affected.

The meta data will be duplicated for the destination key. So it will not take much additional space, even with lots of metadata.

When you pass a N\+U\+L\+L-\/pointer as source the data of dest will be cleaned completely (except reference counter, see \hyperlink{group__key_gab2242311a36bbc0520e0d36895107ec1}{key\+Clear()}) and you get a fresh dest key\+:


\begin{DoxyCodeInclude}
\textcolor{keywordtype}{void} g (\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * k)
\{
        \hyperlink{group__key_ga6a12cbbe656a1ad9f41b8c681d7a2f92}{keyCopy} (k, 0);
        \textcolor{comment}{// k is now an empty and fresh key}
\}
\end{DoxyCodeInclude}
 If you want to copy everything, except e.\+g. the value you can use \hyperlink{group__key_ga6a12cbbe656a1ad9f41b8c681d7a2f92}{key\+Copy()} too\+:


\begin{DoxyCodeInclude}
\textcolor{keywordtype}{void} j (\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * k)
\{
        \textcolor{keywordtype}{size\_t} size = \hyperlink{group__keyvalue_gae326672fffb7474abfe9baf53b73217e}{keyGetValueSize} (k);
        \textcolor{keywordtype}{char} * value = malloc (size);
        \textcolor{keywordtype}{int} bstring = \hyperlink{group__keytest_gaea7670778abd07fee0fe8ac12a149190}{keyIsString} (k);

        \textcolor{comment}{// receive key c}
        memcpy (value, \hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{keyValue} (k), size);
        \hyperlink{group__key_ga6a12cbbe656a1ad9f41b8c681d7a2f92}{keyCopy} (k, c);
        \textcolor{keywordflow}{if} (bstring)
                \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{keySetString} (k, value);
        \textcolor{keywordflow}{else}
                \hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{keySetBinary} (k, value, size);
        free (value);
        \textcolor{comment}{// the caller will see the changed key k}
        \textcolor{comment}{// with the name and metadata from c (except}
        \textcolor{comment}{// metadata "binary", which stayed the same)}
\}
\end{DoxyCodeInclude}
 Restrain from coping everything yourself, because it will lead to wrong metadata and is not able to copy empty or cascading names\+:


\begin{DoxyCodeInclude}
\textcolor{keywordtype}{void} i (\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * k)
\{
        \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{keySetName} (k, \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (c));
        \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{keySetString} (k, \hyperlink{group__keyvalue_ga880936f2481d28e6e2acbe7486a21d05}{keyString} (c));
        \hyperlink{group__keymeta_ga8e63720a65610a29597494d0671f9401}{keyCopyAllMeta} (k, c);
        \textcolor{comment}{// k is not a copy of c even if everything was successfully,}
        \textcolor{comment}{// because it still contains meta data from k}
\}
\end{DoxyCodeInclude}



\begin{DoxyParams}{Parameters}
{\em dest} & the key which will be written to \\
\hline
{\em source} & the key which should be copied or N\+U\+L\+L to clean the destination key\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on failure when a N\+U\+L\+L pointer was passed for dest or a dynamic property could not be written. The content will be unmodified then. \\
\hline
{\em 0} & when dest was cleaned \\
\hline
{\em 1} & when source was successfully copied \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} to \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} a duplication of a \hyperlink{group__key}{Key} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_aec0910bf293db33deac6a3f81359cb48}{\index{kdb\+::\+Key@{kdb\+::\+Key}!copy\+All\+Meta@{copy\+All\+Meta}}
\index{copy\+All\+Meta@{copy\+All\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{copy\+All\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::copy\+All\+Meta (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_aec0910bf293db33deac6a3f81359cb48}


Do a shallow copy of all meta data from source to dest. 

The key dest will additionally have all meta data the source had. Meta data not present in source will not be changed. Meta data which was present in source and dest will be overwritten.

For example the meta data type is copied into the \hyperlink{classkdb_1_1Key}{Key} k\+:


\begin{DoxyCodeInclude}
\textcolor{keywordtype}{void} l (\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * k)
\{
        \textcolor{comment}{// receive c}
        \hyperlink{group__keymeta_ga8e63720a65610a29597494d0671f9401}{keyCopyAllMeta} (k, c);
        \textcolor{comment}{// the caller will see the changed key k}
        \textcolor{comment}{// with all the metadata from c}
\}
\end{DoxyCodeInclude}
 The main purpose of this function is for plugins or applications which want to add the same meta data to n keys. When you do that with \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()} it will take n times the memory for the key. This can be considerable amount of memory for many keys with some meta data for each.

To avoid that problem you can use \hyperlink{group__keymeta_ga8e63720a65610a29597494d0671f9401}{key\+Copy\+All\+Meta()} or \hyperlink{group__keymeta_ga9a22b992478e613c8788bd460b4a1f0c}{key\+Copy\+Meta()}\+:


\begin{DoxyCodeInclude}
\textcolor{keywordtype}{void} o (KeySet * ks)
\{
        \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * current;
        \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * shared = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (0);
        \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{keySetMeta} (shared, \textcolor{stringliteral}{"shared1"}, \textcolor{stringliteral}{"this meta data should be shared among many keys"});
        \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{keySetMeta} (shared, \textcolor{stringliteral}{"shared2"}, \textcolor{stringliteral}{"this meta data should be shared among many keys also"});
        \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{keySetMeta} (shared, \textcolor{stringliteral}{"shared3"}, \textcolor{stringliteral}{"this meta data should be shared among many keys too"});

        \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ksRewind} (ks);
        \textcolor{keywordflow}{while} ((current = \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ksNext} (ks)) != 0)
        \{
                \textcolor{keywordflow}{if} (needsSharedData (current)) \hyperlink{group__keymeta_ga8e63720a65610a29597494d0671f9401}{keyCopyAllMeta} (current, shared);
        \}

        \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (shared);
\}
\end{DoxyCodeInclude}
 \begin{DoxyPostcond}{Postcondition}
for every meta\+Name present in source\+: key\+Get\+Meta(source, meta\+Name) == key\+Get\+Meta(dest, meta\+Name)
\end{DoxyPostcond}

\begin{DoxyRetVals}{Return values}
{\em 1} & if was successfully copied \\
\hline
{\em 0} & if source did not have any meta data \\
\hline
{\em -\/1} & on null pointer of dest or source \\
\hline
{\em -\/1} & on memory problems \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em dest} & the destination where the meta data should be copied too \\
\hline
{\em source} & the key where the meta data should be copied from\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}{get\+Meta()}, \hyperlink{classkdb_1_1Key_a4c5a3d463127ade0b766c4298002daa3}{set\+Meta()}, \hyperlink{classkdb_1_1Key_a53f6d2196a7f17c4bdc544207bdc5f4c}{copy\+Meta()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a53f6d2196a7f17c4bdc544207bdc5f4c}{\index{kdb\+::\+Key@{kdb\+::\+Key}!copy\+Meta@{copy\+Meta}}
\index{copy\+Meta@{copy\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{copy\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::copy\+Meta (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{other, }
\item[{const std\+::string \&}]{meta\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a53f6d2196a7f17c4bdc544207bdc5f4c}


Do a shallow copy of meta data from source to dest. 

The key dest will have the same meta data referred with meta\+Name afterwards then source.

For example the meta data type is copied into the \hyperlink{classkdb_1_1Key}{Key} k.


\begin{DoxyCode}
\textcolor{keywordtype}{void} l(\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k)
\{
        \textcolor{comment}{// receive c}
        \hyperlink{group__keymeta_ga9a22b992478e613c8788bd460b4a1f0c}{keyCopyMeta}(k, c, \textcolor{stringliteral}{"type"});
        \textcolor{comment}{// the caller will see the changed key k}
        \textcolor{comment}{// with the metadata "type" from c}
\}
\end{DoxyCode}


The main purpose of this function is for plugins or applications which want to add the same meta data to n keys. When you do that with \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()} it will take n times the memory for the key. This can be considerable amount of memory for many keys with some meta data for each.

To avoid that problem you can use \hyperlink{group__keymeta_ga8e63720a65610a29597494d0671f9401}{key\+Copy\+All\+Meta()} or \hyperlink{group__keymeta_ga9a22b992478e613c8788bd460b4a1f0c}{key\+Copy\+Meta()}.


\begin{DoxyCode}
\textcolor{keywordtype}{void} o(KeySet *ks)
\{
        \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *current;
        \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *shared = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (0);
        \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{keySetMeta}(shared, \textcolor{stringliteral}{"shared"}, \textcolor{stringliteral}{"this meta data should be shared among many keys"});

        \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ksRewind}(ks);
        \textcolor{keywordflow}{while} ((current = \hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ksNext}(ks)) != 0)
        \{
                \textcolor{keywordflow}{if} (needs\_shared\_data(current)) \hyperlink{group__keymeta_ga9a22b992478e613c8788bd460b4a1f0c}{keyCopyMeta}(current, shared, \textcolor{stringliteral}{"shared"});
        \}
\}
\end{DoxyCode}


\begin{DoxyPostcond}{Postcondition}
key\+Get\+Meta(source, meta\+Name) == key\+Get\+Meta(dest, meta\+Name)
\end{DoxyPostcond}

\begin{DoxyRetVals}{Return values}
{\em 1} & if was successfully copied \\
\hline
{\em 0} & if the meta data in dest was removed too \\
\hline
{\em -\/1} & on null pointers (source or dest) \\
\hline
{\em -\/1} & on memory problems \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em dest} & the destination where the meta data should be copied too \\
\hline
{\em source} & the key where the meta data should be copied from \\
\hline
{\em meta\+Name} & the name of the meta data which should be copied\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}{get\+Meta()}, \hyperlink{classkdb_1_1Key_a4c5a3d463127ade0b766c4298002daa3}{set\+Meta()}, \hyperlink{classkdb_1_1Key_aec0910bf293db33deac6a3f81359cb48}{copy\+All\+Meta()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a2be586ccd64cd280561ba5cd23f6ff1e}{\index{kdb\+::\+Key@{kdb\+::\+Key}!current\+Meta@{current\+Meta}}
\index{current\+Meta@{current\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{current\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Key} kdb\+::\+Key\+::current\+Meta (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a2be586ccd64cd280561ba5cd23f6ff1e}


Returns the Value of a Meta-\/\+Information which is current. 

The pointer is N\+U\+L\+L if you reached the end or after \hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()}.

\begin{DoxyNote}{Note}
You must not delete or change the returned key, use \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()} if you want to delete or change it.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a buffer to the value pointed by {\ttfamily key's} cursor 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()}, \hyperlink{group__keymeta_ga5dbb669802eea27e106ee3a5e39717a9}{key\+Rewind\+Meta()}

\hyperlink{group__keyset_ga4287b9416912c5f2ab9c195cb74fb094}{ks\+Current()} for pedant in iterator interface of \hyperlink{classkdb_1_1KeySet}{Key\+Set}
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
that the key will be null if last meta data is found.
\end{DoxyNote}

\begin{DoxyCode}
k.rewindMeta();
\textcolor{keywordflow}{while} (meta = k.nextMeta())
\{
        cout << meta.getName() << \textcolor{stringliteral}{" "} << meta.getString() << endl;
\}
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_adf6171b76e01c2b84c6050d43673dd97}{rewind\+Meta()}, \hyperlink{classkdb_1_1Key_a855f37fef58a4ea4006d9e281f66cfe1}{next\+Meta()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a2305da805095605aca38d53f2733fb57}{\index{kdb\+::\+Key@{kdb\+::\+Key}!del\+Meta@{del\+Meta}}
\index{del\+Meta@{del\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{del\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::del\+Meta (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{meta\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a2305da805095605aca38d53f2733fb57}


Delete metadata for key. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_a4c5a3d463127ade0b766c4298002daa3}{set\+Meta()}, \hyperlink{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}{get\+Meta()}, \hyperlink{classkdb_1_1Key_a53f6d2196a7f17c4bdc544207bdc5f4c}{copy\+Meta()}, \hyperlink{classkdb_1_1Key_aec0910bf293db33deac6a3f81359cb48}{copy\+All\+Meta()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a43a1f28d7a0d40f0ded8473d480931ff}{\index{kdb\+::\+Key@{kdb\+::\+Key}!dup@{dup}}
\index{dup@{dup}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{dup}]{\setlength{\rightskip}{0pt plus 5cm}ckdb\+::\+Key $\ast$ kdb\+::\+Key\+::dup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a43a1f28d7a0d40f0ded8473d480931ff}


Return a duplicate of a key. 

Memory will be allocated as needed for dynamic properties.

The new key will not be member of any \hyperlink{classkdb_1_1KeySet}{Key\+Set} and will start with a new reference counter at 0. A subsequent \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} will delete the key.


\begin{DoxyCode}
\textcolor{keywordtype}{int} f (\textcolor{keyword}{const} \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * source)
\{
        \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * \hyperlink{classkdb_1_1Key_a43a1f28d7a0d40f0ded8473d480931ff}{dup} = \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{keyDup} (source);
        \textcolor{comment}{// work with duplicate}
        \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (dup);
        \textcolor{comment}{// everything related to dup is freed}
        \textcolor{comment}{// and source is unchanged}
\}
\end{DoxyCode}


Like for a new key after \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} a subsequent \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()} makes a \hyperlink{classkdb_1_1KeySet}{Key\+Set} to take care of the lifecycle of the key.


\begin{DoxyCode}
\textcolor{keywordtype}{int} g (\textcolor{keyword}{const} \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * source, KeySet * ks)
\{
        \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * \hyperlink{classkdb_1_1Key_a43a1f28d7a0d40f0ded8473d480931ff}{dup} = \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{keyDup} (source);
        \textcolor{comment}{// work with duplicate}
        \hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ksAppendKey} (ks, dup);
        \textcolor{comment}{// ksDel(ks) will also free the duplicate}
        \textcolor{comment}{// source remains unchanged.}
\}
\end{DoxyCode}


Duplication of keys should be preferred to \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, because data like owner can be filled with a copy of the key instead of asking the environment. It can also be optimized in the checks, because the keyname is known to be valid.


\begin{DoxyParams}{Parameters}
{\em source} & has to be an initialized source \hyperlink{classkdb_1_1Key}{Key} \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & failure or on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
a fully copy of source on success 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()}, \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()}, \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get@{get}}
\index{get@{get}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ T kdb\+::\+Key\+::get (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}


Get a key value. 

You can write your own template specialication, e.\+g.\+: 
\begin{DoxyCode}
\textcolor{keyword}{template} <>
\textcolor{keyword}{inline} QColor \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{Key::get}()\textcolor{keyword}{ const}
\textcolor{keyword}{}\{
        \textcolor{keywordflow}{if} (\hyperlink{classkdb_1_1Key_af3032a91f0fbf111b6b5e42dd35865db}{getStringSize}() < 1)
        \{
                \textcolor{keywordflow}{throw} KeyTypeConversion();
        \}

        std::string str = \hyperlink{classkdb_1_1Key_afbad98e920ffb6d65d5d690be73ae6d9}{getString}();
        QColor c(str.c\_str());
        \textcolor{keywordflow}{return} c;
\}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
the string directly from the key.
\end{DoxyReturn}
It should be the same as \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get()}. \begin{DoxyReturn}{Returns}
empty string on null pointers
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Exception} & on null key or not a valid size \\
\hline
{\em Key\+Type\+Mismatch} & if key holds binary data and not a string\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
unlike in the C version, it is safe to change the returned string.
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_aa60e37609593de715c342740c76040cc}{is\+String()}, \hyperlink{classkdb_1_1Key_a16b64fd6db0a743e2e4ab08daf6fba73}{get\+Binary()}
\end{DoxySeeAlso}
This method tries to serialise the string to the given type. \hypertarget{classkdb_1_1Key_a43d3efd13e01624c520346a19984750b}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Base\+Name@{get\+Base\+Name}}
\index{get\+Base\+Name@{get\+Base\+Name}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Base\+Name}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string kdb\+::\+Key\+::get\+Base\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a43d3efd13e01624c520346a19984750b}


Returns a pointer to the internal unescaped key name where the {\ttfamily basename} starts. 

This is a much more efficient version of \hyperlink{group__keyname_ga0992d26bcfca767cb8e77053a483eb64}{key\+Get\+Base\+Name()} and you should use it if you are responsible enough to not mess up things. The name might change or even point to a wrong place after a \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()}. So make sure to copy the memory before the name changes.

\hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{key\+Base\+Name()} returns \char`\"{}\char`\"{} when there is no key\+Base\+Name. The reason is 
\begin{DoxyCodeInclude}
        \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{keySetName} (k, \textcolor{stringliteral}{""});
        succeed\_if\_same\_string (\hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{keyBaseName} (k), \textcolor{stringliteral}{""});
        \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{keySetName} (k, \textcolor{stringliteral}{"user"});
        succeed\_if\_same\_string (\hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{keyBaseName} (k), \textcolor{stringliteral}{""});
\end{DoxyCodeInclude}
 And there is also support for really empty basenames\+: 
\begin{DoxyCodeInclude}
        \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{keySetName} (k, \textcolor{stringliteral}{"system/valid"});
        succeed\_if (\hyperlink{group__keyname_gaa942091fc4bd5c2699e49ddc50829524}{keyAddBaseName} (k, \textcolor{stringliteral}{""}) >= 0, \textcolor{stringliteral}{"could not add a base name"});
        succeed\_if\_same\_string (\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (k), \textcolor{stringliteral}{"system/valid/%"});
        succeed\_if\_same\_string (\hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{keyBaseName} (k), \textcolor{stringliteral}{""});
\end{DoxyCodeInclude}
 \begin{DoxyNote}{Note}
You must never use the pointer returned by \hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{key\+Base\+Name()} method to change the name, but you should use \hyperlink{group__keyname_ga6e804bd453f98c28b0ff51430d1df407}{key\+Set\+Base\+Name()} instead.

Do not assume that \hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{key\+Base\+Name()} points to the same region as \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} does.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the object to obtain the basename from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the basename 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em \char`\"{}\char`\"{}} & when the key has no (base)name \\
\hline
{\em 0} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname_ga0992d26bcfca767cb8e77053a483eb64}{key\+Get\+Base\+Name()}, \hyperlink{group__keyname_ga1a0b76c5d9e5367c7e72211e6c63d43a}{key\+Get\+Base\+Name\+Size()} 

\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} to \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} a pointer to the name 

\hyperlink{owner_8c_af6485fb8599714b6bbd830cf915ffea5}{key\+Owner()} to \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} a pointer to the owner 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a92fde543f3fbfaa0f8af80dad12a9fe7}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Base\+Name\+Size@{get\+Base\+Name\+Size}}
\index{get\+Base\+Name\+Size@{get\+Base\+Name\+Size}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Base\+Name\+Size}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t kdb\+::\+Key\+::get\+Base\+Name\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a92fde543f3fbfaa0f8af80dad12a9fe7}


Calculates number of bytes needed to store basename of {\ttfamily key}. 

\hyperlink{classkdb_1_1Key}{Key} names that have only root names (e.\+g. {\ttfamily \char`\"{}system\char`\"{}} or {\ttfamily \char`\"{}user\char`\"{}} or {\ttfamily \char`\"{}user\+:domain\char`\"{}} ) does not have basenames, thus the function will return 1 bytes to store \char`\"{}\char`\"{}.

Basenames are denoted as\+:
\begin{DoxyItemize}
\item {\ttfamily system/some/thing/basename} -\/$>$ {\ttfamily basename} 
\item {\ttfamily user\+:domain/some/thing/base\textbackslash{}/name} $>$ {\ttfamily base\textbackslash{}/name} 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
size in bytes of {\ttfamily key's} basename including ending N\+U\+L\+L 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{key\+Base\+Name()}, \hyperlink{group__keyname_ga0992d26bcfca767cb8e77053a483eb64}{key\+Get\+Base\+Name()} 

\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()}, \hyperlink{group__keyname_gab29a850168d9b31c9529e90cf9ab68be}{key\+Get\+Name()}, \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a16b64fd6db0a743e2e4ab08daf6fba73}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Binary@{get\+Binary}}
\index{get\+Binary@{get\+Binary}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Binary}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string kdb\+::\+Key\+::get\+Binary (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a16b64fd6db0a743e2e4ab08daf6fba73}


Get the value of a key as a binary. 

\begin{DoxyReturn}{Returns}
the binary Value of the key.
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em \char`\"{}\char`\"{}} & on null pointers (size == 0) and on data only containing \textbackslash{}0\\
\hline
\end{DoxyRetVals}
\begin{DoxyNote}{Note}
if you need to distinguish between null pointers and data containing \textbackslash{}0 you can use \hyperlink{classkdb_1_1Key_a3e0bbc6b746b89db7abb73a4cc2fff39}{get\+Value()}.
\end{DoxyNote}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Exception} & on invalid binary size \\
\hline
{\em Key\+Type\+Mismatch} & if key is string and not a binary\\
\hline
\end{DoxyExceptions}
If the type is not binary -\/1 will be returned.

When the binary data is empty (this is not the same as \char`\"{}\char`\"{}!) 0 will be returned and the returned\+Binary will not be changed.

For string values see \hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()} and \hyperlink{group__keytest_gaea7670778abd07fee0fe8ac12a149190}{key\+Is\+String()}.

When the returned\+Binary is to small to hold the data (its maximum size is given by max\+Size), the returned\+Binary will not be changed and -\/1 is returned.

\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *key = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user/keyname"}, KEY\_TYPE, KEY\_TYPE\_BINARY, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\textcolor{keywordtype}{char} buffer[300];

\textcolor{keywordflow}{if} (\hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{keyGetBinary}(key,buffer,\textcolor{keyword}{sizeof}(buffer)) == -1)
\{
        \textcolor{comment}{// handle error}
\}
\end{DoxyCode}

\end{DoxyParagraph}

\begin{DoxyParams}{Parameters}
{\em key} & the object to gather the value from \\
\hline
{\em returned\+Binary} & pre-\/allocated memory to store a copy of the key value \\
\hline
{\em max\+Size} & number of bytes of pre-\/allocated memory in {\ttfamily returned\+Binary} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes actually copied to {\ttfamily returned\+Binary} 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & if the binary is empty \\
\hline
{\em -\/1} & on N\+U\+L\+L pointers \\
\hline
{\em -\/1} & if max\+Size is 0 \\
\hline
{\em -\/1} & if max\+Size is too small for string \\
\hline
{\em -\/1} & if max\+Size is larger than S\+S\+I\+Z\+E\+\_\+\+M\+A\+X \\
\hline
{\em -\/1} & on type mismatch\+: binary expected, but found string \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{key\+Value()}, \hyperlink{group__keyvalue_gae326672fffb7474abfe9baf53b73217e}{key\+Get\+Value\+Size()}, \hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{key\+Set\+Binary()} 

\hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()} and \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{key\+Set\+String()} as preferred alternative to binary 

\hyperlink{group__keytest_ga9526b371087564e43e3dff8ad0dac949}{key\+Is\+Binary()} to see how to check for binary type

\hyperlink{classkdb_1_1Key_aad92210fe2389ad950a47a4eca428574}{is\+Binary()}, \hyperlink{classkdb_1_1Key_afbad98e920ffb6d65d5d690be73ae6d9}{get\+String()}, \hyperlink{classkdb_1_1Key_a3e0bbc6b746b89db7abb73a4cc2fff39}{get\+Value()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_af173c1c4ab4104c5bc48a98cf011ca8d}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Binary\+Size@{get\+Binary\+Size}}
\index{get\+Binary\+Size@{get\+Binary\+Size}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Binary\+Size}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t kdb\+::\+Key\+::get\+Binary\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_af173c1c4ab4104c5bc48a98cf011ca8d}


Returns the number of bytes needed to store the key value, including the N\+U\+L\+L terminator. 

It returns the correct size, independent of the \hyperlink{classkdb_1_1Key}{Key} Type. If it is a binary there might be '\textbackslash{}0' values in it.

For an empty string you need one byte to store the ending N\+U\+L\+L. For that reason 1 is returned. This is not true for binary data, so there might be returned 0 too.

A binary key has no '\textbackslash{}0' termination. String types have it, so to there length will be added 1 to have enough space to store it.

This method can be used with \hyperlink{internal_8c_a35cdc2e5caed3454cb73b4fc7f37858c}{elektra\+Malloc()} before \hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()} or \hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()} is called.


\begin{DoxyCode}
\textcolor{keywordtype}{char} *buffer;
buffer = \hyperlink{internal_8c_a35cdc2e5caed3454cb73b4fc7f37858c}{elektraMalloc} (\hyperlink{group__keyvalue_gae326672fffb7474abfe9baf53b73217e}{keyGetValueSize} (key));
\textcolor{comment}{// use this buffer to store the value (binary or string)}
\textcolor{comment}{// pass keyGetValueSize (key) for maxSize}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes needed to store the key value 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & when there is no data and type is not binary \\
\hline
{\em 0} & when there is no data and type is binary \\
\hline
{\em -\/1} & on null pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()}, \hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()}, \hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{key\+Value()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_ab94686ea0b459e5a383942ec322d9c6e}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Full\+Name@{get\+Full\+Name}}
\index{get\+Full\+Name@{get\+Full\+Name}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Full\+Name}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string kdb\+::\+Key\+::get\+Full\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ab94686ea0b459e5a383942ec322d9c6e}


Get key full name, including the user domain name. 

\begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & on empty name \\
\hline
{\em -\/1} & on N\+U\+L\+L pointers \\
\hline
{\em -\/1} & if max\+Size is 0 or larger than S\+S\+I\+Z\+E\+\_\+\+M\+A\+X \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em key} & the key object \\
\hline
{\em returned\+Name} & pre-\/allocated memory to write the key name \\
\hline
{\em max\+Size} & maximum number of bytes that will fit in returned\+Name, including the final N\+U\+L\+L\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Exception} & if key is null \\
\hline
\end{DoxyExceptions}
\hypertarget{classkdb_1_1Key_a4b5c13b86402dffa0845a6044cd57b39}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Full\+Name\+Size@{get\+Full\+Name\+Size}}
\index{get\+Full\+Name\+Size@{get\+Full\+Name\+Size}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Full\+Name\+Size}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t kdb\+::\+Key\+::get\+Full\+Name\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a4b5c13b86402dffa0845a6044cd57b39}


Bytes needed to store the key name including user domain and ending N\+U\+L\+L. 


\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes needed to store key name including user domain 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & on empty name \\
\hline
{\em -\/1} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname_gaaba1494a5ffc976e0e56c43f4334a23c}{key\+Get\+Full\+Name()}, \hyperlink{group__keyname_gabdbcfa51ed8a387e47ead207affa2d2e}{key\+Get\+Name\+Size()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a9e4f81dae7370976dad75030e8c0d084}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Func@{get\+Func}}
\index{get\+Func@{get\+Func}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Func}]{\setlength{\rightskip}{0pt plus 5cm}Key\+::func\+\_\+t kdb\+::\+Key\+::get\+Func (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a9e4f81dae7370976dad75030e8c0d084}


Elektra can store function pointers as binary. 

This function returns such a function pointer.


\begin{DoxyExceptions}{Exceptions}
{\em Key\+Type\+Mismatch} & if no binary data found, or binary data has not correct length\\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
a function pointer stored with \hyperlink{classkdb_1_1Key_af7211129a4b95f4d1e335dcd06e9bf0a}{set\+Binary()} 
\end{DoxyReturn}
\hypertarget{classkdb_1_1Key_ae81381365a7c159f070e74a7b7bd8688}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Key@{get\+Key}}
\index{get\+Key@{get\+Key}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Key}]{\setlength{\rightskip}{0pt plus 5cm}ckdb\+::\+Key $\ast$ kdb\+::\+Key\+::get\+Key (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ae81381365a7c159f070e74a7b7bd8688}


Passes out the raw key pointer. 

This pointer can be used to directly change the underlying key object.

\begin{DoxyNote}{Note}
that the ownership remains in the object 
\end{DoxyNote}
\hypertarget{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Meta@{get\+Meta}}
\index{get\+Meta@{get\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ T kdb\+::\+Key\+::get\+Meta (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{meta\+Name}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}


Returns the Value of a Meta-\/\+Information given by name. 

This is a much more efficient version of \hyperlink{group__keymeta_ga9ed3875495ddb3d8a8d29158a60a147c}{key\+Get\+Meta()}. But unlike with key\+Get\+Meta you are not allowed to modify the resulting string.


\begin{DoxyCode}
\textcolor{keywordtype}{int} f(\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k)
\{
        \textcolor{keywordflow}{if} (!strcmp(\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{keyValue}(\hyperlink{group__keymeta_ga9ed3875495ddb3d8a8d29158a60a147c}{keyGetMeta}(k, \textcolor{stringliteral}{"type"})), \textcolor{stringliteral}{"boolean"}))
        \{
                \textcolor{comment}{// the type of the key is boolean}
        \}
\}
\end{DoxyCode}


\begin{DoxyNote}{Note}
You must not delete or change the returned key, use \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()} if you want to delete or change it.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em meta\+Name} & the name of the meta information you want the value from \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & if the key or meta\+Name is 0 \\
\hline
{\em 0} & if no such meta\+Name is found \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
value of Meta-\/\+Information if Meta-\/\+Information is found 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keymeta_ga9ed3875495ddb3d8a8d29158a60a147c}{key\+Get\+Meta()}, \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()}
\end{DoxySeeAlso}
You can specify your own template specialisation\+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<>
\textcolor{keyword}{inline} yourtype \hyperlink{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}{Key::getMeta}(\textcolor{keyword}{const} std::string &name)\textcolor{keyword}{ const}
\textcolor{keyword}{}\{
        yourtype x;
        std::string str;
        str = std::string(
                static\_cast<const char*>(
                        \hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{ckdb::keyValue}(
                                \hyperlink{group__keymeta_ga9ed3875495ddb3d8a8d29158a60a147c}{ckdb::keyGetMeta}(key, name.c\_str())
                                )
                        )
                );
        \textcolor{keywordflow}{return} yourconversion(str);
\}
\end{DoxyCode}



\begin{DoxyExceptions}{Exceptions}
{\em Key\+Type\+Conversion} & if meta data could not be parsed\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
No exception will be thrown if a const \hyperlink{classkdb_1_1Key}{Key} or char$\ast$ is requested, but don't forget the const\+: get\+Meta$<$const Key$>$, otherwise you will get an compiler error.
\end{DoxyNote}
If no meta is available\+:
\begin{DoxyItemize}
\item char$\ast$ is null (evaluates to 0)
\item const \hyperlink{classkdb_1_1Key}{Key} is null (evaluate to false)
\item otherwise the default constructed type will be returned \begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_abb2c472e514ecef5fedb63ecae7c0f54}{has\+Meta}

\hyperlink{classkdb_1_1Key_a2305da805095605aca38d53f2733fb57}{del\+Meta()}, \hyperlink{classkdb_1_1Key_a4c5a3d463127ade0b766c4298002daa3}{set\+Meta()}, \hyperlink{classkdb_1_1Key_a53f6d2196a7f17c4bdc544207bdc5f4c}{copy\+Meta()}, \hyperlink{classkdb_1_1Key_aec0910bf293db33deac6a3f81359cb48}{copy\+All\+Meta()} 
\end{DoxySeeAlso}

\end{DoxyItemize}\hypertarget{classkdb_1_1Key_aa3903afe9a4b7aebf427a74612a803cd}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Name@{get\+Name}}
\index{get\+Name@{get\+Name}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Name}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string kdb\+::\+Key\+::get\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_aa3903afe9a4b7aebf427a74612a803cd}


Returns a pointer to the abbreviated real internal {\ttfamily key} name. 

This is a much more efficient version of \hyperlink{group__keyname_gab29a850168d9b31c9529e90cf9ab68be}{key\+Get\+Name()} and can use it if you are responsible enough to not mess up things. You are not allowed to change anything in the returned array. The content of that string may change after \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()} and similar functions. If you need a copy of the name, consider using \hyperlink{group__keyname_gab29a850168d9b31c9529e90cf9ab68be}{key\+Get\+Name()}.

The name will be without owner, see \hyperlink{group__keyname_gaaba1494a5ffc976e0e56c43f4334a23c}{key\+Get\+Full\+Name()} if you need the name with its owner.


\begin{DoxyRetVals}{Return values}
{\em \char`\"{}\char`\"{}} & when there is no key\+Name. The reason is 
\begin{DoxyCode}
key=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(0);
\hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{keySetName}(key,\textcolor{stringliteral}{""});
\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName}(key); \textcolor{comment}{// you would expect "" here}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel}(key);
\end{DoxyCode}
\\
\hline
\end{DoxyRetVals}
Valid key names are\+:


\begin{DoxyItemize}
\item {\ttfamily spec/something} for specification of other keys.
\item {\ttfamily proc/something} for in-\/memory keys, e.\+g. commandline.
\item {\ttfamily dir/something} for dir keys in current working directory
\item {\ttfamily system/something} for system keys in /etc or /
\item {\ttfamily user/something} for user keys in home directory
\item {\ttfamily user\+:username/something} for other users (deprecated\+: \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} + \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdb\+Set()} currently unsupported)
\item {\ttfamily /something} for cascading keys (actually refers to one of the above, see also \hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()})

\begin{DoxyNote}{Note}
Note that the \hyperlink{classkdb_1_1Key}{Key} structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} method to set a new value. Use \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()} instead.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the keyname which must not be changed. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em \char`\"{}\char`\"{}} & when there is no (a empty) keyname \\
\hline
{\em 0} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname_gabdbcfa51ed8a387e47ead207affa2d2e}{key\+Get\+Name\+Size()} for the string length 

\hyperlink{group__keyname_gaaba1494a5ffc976e0e56c43f4334a23c}{key\+Get\+Full\+Name()}, \hyperlink{group__keyname_gab65dc9d43d3ee08d5e936a20ebbddd23}{key\+Get\+Full\+Name\+Size()} to \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} the full name 

\hyperlink{group__keyname_gab29a850168d9b31c9529e90cf9ab68be}{key\+Get\+Name()} as alternative to \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} a \hyperlink{classkdb_1_1Key_ab5bc93e22f4cf40b9d2b1fc32cc260be}{copy} 

\hyperlink{owner_8c_af6485fb8599714b6bbd830cf915ffea5}{key\+Owner()} to \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} a pointer to owner 

\hyperlink{group__keyname_ga6fe6af4c27b35d911a533f4ae4d698bb}{key\+Unescaped\+Name} to \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} an unescaped \hyperlink{group__key}{Key} name
\end{DoxySeeAlso}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Exception} & if key is null\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
unlike in the C version, it is safe to change the returned string. 
\end{DoxyNote}

\end{DoxyItemize}\hypertarget{classkdb_1_1Key_aee1d42f22eda4d84d78ab72cd60cc005}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Name\+Size@{get\+Name\+Size}}
\index{get\+Name\+Size@{get\+Name\+Size}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Name\+Size}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t kdb\+::\+Key\+::get\+Name\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_aee1d42f22eda4d84d78ab72cd60cc005}


Bytes needed to store the key name without owner. 

For an empty key name you need one byte to store the ending N\+U\+L\+L. For that reason 1 is returned.


\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes needed, including ending N\+U\+L\+L, to store key name without owner 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & if there is is no key Name \\
\hline
{\em -\/1} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname_gab29a850168d9b31c9529e90cf9ab68be}{key\+Get\+Name()}, \hyperlink{group__keyname_gab65dc9d43d3ee08d5e936a20ebbddd23}{key\+Get\+Full\+Name\+Size()} 

\hyperlink{group__keyname_ga5e7eff0c77678420199d0d2e8729152b}{key\+Get\+Unescaped\+Name\+Size} to \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get} size of unescaped name 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a2cf2b97f404d5808f46a9a5c4b8b93e1}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Namespace@{get\+Namespace}}
\index{get\+Namespace@{get\+Namespace}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Namespace}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string kdb\+::\+Key\+::get\+Namespace (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a2cf2b97f404d5808f46a9a5c4b8b93e1}
\begin{DoxyReturn}{Returns}
namespace as string
\end{DoxyReturn}
Will return slash for cascading names.

\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_aa3903afe9a4b7aebf427a74612a803cd}{get\+Name()}, \hyperlink{classkdb_1_1Key_ab6103772c702b400eaefbc4665f5c0cf}{is\+User()}, \hyperlink{classkdb_1_1Key_ac0f21b82a3d851eb3dfae53ddcfdbe48}{is\+System()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a213fb46e13b669cc862fce06ac361b79}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Reference\+Counter@{get\+Reference\+Counter}}
\index{get\+Reference\+Counter@{get\+Reference\+Counter}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Reference\+Counter}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t kdb\+::\+Key\+::get\+Reference\+Counter (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a213fb46e13b669cc862fce06ac361b79}


Return how many references the key has. 

The reference counting is the essential property of keys to make sure that they can be put safely into data structures. E.\+g. if you put a \hyperlink{classkdb_1_1Key}{Key} into a \hyperlink{classkdb_1_1KeySet}{Key\+Set}\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/proper\_name"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}); \textcolor{comment}{// ref counter = 0}
KeySet *ks = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew} (1, k, \hyperlink{kdbenum_8c_a7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel}(k); \textcolor{comment}{// key will not be deleted, because its in the keyset}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel}(ks); \textcolor{comment}{// now the key will be deleted}
\end{DoxyCodeInclude}
 You can even add the key to more Key\+Sets\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/proper\_name"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}); \textcolor{comment}{// ref counter 0}
KeySet *ks1 = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew}(1, k, \hyperlink{kdbenum_8c_a7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END}); \textcolor{comment}{// ref counter of k 1}
KeySet *ks2 = \hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew}(1, k, \hyperlink{kdbenum_8c_a7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END}); \textcolor{comment}{// ref counter of k 2}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel}(ks1); \textcolor{comment}{// ref counter of k 1}
\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel}(ks2); \textcolor{comment}{// k is now deleted}
\end{DoxyCodeInclude}
 If you increment only by one with \hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()} the same as said above is valid\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(0); \textcolor{comment}{// ref counter = 0}
\hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{keyIncRef}(k); \textcolor{comment}{// ref counter = 1}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel}(k); \textcolor{comment}{// key will not be deleted}
\hyperlink{group__key_ga2c6433ca22109e4e141946057eccb283}{keyDecRef}(k);
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel}(k);
\end{DoxyCodeInclude}
 or use \hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()} more than once\+:


\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(0); \textcolor{comment}{// ref counter 0}
\hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{keyIncRef}(k); \textcolor{comment}{// ref counter of key 1}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);   \textcolor{comment}{// has no effect}
\hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{keyIncRef}(k); \textcolor{comment}{// ref counter of key 2}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);   \textcolor{comment}{// has no effect}
\hyperlink{group__key_ga2c6433ca22109e4e141946057eccb283}{keyDecRef}(k); \textcolor{comment}{// ref counter of key 1}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);   \textcolor{comment}{// has no effect}
\hyperlink{group__key_ga2c6433ca22109e4e141946057eccb283}{keyDecRef}(k); \textcolor{comment}{// ref counter is now 0}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k); \textcolor{comment}{// k is now deleted}
\end{DoxyCodeInclude}
 The key won't be deleted by a \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} as long refcounter is not 0.

The references will be incremented on successful calls to \hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()} or \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()}.

\begin{DoxyNote}{Note}
\hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} will reset the references for dupped key.
\end{DoxyNote}
For your own applications you can use \hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()} and \hyperlink{group__key_ga2c6433ca22109e4e141946057eccb283}{key\+Dec\+Ref()} for reference counting, too.


\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of references 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on null pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()} and \hyperlink{group__key_ga2c6433ca22109e4e141946057eccb283}{key\+Dec\+Ref()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_afbad98e920ffb6d65d5d690be73ae6d9}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+String@{get\+String}}
\index{get\+String@{get\+String}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+String}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string kdb\+::\+Key\+::get\+String (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_afbad98e920ffb6d65d5d690be73ae6d9}
\begin{DoxyReturn}{Returns}
the string directly from the key.
\end{DoxyReturn}
It should be the same as \hyperlink{classkdb_1_1Key_a0916e2e6be60b5c591bae56e250ed693}{get()}. \begin{DoxyReturn}{Returns}
empty string on null pointers
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Exception} & on null key or not a valid size \\
\hline
{\em Key\+Type\+Mismatch} & if key holds binary data and not a string\\
\hline
\end{DoxyExceptions}
\begin{DoxyNote}{Note}
unlike in the C version, it is safe to change the returned string.
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_aa60e37609593de715c342740c76040cc}{is\+String()}, \hyperlink{classkdb_1_1Key_a16b64fd6db0a743e2e4ab08daf6fba73}{get\+Binary()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_af3032a91f0fbf111b6b5e42dd35865db}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+String\+Size@{get\+String\+Size}}
\index{get\+String\+Size@{get\+String\+Size}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+String\+Size}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t kdb\+::\+Key\+::get\+String\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_af3032a91f0fbf111b6b5e42dd35865db}


Returns the number of bytes needed to store the key value, including the N\+U\+L\+L terminator. 

It returns the correct size, independent of the \hyperlink{classkdb_1_1Key}{Key} Type. If it is a binary there might be '\textbackslash{}0' values in it.

For an empty string you need one byte to store the ending N\+U\+L\+L. For that reason 1 is returned. This is not true for binary data, so there might be returned 0 too.

A binary key has no '\textbackslash{}0' termination. String types have it, so to there length will be added 1 to have enough space to store it.

This method can be used with \hyperlink{internal_8c_a35cdc2e5caed3454cb73b4fc7f37858c}{elektra\+Malloc()} before \hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()} or \hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()} is called.


\begin{DoxyCode}
\textcolor{keywordtype}{char} *buffer;
buffer = \hyperlink{internal_8c_a35cdc2e5caed3454cb73b4fc7f37858c}{elektraMalloc} (\hyperlink{group__keyvalue_gae326672fffb7474abfe9baf53b73217e}{keyGetValueSize} (key));
\textcolor{comment}{// use this buffer to store the value (binary or string)}
\textcolor{comment}{// pass keyGetValueSize (key) for maxSize}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes needed to store the key value 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & when there is no data and type is not binary \\
\hline
{\em 0} & when there is no data and type is binary \\
\hline
{\em -\/1} & on null pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()}, \hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()}, \hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{key\+Value()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a3e0bbc6b746b89db7abb73a4cc2fff39}{\index{kdb\+::\+Key@{kdb\+::\+Key}!get\+Value@{get\+Value}}
\index{get\+Value@{get\+Value}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{get\+Value}]{\setlength{\rightskip}{0pt plus 5cm}const void $\ast$ kdb\+::\+Key\+::get\+Value (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a3e0bbc6b746b89db7abb73a4cc2fff39}


Return a pointer to the real internal {\ttfamily key} value. 

This is a much more efficient version of \hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()} \hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()}, and you should use it if you are responsible enough to not mess up things. You are not allowed to modify anything in the returned string. If you need a copy of the Value, consider to use \hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()} or \hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()} instead.\hypertarget{group__keyvalue_string}{}\subsection{String Handling}\label{group__keyvalue_string}
If {\ttfamily key} is string (\hyperlink{group__keytest_gaea7670778abd07fee0fe8ac12a149190}{key\+Is\+String()}), you may cast the returned as a {\ttfamily \char`\"{}char $\ast$\char`\"{}} because you'll get a N\+U\+L\+L terminated regular string.

\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{key\+Value()} returns \char`\"{}\char`\"{} in string mode when there is no value. The reason is 
\begin{DoxyCode}
key=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(0);
\hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{keySetString}(key,\textcolor{stringliteral}{""});
\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{keyValue}(key); \textcolor{comment}{// you would expect "" here}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel}(key);
\end{DoxyCode}
\hypertarget{group__keyvalue_binary}{}\subsection{Binary Data Handling}\label{group__keyvalue_binary}
If the data is binary, the size of the value must be determined by \hyperlink{group__keyvalue_gae326672fffb7474abfe9baf53b73217e}{key\+Get\+Value\+Size()}, any strlen() operations are not suitable to determine the size.

\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{key\+Value()} returns 0 in binary mode when there is no value. The reason is 
\begin{DoxyCode}
key=\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(0);
\hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{keySetBinary}(key, 0, 0);
\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{keyValue}(key); \textcolor{comment}{// you would expect 0 here}

\hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{keySetBinary}(key,\textcolor{stringliteral}{""}, 1);
\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{keyValue}(key); \textcolor{comment}{// you would expect "" (a pointer to '\(\backslash\)0') here}

\textcolor{keywordtype}{int} i=23;
\hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{keySetBinary}(key, (\textcolor{keywordtype}{void}*)&i, 4);
(\textcolor{keywordtype}{int}*)\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{keyValue}(key); \textcolor{comment}{// you would expect a pointer to (int)23 here}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel}(key);
\end{DoxyCode}


\begin{DoxyNote}{Note}
Note that the \hyperlink{classkdb_1_1Key}{Key} structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by \hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{key\+Value()} method to set a new value. Use \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{key\+Set\+String()} or \hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{key\+Set\+Binary()} instead.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
Binary keys will return a N\+U\+L\+L pointer when there is no data in contrast to \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()}, \hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{key\+Base\+Name()}, \hyperlink{owner_8c_af6485fb8599714b6bbd830cf915ffea5}{key\+Owner()} and \hyperlink{group__meta_gac89fd319783b3457db45b4c09e55274a}{key\+Comment()}. For string value the behaviour is the same.
\end{DoxyWarning}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCode}
KDB *handle = \hyperlink{group__kdb_ga6808defe5870f328dd17910aacbdc6ca}{kdbOpen}();
KeySet *ks=\hyperlink{group__keyset_ga671e1aaee3ae9dc13b4834a4ddbd2c3c}{ksNew}(0, \hyperlink{kdbenum_8c_a7a28fce3773b2c873c94ac80b8b4cd54}{KS\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *current=0;

kdbGetByName(handle,ks,\textcolor{stringliteral}{"system/sw/my"},\hyperlink{group__keyset_gga98a3d6a4016c9dad9cbd1a99a9c2a45aad9d03b36ee88ca5a774cc01b190c99b8}{KDB\_O\_SORT}|KDB\_O\_RECURSIVE);

\hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ksRewind}(ks);
\textcolor{keywordflow}{while} (current=\hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ksNext}(ks)) \{
        \textcolor{keywordtype}{size\_t} size=0;
        
        \textcolor{keywordflow}{if} (keyIsBin(current)) \{
                size=\hyperlink{group__keyvalue_gae326672fffb7474abfe9baf53b73217e}{keyGetValueSize}(current);
                printf(\textcolor{stringliteral}{"Key %s has a value of size %d bytes. Value: <BINARY>\(\backslash\)nComment: %s"},
                        \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName}(current),
                        size,
                        \hyperlink{group__meta_gac89fd319783b3457db45b4c09e55274a}{keyComment}(current));
        \} \textcolor{keywordflow}{else} \{
                size=\hyperlink{internal_8c_afd676487565d083a6ad5a1381095acd8}{elektraStrLen}((\textcolor{keywordtype}{char} *)\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{keyValue}(current));
                printf(\textcolor{stringliteral}{"Key %s has a value of size %d bytes. Value: %s\(\backslash\)nComment: %s"},
                        \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName}(current),
                        size,
                        (\textcolor{keywordtype}{char} *)\hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{keyValue}(current),
                        \hyperlink{group__meta_gac89fd319783b3457db45b4c09e55274a}{keyComment}(current));
        \}
\}

\hyperlink{group__keyset_ga27e5c16473b02a422238c8d970db7ac8}{ksDel} (ks);
\hyperlink{group__kdb_gadb54dc9fda17ee07deb9444df745c96f}{kdbClose} (handle);
\end{DoxyCode}

\end{DoxyParagraph}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to internal value 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em \char`\"{}\char`\"{}} & when there is no data and key is not binary \\
\hline
{\em 0} & where there is no data and key is binary \\
\hline
{\em 0} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_gae326672fffb7474abfe9baf53b73217e}{key\+Get\+Value\+Size()}, \hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()}, \hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()}
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
the value of the key 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_a16b64fd6db0a743e2e4ab08daf6fba73}{get\+Binary()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_abb2c472e514ecef5fedb63ecae7c0f54}{\index{kdb\+::\+Key@{kdb\+::\+Key}!has\+Meta@{has\+Meta}}
\index{has\+Meta@{has\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{has\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::has\+Meta (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{meta\+Name}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_abb2c472e514ecef5fedb63ecae7c0f54}

\begin{DoxyRetVals}{Return values}
{\em true} & if there is a metadata with given name \\
\hline
{\em false} & if no such metadata exists\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}{get\+Meta()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a493893308d5b4c54d646cc0df5a076ae}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+Below@{is\+Below}}
\index{is\+Below@{is\+Below}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+Below}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+Below (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{k}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a493893308d5b4c54d646cc0df5a076ae}


Check if the key check is below the key key or not. 


\begin{DoxyParams}{Parameters}
{\em k} & the other key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if our key is below k
\end{DoxyReturn}
Example\+: \begin{DoxyVerb}key user/sw/app
check user/sw/app/key
\end{DoxyVerb}


returns true because check is below key

Example\+: \begin{DoxyVerb}key user/sw/app
check user/sw/app/folder/key
\end{DoxyVerb}


returns also true because check is indirect below key

Obviously, there is no key above a namespace (e.\+g. user, system, /)\+:

\begin{DoxyVerb}key *
check user
\end{DoxyVerb}



\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em check} & the key to find the relative position of \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & if check is below key \\
\hline
{\em 0} & if it is not below or if it is the same key \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()}, \hyperlink{group__keyname_gab29a850168d9b31c9529e90cf9ab68be}{key\+Get\+Name()}, \hyperlink{group__keytest_ga4f175aafd98948ce6c774f3bd92b72ca}{key\+Is\+Direct\+Below()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a0d4d2d50f9e3624ade560b0f74267d86}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+Below\+Or\+Same@{is\+Below\+Or\+Same}}
\index{is\+Below\+Or\+Same@{is\+Below\+Or\+Same}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+Below\+Or\+Same}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+Below\+Or\+Same (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{k}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a0d4d2d50f9e3624ade560b0f74267d86}


Check if a key is below or same or not. 


\begin{DoxyParams}{Parameters}
{\em k} & the other key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if our key is below k or the same as k
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keytest_ga03332b5d97c76a4fd2640aca4762b8df}{key\+Is\+Below()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_aad92210fe2389ad950a47a4eca428574}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+Binary@{is\+Binary}}
\index{is\+Binary@{is\+Binary}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+Binary}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+Binary (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_aad92210fe2389ad950a47a4eca428574}


Check if a key is binary type. 

The function checks if the key is a binary. Opposed to string values binary values can have '\textbackslash{}0' inside the value and may not be terminated by a null character. Their disadvantage is that you need to pass their size.

Make sure to use this function and don't test the binary type another way to ensure compatibility and to write less error prone programs.


\begin{DoxyRetVals}{Return values}
{\em 1} & if it is binary \\
\hline
{\em 0} & if it is not \\
\hline
{\em -\/1} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()}, \hyperlink{group__keyvalue_gaa50a5358fd328d373a45f395fa1b99e7}{key\+Set\+Binary()} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em key} & the key to check \\
\hline
\end{DoxyParams}
\hypertarget{classkdb_1_1Key_a3cc66b309bd42e67d7bc0e4234aa76a1}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+Direct\+Below@{is\+Direct\+Below}}
\index{is\+Direct\+Below@{is\+Direct\+Below}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+Direct\+Below}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+Direct\+Below (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{k}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a3cc66b309bd42e67d7bc0e4234aa76a1}


Check if the key check is direct below the key key or not. 


\begin{DoxyParams}{Parameters}
{\em k} & the other key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if our key is direct below k
\end{DoxyReturn}
\begin{DoxyVerb}Example:
key user/sw/app
check user/sw/app/key

returns true because check is below key

Example:
key user/sw/app
check user/sw/app/folder/key

does not return true, because there is only a indirect relation
\end{DoxyVerb}



\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em check} & the key to find the relative position of \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & if check is below key \\
\hline
{\em 0} & if it is not below or if it is the same key \\
\hline
{\em -\/1} & on null pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keytest_ga03332b5d97c76a4fd2640aca4762b8df}{key\+Is\+Below()}, \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()}, \hyperlink{group__keyname_gab29a850168d9b31c9529e90cf9ab68be}{key\+Get\+Name()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_adcd75cc13e9d766eaac72beb7d748bdb}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+Inactive@{is\+Inactive}}
\index{is\+Inactive@{is\+Inactive}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+Inactive}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+Inactive (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_adcd75cc13e9d766eaac72beb7d748bdb}


Check whether a key is inactive. 

In Elektra terminology a hierarchy of keys is inactive if the rootkey's basename starts with '.'. So a key is also inactive if it is below an inactive key. For example, user/key/.hidden is inactive and so is user/.hidden/below.

Inactive keys should not have any meaning to applications, they are only a convention reserved for users and administrators. To automatically remove all inactive keys for an application, consider to use the hidden plugin.


\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & if the key is inactive \\
\hline
{\em 0} & if the key is active \\
\hline
{\em -\/1} & on N\+U\+L\+L pointer or when key has no name \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+Null@{is\+Null}}
\index{is\+Null@{is\+Null}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+Null}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+Null (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}


Checks if C++ wrapper has an underlying key. 

\begin{DoxySeeAlso}{See also}
operator bool(), \hyperlink{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{is\+Valid()} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
true if no underlying key exists 
\end{DoxyReturn}
\hypertarget{classkdb_1_1Key_aa60e37609593de715c342740c76040cc}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+String@{is\+String}}
\index{is\+String@{is\+String}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+String}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+String (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_aa60e37609593de715c342740c76040cc}


Check if a key is string type. 

String values are null terminated and are not allowed to have any '\textbackslash{}0' characters inside the string.

Make sure to use this function and don't test the string type another way to ensure compatibility and to write less error prone programs.


\begin{DoxyRetVals}{Return values}
{\em 1} & if it is string \\
\hline
{\em 0} & if it is not \\
\hline
{\em -\/1} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()}, \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{key\+Set\+String()} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em key} & the key to check \\
\hline
\end{DoxyParams}
\hypertarget{classkdb_1_1Key_ac0f21b82a3d851eb3dfae53ddcfdbe48}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+System@{is\+System}}
\index{is\+System@{is\+System}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+System}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+System (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ac0f21b82a3d851eb3dfae53ddcfdbe48}


Name starts with \char`\"{}system\char`\"{}. 


\begin{DoxyRetVals}{Return values}
{\em true} & if it is a system key \\
\hline
{\em false} & otherwise \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_ab6103772c702b400eaefbc4665f5c0cf}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+User@{is\+User}}
\index{is\+User@{is\+User}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+User}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+User (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ab6103772c702b400eaefbc4665f5c0cf}


Name starts with \char`\"{}user\char`\"{}. 


\begin{DoxyRetVals}{Return values}
{\em true} & if it is a user key \\
\hline
{\em false} & otherwise \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{\index{kdb\+::\+Key@{kdb\+::\+Key}!is\+Valid@{is\+Valid}}
\index{is\+Valid@{is\+Valid}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{is\+Valid}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::is\+Valid (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}
\begin{DoxyReturn}{Returns}
if the key is valid
\end{DoxyReturn}
An invalid key has no name. The name of valid keys either start with user or system.


\begin{DoxyRetVals}{Return values}
{\em true} & if the key has a valid name \\
\hline
{\em false} & if the key has an invalid name\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_aa3903afe9a4b7aebf427a74612a803cd}{get\+Name()}, \hyperlink{classkdb_1_1Key_ab6103772c702b400eaefbc4665f5c0cf}{is\+User()}, \hyperlink{classkdb_1_1Key_ac0f21b82a3d851eb3dfae53ddcfdbe48}{is\+System()}, \hyperlink{classkdb_1_1Key_a2cf2b97f404d5808f46a9a5c4b8b93e1}{get\+Namespace()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_ab727b6254fec01a129d3e6ac681a5fe5}{\index{kdb\+::\+Key@{kdb\+::\+Key}!need\+Sync@{need\+Sync}}
\index{need\+Sync@{need\+Sync}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{need\+Sync}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::need\+Sync (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ab727b6254fec01a129d3e6ac681a5fe5}


Test if a key needs to be synced to backend storage. 

If any key modification took place the key will be flagged so that \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdb\+Set()} knows which keys were modified and which not.

After \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()} the flag will normally be set, but after \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} and \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdb\+Set()} the flag will be removed. When you modify the key the flag will be set again.

In your application you can make use of that flag to know if you changed something in a key after a \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} or \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdb\+Set()}.

\begin{DoxyNote}{Note}
Note that the sync status will be updated on any change, including meta data.
\end{DoxyNote}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000010}{Deprecated}]The handling of synchronization is done internally and does not need to be checked by neither application nor plugins.\end{DoxyRefDesc}


\begin{DoxySeeAlso}{See also}
after \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, \hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} keys need sync
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & if {\ttfamily key} was changed in memory, 0 otherwise \\
\hline
{\em -\/1} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_a855f37fef58a4ea4006d9e281f66cfe1}{\index{kdb\+::\+Key@{kdb\+::\+Key}!next\+Meta@{next\+Meta}}
\index{next\+Meta@{next\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{next\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Key} kdb\+::\+Key\+::next\+Meta (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a855f37fef58a4ea4006d9e281f66cfe1}


Iterate to the next meta information. 

Keys have an internal cursor that can be reset with \hyperlink{group__keymeta_ga5dbb669802eea27e106ee3a5e39717a9}{key\+Rewind\+Meta()}. Every time \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()} is called the cursor is incremented and the new current Name of Meta Information is returned.

You'll get a N\+U\+L\+L pointer if the meta information after the end of the \hyperlink{classkdb_1_1Key}{Key} was reached. On subsequent calls of \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()} it will still return the N\+U\+L\+L pointer.

The {\ttfamily key} internal cursor will be changed, so it is not const.

\begin{DoxyNote}{Note}
That the resulting key is guaranteed to have a value, because meta information has no binary or null pointer semantics.

You must not delete or change the returned key, use \hyperlink{group__keymeta_gae1f15546b234ffb6007d8a31178652b9}{key\+Set\+Meta()} if you want to delete or change it.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a key representing meta information 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & when the end is reached \\
\hline
{\em 0} & on N\+U\+L\+L pointer\\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_ga317321c9065b5a4b3e33fe1c399bcec9}{ks\+Next()} for pedant in iterator interface of \hyperlink{classkdb_1_1KeySet}{Key\+Set}

\hyperlink{classkdb_1_1Key_adf6171b76e01c2b84c6050d43673dd97}{rewind\+Meta()}, \hyperlink{classkdb_1_1Key_a2be586ccd64cd280561ba5cd23f6ff1e}{current\+Meta()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_ac203d41896988df49dd149c2a6ad91d8}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator bool@{operator bool}}
\index{operator bool@{operator bool}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator bool}]{\setlength{\rightskip}{0pt plus 5cm}kdb\+::\+Key\+::operator bool (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ac203d41896988df49dd149c2a6ad91d8}


This is for loops and lookups only. 

Opposite of \hyperlink{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{is\+Null()}

For loops it checks if there are still more keys. For lookups it checks if a key could be found.

\begin{DoxyWarning}{Warning}
you should not construct or use null keys
\end{DoxyWarning}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_a46ac7f1f28842e6edc03b2f97ae14bdc}{is\+Null()}, \hyperlink{classkdb_1_1Key_acbb13cfcabb4548177e86eec1ac16d87}{is\+Valid()} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
false on null keys 

true otherwise 
\end{DoxyReturn}
\hypertarget{classkdb_1_1Key_a313a84b686a72769ecf4c368a79d492c}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator"!=}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::operator!= (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{k}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a313a84b686a72769ecf4c368a79d492c}


Compare the name of two keys. 

\begin{DoxyReturn}{Returns}
a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.
\end{DoxyReturn}
The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

\hyperlink{group__keytest_gaf6e66e12fe04d535a5d1c8218ced803e}{key\+Cmp()} defines the sorting order for a \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

The following 3 points are the rules for null values\+:


\begin{DoxyItemize}
\item A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.
\item A null name will be found to be smaller than every other name. If both are null names, 0 is returned.
\end{DoxyItemize}

If the name is equal then\+:


\begin{DoxyItemize}
\item No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
the owner will only be used if the names are equal.
\end{DoxyNote}
Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see \hyperlink{group__keytest_ga6bb0f95ac34ce9c42d61bb35a76139d0}{key\+Rel()}.

Given any Keys k1 and k2 constructed with \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, following equation hold true\+:


\begin{DoxyCodeInclude}
\end{DoxyCodeInclude}
 Here are some more examples\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/b"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


And even more\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"markus"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"max"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


Do not strcmp the \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} yourself because the result differs from simple ascii comparison.


\begin{DoxyParams}{Parameters}
{\em k1} & the first key object to compare with \\
\hline
{\em k2} & the second key object to compare with\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}, \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()} will compare keys when appending 

\hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} will compare keys during searching
\end{DoxySeeAlso}

\begin{DoxyRetVals}{Return values}
{\em true} & != 0 \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_a6e0dd36c31cc7c46ee1cda0decc6e884}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator$\ast$}]{\setlength{\rightskip}{0pt plus 5cm}ckdb\+::\+Key $\ast$ kdb\+::\+Key\+::operator$\ast$ (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a6e0dd36c31cc7c46ee1cda0decc6e884}


Is a abbreviation for get\+Key. 

Passes out the raw key pointer. This pointer can be used to directly change the underlying key object.

\begin{DoxyNote}{Note}
that the ownership remains in the object
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_ae81381365a7c159f070e74a7b7bd8688}{get\+Key()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a31f7139c5378b3fde4dfab4955208d23}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator++@{operator++}}
\index{operator++@{operator++}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator++}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::operator++ (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a31f7139c5378b3fde4dfab4955208d23}


Increment the viability of a key object. 

This function is intended for applications using their own reference counter for key objects. With it you can increment the reference and thus avoid destruction of the object in a subsequent \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()}.

The reference counter can't be incremented once it reached S\+S\+I\+Z\+E\+\_\+\+M\+A\+X. In that situation nothing will happen and S\+S\+I\+Z\+E\+\_\+\+M\+A\+X will be returned.

\begin{DoxyNote}{Note}
\hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} will reset the references for dupped key.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
the value of the new reference counter 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on null pointer \\
\hline
{\em S\+S\+I\+Z\+E\+\_\+\+M\+A\+X} & when maximum exceeded \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga4aabc4272506dd63161db2bbb42de8ae}{key\+Get\+Ref()} for longer explanation, \hyperlink{group__key_ga2c6433ca22109e4e141946057eccb283}{key\+Dec\+Ref()}, \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_ab017ed5e104e441d86725f61439d1f24}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator++@{operator++}}
\index{operator++@{operator++}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator++}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::operator++ (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ab017ed5e104e441d86725f61439d1f24}


Increment the viability of a key object. 

This function is intended for applications using their own reference counter for key objects. With it you can increment the reference and thus avoid destruction of the object in a subsequent \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()}.

The reference counter can't be incremented once it reached S\+S\+I\+Z\+E\+\_\+\+M\+A\+X. In that situation nothing will happen and S\+S\+I\+Z\+E\+\_\+\+M\+A\+X will be returned.

\begin{DoxyNote}{Note}
\hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} will reset the references for dupped key.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
the value of the new reference counter 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on null pointer \\
\hline
{\em S\+S\+I\+Z\+E\+\_\+\+M\+A\+X} & when maximum exceeded \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga4aabc4272506dd63161db2bbb42de8ae}{key\+Get\+Ref()} for longer explanation, \hyperlink{group__key_ga2c6433ca22109e4e141946057eccb283}{key\+Dec\+Ref()}, \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_acbb63da4ab49c66c851228511c000ec7}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator-\/-\/@{operator-\/-\/}}
\index{operator-\/-\/@{operator-\/-\/}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator-\/-\/}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::operator-\/-\/ (
\begin{DoxyParamCaption}
\item[{int}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_acbb63da4ab49c66c851228511c000ec7}


Decrement the viability of a key object. 

The references will be decremented for \hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ks\+Pop()} or successful calls of \hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} with the option K\+D\+B\+\_\+\+O\+\_\+\+P\+O\+P. It will also be decremented with an following \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} in the case that an old key is replaced with another key with the same name.

The reference counter can't be decremented once it reached 0. In that situation nothing will happen and 0 will be returned.

\begin{DoxyNote}{Note}
\hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} will reset the references for dupped key.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
the value of the new reference counter 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on null pointer \\
\hline
{\em 0} & when the key is ready to be freed \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga4aabc4272506dd63161db2bbb42de8ae}{key\+Get\+Ref()} for longer explanation, \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()}, \hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_afa095fe7021b7ca01e6224b976449b3f}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator-\/-\/@{operator-\/-\/}}
\index{operator-\/-\/@{operator-\/-\/}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator-\/-\/}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::operator-\/-\/ (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_afa095fe7021b7ca01e6224b976449b3f}


Decrement the viability of a key object. 

The references will be decremented for \hyperlink{group__keyset_gae42530b04defb772059de0600159cf69}{ks\+Pop()} or successful calls of \hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} with the option K\+D\+B\+\_\+\+O\+\_\+\+P\+O\+P. It will also be decremented with an following \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()} in the case that an old key is replaced with another key with the same name.

The reference counter can't be decremented once it reached 0. In that situation nothing will happen and 0 will be returned.

\begin{DoxyNote}{Note}
\hyperlink{group__key_gae6ec6a60cc4b8c1463fa08623d056ce3}{key\+Dup()} will reset the references for dupped key.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
the value of the new reference counter 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on null pointer \\
\hline
{\em 0} & when the key is ready to be freed \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_ga4aabc4272506dd63161db2bbb42de8ae}{key\+Get\+Ref()} for longer explanation, \hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{key\+Del()}, \hyperlink{group__key_ga6970a6f254d67af7e39f8e469bb162f1}{key\+Inc\+Ref()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_ab64ec9d578e083dad3e43322535cf108}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator-\/$>$@{operator-\/$>$}}
\index{operator-\/$>$@{operator-\/$>$}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator-\/$>$}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Key} $\ast$ kdb\+::\+Key\+::operator-\/$>$ (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ab64ec9d578e083dad3e43322535cf108}
\begin{DoxyReturn}{Returns}
a pointer to this object
\end{DoxyReturn}
Needed for \hyperlink{classkdb_1_1KeySet}{Key\+Set} iterators. \begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1KeySetIterator}{Key\+Set\+Iterator} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_aace409efd393ae21f08d333f45da2769}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator$<$}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_aace409efd393ae21f08d333f45da2769}


Compare the name of two keys. 

\begin{DoxyReturn}{Returns}
a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.
\end{DoxyReturn}
The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

\hyperlink{group__keytest_gaf6e66e12fe04d535a5d1c8218ced803e}{key\+Cmp()} defines the sorting order for a \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

The following 3 points are the rules for null values\+:


\begin{DoxyItemize}
\item A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.
\item A null name will be found to be smaller than every other name. If both are null names, 0 is returned.
\end{DoxyItemize}

If the name is equal then\+:


\begin{DoxyItemize}
\item No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
the owner will only be used if the names are equal.
\end{DoxyNote}
Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see \hyperlink{group__keytest_ga6bb0f95ac34ce9c42d61bb35a76139d0}{key\+Rel()}.

Given any Keys k1 and k2 constructed with \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, following equation hold true\+:


\begin{DoxyCodeInclude}
\end{DoxyCodeInclude}
 Here are some more examples\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/b"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


And even more\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"markus"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"max"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


Do not strcmp the \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} yourself because the result differs from simple ascii comparison.


\begin{DoxyParams}{Parameters}
{\em k1} & the first key object to compare with \\
\hline
{\em k2} & the second key object to compare with\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}, \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()} will compare keys when appending 

\hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} will compare keys during searching
\end{DoxySeeAlso}

\begin{DoxyRetVals}{Return values}
{\em true} & $<$ 0 \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_a3b466f59870b989aa9ec41558bba4d19}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator$<$=}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a3b466f59870b989aa9ec41558bba4d19}


Compare the name of two keys. 

\begin{DoxyReturn}{Returns}
a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.
\end{DoxyReturn}
The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

\hyperlink{group__keytest_gaf6e66e12fe04d535a5d1c8218ced803e}{key\+Cmp()} defines the sorting order for a \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

The following 3 points are the rules for null values\+:


\begin{DoxyItemize}
\item A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.
\item A null name will be found to be smaller than every other name. If both are null names, 0 is returned.
\end{DoxyItemize}

If the name is equal then\+:


\begin{DoxyItemize}
\item No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
the owner will only be used if the names are equal.
\end{DoxyNote}
Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see \hyperlink{group__keytest_ga6bb0f95ac34ce9c42d61bb35a76139d0}{key\+Rel()}.

Given any Keys k1 and k2 constructed with \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, following equation hold true\+:


\begin{DoxyCodeInclude}
\end{DoxyCodeInclude}
 Here are some more examples\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/b"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


And even more\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"markus"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"max"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


Do not strcmp the \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} yourself because the result differs from simple ascii comparison.


\begin{DoxyParams}{Parameters}
{\em k1} & the first key object to compare with \\
\hline
{\em k2} & the second key object to compare with\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}, \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()} will compare keys when appending 

\hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} will compare keys during searching
\end{DoxySeeAlso}

\begin{DoxyRetVals}{Return values}
{\em true} & $<$= 0 \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_a628f3ee543a1d71d4488233018eddd86}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator=@{operator=}}
\index{operator=@{operator=}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Key} \& kdb\+::\+Key\+::operator= (
\begin{DoxyParamCaption}
\item[{ckdb\+::\+Key $\ast$}]{k}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a628f3ee543a1d71d4488233018eddd86}


Assign a C key. 

Will call del() on the old key. \hypertarget{classkdb_1_1Key_a63a006c140cfd2a633c6fdf3f9eb9d1a}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator=@{operator=}}
\index{operator=@{operator=}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Key} \& kdb\+::\+Key\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{k}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a63a006c140cfd2a633c6fdf3f9eb9d1a}


Assign a key. 

Will call del() on the old key. \hypertarget{classkdb_1_1Key_abaff8356eb91a6d3aed2b6d282269da2}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator==@{operator==}}
\index{operator==@{operator==}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator==}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{k}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_abaff8356eb91a6d3aed2b6d282269da2}


Compare the name of two keys. 

\begin{DoxyReturn}{Returns}
a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.
\end{DoxyReturn}
The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

\hyperlink{group__keytest_gaf6e66e12fe04d535a5d1c8218ced803e}{key\+Cmp()} defines the sorting order for a \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

The following 3 points are the rules for null values\+:


\begin{DoxyItemize}
\item A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.
\item A null name will be found to be smaller than every other name. If both are null names, 0 is returned.
\end{DoxyItemize}

If the name is equal then\+:


\begin{DoxyItemize}
\item No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
the owner will only be used if the names are equal.
\end{DoxyNote}
Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see \hyperlink{group__keytest_ga6bb0f95ac34ce9c42d61bb35a76139d0}{key\+Rel()}.

Given any Keys k1 and k2 constructed with \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, following equation hold true\+:


\begin{DoxyCodeInclude}
\end{DoxyCodeInclude}
 Here are some more examples\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/b"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


And even more\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"markus"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"max"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


Do not strcmp the \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} yourself because the result differs from simple ascii comparison.


\begin{DoxyParams}{Parameters}
{\em k1} & the first key object to compare with \\
\hline
{\em k2} & the second key object to compare with\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}, \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()} will compare keys when appending 

\hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} will compare keys during searching
\end{DoxySeeAlso}

\begin{DoxyRetVals}{Return values}
{\em true} & == 0 \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_a1bd2b165eeade6a71401b9b122864bad}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator$>$}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a1bd2b165eeade6a71401b9b122864bad}


Compare the name of two keys. 

\begin{DoxyReturn}{Returns}
a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.
\end{DoxyReturn}
The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

\hyperlink{group__keytest_gaf6e66e12fe04d535a5d1c8218ced803e}{key\+Cmp()} defines the sorting order for a \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

The following 3 points are the rules for null values\+:


\begin{DoxyItemize}
\item A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.
\item A null name will be found to be smaller than every other name. If both are null names, 0 is returned.
\end{DoxyItemize}

If the name is equal then\+:


\begin{DoxyItemize}
\item No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
the owner will only be used if the names are equal.
\end{DoxyNote}
Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see \hyperlink{group__keytest_ga6bb0f95ac34ce9c42d61bb35a76139d0}{key\+Rel()}.

Given any Keys k1 and k2 constructed with \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, following equation hold true\+:


\begin{DoxyCodeInclude}
\end{DoxyCodeInclude}
 Here are some more examples\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/b"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


And even more\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"markus"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"max"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


Do not strcmp the \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} yourself because the result differs from simple ascii comparison.


\begin{DoxyParams}{Parameters}
{\em k1} & the first key object to compare with \\
\hline
{\em k2} & the second key object to compare with\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}, \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()} will compare keys when appending 

\hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} will compare keys during searching
\end{DoxySeeAlso}

\begin{DoxyRetVals}{Return values}
{\em true} & $>$ 0 \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_aa1258657e3dbddf4aed3716dd63d2a3c}{\index{kdb\+::\+Key@{kdb\+::\+Key}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{operator$>$=}]{\setlength{\rightskip}{0pt plus 5cm}bool kdb\+::\+Key\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{const {\bf Key} \&}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_aa1258657e3dbddf4aed3716dd63d2a3c}


Compare the name of two keys. 

\begin{DoxyReturn}{Returns}
a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.
\end{DoxyReturn}
The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

\hyperlink{group__keytest_gaf6e66e12fe04d535a5d1c8218ced803e}{key\+Cmp()} defines the sorting order for a \hyperlink{classkdb_1_1KeySet}{Key\+Set}.

The following 3 points are the rules for null values\+:


\begin{DoxyItemize}
\item A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.
\item A null name will be found to be smaller than every other name. If both are null names, 0 is returned.
\end{DoxyItemize}

If the name is equal then\+:


\begin{DoxyItemize}
\item No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
the owner will only be used if the names are equal.
\end{DoxyNote}
Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see \hyperlink{group__keytest_ga6bb0f95ac34ce9c42d61bb35a76139d0}{key\+Rel()}.

Given any Keys k1 and k2 constructed with \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, following equation hold true\+:


\begin{DoxyCodeInclude}
\end{DoxyCodeInclude}
 Here are some more examples\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/b"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


And even more\+: 
\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k1 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"markus"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *k2 = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}(\textcolor{stringliteral}{"user/a"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b}{KEY\_OWNER}, \textcolor{stringliteral}{"max"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});

\textcolor{comment}{// keyCmp(k1,k2) < 0}
\textcolor{comment}{// keyCmp(k2,k1) > 0}
\end{DoxyCode}


Do not strcmp the \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} yourself because the result differs from simple ascii comparison.


\begin{DoxyParams}{Parameters}
{\em k1} & the first key object to compare with \\
\hline
{\em k2} & the second key object to compare with\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyset_gaa5a1d467a4d71041edce68ea7748ce45}{ks\+Append\+Key()}, \hyperlink{group__keyset_ga21eb9c3a14a604ee3a8bdc779232e7b7}{ks\+Append()} will compare keys when appending 

\hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()} will compare keys during searching
\end{DoxySeeAlso}

\begin{DoxyRetVals}{Return values}
{\em true} & $>$= 0 \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_a9ae719043e6e99f5f3d6fb85837306f8}{\index{kdb\+::\+Key@{kdb\+::\+Key}!release@{release}}
\index{release@{release}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{release}]{\setlength{\rightskip}{0pt plus 5cm}ckdb\+::\+Key $\ast$ kdb\+::\+Key\+::release (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a9ae719043e6e99f5f3d6fb85837306f8}


Passes out the raw key pointer and resets internal key handle. 

\begin{DoxyNote}{Note}
that the ownership is moved outside.
\end{DoxyNote}

\begin{DoxyRetVals}{Return values}
{\em 0} & if no key is held (null pointer), no action is done then. \\
\hline
\end{DoxyRetVals}
\hypertarget{classkdb_1_1Key_adf6171b76e01c2b84c6050d43673dd97}{\index{kdb\+::\+Key@{kdb\+::\+Key}!rewind\+Meta@{rewind\+Meta}}
\index{rewind\+Meta@{rewind\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{rewind\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::rewind\+Meta (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_adf6171b76e01c2b84c6050d43673dd97}


Rewind the internal iterator to first meta data. 

Use it to set the cursor to the beginning of the \hyperlink{classkdb_1_1Key}{Key} Meta Infos. \hyperlink{group__keymeta_ga74a273f529030f4947df52e14fdd2869}{key\+Current\+Meta()} will then always return N\+U\+L\+L afterwards. So you want to \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()} first.


\begin{DoxyCode}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *key;
\textcolor{keyword}{const} \hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} *meta;

\hyperlink{group__keymeta_ga5dbb669802eea27e106ee3a5e39717a9}{keyRewindMeta} (key);
\textcolor{keywordflow}{while} ((meta = \hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{keyNextMeta} (key))!=0)
\{
        printf (\textcolor{stringliteral}{"name: %s, value: %s"}, \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName}(meta), \hyperlink{group__keyvalue_ga880936f2481d28e6e2acbe7486a21d05}{keyString}(meta));
\}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & on success \\
\hline
{\em 0} & if there is no meta information for that key (\hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()} will always return 0 in that case) \\
\hline
{\em -\/1} & on N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keymeta_ga4c88342f580a4291455a801af71ce048}{key\+Next\+Meta()}, \hyperlink{group__keymeta_ga74a273f529030f4947df52e14fdd2869}{key\+Current\+Meta()} 

\hyperlink{group__keyset_gabe793ff51f1728e3429c84a8a9086b70}{ks\+Rewind()} for pedant in iterator interface of \hyperlink{classkdb_1_1KeySet}{Key\+Set}

\hyperlink{classkdb_1_1Key_a855f37fef58a4ea4006d9e281f66cfe1}{next\+Meta()}, \hyperlink{classkdb_1_1Key_a2be586ccd64cd280561ba5cd23f6ff1e}{current\+Meta()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a615124f0a2b291e03975b49c233654d7}{\index{kdb\+::\+Key@{kdb\+::\+Key}!set@{set}}
\index{set@{set}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{set}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void kdb\+::\+Key\+::set (
\begin{DoxyParamCaption}
\item[{T}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a615124f0a2b291e03975b49c233654d7}


Set a key value. 

Set the value for {\ttfamily key} as {\ttfamily new\+String\+Value}. The function will allocate and save a private copy of {\ttfamily new\+String\+Value}, so the parameter can be freed after the call.

String values will be saved in backend storage, when kdb\+Set\+Key() will be called, in U\+T\+F-\/8 universal encoding, regardless of the program's current encoding, when iconv plugin is present.

\begin{DoxyNote}{Note}
The type will be set to K\+E\+Y\+\_\+\+T\+Y\+P\+E\+\_\+\+S\+T\+R\+I\+N\+G. When the type of the key is already a string type it won't be changed.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the key to set the string value \\
\hline
{\em new\+String\+Value} & N\+U\+L\+L-\/terminated text string to be set as {\ttfamily key's} value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes actually saved in private struct including final N\+U\+L\+L 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & if new\+String\+Value is a N\+U\+L\+L pointer, this will make the string empty (string only containing null termination) \\
\hline
{\em -\/1} & if key is a N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()}, \hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{key\+Value()}, \hyperlink{group__keyvalue_ga880936f2481d28e6e2acbe7486a21d05}{key\+String()}
\end{DoxySeeAlso}
This method tries to deserialise the string to the given type. \hypertarget{classkdb_1_1Key_a0c8c7cef03d6482d89973be72fb3c8b8}{\index{kdb\+::\+Key@{kdb\+::\+Key}!set\+Base\+Name@{set\+Base\+Name}}
\index{set\+Base\+Name@{set\+Base\+Name}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{set\+Base\+Name}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::set\+Base\+Name (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{base\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a0c8c7cef03d6482d89973be72fb3c8b8}


Sets a base name for a key. 

Sets {\ttfamily base\+Name} as the new basename for {\ttfamily key}. Only the base\+Name will be affected and no other part of the key.

All text after the last {\ttfamily '/'} in the {\ttfamily key} keyname is erased and {\ttfamily base\+Name} is appended.

So let us suppose {\ttfamily key} has name {\ttfamily \char`\"{}system/dir1/dir2/key1\char`\"{}}. If {\ttfamily base\+Name} is {\ttfamily \char`\"{}key2\char`\"{}}, the resulting key name will be {\ttfamily \char`\"{}system/dir1/dir2/key2\char`\"{}}. If {\ttfamily base\+Name} is empty or N\+U\+L\+L, the resulting key name will be {\ttfamily \char`\"{}system/dir1/dir2\char`\"{}}.

This function does proper escaping on the supplied name argument.

You can use all names to set as basename (e.\+g. . (dot), .. (dot-\/dot), \% and \char`\"{}\char`\"{} (empty)). They will be properly escaped.

A simple example is\+: 
\begin{DoxyCodeInclude}
\hyperlink{classkdb_1_1Key_a5679f5cae63caddd64a60388b9cc77fa}{Key} * k = \hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew} (\textcolor{stringliteral}{"user/my/long/name"}, \hyperlink{group__key_gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END});
\hyperlink{group__keyname_ga6e804bd453f98c28b0ff51430d1df407}{keySetBaseName} (k, \textcolor{stringliteral}{"myname"});
printf (\textcolor{stringliteral}{"%s\(\backslash\)n"}, \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (k)); \textcolor{comment}{// will print user/my/long/myname}
\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel} (k);
\end{DoxyCodeInclude}
 If you want to add and not change the basename, use \hyperlink{group__keyname_gaa942091fc4bd5c2699e49ddc50829524}{key\+Add\+Base\+Name()} instead. If you do not want escaping, use \hyperlink{group__keyname_gaa70593a2c772c4b7bc33423b9b10a270}{key\+Add\+Name()} instead.

To add an inactive key name, use\+: 
\begin{DoxyCodeInclude}
        \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{keySetName} (k, \textcolor{stringliteral}{"system/valid"});
        \hyperlink{group__keyname_ga6e804bd453f98c28b0ff51430d1df407}{keySetBaseName} (k, \textcolor{stringliteral}{".hiddenkey"});
        succeed\_if\_same\_string (\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (k), \textcolor{stringliteral}{"system/.hiddenkey"});
        succeed\_if\_same\_string (\hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{keyBaseName} (k), \textcolor{stringliteral}{".hiddenkey"});
\end{DoxyCodeInclude}
 When you want to add an array item, use\+: 
\begin{DoxyCodeInclude}
        \hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{keySetName} (k, \textcolor{stringliteral}{"system/valid"});
        \hyperlink{group__keyname_ga6e804bd453f98c28b0ff51430d1df407}{keySetBaseName} (k, \textcolor{stringliteral}{""});
        succeed\_if\_same\_string (\hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{keyName} (k), \textcolor{stringliteral}{"system/%"});
        succeed\_if\_same\_string (\hyperlink{group__keyname_gaaff35e7ca8af5560c47e662ceb9465f5}{keyBaseName} (k), \textcolor{stringliteral}{""});
\end{DoxyCodeInclude}
 \begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname}{Name Manipulation Methods} for more details on special names
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em base\+Name} & the string used to overwrite the basename of the key \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the size in bytes of the new key name 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on N\+U\+L\+L pointers \\
\hline
{\em -\/1} & if key was inserted to a keyset before \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyname_gaa942091fc4bd5c2699e49ddc50829524}{key\+Add\+Base\+Name()} 

\hyperlink{group__keyname_ga7699091610e7f3f43d2949514a4b35d9}{key\+Set\+Name()} to \hyperlink{classkdb_1_1Key_a615124f0a2b291e03975b49c233654d7}{set} a new name
\end{DoxySeeAlso}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Invalid\+Name} & if the name is not valid \\
\hline
\end{DoxyExceptions}
\hypertarget{classkdb_1_1Key_af7211129a4b95f4d1e335dcd06e9bf0a}{\index{kdb\+::\+Key@{kdb\+::\+Key}!set\+Binary@{set\+Binary}}
\index{set\+Binary@{set\+Binary}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{set\+Binary}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t kdb\+::\+Key\+::set\+Binary (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{new\+Binary, }
\item[{size\+\_\+t}]{data\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_af7211129a4b95f4d1e335dcd06e9bf0a}


Set the value of a key as a binary. 

A private copy of {\ttfamily new\+Binary} will allocated and saved inside {\ttfamily key}, so the parameter can be deallocated after the call.

Binary values might be encoded in another way then string values depending on the plugin. Typically character encodings should not take place on binary data. Consider using a string key instead.

When new\+Binary is a N\+U\+L\+L pointer the binary will be freed and 0 will be returned.

\begin{DoxyNote}{Note}
The meta data \char`\"{}binary\char`\"{} will be set to mark that the key is binary from now on. When the key is already binary the meta data won't be changed. This will only happen in the successful case, but not when -\/1 is returned.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the object on which to set the value \\
\hline
{\em new\+Binary} & is a pointer to any binary data or N\+U\+L\+L to free the previous set data \\
\hline
{\em data\+Size} & number of bytes to copy from {\ttfamily new\+Binary} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes actually copied to internal struct storage 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & when the internal binary was freed and is now a null pointer \\
\hline
{\em -\/1} & if key is a N\+U\+L\+L pointer \\
\hline
{\em -\/1} & when data\+Size is 0 (but new\+Binary not N\+U\+L\+L) or larger than S\+S\+I\+Z\+E\+\_\+\+M\+A\+X \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_ga4c0d8a4a11174197699c231e0b5c3c84}{key\+Get\+Binary()} 

\hyperlink{group__keytest_ga9526b371087564e43e3dff8ad0dac949}{key\+Is\+Binary()} to check if the type is binary 

\hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()} and \hyperlink{group__keyvalue_ga622bde1eb0e0c4994728331326340ef2}{key\+Set\+String()} as preferred alternative to binary 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_a4c5a3d463127ade0b766c4298002daa3}{\index{kdb\+::\+Key@{kdb\+::\+Key}!set\+Meta@{set\+Meta}}
\index{set\+Meta@{set\+Meta}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{set\+Meta}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void kdb\+::\+Key\+::set\+Meta (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{meta\+Name, }
\item[{T}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_a4c5a3d463127ade0b766c4298002daa3}


Set metadata for key. 

Set a new Meta-\/\+Information. Will set a new Meta-\/\+Information pair consisting of meta\+Name and new\+Meta\+String.

Will add a new Pair for Meta-\/\+Information if meta\+Name was not added up to now.

It will modify a existing Pair of Meta-\/\+Information if the the meta\+Name was inserted already.

It will remove a meta information if new\+Meta\+String is 0.


\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em meta\+Name} & the name of the meta information where you want to change the value \\
\hline
{\em new\+Meta\+String} & the new value for the meta information \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & on error if key or meta\+Name is 0, out of memory or names are not valid \\
\hline
{\em 0} & if the Meta-\/\+Information for meta\+Name was removed \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
size ($>$0) of new\+Meta\+String if Meta-\/\+Information was successfully added 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keymeta_ga9ed3875495ddb3d8a8d29158a60a147c}{key\+Get\+Meta()}
\end{DoxySeeAlso}
\begin{DoxyWarning}{Warning}
unlike the C Interface, it is not possible to remove metadata with this method. k.\+set\+Meta(\char`\"{}something\char`\"{}, N\+U\+L\+L) will lead to set the number 0 or to something different (may depend on compiler definition of N\+U\+L\+L). See discussion in Issue \href{https://github.com/ElektraInitiative/libelektra/issues/8}{\tt https\+://github.\+com/\+Elektra\+Initiative/libelektra/issues/8}
\end{DoxyWarning}
Use \hyperlink{classkdb_1_1Key_a2305da805095605aca38d53f2733fb57}{del\+Meta()} to avoid these issues.

\begin{DoxySeeAlso}{See also}
\hyperlink{classkdb_1_1Key_a2305da805095605aca38d53f2733fb57}{del\+Meta()}, \hyperlink{classkdb_1_1Key_a36e21abc1a5b8c3a8d3ee39f8f8b91fa}{get\+Meta()}, \hyperlink{classkdb_1_1Key_a53f6d2196a7f17c4bdc544207bdc5f4c}{copy\+Meta()}, \hyperlink{classkdb_1_1Key_aec0910bf293db33deac6a3f81359cb48}{copy\+All\+Meta()} 
\end{DoxySeeAlso}
\hypertarget{classkdb_1_1Key_aac3b5d3a854d02187484bfbdbdf975af}{\index{kdb\+::\+Key@{kdb\+::\+Key}!set\+Name@{set\+Name}}
\index{set\+Name@{set\+Name}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{set\+Name}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::set\+Name (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{new\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_aac3b5d3a854d02187484bfbdbdf975af}


Set a new name to a key. 

A valid name is one of the forms\+:
\begin{DoxyItemize}
\item {\ttfamily spec/something} for specification of other keys.
\item {\ttfamily proc/something} for in-\/memory keys, e.\+g. commandline.
\item {\ttfamily dir/something} for dir keys in current working directory
\item {\ttfamily system/something} for system keys in /etc or /
\item {\ttfamily user/something} for user keys in home directory
\item {\ttfamily user\+:username/something} for other users (deprecated\+: \hyperlink{group__kdb_ga28e385fd9cb7ccfe0b2f1ed2f62453a1}{kdb\+Get()} + \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdb\+Set()} currently unsupported)
\item {\ttfamily /something} for cascading keys (actually refers to one of the above, see also \hyperlink{group__keyset_gaa34fc43a081e6b01e4120daa6c112004}{ks\+Lookup()})
\end{DoxyItemize}

An invalid name either has an invalid namespace or a wrongly escaped \textbackslash{} at the end of the name.

See \hyperlink{group__keyname}{key names } for the exact rules.

The last form has explicitly set the owner, to let the library know in which user folder to save the key. A owner is a user name. If it is not defined (the second form) current user is used.

You should always follow the guidelines for key tree structure creation.

A private copy of the key name will be stored, and the {\ttfamily new\+Name} parameter can be freed after this call.

.., . and / will be handled as in filesystem paths. A valid name will be build out of the (valid) name what you pass, e.\+g. user///sw/../sw//././\+My\+App -\/$>$ user/sw/\+My\+App

On invalid names, N\+U\+L\+L or \char`\"{}\char`\"{} the name will be \char`\"{}\char`\"{} afterwards.


\begin{DoxyRetVals}{Return values}
{\em size} & in bytes of this new key name including ending N\+U\+L\+L \\
\hline
{\em 0} & if new\+Name is an empty string or a N\+U\+L\+L pointer (name will be empty afterwards) \\
\hline
{\em -\/1} & if new\+Name is invalid (name will be empty afterwards) \\
\hline
{\em -\/1} & if key was inserted to a keyset before \\
\hline
\end{DoxyRetVals}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em new\+Name} & the new key name \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{key\+New()}, \hyperlink{owner_8c_a88d6ec200ba0707b7c1b4a88133d2be4}{key\+Set\+Owner()} 

\hyperlink{group__keyname_gab29a850168d9b31c9529e90cf9ab68be}{key\+Get\+Name()}, \hyperlink{group__keyname_gaaba1494a5ffc976e0e56c43f4334a23c}{key\+Get\+Full\+Name()}, \hyperlink{group__keyname_ga8e805c726a60da921d3736cda7813513}{key\+Name()} 

\hyperlink{group__keyname_ga6e804bd453f98c28b0ff51430d1df407}{key\+Set\+Base\+Name()}, \hyperlink{group__keyname_gaa942091fc4bd5c2699e49ddc50829524}{key\+Add\+Base\+Name()} to manipulate a name
\end{DoxySeeAlso}

\begin{DoxyExceptions}{Exceptions}
{\em Key\+Invalid\+Name} & if the name is not valid \\
\hline
\end{DoxyExceptions}
\hypertarget{classkdb_1_1Key_ab97ef37aa235f0ae04dc6e6c21109d1a}{\index{kdb\+::\+Key@{kdb\+::\+Key}!set\+String@{set\+String}}
\index{set\+String@{set\+String}!kdb\+::\+Key@{kdb\+::\+Key}}
\subsubsection[{set\+String}]{\setlength{\rightskip}{0pt plus 5cm}void kdb\+::\+Key\+::set\+String (
\begin{DoxyParamCaption}
\item[{std\+::string}]{new\+String}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{classkdb_1_1Key_ab97ef37aa235f0ae04dc6e6c21109d1a}


Set the value for {\ttfamily key} as {\ttfamily new\+String\+Value}. 

The function will allocate and save a private copy of {\ttfamily new\+String\+Value}, so the parameter can be freed after the call.

String values will be saved in backend storage, when kdb\+Set\+Key() will be called, in U\+T\+F-\/8 universal encoding, regardless of the program's current encoding, when iconv plugin is present.

\begin{DoxyNote}{Note}
The type will be set to K\+E\+Y\+\_\+\+T\+Y\+P\+E\+\_\+\+S\+T\+R\+I\+N\+G. When the type of the key is already a string type it won't be changed.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the key to set the string value \\
\hline
{\em new\+String\+Value} & N\+U\+L\+L-\/terminated text string to be set as {\ttfamily key's} value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes actually saved in private struct including final N\+U\+L\+L 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & if new\+String\+Value is a N\+U\+L\+L pointer, this will make the string empty (string only containing null termination) \\
\hline
{\em -\/1} & if key is a N\+U\+L\+L pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__keyvalue_ga41b9fac5ccddafe407fc0ae1e2eb8778}{key\+Get\+String()}, \hyperlink{group__keyvalue_ga6f29609c5da53c6dc26a98678d5752af}{key\+Value()}, \hyperlink{group__keyvalue_ga880936f2481d28e6e2acbe7486a21d05}{key\+String()} 
\end{DoxySeeAlso}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{key_8hpp}{key.\+hpp}\item 
\hyperlink{kdbvalue_8hpp}{kdbvalue.\+hpp}\end{DoxyCompactItemize}
