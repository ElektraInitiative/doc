<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Bindings for the High-level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Bindings for the High-level API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_tutorials_highlevel_bindings"></a> This document describes how and when to write a language binding for the high-level API.</p>
<p>Writing bindings for high-level API is different from writing bindings for other parts of Elektra. This is mainly because the high-level API has different goals.</p>
<h1><a class="anchor" id="autotoc_md3583"></a>
Goals</h1>
<p>The goals of any high-level API (or binding to the C high-level API) for Elektra should be:</p>
<ul>
<li><b>Type Safety:</b> The API should use Elektra's type system as dictated by the <code>type</code> plugin. The various types shall be mapped to native types of the target language. All API calls interacting with keys should reflect the type of the key. Type mismatches should produce errors.</li>
<li><b>Easy to Use:</b> The API should be easy to use and abstract as much of the low-level API as possible. The main part of the API should not consists of more than an initialization method, typed <code>get</code> and <code>set</code> calls and if required by the language a method freeing the acquired resources.</li>
<li><b>No Errors in Getters:</b> It is a stated goal of our high-level API to make <code>get</code> calls not able to fail. This means <code>get</code> calls <em>cannot</em> return an error under normal conditions. This can be ensure via checks during initialization or via code-generation. Both are based on the specification. Without a specification it is not possible to prevent errors because of missing keys, since we have no way of knowing which keys should exist. <br  />
<br  />
 There is an exception to this rule. Some target languages have a standard error concept, which not only forces the user to handle arising errors, but also does so in a simple and concise way. An example of this is Rust. Its <code>Result</code> type forces the user to handle errors and the <code>?</code> operator allows to do this in a concise way. <br  />
 However, we still recommend to avoid errors as far as possible.</li>
<li><b>Idiomatic Code:</b> If the target language has a concept of "idiomatic code", the API should fall into that category.</li>
</ul>
<h1><a class="anchor" id="autotoc_md3584"></a>
When to write Bindings</h1>
<p>Based on the goals above, you should decide, whether it is possible to write a binding for the C high-level API while preserving the goals.</p>
<p>If you decide to write a binding, proceed with this tutorial.</p>
<p>If not, designing an API to meet our goals is up to you. While designing the API you should keep in mind that you can always use code-generator (<code>kdb gen</code>) templates like the C API does.</p>
<h1><a class="anchor" id="autotoc_md3585"></a>
How to write Bindings</h1>
<p>Since the C high-level API consists of a shared library API and a code-generated part, your binding will also have these two parts.</p>
<h2><a class="anchor" id="autotoc_md3586"></a>
Bindings for the &lt;tt&gt;highlevel&lt;/tt&gt; Library</h2>
<p>Writing the binding for the <code>highlevel</code> library works the same way as writing a language binding for any part of Elektra. The only additional challenge is that the binding should still meet the same goals and (as far as possible) fulfill the same guarantees as the C API.</p>
<p>Some languages like to split bindings into two parts. One version that maps the C API one-to-one and another part that builds on the first one. The second part then uses the languages additional features. Since our API isn't intended to be used directly, but through generated code, it might not be necessary to write the second part. It may be sufficient to write (or generate) a one-to-one mirror of the C API and use that in the code-generator template.</p>
<p>The generated code should still be understandable. So if writing a more idiomatic API on top of the direct mapping, significantly simplifies the generated code (and maybe also the template), you should write such an API.</p>
<h2><a class="anchor" id="autotoc_md3587"></a>
Bindings for the &lt;tt&gt;lowlevel&lt;/tt&gt; Library</h2>
<p>Your programming language of choice must provide a way to call into C code (like <a href="https://golang.org/cmd/cgo/">cgo</a>).</p>
<p>In general we prefer (in this order):</p>
<ol type="1">
<li>Automatically and statically generated bindings (like <a href="http://www.swig.org/">swig</a>).</li>
<li>Manually written bindings that directly call to library without any statically build part (like JNI and GI). They are a bit slower but can directly access libelektra.so.</li>
<li>Manually written bindings that are built statically.</li>
</ol>
<p>If you want to manually write a binding make sure you have a good understanding of the possible limitations the interop layer can have (e.g. variadic functions, freeing of resources, ...).</p>
<p>What you will also need is to set up the compiler + linker flags. For this we recommend <a href="https://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a>, because Elektra already provides <code>.pc</code> (and <code>cmake</code>) files.</p>
<p>For garbage collected (GC) languages freeing memory by hand is not something you usually do and since the GC has no knowledge of memory allocated in C we have two options:</p>
<ul>
<li>Forcing the user to call the appropriate functions like <code><a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects.">keyDel()</a></code> themselves, which is very developer unfriendly and error prone or</li>
<li>Using language features like Java / C++ Destructors or Go's <code>runtime.SetFinalizer()</code> function to automatically and reliably release the memory as soon as the native objects are garbage collected.</li>
</ul>
<p>If you decide on mapping the functionality of kdb.h 1:1 it is pretty straightforward - whereas if you want to adapt or enhance some API's to leverage language features like iterators or operator overloading feel free to do so. The less “alien” the binding feels to its users the better.</p>
<p>Remember that Elektra has internal iterators (for metadata+keysets) but in general we prefer external iterators by either copying the KeySet per iterator or using <code>ksAtCursor</code>.</p>
<h2><a class="anchor" id="autotoc_md3588"></a>
Variadic Functions</h2>
<p>Some languages for example cannot call variadic functions because in C the amount of parameters has to be known at compile-time. In Go for example this is not the case since it supports variable length arguments at runtime with the <code>...</code> operator.</p>
<p>This is unfortunate because the low-level bindings rely heavily on variadic functions. It is possible to work around this problem by either</p>
<ol type="1">
<li>Writing helper functions in C that call these variadic functions with a fixed amount of parameters or</li>
<li>Imitating the behavior of a function e.g. <code><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step.">keyNew()</a></code> by calling multiple functions: <code><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step.">keyNew()</a></code> and <code><a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a></code> for every metakey/value that was passed.</li>
</ol>
<h2><a class="anchor" id="autotoc_md3589"></a>
Creating the Code-Generator Template</h2>
<p>How to create a template for <code>kdb gen</code> is detailed in <a class="el" href="doc_tutorials_code-generator_md.html">this tutorial</a>.</p>
<p>The created template should support the same input keysets (and parent keys) as the <code>highlevel</code> template. If and how exactly you implement the advanced features (structs, unions, ...) is up to you. Note: enums should always be supported (if your language has them) as they are one of the <code>type</code> plugins types.</p>
<p>For example, in C++ the generated code could consist of nested structs with overloaded operators. In that case the structs features doesn't really make sense, since everything is already structs. Of course you could reuse some of the <code>gen/*</code> metadata to allow some cross-compatibility. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
