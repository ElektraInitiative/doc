.TH "keyset" 3elektra "Fri Aug 4 2023" "Version 0.11.0" "Elektra" \" -*- nroff -*-
.ad l
.nh
.SH NAME
keyset \- KeySet
.PP
 \- Methods to manipulate KeySets\&.  

.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBKS_END\fP   ((Key *) 0)"
.br
.RI "End of a list of keys\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBelektraLookupFlags\fP { \fBKDB_O_NONE\fP = 0, \fBKDB_O_DEL\fP = 1, \fBKDB_O_POP\fP = 1 << 1 }"
.br
.RI "Options to change the default behavior of \fBksLookup()\fP functions\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "KeySet * \fBksNew\fP (size_t alloc,\&.\&.\&.)"
.br
.RI "Allocate, initialize and return a new KeySet object\&. "
.ti -1c
.RI "KeySet * \fBksVNew\fP (size_t alloc, va_list va)"
.br
.RI "Allocate, initialize and return a new KeySet object\&. "
.ti -1c
.RI "KeySet * \fBksDup\fP (const KeySet *source)"
.br
.RI "Return a duplicate of a KeySet\&. "
.ti -1c
.RI "int \fBksCopy\fP (KeySet *dest, const KeySet *source)"
.br
.RI "Replace the content of a KeySet with another one\&. "
.ti -1c
.RI "int \fBksDel\fP (KeySet *ks)"
.br
.RI "A destructor for KeySet objects\&. "
.ti -1c
.RI "int \fBksClear\fP (KeySet *ks)"
.br
.RI "Empties a KeySet\&. "
.ti -1c
.RI "uint16_t \fBksIncRef\fP (KeySet *ks)"
.br
.RI "Increment the reference counter of a KeySet object\&. "
.ti -1c
.RI "uint16_t \fBksDecRef\fP (KeySet *ks)"
.br
.RI "Decrement the reference counter of a KeySet object\&. "
.ti -1c
.RI "uint16_t \fBksGetRef\fP (const KeySet *ks)"
.br
.RI "Return the current reference counter value of a KeySet object\&. "
.ti -1c
.RI "ssize_t \fBksGetSize\fP (const KeySet *ks)"
.br
.RI "Return the number of Keys that \fCks\fP contains\&. "
.ti -1c
.RI "ssize_t \fBksSearch\fP (const KeySet *ks, const Key *key)"
.br
.RI "Search in a key set, either yielding the actual index of the key, if the key has been found within the key set, or a negative value indicating the insertion index of the key, if the key would be inserted\&. "
.ti -1c
.RI "ssize_t \fBksAppendKey\fP (KeySet *ks, Key *toAppend)"
.br
.RI "Appends a Key to the end of \fCks\fP\&. "
.ti -1c
.RI "ssize_t \fBksAppend\fP (KeySet *ks, const KeySet *toAppend)"
.br
.RI "Append all Keys in \fCtoAppend\fP to the end of the KeySet \fCks\fP\&. "
.ti -1c
.RI "ssize_t \fBksRename\fP (KeySet *ks, const Key *root, const Key *newRoot)"
.br
.RI "Moves all keys below \fCroot\fP to below \fCnewRoot\fP\&. "
.ti -1c
.RI "elektraCursor \fBksFindHierarchy\fP (const KeySet *ks, const Key *root, elektraCursor *end)"
.br
.RI "Searches for the start and optionally end of the key hierarchy rooted at \fCroot\fP in \fCks\fP\&. "
.ti -1c
.RI "KeySet * \fBksBelow\fP (const KeySet *ks, const Key *root)"
.br
.RI "Retrieves all Keys from KeySet \fCks\fP that are below or at \fCroot\fP\&. "
.ti -1c
.RI "KeySet * \fBksCut\fP (KeySet *ks, const Key *cutpoint)"
.br
.RI "Cuts out all Keys from KeySet \fCks\fP that are below or at \fCcutpoint\fP\&. "
.ti -1c
.RI "Key * \fBksPop\fP (KeySet *ks)"
.br
.RI "Remove and return the last Key of \fCks\fP\&. "
.ti -1c
.RI "int \fBksRewind\fP (KeySet *ks)"
.br
.RI "Rewinds the KeySet internal cursor\&. "
.ti -1c
.RI "Key * \fBksNext\fP (KeySet *ks)"
.br
.RI "Returns the next Key in a KeySet\&. "
.ti -1c
.RI "Key * \fBksCurrent\fP (const KeySet *ks)"
.br
.RI "Return the current Key\&. "
.ti -1c
.RI "elektraCursor \fBksGetCursor\fP (const KeySet *ks)"
.br
.RI "Get the internal cursor of the KeySet\&. "
.ti -1c
.RI "Key * \fBksAtCursor\fP (const KeySet *ks, elektraCursor pos)"
.br
.RI "Return Key at given position \fCpos\fP\&. "
.ti -1c
.RI "int \fBksSetCursor\fP (KeySet *ks, elektraCursor cursor)"
.br
.RI "Set the KeySet internal cursor to \fCcursor\fP\&. "
.ti -1c
.RI "Key * \fBksLookup\fP (KeySet *ks, Key *key, \fBelektraLookupFlags\fP options)"
.br
.RI "Look for a Key contained in \fCks\fP that matches the name of the \fCkey\fP\&. "
.ti -1c
.RI "Key * \fBksLookupByName\fP (KeySet *ks, const char *name, \fBelektraLookupFlags\fP options)"
.br
.RI "Convenience method to look for a Key contained in \fCks\fP with name \fCname\fP\&. "
.ti -1c
.RI "ssize_t \fBksSubtract\fP (KeySet *total, const KeySet *sub)"
.br
.RI "Remove all the keys in \fCsub\fP from \fCtotal\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 
Methods to manipulate KeySets\&. 

A KeySet is a set of keys\&.
.PP
Most important properties of a KeySet:
.PP
.IP "\(bu" 2
Allows us to iterate over all keys (in any depth)
.IP "\(bu" 2
Iteration is always sorted
.IP "\(bu" 2
Fast key lookup
.IP "\(bu" 2
A Key may be shared among many KeySets\&.
.PP
.PP
The most important methods of KeySet:
.PP
.IP "\(bu" 2
With \fBksNew()\fP you can create a new KeySet\&.
.IP "\(bu" 2
You can append keys with \fBksAppendKey()\fP or with \fBksAppend()\fP you can append a whole keyset\&.
.IP "\(bu" 2
Using \fBksLookup()\fP you can lookup (or pop with \fBKDB_O_POP\fP) a key\&.
.IP "\(bu" 2
With \fBksGetSize()\fP and \fBksAtCursor()\fP you can iterate through the keyset\&. Be assured that you will get every key of the set in a stable order (parents before children)\&.
.PP
.PP
KeySet is the most important data structure in Elektra\&. It makes it possible to get and store many keys at once inside the database\&. In addition to that, the class can be used as high level datastructure in applications and it can be used in plugins to manipulate or check configuration\&.
.PP
With \fBksLookupByName()\fP it is possible to fetch easily specific keys out of the list of keys\&.
.PP
You can easily create and iterate keys:
.PP
.PP
.nf
// create a new keyset with 3 keys
// with a hint that about 20 keys will be inside
KeySet * myConfig = ksNew (20, keyNew ("user:/name1", KEY_END), keyNew ("user:/name2", KEY_END), keyNew ("user:/name3", KEY_END), KS_END);
// append a key in the keyset
ksAppendKey (myConfig, keyNew ("user:/name4", KEY_END));

Key * current;

for (elektraCursor it = 0; it < ksGetSize (myConfig); ++it)
{
        current = ksAtCursor (myConfig, it);
        printf ("Key name is %s\&.\n", keyName (current));
}

ksDel (myConfig); // delete keyset and all keys appended
.fi
.PP
 
.PP
\fBCopy-on-Write\fP
.RS 4

.RE
.PP
Keysets employ copy-on-write techniques to minimize memory footprint\&. If you create a copy or a duplication of a keyset, the resulting keyset initially references the same data as the source keyset\&. Only if add or remove keys from a keyset additional memory is allocated\&. 
.SH "Macro Definition Documentation"
.PP 
.SS "#define KS_END   ((Key *) 0)"

.PP
End of a list of keys\&. Use this macro to define the end of a variable-length list of keys\&.
.PP
\fBSee also\fP
.RS 4
\fBksNew()\fP and \fBksVNew()\fP 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBelektraLookupFlags\fP"

.PP
Options to change the default behavior of \fBksLookup()\fP functions\&. These options can be ORed\&. That is the |-Operator in C\&.
.PP
\fBSee also\fP
.RS 4
\fBkdbGet()\fP, \fBkdbSet()\fP 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKDB_O_NONE \fP\fP
No Option set\&. 
.PP
\fBSee also\fP
.RS 4
\fBksLookup()\fP 
.RE
.PP

.TP
\fB\fIKDB_O_DEL \fP\fP
Delete parentKey key in \fBksLookup()\fP\&. 
.PP
\fBSee also\fP
.RS 4
\fBksLookup()\fP 
.RE
.PP

.TP
\fB\fIKDB_O_POP \fP\fP
Pop Parent out of keyset key in \fBksLookup()\fP\&. 
.PP
.nf
   @see ksPop().

.fi
.PP
 
.SH "Function Documentation"
.PP 
.SS "ssize_t ksAppend (KeySet * ks, const KeySet * toAppend)"

.PP
Append all Keys in \fCtoAppend\fP to the end of the KeySet \fCks\fP\&. \fCtoAppend\fP KeySet will be left unchanged\&.
.PP
If a Key is both in \fCtoAppend\fP and \fCks\fP, the Key in \fCks\fP will be overwritten\&.
.PP
\fBPostcondition\fP
.RS 4
Sorted KeySet ks with all Keys it had before and additionally the Keys from toAppend
.RE
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet that will receive the Keys 
.br
\fItoAppend\fP the KeySet that provides the Keys that will be transferred
.RE
.PP
\fBReturns\fP
.RS 4
the size of the KeySet \fCks\fP after transfer 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP on NULL pointers
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksAppendKey()\fP 
.RE
.PP

.SS "ssize_t ksAppendKey (KeySet * ks, Key * toAppend)"

.PP
Appends a Key to the end of \fCks\fP\&. Hands the ownership of the Key \fCtoAppend\fP to the KeySet \fCks\fP\&. ksDel(ks) uses keyDel(k) to delete every Key unless it got its reference counter incremented by \fBkeyIncRef()\fP, e\&.g\&. by another KeySet that contains this Key\&.
.PP
The reference counter of the Key will be incremented to indicate this ownership, and thus \fCtoAppend\fP is not const\&.
.PP
\fBSee also\fP
.RS 4
\fBkeyGetRef()\fP
.RE
.PP
If the Key's name already exists in the KeySet, it will be replaced with the new Key\&.
.PP
\fBksAppendKey()\fP will also lock the Key's name from \fCtoAppend\fP\&. This is necessary so that the order of the KeySet cannot be destroyed via calls to \fBkeySetName()\fP\&.
.PP
The KeySet internal cursor will be set to the new Key\&.
.PP
It is safe to directly append newly created Keys: 
.PP
.nf
KeySet * ks = ksNew (1, KS_END);
ksAppendKey (ks, keyNew ("user:/my/new/key", KEY_END));
ksDel (ks);
// key deleted, too!

.fi
.PP
 If you want the key to outlive the KeySet, make sure to do proper ref counting: 
.PP
.nf
KeySet * ks = ksNew (1, KS_END);
Key * k = keyNew ("user:/ref/key", KEY_END);
keyIncRef (k);
ksAppendKey (ks, k);
ksDel (ks);
// now we still can work with the key k!
keyDecRef (k);
keyDel (k);

.fi
.PP
 You can duplicate the Key to avoid aliasing, but then the Key in the KeySet has another identity: 
.PP
.nf
KeySet * ks = ksNew (1, KS_END);
Key * k = keyNew ("user:/ref/key", KEY_END);
ksAppendKey (ks, keyDup (k, KEY_CP_ALL));
ksDel (ks);
// now we still can work with the key k!
keyDel (k);

.fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIks\fP KeySet where \fCtoAppend\fP should be append 
.br
\fItoAppend\fP Key that will be appended to \fCks\fP or deleted
.RE
.PP
\fBReturns\fP
.RS 4
the size of the KeySet after appending 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP on NULL pointers 
.br
\fI-1\fP if appending failed (only on memory problems)\&. The Key will be deleted then\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksAppend()\fP for appending a KeySet to another KeySet 
.PP
\fBkeyIncRef()\fP for manually increasing a Key's reference counter 
.RE
.PP

.SS "Key* ksAtCursor (const KeySet * ks, elektraCursor pos)"

.PP
Return Key at given position \fCpos\fP\&. The position is a number starting from 0\&.
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet to get the Key from 
.br
\fIpos\fP the position of the Key that should be retrieved
.RE
.PP
\fBReturns\fP
.RS 4
the Key at the cursor \fCpos\fP on success 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINULL\fP on NULL pointer, negative cursor position or a position that does not lie within the KeySet \fCks\fP 
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP

.SS "KeySet* ksBelow (const KeySet * ks, const Key * root)"

.PP
Retrieves all Keys from KeySet \fCks\fP that are below or at \fCroot\fP\&. This function works very much like \fBksCut()\fP\&. It returns an identical KeySet, but the Keys also remain in \fCks\fP 
.PP
\fBParameters\fP
.RS 4
\fIks\fP the Keyset to copy from 
.br
\fIroot\fP the point where to copy from the Keyset
.RE
.PP
\fBReturns\fP
.RS 4
a new allocated KeySet which needs to be deleted with \fBksDel()\fP\&. The KeySet consists of all Keys (of the original KeySet ks) below \fCroot\fP\&. If \fCroot\fP exists, it will also be appended\&. 
.RE
.PP

.SS "int ksClear (KeySet * ks)"

.PP
Empties a KeySet\&. This function
.IP "\(bu" 2
\fBdoes not\fP check or modify the reference count of \fCks\fP
.IP "\(bu" 2
decrements the reference count of all keys contained in \fCks\fP
.IP "\(bu" 2
deletes all keys that where only referenced by \fCks\fP
.IP "\(bu" 2
resets size of \fCks\fP to 0
.PP
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet to clear
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP on success 
.br
\fI-1\fP on failure (memory) or ks == NULL 
.RE
.PP

.SS "int ksCopy (KeySet * dest, const KeySet * source)"

.PP
Replace the content of a KeySet with another one\&. Most often you may want a duplicate of a KeySet, see \fBksDup()\fP or append keys, see \fBksAppend()\fP\&. In some situations you need to copy Keys from a KeySet to another KeySet, for which this function exists\&.
.PP
\fBNote\fP
.RS 4
You can also use it to clear a KeySet when you pass a NULL pointer as \fCsource\fP\&.
.RE
.PP
\fBImplementation:\fP
.RS 4
First all Keys in \fCdest\fP will be deleted\&. Afterwards the content of \fCsource\fP will be added to the destination\&.
.RE
.PP
A flat copy is made, so Keys will not be duplicated, but their reference counter is updated, so both KeySets need to be deleted via \fBksDel()\fP\&.
.PP
.PP
.nf
int f (KeySet *ks)
{
        KeySet *c = ksNew (20, \&.\&.\&., KS_END);
        // c receives keys
        ksCopy (ks, c); // pass the KeySet to the caller

        ksDel (c);
}       // caller needs to ksDel (ks)
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIsource\fP an initialized KeySet or NULL 
.br
\fIdest\fP an initialized KeySet, where the Keys from \fCsource\fP get copied to
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP on success 
.br
\fI0\fP if \fCdest\fP was cleared successfully (\fCsource\fP is NULL) 
.br
\fI-1\fP when \fCdest\fP is a NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksNew()\fP for creating a new KeySet 
.PP
\fBksDel()\fP for deleting an existing KeySet 
.PP
\fBksDup()\fP for duplicating an existing KeySet 
.PP
\fBkeyCopy()\fP for copying Keys 
.RE
.PP

.SS "Key* ksCurrent (const KeySet * ks)"

.PP
Return the current Key\&. The returned pointer is NULL if you reached the end or after \fBksRewind()\fP\&.
.PP
\fBNote\fP
.RS 4
You must not delete the Key or change the Key, use \fBksPop()\fP if you want to delete it\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet object to get the current Key from
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the Key pointed by \fCks's\fP cursor 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksNext()\fP to get the next Key in the KeySet 
.PP
\fBksRewind()\fP for resetting the internal cursor of the KeySet 
.RE
.PP

.SS "KeySet* ksCut (KeySet * ks, const Key * cutpoint)"

.PP
Cuts out all Keys from KeySet \fCks\fP that are below or at \fCcutpoint\fP\&. Searches for the \fCcutpoint\fP inside the KeySet \fCks\fP\&. If found, it cuts out this Key and everything which is below (see \fBkeyIsBelow()\fP) this Key\&. These Keys will be missing in the keyset \fCks\fP\&. Instead, they will be moved to the returned KeySet\&. If \fCcutpoint\fP is not found an empty KeySet is returned and \fCks\fP is not changed\&.
.PP
The cursor will stay at the same Key as it was before\&. If the cursor was inside the region of cut (moved) Keys, the cursor will be set to the Key before the \fCcutpoint\fP\&.
.PP
If you use \fBksCut()\fP on a KeySet you got from \fBkdbGet()\fP and plan to use \fBkdbSet()\fP later, make sure that you keep all Keys that should not be removed permanently\&. You have to keep the KeySet that was returned and the KeySet \fCks\fP\&.
.PP
\fBExample:\fP
.RS 4

.RE
.PP
You have the keyset \fCks:\fP 
.IP "\(bu" 2
\fCsystem:/mountpoint/interest\fP 
.IP "\(bu" 2
\fCsystem:/mountpoint/interest/folder\fP 
.IP "\(bu" 2
\fCsystem:/mountpoint/interest/folder/key1\fP 
.IP "\(bu" 2
\fCsystem:/mountpoint/interest/folder/key2\fP 
.IP "\(bu" 2
\fCsystem:/mountpoint/other/key1\fP 
.PP
.PP
When you use 
.PP
.nf
     Key * parentKey = keyNew ("system:/mountpoint/interest", KEY_END);
        KDB * kdb = kdbOpen (NULL, parentKey);
        KeySet * ks = ksNew (0, KS_END);
        kdbGet (kdb, ks, parentKey);
        KeySet * returned = ksCut (ks, parentKey);
        kdbSet (kdb, ks, parentKey); // all keys below cutpoint are now removed
        kdbClose (kdb, parentKey);

.fi
.PP
 Then in \fCreturned\fP are:
.IP "\(bu" 2
\fCsystem:/mountpoint/interest\fP 
.IP "\(bu" 2
\fCsystem:/mountpoint/interest/folder\fP 
.IP "\(bu" 2
\fCsystem:/mountpoint/interest/folder/key1\fP 
.IP "\(bu" 2
\fCsystem:/mountpoint/interest/folder/key2\fP 
.PP
.PP
And in \fCks\fP are:
.IP "\(bu" 2
\fCsystem:/mountpoint/other/key1\fP 
.PP
.PP
So \fBkdbSet()\fP permanently removes all keys at or below \fCsystem:/mountpoint/interest\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIks\fP the Keyset to cut\&. It will be modified by removing all Keys at or below the cutpoint\&. 
.br
\fIcutpoint\fP the point where to cut out the Keyset
.RE
.PP
\fBReturns\fP
.RS 4
a new allocated KeySet which needs to be deleted with \fBksDel()\fP\&. The KeySet consists of all Keys (of the original KeySet ks) below the cutpoint\&. If the Key cutpoint exists, it will also be appended\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP on NULL pointers, no Key name or allocation problems
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBkdbGet()\fP for an explanation on why you might get more Keys than you requested\&. 
.RE
.PP

.SS "uint16_t ksDecRef (KeySet * ks)"

.PP
Decrement the reference counter of a KeySet object\&. As long as the reference counter is non-zero, \fC\fBksDel()\fP\fP operations on \fCkey\fP will be a no-op and return an error code\&.
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the KeySet object whose reference counter should get decreased
.RE
.PP
\fBReturns\fP
.RS 4
the updated value of the reference counter 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIUINT16_MAX\fP on NULL pointer 
.br
\fI0\fP when the reference counter already was the minimum value 0, the reference counter will not be modified in this case
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksGetRef()\fP to retrieve the current reference count 
.PP
\fBksIncRef()\fP for increasing the reference counter and for a more complete explanation of the reference counting system 
.PP
\fBksDel()\fP for deleting a Key 
.RE
.PP

.SS "int ksDel (KeySet * ks)"

.PP
A destructor for KeySet objects\&. Every KeySet created by \fBksNew()\fP must be deleted with \fBksDel()\fP\&.
.PP
When the reference counter of \fCks\fP is non-zero, this function will do nothing and simply return the current value of the reference counter\&.
.PP
It is therefore safe to call \fCksDel (ks)\fP on any \fCKeySet * ks\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet object to delete
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP when the KeySet was freed 
.br
\fI-1\fP on NULL pointers 
.RE
.PP
\fBReturns\fP
.RS 4
the value of the reference counter, if it was non-zero
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksNew()\fP for creating a new KeySet 
.PP
\fBksIncRef()\fP for more information about the reference counter 
.RE
.PP

.SS "KeySet* ksDup (const KeySet * source)"

.PP
Return a duplicate of a KeySet\&. Objects created with \fBksDup()\fP must be destroyed with \fBksDel()\fP\&.
.PP
Memory will be allocated as needed for dynamic properties, so you need to \fBksDel()\fP the returned pointer\&.
.PP
A flat copy is made, so the Keys will not be duplicated, but their reference counter is updated, so both KeySets need to be deleted via \fBksDel()\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIsource\fP has to be an initialized KeySet
.RE
.PP
\fBReturns\fP
.RS 4
a flat copy of source on success 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksNew()\fP for creating a new KeySet 
.PP
\fBksDel()\fP for deleting a KeySet 
.PP
keyDup() for Key duplication 
.RE
.PP

.SS "elektraCursor ksFindHierarchy (const KeySet * ks, const Key * root, elektraCursor * end)"

.PP
Searches for the start and optionally end of the key hierarchy rooted at \fCroot\fP in \fCks\fP\&. The hierarchy will only contain keys in the same namespace as \fCroot\fP\&. If \fCroot\fP is a cascading key, only cascading keys will be part of the hierarchy\&.
.PP
The main use-case for this function is this kind of loop:
.PP
.PP
.nf
elektraCursor end;
for (elektraCursor it = ksFindHierarchy (ks, root, &end); it < end; ++it)
{
        Key * cur = ksAtCursor (ks, it);
}
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIks\fP The keyset to search in 
.br
\fIroot\fP The root of the hierachy to find 
.br
\fIend\fP If this is not NULL, it will be set to position of the first key after \fCroot\fP that is not below \fCroot\fP\&. This is useful for loops like the one above\&. If not keys below \fCroot\fP exist in \fCks\fP, \fCend\fP will always be set to the size of \fCks\fP\&. This way a loop like the one above will still work correctly\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP if \fCks\fP or \fCroot\fP are NULL 
.RE
.PP
\fBReturns\fP
.RS 4
the position of either \fCroot\fP itself or the first key below \fCroot\fP that is part of \fCks\fP\&. If no keys below \fCroot\fP exist in \fCks\fP, the size of \fCks\fP is returned\&. The snippet above shows why this is useful\&. 
.RE
.PP

.SS "elektraCursor ksGetCursor (const KeySet * ks)"

.PP
Get the internal cursor of the KeySet\&. 
.PP
\fBWarning\fP
.RS 4
Cursors are getting invalid when the Key was \fBksPop()\fPed or \fBksLookup()\fP with KDB_O_POP was used\&.
.RE
.PP
.SH "Read ahead"
.PP
With the cursors it is possible to read ahead in a KeySet:
.PP
.PP
.nf
elektraCursor jump;
ksRewind (ks);
while ((key = keyNextMeta (ks))!=0)
{
        // now mark this key
        jump = ksGetCursor(ks);

        //code\&.\&.
        keyNextMeta (ks); // now browse on
        // use ksCurrent(ks) to check the keys
        //code\&.\&.

        // jump back to the position marked before
        ksSetCursor(ks, jump);
}
.fi
.PP
.SH "Restoring state"
.PP
It can also be used to restore the state of a KeySet in a function
.PP
.PP
.nf
int f (KeySet *ks)
{
        elektraCursor state = ksGetCursor(ks);

        // work with keyset

        // now bring the keyset to the state before
        ksSetCursor (ks, state);
}
.fi
.PP
.PP
It is of course possible to make the KeySet const and cast its const away to set the cursor\&. Another way to achieve the same is to \fBksDup()\fP the KeySet, but it is not as efficient\&.
.PP
An invalid cursor will be returned directly after \fBksRewind()\fP\&. When you set an invalid cursor \fBksCurrent()\fP is 0\&.
.SH "Using Cursor directly"
.PP
You can also use the cursor directly by initializing it to some index in the KeySet and then incrementing or decrementing it, to iterate over the KeySet\&.
.PP
.PP
.nf
        Key * cur;
        for (elektraCursor cursor = 0; (cur = ksAtCursor (ks, cursor)) != NULL; ++cursor)
        {
                printf ("%s\n", keyName (cur));
        }
.fi
.PP
 You can also use a while loop if you need access to the last cursor position\&.
.PP
.PP
.nf
        elektraCursor cursor = 0;
        Key * cur;

        while ((cur = ksAtCursor (ks, cursor)) != 0)
        {
                printf ("%s\n", keyName (cur));
                ++cursor;
        }
.fi
.PP
 
.PP
\fBNote\fP
.RS 4
Only use a cursor for the same KeySet which it was made for\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet object to get the cursor from
.RE
.PP
\fBReturns\fP
.RS 4
a valid cursor on success 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP on NULL pointer 
.br
\fI-1\fP on an invalid internal cursor or after ksRewind
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksNext()\fP for moving the internal cursor forward 
.PP
\fBksSetCursor()\fP for setting the cursor to a specific position 
.PP
\fBksAtCursor()\fP for getting the Key at a specific position 
.RE
.PP

.SS "uint16_t ksGetRef (const KeySet * ks)"

.PP
Return the current reference counter value of a KeySet object\&. 
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet whose reference counter to retrieve
.RE
.PP
\fBReturns\fP
.RS 4
the value of the \fCkey's\fP reference counter 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksIncRef()\fP for increasing the reference counter and for a more complete explanation of the reference counting system 
.PP
\fBksDecRef()\fP for decreasing the reference counter 
.RE
.PP

.SS "ssize_t ksGetSize (const KeySet * ks)"

.PP
Return the number of Keys that \fCks\fP contains\&. 
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet object to get the size from
.RE
.PP
\fBReturns\fP
.RS 4
the number of Keys that \fCks\fP contains\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP

.SS "uint16_t ksIncRef (KeySet * ks)"

.PP
Increment the reference counter of a KeySet object\&. As long as the reference counter is non-zero, \fC\fBksDel()\fP\fP operations on \fCkey\fP will be a no-op and return an error code\&.
.PP
Elektra's system for reference counting is not based on a concept of shared ownership\&. It is more similar to a shared lock, where the counter is used to keep track of how many clients hold the lock\&.
.PP
Initially, the reference counter will be 0\&. This can be interpreted as the lock being unlocked\&. When you increment the reference counter, the lock becomes locked and \fC\fBksDel()\fP\fP is blocked and fails\&. Only when the reference counter is fully decremented back down to 0 again, will \fC\fBksDel()\fP\fP work again\&.
.PP
\fBNote\fP
.RS 4
The reference counter can never exceed \fCUINT16_MAX - 1\fP\&. \fCUINT16_MAX\fP is reserved as an error code\&.
.RE
.PP
\fBPostcondition\fP
.RS 4
\fCks's\fP reference counter is > 0 
.PP
\fCks's\fP reference counter is <= UINT16_MAX - 1
.RE
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet object whose reference counter should be increased
.RE
.PP
\fBReturns\fP
.RS 4
the updated value of the reference counter 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIUINT16_MAX\fP on NULL pointer 
.br
\fIUINT16_MAX\fP when the reference counter already was the maximum value \fCUINT16_MAX - 1\fP, the reference counter will not be modified in this case
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksGetRef()\fP to retrieve the current reference count 
.PP
\fBksDecRef()\fP for decreasing the reference counter 
.PP
\fBksDel()\fP for deleting a Key 
.RE
.PP

.SS "Key* ksLookup (KeySet * ks, Key * key, \fBelektraLookupFlags\fP options)"

.PP
Look for a Key contained in \fCks\fP that matches the name of the \fCkey\fP\&. 
.PP
\fBNote\fP
.RS 4
Applications should only use \fBksLookup()\fP with cascading Keys (Key name starting with \fC/\fP)\&. Furthermore, a lookup should be done for every Key (also when iterating over Keys) so that the specifications are honored correctly\&. Keys of all namespaces need to be present so that \fBksLookup()\fP can work correctly, so make sure to also use \fBkdbGet()\fP with a cascading Key\&.
.RE
.PP
\fBksLookup()\fP is designed to let you work with a KeySet containing all Keys of the application\&. The idea is to fully \fBkdbGet()\fP the whole configuration of your application and process it all at once with many \fC\fBksLookup()\fP\fP\&.
.PP
This function is efficient (at least using binary search)\&. Together with \fBkdbGet()\fP, which you can use to load the whole configuration, you can write very effective and short code for configuration:
.PP
.PP
.nf
Key * key = keyNew ("/sw/tests/myapp/#0/current/",  KEY_END);
KDB * handle = kdbOpen (NULL, key);
kdbGet (handle, myConfig, key);
Key * result = ksLookupByName (myConfig, "/sw/tests/myapp/#0/current/testkey1", 0);
.fi
.PP
 This is the way programs should get their configuration and search for the values\&. It is guaranteed, that more namespaces can be added easily and that all values can be set by admin and user\&. Furthermore, using the kdb-tool, it is possible to introspect which values an application will get (by doing the same cascading lookup)\&.
.PP
If found, a pointer to the Key is returned\&. If not found a NULL pointer is returned\&.
.PP
Cascading lookups will by default search in all namespaces (proc:/, dir:/, user:/ and system:/), but will also correctly consider the specification (=metadata) in spec:/:
.PP
.IP "\(bu" 2
\fCoverride/#\fP will make sure that another Key is considered before
.IP "\(bu" 2
\fCnamespace/#\fP will change the number and/or order in which the namespaces are searched
.IP "\(bu" 2
\fCfallback/#\fP will search for other Keys when the other possibilities up to now were not successful
.IP "\(bu" 2
\fCdefault\fP to return the given value when not even \fCfallback\fP Keys were found\&.
.PP
.PP
\fBNote\fP
.RS 4
override and fallback work recursively, while default does not\&.
.RE
.PP
This process is very flexible, but it would be boring to manually follow all this links to find out which Key will be taken in the end\&. Use \fCkdb get -v\fP to trace the Keys\&.
.PP
\fBKDB_O_POP\fP
.RS 4
When \fBKDB_O_POP\fP is set the Key which was found will be \fBksPop()\fPed\&.
.RE
.PP
\fBNote\fP
.RS 4
Like in \fBksPop()\fP the popped Key always needs to be \fBkeyDel()\fP afterwards, even if it is appended to another KeySet\&.
.RE
.PP
.PP
.nf
void f (KeySet * iterator, KeySet * lookup)
{
        KeySet * append = ksNew (ksGetSize (lookup), KS_END);
        ssize_t ksSize = ksGetSize (iterator);

        for (elektraCursor it = 0; it < ksSize; ++it)
        {
                Key * current = ksAtCursor (iterator, it);
                Key * key = ksLookup (lookup, current, KDB_O_POP);
                // do something\&.\&.\&.
                ksAppendKey (append, key); // now append it to append, not lookup!
                keyDel (key);              // make sure to ALWAYS delete poped keys\&.
        }
        ksAppend (lookup, append);
        // now lookup needs to be sorted only once, append never
        ksDel (append);
}
.fi
.PP
 This is also a nice example how a complete application with \fBksLookup()\fP can look like\&.
.PP
\fBKDB_O_DEL\fP
.RS 4
Passing \fBKDB_O_DEL\fP will cause the deletion of the parameter \fCkey\fP using \fBkeyDel()\fP\&.
.RE
.PP
\fBHybrid search\fP
.RS 4
When Elektra is compiled with \fCENABLE_OPTIMIZATIONS=ON\fP a hybrid search decides dynamically between the binary search and the \fCOPMPHM\fP\&. The hybrid search can be overruled by passing \fBKDB_O_OPMPHM\fP or \fBKDB_O_BINSEARCH\fP in the options to \fBksLookup()\fP\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet that should be searched 
.br
\fIkey\fP the Key object you are looking for 
.br
\fIoptions\fP of type \fBelektraLookupFlags\fP with some \fCKDB_O_*\fP option bits - as explained above
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the Key found 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP if no Key has been found 
.br
\fI0\fP on NULL pointers
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksLookupByName()\fP to search by a name given by a string 
.PP
\fBksGetSize()\fP, \fBksAtCursor()\fP for iterating over a KeySet 
.RE
.PP

.SS "Key* ksLookupByName (KeySet * ks, const char * name, \fBelektraLookupFlags\fP options)"

.PP
Convenience method to look for a Key contained in \fCks\fP with name \fCname\fP\&. There are several options that can be used in conjunction with this function\&. All possible option flags can be found in \fBelektraLookupFlags\fP
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet that should be searched 
.br
\fIname\fP name of the Key you are looking for 
.br
\fIoptions\fP some \fCKDB_O_*\fP option bits (KDB_O_POP, KDB_O_DEL):
.IP "\(bu" 2
See \fBksLookup()\fP or \fBelektraLookupFlags\fP for possible options
.PP
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the Key found 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP if no Key has been found 
.br
\fI0\fP on NULL pointers
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksLookup()\fP for explanation of the functionality and examples\&. 
.PP
\fBksGetSize()\fP, \fBksAtCursor()\fP for iterating over a KeySet 
.RE
.PP

.SS "KeySet* ksNew (size_t alloc,  \&.\&.\&.)"

.PP
Allocate, initialize and return a new KeySet object\&. Objects created with \fBksNew()\fP must be destroyed with \fBksDel()\fP\&.
.PP
You can use an arbitrary long list of parameters to preload the KeySet with a list of Keys\&. Either your first and only parameter is 0 or your last parameter must be KS_END\&.
.PP
So, terminate with ksNew(0, KS_END) or ksNew(20, \&.\&.\&., KS_END)
.PP
\fBWarning\fP
.RS 4
Never use ksNew(0, keyNew(\&.\&.\&.), KS_END)\&. If the first parameter is 0, other arguments are ignored\&.
.RE
.PP
The first parameter \fCalloc\fP defines how many Keys can be added without reallocation\&. If you pass any alloc size greater than 0, but less than 16, it will default to 16\&.
.PP
For most uses
.PP
.PP
.nf
KeySet * keys = ksNew (1, KS_END);
// enough memory for up to 16 keys, without needing reallocation
ksDel (keys);
.fi
.PP
 will be fine\&. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large KeySets\&.
.PP
You can defer the allocation of the internal array that holds the Keys, by passing 0 as the alloc size\&. This is useful if it is unclear whether your KeySet will actually hold any Keys and you want to avoid a malloc call\&.
.PP
.PP
.nf
// Create KeySet without allocating memory for keys
KeySet * keys = ksNew (0, KS_END);
// The first allocation will happen in ksAppendKey
ksAppendKey(keys, keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key02", KEY_VALUE, "value02", KEY_END));
// work with the KeySet
ksDel (keys);
.fi
.PP
 If the size of the KeySet is known in advance, use the \fCalloc\fP parameter to hint the size of the KeySet\&.
.PP
If your application only needs up to 15 Keys you can request a KeySet of size 15:
.PP
.PP
.nf
KeySet * keys = ksNew (15, keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key01", KEY_VALUE, "value01", KEY_END),
                       keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key02", KEY_VALUE, "value02", KEY_END),
                       keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key03", KEY_VALUE, "value03", KEY_END),
                       // \&.\&.\&.
                       keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key15", KEY_VALUE, "value15", KEY_END), KS_END);
// work with it
ksDel (keys);
.fi
.PP
 If you start having 3 Keys, and your application needs approximately 200 up to 500 Keys, you can use:
.PP
.PP
.nf
KeySet * config = ksNew (500, keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key1", KEY_VALUE, "value1", KEY_END),
                         keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key2", KEY_VALUE, "value2", KEY_END),
                         keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key3", KEY_VALUE, "value3", KEY_END),
                         KS_END); // don't forget the KS_END at the end!
// work with it
ksDel (config);
.fi
.PP
 Alloc size is 500, the size of the KeySet will be 3 after ksNew\&. This means the KeySet will reallocate when appending more than 497 keys\&.
.PP
The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible KeySet\&. If you prefer, you can always create an empty KeySet and use \fBksAppendKey()\fP\&.
.PP
\fBPostcondition\fP
.RS 4
the KeySet is rewinded properly
.RE
.PP
\fBParameters\fP
.RS 4
\fIalloc\fP gives a hint for how many Keys may be stored initially
.RE
.PP
\fBReturns\fP
.RS 4
a ready to use KeySet object 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP on memory error
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksDel()\fP to free the KeySet afterwards 
.PP
\fBksDup()\fP to duplicate an existing KeySet 
.PP
\fBksAppendKey()\fP to append individual Keys to a KeySet 
.RE
.PP

.SS "Key* ksNext (KeySet * ks)"

.PP
Returns the next Key in a KeySet\&. KeySets have an internal cursor that can be reset with \fBksRewind()\fP\&. Every time \fBksNext()\fP is called, the cursor is incremented and the new current Key is returned\&.
.PP
You'll get a NULL pointer if the Key at the end of the KeySet has been reached\&. On subsequent calls of \fBksNext()\fP it will still return the NULL pointer\&.
.PP
The \fCks\fP internal cursor will be changed, so it is not const\&.
.PP
\fBNote\fP
.RS 4
You must not delete or change the Key, use \fBksPop()\fP if you want to delete it\&.
.PP
That applications must do \fBksLookup()\fP with an cascading Key for every single Key before using it, because specifications allow to hide or override Keys\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet object to work with
.RE
.PP
\fBReturns\fP
.RS 4
the new current Key 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP when the end of the KeySet has been reached 
.br
\fI0\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksRewind()\fP for resetting the internal cursor of the KeySet 
.PP
\fBksCurrent()\fP for getting the Key the cursor currently points at 
.PP
\fBksLookup()\fP to honor specifications 
.RE
.PP

.SS "Key* ksPop (KeySet * ks)"

.PP
Remove and return the last Key of \fCks\fP\&. The reference counter of the Key will be decremented by one\&.
.PP
The KeySet's cursor will not be affected if it did not point to the popped Key\&.
.PP
\fBNote\fP
.RS 4
You need to \fBkeyDel()\fP the Key afterwards, if you don't append it to another KeySet\&. It has the same semantics like a Key allocated with \fBkeyNew()\fP or keyDup()\&.
.RE
.PP
.PP
.nf
ks1=ksNew(0, KS_END);
ks2=ksNew(0, KS_END);

k1=keyNew("user:/name", KEY_END); // ref counter 0
ksAppendKey(ks1, k1); // ref counter 1
ksAppendKey(ks2, k1); // ref counter 2

k1=ksPop (ks1); // ref counter 1
k1=ksPop (ks2); // ref counter 0, like after keyNew()

ksAppendKey(ks1, k1); // ref counter 1

ksDel (ks1); // key is deleted too
ksDel (ks2);
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIks\fP KeySet to pop a Key from
.RE
.PP
\fBReturns\fP
.RS 4
the last Key of \fCks\fP 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINULL\fP if \fCks\fP is empty or a NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksLookup()\fP to pop Keys by name 
.PP
\fBksCopy()\fP to pop all Keys 
.RE
.PP

.SS "ssize_t ksRename (KeySet * ks, const Key * root, const Key * newRoot)"

.PP
Moves all keys below \fCroot\fP to below \fCnewRoot\fP\&. Only keys below \fCroot\fP will be modified\&. The rest of \fCks\fP remains untouched\&.
.PP
This functions is similar to the following snippet, but there are some differences\&.
.PP
.PP
.nf
KeySet * toRename = ksCut (ks, root);
for (elektraCursor cursor = 0; cursor < ksGetSize (toRename); cursor++)
{
    Key * cur = keyDup (ksAtCursor (ks, cursor));
    keyReplacePrefix (cur, root, newRoot);
    ksAppendKey (ks, cur);
}
ksDel (toRename);
.fi
.PP
.PP
Firstly, the optimizations only work, if \fCks\fP doesn't contain any keys below \fCnewRoot\fP that aren't below \fCroot\fP\&. If such keys exist, \fBksRename()\fP will still work, but it will fall back to code similar to the for-loop above\&.
.PP
The second difference is that \fBksRename()\fP will modify the keys in \fCks\fP directly, if they aren't referenced from anywhere else (if their reference count is 1 (see \fBkeyGetRef()\fP))\&. Normally, this shouldn't cause problems, but if you have a direct \fCKey *\fP pointer to a key in \fCks\fP or hold a reference to some data within a key of \fCks\fP, you may need to call \fBkeyIncRef()\fP to ensure the key isn't modified\&.
.PP
\fBParameters\fP
.RS 4
\fIks\fP the keyset to manipulate 
.br
\fIroot\fP the old prefix that will be removed, must not be a cascading key 
.br
\fInewRoot\fP the new prefix the will replace the old one, must not be a cascading key
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP if any of \fCks\fP, \fCroot\fP, \fCnewRoot\fP is NULL, or if \fCroot\fP or \fCnewRoot\fP are cascading keys 
.br
\fI-2\fP if \fCks\fP already contains keys below \fCnewRoot\fP 
.br
\fI0\fP if \fCks\fP contains no keys below \fCroot\fP (and also not \fCroot\fP itself) 
.RE
.PP
\fBReturns\fP
.RS 4
otherwise, the number of keys that have been renamed 
.RE
.PP

.SS "int ksRewind (KeySet * ks)"

.PP
Rewinds the KeySet internal cursor\&. Use it to set the cursor to the beginning of the KeySet\&. \fBksCurrent()\fP will always return NULL afterwards\&. So you want to use \fBksNext()\fP first\&.
.PP
.PP
.nf
ksRewind (ks);
while ((key = ksNext (ks))!=0) {}
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet that should be rewound
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP on success 
.br
\fI-1\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksNext()\fP for moving the cursor to the next entry in the KeySet 
.PP
\fBksCurrent()\fP for getting the current element in the KeySet 
.RE
.PP

.SS "ssize_t ksSearch (const KeySet * ks, const Key * key)"

.PP
Search in a key set, either yielding the actual index of the key, if the key has been found within the key set, or a negative value indicating the insertion index of the key, if the key would be inserted\&. 
.PP
.nf
ssize_t result = ksSearch(ks, key);

if (result >= 0)
{
        ssize_t position = result;
        // The key already exist in key set\&.
} else {
        ssize_t insertpos = -result-1;
        // The key was not found in key set\&.
}

.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIks\fP the keyset to work with 
.br
\fIkey\fP the key to check 
.RE
.PP
\fBReturns\fP
.RS 4
position where the key is (>=0) if the key was found 
.PP
-insertpos -1 (< 0) if the key was not found so to get the insertpos simple do: -insertpos -1 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksLookup()\fP for retrieving the found \fBKey\fP 
.RE
.PP

.SS "int ksSetCursor (KeySet * ks, elektraCursor cursor)"

.PP
Set the KeySet internal cursor to \fCcursor\fP\&. Use it to set the cursor to a stored position\&. \fBksCurrent()\fP will then return the Key at the position of the supplied cursor\&.
.PP
\fBWarning\fP
.RS 4
Cursors may get invalid when the Key was \fBksPop()\fPed or \fBksLookup()\fP was used together with KDB_O_POP\&.
.RE
.PP
.PP
.nf
elektraCursor cursor;
\&.\&.
// key now in any position here
cursor = ksGetCursor (ks);
while ((key = keyNextMeta (ks))!=0) {}
ksSetCursor (ks, cursor); // reset state
ksCurrent(ks); // in same position as before
.fi
.PP
.PP
An invalid cursor will set the KeySet to its beginning like \fBksRewind()\fP\&. When you set an invalid cursor \fBksCurrent()\fP is 0\&.
.PP
\fBParameters\fP
.RS 4
\fIks\fP the KeySet object where the cursor should be set 
.br
\fIcursor\fP the cursor to set for \fCks\fP 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP when the KeySet has been \fBksRewind()\fPed 
.br
\fI1\fP otherwise 
.br
\fI-1\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksGetCursor()\fP for getting the cursor at the current position 
.PP
\fBksNext()\fP for moving the internal cursor forward 
.PP
\fBksCurrent()\fP for getting the Key at the current position 
.RE
.PP

.SS "ssize_t ksSubtract (KeySet * total, const KeySet * sub)"

.PP
Remove all the keys in \fCsub\fP from \fCtotal\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fItotal\fP the keyset where the keys should be removed from 
.br
\fIsub\fP the keys to remove 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP on \fCNULL\fP pointers 
.br
\fIthe\fP number of keys removed from \fCtotal\fP 
.RE
.PP

.SS "KeySet* ksVNew (size_t alloc, va_list va)"

.PP
Allocate, initialize and return a new KeySet object\&. Objects created with \fBksNew()\fP must be destroyed with \fBksDel()\fP\&.
.PP
You can use an arbitrary long list of parameters to preload the KeySet with a list of Keys\&. Either your first and only parameter is 0 or your last parameter must be KS_END\&.
.PP
So, terminate with ksNew(0, KS_END) or ksNew(20, \&.\&.\&., KS_END)
.PP
\fBWarning\fP
.RS 4
Never use ksNew(0, keyNew(\&.\&.\&.), KS_END)\&. If the first parameter is 0, other arguments are ignored\&.
.RE
.PP
The first parameter \fCalloc\fP defines how many Keys can be added without reallocation\&. If you pass any alloc size greater than 0, but less than 16, it will default to 16\&.
.PP
For most uses
.PP
.PP
.nf
KeySet * keys = ksNew (1, KS_END);
// enough memory for up to 16 keys, without needing reallocation
ksDel (keys);
.fi
.PP
 will be fine\&. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large KeySets\&.
.PP
You can defer the allocation of the internal array that holds the Keys, by passing 0 as the alloc size\&. This is useful if it is unclear whether your KeySet will actually hold any Keys and you want to avoid a malloc call\&.
.PP
.PP
.nf
// Create KeySet without allocating memory for keys
KeySet * keys = ksNew (0, KS_END);
// The first allocation will happen in ksAppendKey
ksAppendKey(keys, keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key02", KEY_VALUE, "value02", KEY_END));
// work with the KeySet
ksDel (keys);
.fi
.PP
 If the size of the KeySet is known in advance, use the \fCalloc\fP parameter to hint the size of the KeySet\&.
.PP
If your application only needs up to 15 Keys you can request a KeySet of size 15:
.PP
.PP
.nf
KeySet * keys = ksNew (15, keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key01", KEY_VALUE, "value01", KEY_END),
                       keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key02", KEY_VALUE, "value02", KEY_END),
                       keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key03", KEY_VALUE, "value03", KEY_END),
                       // \&.\&.\&.
                       keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key15", KEY_VALUE, "value15", KEY_END), KS_END);
// work with it
ksDel (keys);
.fi
.PP
 If you start having 3 Keys, and your application needs approximately 200 up to 500 Keys, you can use:
.PP
.PP
.nf
KeySet * config = ksNew (500, keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key1", KEY_VALUE, "value1", KEY_END),
                         keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key2", KEY_VALUE, "value2", KEY_END),
                         keyNew ("user:/sw/org/app/#0/current/fixedConfiguration/key3", KEY_VALUE, "value3", KEY_END),
                         KS_END); // don't forget the KS_END at the end!
// work with it
ksDel (config);
.fi
.PP
 Alloc size is 500, the size of the KeySet will be 3 after ksNew\&. This means the KeySet will reallocate when appending more than 497 keys\&.
.PP
The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible KeySet\&. If you prefer, you can always create an empty KeySet and use \fBksAppendKey()\fP\&.
.PP
\fBPostcondition\fP
.RS 4
the KeySet is rewinded properly
.RE
.PP
\fBParameters\fP
.RS 4
\fIalloc\fP gives a hint for how many Keys may be stored initially
.RE
.PP
\fBReturns\fP
.RS 4
a ready to use KeySet object 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP on memory error
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0 
.RE
.PP
\fBSee also\fP
.RS 4
\fBksDel()\fP to free the KeySet afterwards 
.PP
\fBksDup()\fP to duplicate an existing KeySet 
.PP
\fBksAppendKey()\fP to append individual Keys to a KeySet
.RE
.PP
\fBPrecondition\fP
.RS 4
caller must call va_start and va_end 
.RE
.PP
\fBva the list of arguments\fP
.RS 4

.RE
.PP
\fBParameters\fP
.RS 4
\fIalloc\fP the allocation size 
.br
\fIva\fP the list of variable arguments 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Elektra from the source code\&.
