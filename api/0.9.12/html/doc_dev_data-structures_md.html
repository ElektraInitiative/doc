<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Data Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
$darkmode
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Add mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_color_doxygen.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Elektra<span id="projectnumber">&#160;0.9.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Data Structures </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_dev_data_structures"></a> For an introduction, please <a class="el" href="doc_dev_classes_md.html">read first about elektra classes</a>. You might want to read <a class="el" href="doc_dev_architecture_md.html">about architecture first</a>.</p>
<h1><a class="anchor" id="autotoc_md2585"></a>
Introduction</h1>
<p>Data structures define the common layer in Elektra. They are used for transferring configuration between Elektra and applications, but also between plugins.</p>
<h2><a class="anchor" id="autotoc_md2586"></a>
ADT</h2>
<p>Both the <code>KeySet</code> and the interface to metadata within a <code>Key</code> are actually <b>ADT</b> (abstract data types). The API is designed so that different implementations of the data structures can be used internally.</p>
<p>A sorted <b>array</b> provides very fast iteration O(1) and has nearly no size-overhead.</p>
<p>A <b>hash map</b> data structure presents the best candidate for lookups O(1).</p>
<p><code>KeySet</code> combines the best of both worlds: <code>KeySet</code> is implemented as a sorted array and uses an <a href="#order-preserving-minimal-perfect-hash-map-aka-opmphm">order-preserving minimal perfect hash map (OPMPHM)</a> for lookups.</p>
<h2><a class="anchor" id="autotoc_md2587"></a>
ABI compatibility</h2>
<p>Application binary interface, or ABI, is the interface to all data structures of an application or library directly allocated or accessed by the user.</p>
<p>Special care has been taken in Elektra to support all changes within the data structures without any ABI changes. ABI changes would entail the recompilation of applications and plugins using Elektra. The functions <code><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step.">keyNew()</a></code>, <code><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a></code> and <code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> allocate the data structures for the applications. The user only gets pointers to them. It is not possible for the user to allocate or access these data structures directly when only using the public header file <code>&lt;kdb.h&gt;</code>. The functions <code><a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects.">keyDel()</a></code>, <code><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a></code> and <code><a class="el" href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f" title="Closes the session with the Key database.">kdbClose()</a></code> free the resources after use. Using the C++ binding deallocation is done automatically.</p>
<h2><a class="anchor" id="autotoc_md2588"></a>
Copy-on-Write</h2>
<p>The two basic Elektra datastructures <code>Key</code> and <code>KeySet</code> implement full copy-on-write (COW) functionality. If a key or a keyset gets copied, only a shallow copy with references to the original data (name, value, contained keys, etc.) is created. When this shared data is modified, new memory is allocated to keep the shared version in tact. As a consequence, duplicated keys or keysets only require a fraction of the memory compared to their source counterparts.</p>
<h1><a class="anchor" id="autotoc_md2589"></a>
Metadata</h1>
<p>Read <a class="el" href="doc_dev_metadata_md.html">here</a>.</p>
<h1><a class="anchor" id="autotoc_md2590"></a>
KeySet</h1>
<p>This subsection describes what has changed between 0.7 and 0.8 and deals with some general implementation issues.</p>
<h2><a class="anchor" id="autotoc_md2591"></a>
Operations</h2>
<p><code>KeySet</code> resembles the classical mathematical set. Operations like union, intersection or difference are well-defined. In mathematics typically every operation yields a new set. Instead, we try to reuse sets in the following ways:</p>
<ul>
<li><p class="startli">A completely new and independent <code>KeySet</code> as return value would resemble the mathematical ideal closely. This operation would be expensive. Every <code>Key</code> needs to be duplicated and inserted into a new <code>KeySet</code>.</p>
<p class="startli">Such a <b>deep duplication</b> was only needed in <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to the Key database in an atomic and universal way.">kdbSet()</a></code>.</p>
</li>
<li><p class="startli">The resulting <code>KeySet</code> is created during the operation, but only a flat copy is made. This means that the keys in it are actually not duplicated, but only their reference counter is increased. This method is similar to the mathematical model. Compared with a deep copy it can achieve good performance. But all changes to the values of keys in the resulting <code>KeySet</code> affect the original <code>KeySet</code>, too.</p>
<p class="startli"><code><a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup(const KeySet *source)</a></code> produces a new <code>KeySet</code>. That way the <code>source</code> is not changed as shown by the <code>const</code> modifier.</p>
</li>
<li><p class="startli">The result of the operation is applied to the <code>KeySet</code> passed as argument directly. This is actually quite common, but for this situation other names of the operations are more suitable.</p>
<p class="startli">For example, a union which changes the <code>KeySet</code> is called <code><a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all Keys in toAppend to the end of the KeySet ks.">ksAppend()</a></code>.</p>
</li>
<li><p class="startli">A new <code>KeySet</code> is created, but the <code>KeySet</code> passed as parameter is reduced by the keys needed for the new <code>KeySet</code>. This is useful in situations where many operations have to be applied in a sequence reducing the given <code>KeySet</code> until no more keys are left. None of the reference pointers change in this situation.</p>
<p class="startli"><code><a class="el" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a" title="Cuts out all Keys from KeySet ks that are below or at cutpoint.">ksCut(KeySet *ks, const Key *cutpoint)</a></code> works that way. All keys below the <code>cutpoint</code> are moved from <code>ks</code> to the returned key set.</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md2592"></a>
Consistency</h2>
<p>There are several ways to define consistency relations on key sets. For <b>strict consistency</b> every parent key must exist before the user can append a key to a key set. For example, the key set with the keys</p>
<div class="fragment"><div class="line">system:/</div>
<div class="line">system:/elektra</div>
<div class="line">system:/elektra/mountpoints</div>
</div><!-- fragment --><p>would allow the key <code>system:/elektra/mountpoints/tcl</code> to be added, but not the key <code>system:/apps/abc</code> because <code>system:/apps</code> is missing. File systems enforce this kind of consistency.</p>
<p>These semantics are however not useful for configurations. Especially for user configurations often only some keys need to be overwritten. It is not a good idea to copy all parent keys to the users' configuration. For this reason we use a less strict definition of consistency supporting such holes.</p>
<p>We also evaluated a form of <b>weak consistency</b>. It avoids adding some unnecessary keys. A constraint is that a key can be added only if it has a parent key. But the constraint does not apply if no other key exists above the key about to be inserted. From that moment it will serve as parent key for other keys. With the current implementation of <code>KeySet</code>, however, it is not possible to decide this constraint in constant time. Instead its worst-case complexity would be $log(n) * x$ where $n$ is the number of keys currently in the key set and $x$ is the <em>depth</em> of the key. The depth is the number of <code>/</code> in the key name. The worst-case of the complexity applies when the inserting works without a parent key. For example, with the keys</p>
<div class="fragment"><div class="line">user:/sw/apps/abc/current/bindings</div>
<div class="line">user:/sw/apps/abc/current/bindings/key1</div>
<div class="line">user:/sw/apps/abc/current/bindings/key2</div>
</div><!-- fragment --><p>the weak consistency would allow inserting <code>user:/sw/apps/abc/current/bindings/key3</code> because it is directly below an existing key. It would also allow adding <code>user:/sw/apps/xyz/current</code> because it does not have any parent key. But it would not allow <code>user:/sw/apps/abc/current/bindings/dir/key1</code> to add. The worst-case complexity was found to be too expensive, and hence <code>KeySet</code> has <b>no consistency</b> check at all.</p>
<p>This means any key with a valid key name can be inserted into <code>KeySet</code>. The <code>KeySet</code> is changed so that it is now impossible to append keys without a name. <code>ksAppendKey(ks, Key *toAppend)</code> takes ownership of the key <code>toAppend</code> and will delete the key in that case. The caller does not have to free <code>toAppend</code>: either it is in the key set or it is deleted.</p>
<p>Binary search determines the position where to insert a key. The C version of binary search <code>bsearch()</code> cannot tell where to insert a key when it is not found. So the algorithm has to be reimplemented. Java's binary search <code>binarySearch()</code> uses a trick to both indicate where a key is found and where to insert it with the same return code by returning the negative value <code>((-insertion point) - 1)</code> indicating where the new value should be inserted when the key is not found. Elektra now also uses this trick internally.</p>
<h2><a class="anchor" id="autotoc_md2593"></a>
Iteration</h2>
<p>Iterating over a <code>KeySet</code> is similar to iterating over arrays. With <code>ssize_t ksGetSize (const KeySet *ks)</code>, the total number of <code>Key</code>s in a <code>KeySet</code> can be retrieved and with the function <code>Key *ksAtCursor (const KeySet *ks, elektraCursor cursor)</code> the <code>Key *</code> at the specified position <code>cursor</code> in <code>ks</code> can be retrieved. The first element (<code>Key</code>) has the index 0, so the last <code>Key</code> in the <code>KeySet</code> <code>ks</code> can be accessed with <code>Key * k = ksAtCursor (ks, ksGetSize (ks) - 1)</code>. Please be aware the elements in a <code>KeySet</code> can move and therefore change their index, e.g. when deleting or adding elements or using <code>ksCut ()</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (elektraCursor it = 0; it &lt; <a class="code" href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">ksGetSize</a> (ks); ++it)</div>
<div class="line">{</div>
<div class="line">        Key * cur = <a class="code" href="group__keyset.html#gab3fb5e067c672d9fd60a4022b2ae9dd1">ksAtCursor</a> (ks, it);</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__keyset_html_ga7474ad6b0a0fa969dbdf267ba5770eee"><div class="ttname"><a href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">ksGetSize</a></div><div class="ttdeci">ssize_t ksGetSize(const KeySet *ks)</div><div class="ttdoc">Return the number of Keys that ks contains.</div><div class="ttdef"><b>Definition:</b> keyset.c:794</div></div>
<div class="ttc" id="agroup__keyset_html_gab3fb5e067c672d9fd60a4022b2ae9dd1"><div class="ttname"><a href="group__keyset.html#gab3fb5e067c672d9fd60a4022b2ae9dd1">ksAtCursor</a></div><div class="ttdeci">Key * ksAtCursor(const KeySet *ks, elektraCursor pos)</div><div class="ttdoc">Return Key at given position pos.</div><div class="ttdef"><b>Definition:</b> keyset.c:1981</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2594"></a>
Order Preserving Minimal Perfect Hash Map (aka OPMPHM)</h1>
<p>The OPMPHM is a non-dynamic randomized hash map of the Las Vegas type, that creates an index over the elements, to gain O(1) access.</p>
<p>The elements must be arranged in an array and each element must have a unique name, to identify the elements. The source can be found in <a href="/home/jenkins/workspace/libelektra-release/src/include/kdbopmphm.h">kdbopmphm.h</a> and <a href="/home/jenkins/workspace/libelektra-release/src/libs/elektra/opmphm.c">opmphm.c</a> and also works outside of Elektra.</p>
<p>The OPMPHM does not store any buckets, your array of elements are the buckets and the OPMPHM represent an arbitrary index over those. The desired index of an element, also known as the order, is set in <code>OpmphmGraph-&gt;edges[i].order</code>, where <code>i</code> is the i-th element in your array. When the orders should represent the array indices, the default order can be applied during the assignment step. When the orders are not the default order, <code>OpmphmGraph-&gt;edges[i].order</code> should be set before the assignment step.</p>
<p>Because the OPMPHM is non-dynamic, there are no insert and delete operations. The OPMPHM gets build for a static set of elements, once the OPMPHM is build, every:</p>
<ul>
<li>change of at least one indexed element name</li>
<li>addition of a new element</li>
<li>deletion of an indexed element</li>
</ul>
<p>leads to an invalid OPMPHM and forces a rebuild. A build consists of two steps the mapping step and the assignment step.</p>
<p>During the mapping step the OPMPHM maps each element to an edge in a random acyclic r-uniform r-partite hypergraph. In a r-uniform r-partite hypergraph each edge connects <code>r</code> vertices, each vertex in a different component. The probability of being acyclic and the number of mapping step invocations depends on the following variables:</p>
<ul>
<li><code>r</code>: The <code>r</code> variable defines the number of components in the random r-uniform r-partite hypergraph. Use the <code>opmphmOptR (n)</code> function to get an optimal value for your number of elements (<code>n</code>).</li>
<li><code>c</code>: The <code>c</code> variable defines the number of vertices in each component of the random r-uniform r-partite hypergraph. The number of vertices in one component is defined as <code>(c * n / r) + 1</code>, where <code>n</code> is the number of elements and <code>r</code> is the variable from above. The <code>c</code> variable must have a minimal value to ensure a success probability, use the <code>opmphmMinC (r)</code> function, with your <code>r</code> from above. To ensure an optimal time until success increment the <code>c</code> variable with the value from the <code>opmphmOptC (n)</code> function, where <code>n</code> is the number of elements.</li>
<li><code>initSeed</code>: The initial seed set in <code>OpmphmInit-&gt;initSeed</code>.</li>
</ul>
<p><code>opmphmOptR (n)</code> and <code>opmphmOptC (n)</code> are heuristic functions constructed through benchmarks. Optimal is only one mapping step invocation in 99.5% of the observed cases. The benchmarks took arbitrary uniform distributed initial seeds and the heuristic functions are made to work with almost every seed.</p>
<h2><a class="anchor" id="autotoc_md2595"></a>
The Build</h2>
<h3><a class="anchor" id="autotoc_md2596"></a>
Initialization</h3>
<p>Use <code>opmphmNew ()</code> and <code>opmphmGraphNew (...)</code> to instantiate the needed structures. The function <code>opmphmGraphNew (...)</code> takes <code>r</code> and <code>c</code> as parameter. Use the <code>opmphmOptR (...)</code> function to get your <code>r</code> value, use this <code>r</code> also to get your <code>c</code> value the following way:</p>
<p><code>c = opmphmMinC (r) + opmphmOptC (n)</code></p>
<p>To initialize the OPMPHM build the <code>OpmphmInit</code> must be set with information about your data. Set your data array <code>OpmphmInit-&gt;data</code> and the element name extraction function <code>OpmphmInit-&gt;getName</code>, which should extract the string from a single data array entry. Provide a good seed in <code>OpmphmInit-&gt;initSeed</code>, needed in the next step.</p>
<h3><a class="anchor" id="autotoc_md2597"></a>
Mapping</h3>
<p>The function <code>opmphmMapping</code> uses your seed (the <code>OpmphmInit-&gt;seed</code> will be changed) and tries to construct the random acyclic r-uniform r-partite hypergraph, this might not succeed, on cycles just call it again.</p>
<h3><a class="anchor" id="autotoc_md2598"></a>
Assignment</h3>
<p>The <code>opmphmAssignment ()</code> function assigns either your order (set at <code>OpmphmGraph-&gt;edges[i].order</code>) or a default order. The <code>defaultOrder</code> parameter indicates the behavior.</p>
<p>After the build the OpmphmInit and OpmphmGraph should be freed. The OPMPHM is now ready for constant lookups with the <code>opmphmLookup ()</code>.</p>
<h2><a class="anchor" id="autotoc_md2599"></a>
The Rebuild</h2>
<p>Once build, follow the steps from the build, just omit the <code>opmphmNew ()</code> invocation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark'
  });
</script>
</body>
</html>
