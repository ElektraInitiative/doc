<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Name Manipulation Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Name Manipulation Methods<div class="ingroups"><a class="el" href="group__key.html">Key</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Methods to do various operations on Key names.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Name Manipulation Methods:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__keyname.png" border="0" alt="" usemap="#group____keyname"/>
<map name="group____keyname" id="group____keyname">
<area shape="rect" id="node2" href="group__key.html" title="Key is an essential class that encapsulates key name , value &#160;and metainfo . " alt="" coords="5,5,51,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8e805c726a60da921d3736cda7813513"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (const Key *key)</td></tr>
<tr class="memdesc:ga8e805c726a60da921d3736cda7813513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the abbreviated real internal <code>key</code> name.  <a href="#ga8e805c726a60da921d3736cda7813513">More...</a><br /></td></tr>
<tr class="separator:ga8e805c726a60da921d3736cda7813513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbcfa51ed8a387e47ead207affa2d2e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a> (const Key *key)</td></tr>
<tr class="memdesc:gabdbcfa51ed8a387e47ead207affa2d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes needed to store the key name without owner.  <a href="#gabdbcfa51ed8a387e47ead207affa2d2e">More...</a><br /></td></tr>
<tr class="separator:gabdbcfa51ed8a387e47ead207affa2d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe6af4c27b35d911a533f4ae4d698bb"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb">keyUnescapedName</a> (const Key *key)</td></tr>
<tr class="memdesc:ga6fe6af4c27b35d911a533f4ae4d698bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a keyname which is null separated and does not use backslash for escaping.  <a href="#ga6fe6af4c27b35d911a533f4ae4d698bb">More...</a><br /></td></tr>
<tr class="separator:ga6fe6af4c27b35d911a533f4ae4d698bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7eff0c77678420199d0d2e8729152b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b">keyGetUnescapedNameSize</a> (const Key *key)</td></tr>
<tr class="memdesc:ga5e7eff0c77678420199d0d2e8729152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return size of unescaped name with embedded and terminating null characters  <a href="#ga5e7eff0c77678420199d0d2e8729152b">More...</a><br /></td></tr>
<tr class="separator:ga5e7eff0c77678420199d0d2e8729152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29a850168d9b31c9529e90cf9ab68be"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a> (const Key *key, char *returnedName, size_t maxSize)</td></tr>
<tr class="memdesc:gab29a850168d9b31c9529e90cf9ab68be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get abbreviated key name (without owner name).  <a href="#gab29a850168d9b31c9529e90cf9ab68be">More...</a><br /></td></tr>
<tr class="separator:gab29a850168d9b31c9529e90cf9ab68be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7699091610e7f3f43d2949514a4b35d9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (Key *key, const char *newName)</td></tr>
<tr class="memdesc:ga7699091610e7f3f43d2949514a4b35d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new name to a key.  <a href="#ga7699091610e7f3f43d2949514a4b35d9">More...</a><br /></td></tr>
<tr class="separator:ga7699091610e7f3f43d2949514a4b35d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65dc9d43d3ee08d5e936a20ebbddd23"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize</a> (const Key *key)</td></tr>
<tr class="memdesc:gab65dc9d43d3ee08d5e936a20ebbddd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes needed to store the key name including user domain and ending NULL.  <a href="#gab65dc9d43d3ee08d5e936a20ebbddd23">More...</a><br /></td></tr>
<tr class="separator:gab65dc9d43d3ee08d5e936a20ebbddd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba1494a5ffc976e0e56c43f4334a23c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName</a> (const Key *key, char *returnedName, size_t maxSize)</td></tr>
<tr class="memdesc:gaaba1494a5ffc976e0e56c43f4334a23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get key full name, including the user domain name.  <a href="#gaaba1494a5ffc976e0e56c43f4334a23c">More...</a><br /></td></tr>
<tr class="separator:gaaba1494a5ffc976e0e56c43f4334a23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (const Key *key)</td></tr>
<tr class="memdesc:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal unescaped key name where the <code>basename</code> starts.  <a href="#gaaff35e7ca8af5560c47e662ceb9465f5">More...</a><br /></td></tr>
<tr class="separator:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0b76c5d9e5367c7e72211e6c63d43a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">keyGetBaseNameSize</a> (const Key *key)</td></tr>
<tr class="memdesc:ga1a0b76c5d9e5367c7e72211e6c63d43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bytes needed to store basename of <code>key</code>.  <a href="#ga1a0b76c5d9e5367c7e72211e6c63d43a">More...</a><br /></td></tr>
<tr class="separator:ga1a0b76c5d9e5367c7e72211e6c63d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0992d26bcfca767cb8e77053a483eb64"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName</a> (const Key *key, char *returned, size_t maxSize)</td></tr>
<tr class="memdesc:ga0992d26bcfca767cb8e77053a483eb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the basename of a key name and put it in <code>returned</code> finalizing the string with NULL.  <a href="#ga0992d26bcfca767cb8e77053a483eb64">More...</a><br /></td></tr>
<tr class="separator:ga0992d26bcfca767cb8e77053a483eb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa942091fc4bd5c2699e49ddc50829524"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (Key *key, const char *baseName)</td></tr>
<tr class="memdesc:gaa942091fc4bd5c2699e49ddc50829524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>baseName</code> (that will be escaped) to the current key name.  <a href="#gaa942091fc4bd5c2699e49ddc50829524">More...</a><br /></td></tr>
<tr class="separator:gaa942091fc4bd5c2699e49ddc50829524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa70593a2c772c4b7bc33423b9b10a270"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270">keyAddName</a> (Key *key, const char *newName)</td></tr>
<tr class="memdesc:gaa70593a2c772c4b7bc33423b9b10a270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an already escaped name to the keyname.  <a href="#gaa70593a2c772c4b7bc33423b9b10a270">More...</a><br /></td></tr>
<tr class="separator:gaa70593a2c772c4b7bc33423b9b10a270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e804bd453f98c28b0ff51430d1df407"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (Key *key, const char *baseName)</td></tr>
<tr class="memdesc:ga6e804bd453f98c28b0ff51430d1df407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>baseName</code> as the new basename for <code>key</code>.  <a href="#ga6e804bd453f98c28b0ff51430d1df407">More...</a><br /></td></tr>
<tr class="separator:ga6e804bd453f98c28b0ff51430d1df407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3ca03ed10f87eb59bdc02cf2a0de8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gafc3ca03ed10f87eb59bdc02cf2a0de8d">keyGetNamespace</a> (const Key *key)</td></tr>
<tr class="memdesc:gafc3ca03ed10f87eb59bdc02cf2a0de8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For currently valid namespaces see <a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68" title="Elektra currently supported Key namespaces. ">elektraNamespace</a>.  <a href="#gafc3ca03ed10f87eb59bdc02cf2a0de8d">More...</a><br /></td></tr>
<tr class="separator:gafc3ca03ed10f87eb59bdc02cf2a0de8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Methods to do various operations on Key names. </p>
<p>To use them: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kdb.h&gt;</span></div></div><!-- fragment --><p>These functions make it easier for C programmers to work with key names.</p>
<dl class="section user"><dt>Terminology of Key Names</dt><dd><ul>
<li>A <em>key name</em> (see <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> and <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a>) defines the place of a key within the key database. To be unique, it is always absolute and canonical.</li>
<li>Key names are composed out of many <em>key name parts</em> split by a separator. These <em>key name parts</em> do not contain an unescaped separator.</li>
<li>A <em>key base name</em> (see <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a> and <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a>) is the last part of the key name.</li>
<li>A <em>C-String</em> is a null terminated sequence of characters. So \0 (null-character) must not occur within a C-String.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Namespaces</dt><dd>A namespace denotes the place the key comes from:</dd></dl>
<ul>
<li><code>spec/something</code> for specification of other keys.</li>
<li><code>proc/something</code> for in-memory keys, e.g. commandline.</li>
<li><code>dir/something</code> for dir keys in current working directory</li>
<li><code>system/something</code> for system keys in /etc or /</li>
<li><code>user/something</code> for user keys in home directory</li>
<li><code>user:username/something</code> for other users (deprecated: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> + <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> currently unsupported)</li>
<li><p class="startli"><code>/something</code> for cascading keys (actually refers to one of the above, see also <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a>)</p>
<dl class="section note"><dt>Note</dt><dd>The rules are currently not formally specified and are subject of change in the next major release. So, always prefer:<ul>
<li>To use <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> and <a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add an already escaped name to the keyname. ">keyAddName()</a> to get the canonified version of the keyname</li>
<li>To use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a> and <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a> to get an escaped key name part.</li>
<li>Not to escape or canonify with your own algorithms!</li>
<li>To use <a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb" title="Returns a keyname which is null separated and does not use backslash for escaping. ">keyUnescapedName()</a> and <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a> to have access to the key name without escape sequences (key name parts are null terminated)</li>
<li>Not to unescape the strings yourself!</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Syntax for Key Names</dt><dd>Key names and key name parts have following goals:<ul>
<li>The C-String passed to <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> and <a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add an already escaped name to the keyname. ">keyAddName()</a> may be any C-String.</li>
<li>The <em>key name parts</em> (e.g. <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a>, <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a>) may be any C-String. Escaping is needed to achieve both goals.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Semantics for Key Name Parts</dt><dd><ul>
<li>% denotes an empty key name part.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Canonicalization for Key Names</dt><dd><ul>
<li>/ (slash) is the separator between key name parts.</li>
<li>// is shortened to /</li>
<li>trailing / (slashes) are removed</li>
<li>. (dot) and .. (dot-dot) is removed in an canonical key name, with following rules:<ul>
<li>/./ is shortened to /</li>
<li>_/../ is shortened to _</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Conventions for key names</dt><dd><ul>
<li>Key name parts starting with # are array elements. Then only _ (underscore) followed by 0-9 is allowed. So we have the regular expression #[_]*[0-9]+ with the further limitation that the number of _ is defined by the number of digits-1.</li>
<li>Key name parts starting with _ are reserved for special purposes (if you use this within a plugin you still have to make sure _ is escaped properly)</li>
<li>Key name parts starting with @ are reserved for special purposes (if you use this within a plugin you still have to make sure @ is escaped properly)</li>
<li>If any key name part starts with . (dot) it means the key is inactive, see <a class="el" href="group__keytest.html#gaa25f699f592031c1a0abc1504d14e13e" title="Check whether a key is inactive. ">keyIsInactive()</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Escaping rules</dt><dd><ul>
<li>\ (backslash) is the escape character for the situations as described here (and only these). The \ character must only be escaped, when one of the following rules apply.</li>
<li>Stray escape characters are only possible in the end of the string.</li>
<li>\/ allows one to escape / (any uneven number of \). Does not introduce a new part.</li>
<li>Any uneven number N of \ before / allows you to escape / with the N/2 of \ prefixed. Does not introduce a new part.</li>
<li>\\/ allows one to use \ as character before / and introduces a new part.</li>
<li>Any even number N of \ before / allows you to have N/2 of \ prefixed before a / which introduces a new part.</li>
<li>Use \. and \.. if you want your key name part to represent . and ..</li>
<li>\\. and \\.. allows us to use \ as character before . and .. (and so on)</li>
<li>Use \% if you want your key name part to start with % (and does not represent an empty name)</li>
<li>Using \\% allows one to use \ as character before % (and so on)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Semantics for Key Name Specifications</dt><dd><ul>
<li>_ denotes that the key name part is arbitrary (syntax as described above).</li>
<li># denotes that the key name part has array syntax.</li>
<li>names surrounded by % (e.g. %profile%) denotes a placeholder. </li>
</ul>
</dd></dl>
</li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa942091fc4bd5c2699e49ddc50829524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa942091fc4bd5c2699e49ddc50829524">&#9670;&nbsp;</a></span>keyAddBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyAddBaseName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <code>baseName</code> (that will be escaped) to the current key name. </p>
<p>A new baseName will be added, no other part of the key name will be affected.</p>
<p>Assumes that <code>key</code> is a directory and will append <code>baseName</code> to it. The function adds the path separator for concatenating.</p>
<p>So if <code>key</code> has name <code>"system/dir1/dir2"</code> and this method is called with <code>baseName</code> <code>"mykey"</code>, the resulting key will have the name <code>"system/dir1/dir2/mykey"</code>.</p>
<p>When <code>baseName</code> is 0 nothing will happen and the size of the name is returned.</p>
<p>The escaping rules apply as in <a class="el" href="group__keyname.html">above </a>.</p>
<p>A simple example is: </p><div class="fragment"><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/my/long&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div><div class="line"><a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;myname&quot;</span>);</div><div class="line">printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k)); <span class="comment">// will print user/my/long/myname</span></div><div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div></div><!-- fragment --><p> E.g. if you add . it will be escaped: </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div><div class="line">        succeed_if (<a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;.&quot;</span>) &gt;= 0, <span class="stringliteral">&quot;could not add a base name&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;system/valid/\\.&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;.&quot;</span>);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a> to set a base name </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> to set a new name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">baseName</td><td>the string to append to the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the new key name including the ending NULL </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the key had no name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
    <tr><td class="paramname">-1</td><td>on allocation errors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa70593a2c772c4b7bc33423b9b10a270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa70593a2c772c4b7bc33423b9b10a270">&#9670;&nbsp;</a></span>keyAddName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyAddName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an already escaped name to the keyname. </p>
<p>The same way as in <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> this method finds the canonical pathname:</p><ul>
<li>it will ignore /./</li>
<li>it will remove a level when /../ is used</li>
<li>it will remove multiple slashes ////</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/x/r&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div><div class="line"><a class="code" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270">keyAddName</a> (k, <span class="stringliteral">&quot;../y/a//././z&quot;</span>);</div><div class="line">assert (!strcmp (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;user/x/y/a/z&quot;</span>));</div><div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div></div><!-- fragment --><p> Unlike <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> it adds relative to the previous name and cannot change the namespace of a key. For example: </p><div class="fragment"><div class="line">Key * n = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/away&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div><div class="line"><a class="code" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270">keyAddName</a> (n, <span class="stringliteral">&quot;../../../new/name&quot;</span>);</div><div class="line">assert (!strcmp (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (n), <span class="stringliteral">&quot;user/new/name&quot;</span>));</div><div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (n);</div></div><!-- fragment --><p> The passed name needs to be valid according the <a class="el" href="group__keyname.html">key name rules </a>. It is not allowed to:</p><ul>
<li>be empty</li>
<li>end with unequal number of \</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key where a name should be added </td></tr>
    <tr><td class="paramname">newName</td><td>the new name to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.8.11</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">size</td><td>of the new key </td></tr>
    <tr><td class="paramname">-1</td><td>if key is a null pointer or the key has an empty name </td></tr>
    <tr><td class="paramname">-1</td><td>if newName is not a valid escaped name </td></tr>
    <tr><td class="paramname">-1</td><td>on allocation errors </td></tr>
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
    <tr><td class="paramname">0</td><td>if nothing was done because newName had only slashes, is too short, is empty or is null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaff35e7ca8af5560c47e662ceb9465f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaff35e7ca8af5560c47e662ceb9465f5">&#9670;&nbsp;</a></span>keyBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyBaseName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the internal unescaped key name where the <code>basename</code> starts. </p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Calculate the basename of a key name and put it in returned finalizing the string with NULL...">keyGetBaseName()</a> and you should use it if you are responsible enough to not mess up things. The name might change or even point to a wrong place after a <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a>. So make sure to copy the memory before the name changes.</p>
<p><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a> returns "" when there is no keyBaseName. The reason is </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;user&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> And there is also support for really empty basenames: </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div><div class="line">        succeed_if (<a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;&quot;</span>) &gt;= 0, <span class="stringliteral">&quot;could not add a base name&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;system/valid/%&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must never use the pointer returned by <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a> method to change the name, but you should use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a> instead.</dd>
<dd>
Do not assume that <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a> points to the same region as <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> does.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object to obtain the basename from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the basename </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when the key has no (base)name </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Calculate the basename of a key name and put it in returned finalizing the string with NULL...">keyGetBaseName()</a>, <a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a" title="Calculates number of bytes needed to store basename of key. ">keyGetBaseNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> to get a pointer to the name </dd>
<dd>
<a class="el" href="owner_8c.html#af6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner. ">keyOwner()</a> to get a pointer to the owner </dd></dl>

</div>
</div>
<a id="ga0992d26bcfca767cb8e77053a483eb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0992d26bcfca767cb8e77053a483eb64">&#9670;&nbsp;</a></span>keyGetBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetBaseName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the basename of a key name and put it in <code>returned</code> finalizing the string with NULL. </p>
<p>Some examples:</p><ul>
<li>basename of <code>system/some/keyname</code> is <code>keyname</code> </li>
<li>basename of <code>"user/tmp/some key"</code> is <code>"some key"</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to extract basename from </td></tr>
    <tr><td class="paramname">returned</td><td>a pre-allocated buffer to store the basename </td></tr>
    <tr><td class="paramname">maxSize</td><td>size of the <code>returned</code> buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes copied to <code>returned</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on empty name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>when maxSize is 0 or larger than SSIZE_MAX </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a>, <a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a" title="Calculates number of bytes needed to store basename of key. ">keyGetBaseNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>, <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> </dd></dl>

</div>
</div>
<a id="ga1a0b76c5d9e5367c7e72211e6c63d43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0b76c5d9e5367c7e72211e6c63d43a">&#9670;&nbsp;</a></span>keyGetBaseNameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetBaseNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of bytes needed to store basename of <code>key</code>. </p>
<p>Key names that have only root names (e.g. <code>"system"</code> or <code>"user"</code> or <code>"user:domain"</code> ) does not have basenames, thus the function will return 1 bytes to store "".</p>
<p>Basenames are denoted as:</p><ul>
<li><code>system/some/thing/basename</code> -&gt; <code>basename</code> </li>
<li><code>user:domain/some/thing/base\/name</code> &gt; <code>base\/name</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes of <code>key's</code> basename including ending NULL </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a>, <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Calculate the basename of a key name and put it in returned finalizing the string with NULL...">keyGetBaseName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>, <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> </dd></dl>

</div>
</div>
<a id="gaaba1494a5ffc976e0e56c43f4334a23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaba1494a5ffc976e0e56c43f4334a23c">&#9670;&nbsp;</a></span>keyGetFullName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetFullName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get key full name, including the user domain name. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on empty name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if maxSize is 0 or larger than SSIZE_MAX </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object </td></tr>
    <tr><td class="paramname">returnedName</td><td>pre-allocated memory to write the key name </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that will fit in returnedName, including the final NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab65dc9d43d3ee08d5e936a20ebbddd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab65dc9d43d3ee08d5e936a20ebbddd23">&#9670;&nbsp;</a></span>keyGetFullNameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetFullNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bytes needed to store the key name including user domain and ending NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed to store key name including user domain </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on empty name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the key name without owner. ">keyGetNameSize()</a> </dd></dl>

</div>
</div>
<a id="gab29a850168d9b31c9529e90cf9ab68be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab29a850168d9b31c9529e90cf9ab68be">&#9670;&nbsp;</a></span>keyGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get abbreviated key name (without owner name). </p>
<p>When there is not enough space to write the name, nothing will be written and -1 will be returned.</p>
<p>maxSize is limited to SSIZE_MAX. When this value is exceeded -1 will be returned. The reason for that is that any value higher is just a negative return value passed by accident. Of course elektraMalloc is not as failure tolerant and will try to allocate.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *getBack = <a class="code" href="internal_8c.html#a35cdc2e5caed3454cb73b4fc7f37858c">elektraMalloc</a> (<a class="code" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a>(key));</div><div class="line"><a class="code" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a>(key, getBack, <a class="code" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a>(key));</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>number of bytes written to <code>returnedName</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>when only a null was written </td></tr>
    <tr><td class="paramname">-1</td><td>when keyname is longer then maxSize or 0 or any NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">returnedName</td><td>pre-allocated memory to write the key name </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that will fit in returnedName, including the final NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the key name without owner. ">keyGetNameSize()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23" title="Bytes needed to store the key name including user domain and ending NULL. ">keyGetFullNameSize()</a> </dd></dl>

</div>
</div>
<a id="gabdbcfa51ed8a387e47ead207affa2d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdbcfa51ed8a387e47ead207affa2d2e">&#9670;&nbsp;</a></span>keyGetNameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bytes needed to store the key name without owner. </p>
<p>For an empty key name you need one byte to store the ending NULL. For that reason 1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed, including ending NULL, to store key name without owner </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if there is is no key Name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23" title="Bytes needed to store the key name including user domain and ending NULL. ">keyGetFullNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b" title="return size of unescaped name with embedded and terminating null characters ">keyGetUnescapedNameSize</a> to get size of unescaped name </dd></dl>

</div>
</div>
<a id="gafc3ca03ed10f87eb59bdc02cf2a0de8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3ca03ed10f87eb59bdc02cf2a0de8d">&#9670;&nbsp;</a></span>keyGetNamespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a> keyGetNamespace </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For currently valid namespaces see <a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68" title="Elektra currently supported Key namespaces. ">elektraNamespace</a>. </p>
<dl class="section since"><dt>Since</dt><dd>0.8.10 Added method to <a class="el" href="kdbproposal_8h.html" title="Proposed declarations. ">kdbproposal.h</a></dd></dl>
<p>To handle every possible cases (including namespaces) a key can have: </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span> (<a class="code" href="group__keyname.html#gafc3ca03ed10f87eb59bdc02cf2a0de8d">keyGetNamespace</a> (k))</div><div class="line">{</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a2be047b124b1ca0e92b5ef124169f0d2">KEY_NS_SPEC</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;spec namespace\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a470ecc9254fcdfccf9923a3e526c9c11">KEY_NS_PROC</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;proc namespace\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68aa0006cf27dbb2586bafba6ff1ae4f4ec">KEY_NS_DIR</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;dir namespace\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a8ce23c70010e8ac8bb540b0947e03a4e">KEY_NS_USER</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;user namespace\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a61adca2f9dff47e65dfcdb492ffa7a20">KEY_NS_SYSTEM</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;system namespace\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a33d6c53529b4e6921d0b1d6565df2f1f">KEY_NS_EMPTY</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;empty name\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a3659698b0a07454ca8055ab693e8efd1">KEY_NS_NONE</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;no key\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68ac5fbf2c3a7ae79fa2d60c48ae3e72688">KEY_NS_META</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;metakey\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a2c9133e3095dccbcde5ca3bb13987b5d">KEY_NS_CASCADING</a>:</div><div class="line">        printf (<span class="stringliteral">&quot;cascading key\n&quot;</span>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">}</div></div><!-- fragment --><p> To loop over all valid namespaces use: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a> ns = <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68ae06281f94c2b7a221115afbaa1e0ff45">KEY_NS_FIRST</a>; ns &lt;= <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68ad4d0f219a657517ddd50cd06c8190310">KEY_NS_LAST</a>; ++ns)</div><div class="line">{</div><div class="line">        <span class="comment">// work with namespace</span></div><div class="line">        printf (<span class="stringliteral">&quot;%d\n&quot;</span>, ns);</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>This method might be enhanced. You do not have any guarantee that, when for a specific name <a class="el" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68ac5fbf2c3a7ae79fa2d60c48ae3e72688" title="metakey, i.e. any key name not under other categories ">KEY_NS_META</a> is returned today, that it still will be returned after the next recompilation. So make sure that your compiler gives you a warning for unhandled switches (gcc: -Wswitch or -Wswitch-enum if you want to handle default) and look out for those warnings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the namespace of a key. </dd></dl>

</div>
</div>
<a id="ga5e7eff0c77678420199d0d2e8729152b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7eff0c77678420199d0d2e8729152b">&#9670;&nbsp;</a></span>keyGetUnescapedNameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetUnescapedNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return size of unescaped name with embedded and terminating null characters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object to work with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb" title="Returns a keyname which is null separated and does not use backslash for escaping. ">keyUnescapedName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the key name without owner. ">keyGetNameSize()</a> for size of escaped variant </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
    <tr><td class="paramname">0</td><td>if no name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e805c726a60da921d3736cda7813513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e805c726a60da921d3736cda7813513">&#9670;&nbsp;</a></span>keyName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the abbreviated real internal <code>key</code> name. </p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a> and can use it if you are responsible enough to not mess up things. You are not allowed to change anything in the returned array. The content of that string may change after <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> and similar functions. If you need a copy of the name, consider using <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>.</p>
<p>The name will be without owner, see <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a> if you need the name with its owner.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no keyName. The reason is <div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div><div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div><div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);</div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p>Valid key names are:</p>
<ul>
<li><code>spec/something</code> for specification of other keys.</li>
<li><code>proc/something</code> for in-memory keys, e.g. commandline.</li>
<li><code>dir/something</code> for dir keys in current working directory</li>
<li><code>system/something</code> for system keys in /etc or /</li>
<li><code>user/something</code> for user keys in home directory</li>
<li><code>user:username/something</code> for other users (deprecated: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> + <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> currently unsupported)</li>
<li><p class="startli"><code>/something</code> for cascading keys (actually refers to one of the above, see also <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a>)</p>
<dl class="section note"><dt>Note</dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> method to set a new value. Use <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the keyname which must not be changed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no (an empty) keyname </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the key name without owner. ">keyGetNameSize()</a> for the string length </dd>
<dd>
<a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23" title="Bytes needed to store the key name including user domain and ending NULL. ">keyGetFullNameSize()</a> to get the full name </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a> as alternative to get a copy </dd>
<dd>
<a class="el" href="owner_8c.html#af6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner. ">keyOwner()</a> to get a pointer to owner </dd>
<dd>
<a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb" title="Returns a keyname which is null separated and does not use backslash for escaping. ">keyUnescapedName</a> to get an unescaped <a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> name </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ga6e804bd453f98c28b0ff51430d1df407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e804bd453f98c28b0ff51430d1df407">&#9670;&nbsp;</a></span>keySetBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetBaseName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>baseName</code> as the new basename for <code>key</code>. </p>
<p>Only the baseName will be affected and no other part of the key.</p>
<p>A simple example is: </p><div class="fragment"><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/my/long/name&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div><div class="line"><a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (k, <span class="stringliteral">&quot;myname&quot;</span>);</div><div class="line">printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k)); <span class="comment">// will print user/my/long/myname</span></div><div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div></div><!-- fragment --><p> All text after the last <code>'/'</code> in the <code>key</code> keyname is erased and <code>baseName</code> is appended. If <code>baseName</code> is 0 (NULL), then the last part of the keyname is removed without replacement.</p>
<p>Let us suppose <code>key</code> has name <code>"system/dir1/dir2/key1"</code>. If <code>baseName</code> is <code>"key2"</code>, the resulting key name will be <code>"system/dir1/dir2/key2"</code>. If <code>baseName</code> is 0 (NULL), the resulting key name will be <code>"system/dir1/dir2"</code>. If <code>baseName</code> is empty, the resulting key name will be <code>"system/dir1/dir2/%"</code>, where <code>"%"</code> denotes an empty base name, as also shown in the following code:</p>
<div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div><div class="line">        <a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (k, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;system/%&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --><p> <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a> does proper escaping on the supplied name argument.</p>
<p>You can use character sequences as <code>baseName</code> (e.g. <code>"."</code> (dot), <code>".."</code> (dot-dot), <code>"%"</code> (empty basename)). They will be properly escaped and will not have their usual meaning.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html" title="Methods to do various operations on Key names. ">Name Manipulation Methods</a> for more details on special names</dd></dl>
<p>If you want to add and not change the basename, use <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a> instead. If you do not want escaping, use <a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add an already escaped name to the keyname. ">keyAddName()</a> instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a> to add a basename instead of changing it </dd>
<dd>
<a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add an already escaped name to the keyname. ">keyAddName()</a> to add a name without escaping </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> to set a completely new name</dd></dl>
<p>To add an inactive key name, use: </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div><div class="line">        <a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (k, <span class="stringliteral">&quot;.hiddenkey&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;system/.hiddenkey&quot;</span>);</div><div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;.hiddenkey&quot;</span>);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">baseName</td><td>the string used to overwrite the basename of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the new key name </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointers in key </td></tr>
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
    <tr><td class="paramname">-1</td><td>on allocation errors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7699091610e7f3f43d2949514a4b35d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7699091610e7f3f43d2949514a4b35d9">&#9670;&nbsp;</a></span>keySetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new name to a key. </p>
<p>A valid name is one of the forms:</p><ul>
<li><code>spec/something</code> for specification of other keys.</li>
<li><code>proc/something</code> for in-memory keys, e.g. commandline.</li>
<li><code>dir/something</code> for dir keys in current working directory</li>
<li><code>system/something</code> for system keys in /etc or /</li>
<li><code>user/something</code> for user keys in home directory</li>
<li><code>user:username/something</code> for other users (deprecated: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> + <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> currently unsupported)</li>
<li><code>/something</code> for cascading keys (actually refers to one of the above, see also <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a>)</li>
</ul>
<p>An invalid name either has an invalid namespace or a wrongly escaped \ at the end of the name.</p>
<p>See <a class="el" href="group__keyname.html">key names </a> for the exact rules.</p>
<p>The last form has explicitly set the owner, to let the library know in which user folder to save the key. A owner is a user name. If it is not defined (the second form) current user is used.</p>
<p>You should always follow the guidelines for key tree structure creation.</p>
<p>A private copy of the key name will be stored, and the <code>newName</code> parameter can be freed after this call.</p>
<p>.., . and / will be handled as in filesystem paths. A valid name will be build out of the (valid) name what you pass, e.g. user///sw/../sw//././MyApp -&gt; user/sw/MyApp</p>
<p>On invalid names, NULL or "" the name will be "" afterwards.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">size</td><td>in bytes of this new key name including ending NULL </td></tr>
    <tr><td class="paramname">0</td><td>if newName is an empty string or a NULL pointer (name will be empty afterwards) </td></tr>
    <tr><td class="paramname">-1</td><td>if newName is invalid (name will be empty afterwards) </td></tr>
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">newName</td><td>the new key name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, <a class="el" href="owner_8c.html#a88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key. ">keySetOwner()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a>, <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a>, <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a> to manipulate a name </dd></dl>

</div>
</div>
<a id="ga6fe6af4c27b35d911a533f4ae4d698bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fe6af4c27b35d911a533f4ae4d698bb">&#9670;&nbsp;</a></span>keyUnescapedName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* keyUnescapedName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a keyname which is null separated and does not use backslash for escaping. </p>
<p>Slashes are replaced with null bytes. So cascading keys start with a null byte. Otherwise escaped characters, e.g. non-hierarchy slash, will be unescaped.</p>
<p>This name is essential if you want to iterate over parts of the key name, want to compare keynames and want to check relations of keys in the hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object to work with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b" title="return size of unescaped name with embedded and terminating null characters ">keyGetUnescapedNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> for escaped variant </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on null pointers </td></tr>
    <tr><td class="paramname">""</td><td>if no name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name in its unescaped form </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
