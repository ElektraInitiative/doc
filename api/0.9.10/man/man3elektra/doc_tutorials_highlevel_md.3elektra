.TH "doc_tutorials_highlevel_md" 3elektra "Mon Jul 11 2022" "Version 0.9.10" "Elektra" \" -*- nroff -*-
.ad l
.nh
.SH NAME
doc_tutorials_highlevel_md \- High-level API (with code-generation) 
 Most applications don't need the flexibility of the low-level API (with \fCkdbGet\fP, \fCkdbSet\fP, etc\&.)\&. In most cases an easy way and safe way to access the configuration values is preferred\&. This is why we created the high-level API\&.
.PP
There are two different ways of using the high-level API:
.PP
.IP "1." 4
directly
.IP "2." 4
via code-generation
.PP
.PP
The recommended way is via code-generation (which will be explained below)\&. If you want to use the high-level API directly take a look at \fBits documentation\fP\&. Please note, however, that certain features are only available through code-generation\&.
.SH "Overview"
.PP
The code-generation API builds on Elektra's specifications\&. Instead of just using specifications at runtime, the code-generator parses them when invoked (ideally right before compiling) and utilizes the specification when generating configuration accessor functions\&.
.SH "Writing a specification"
.PP
The process of writing a full specification for your application is beyond the scope of this guide\&. We will just focus on the parts that are necessary for using the code-generation API\&.
.PP
We will use this specification in the format of the \fCni\fP plugin:
.PP
.PP
.nf
[]
mountpoint = myapp\&.ini

[mydouble]
type = double
default = 0\&.0

[myfloatarray/#]
type = float
default = 1\&.1
.fi
.PP
.PP
In Elektra a specification is defined through the metadata of keys in the \fCspec\fP namespace\&. The specification above contains metadata for three keys:
.PP
.IP "1." 4
the parent key (\fC@\fP)
.IP "2." 4
\fC@/mydouble\fP
.IP "3." 4
\fC@/myfloatarray/#\fP (The \fC#\fP at the end of \fCmyfloatarray/#\fP indicates that it is an array)
.PP
.PP
The \fCmountpoint\fP metadata on the parent key sets the name of our application's config file (the location is defined by Elektra), it should be unique\&.
.PP
The \fCtype\fP metadata specifies the type of a key\&. The available types can be found in the high-level API \fBReadme\fP under 'Data Types'\&. It is important to set the \fCtype\fP, because the code-generator will ignore all keys that don't have a \fCtype\fP\&.
.PP
Because we want our getters to be unable to fail (makes error handling trivial), we need to provide a \fCdefault\fP value as well\&. Note that \fCdefault\fPs for array keys like \fCmyfloatarray/#\fP only work via the \fCspec\fP plugin\&. If you didn't mount everything correctly, you will get an error\&.
.PP
That's it\&. The code-generator just requires that each key (that you want to access) has a \fCtype\fP and a \fCdefault\fP value\&.
.PP
\fINote:\fP You can also mark keys with the \fCrequire\fP metadata, if there is no reasonable default value\&. This is only recommended as a last resort, but still preserves the guarantee that \fCelektraGet*\fP calls won't fail\&. If a \fCrequire\fPd key is missing, the initialization of the \fCElektra\fP handle will fail\&.
.SH "Invoking the code-generator"
.PP
The code-generator is a very powerful and flexible tool and has many options to tweak its output\&. If you want to know more about how to set up everything just the way you want to, take a look at the man-pages \fB`kdb-gen(1)`\fP and \fB`kdb-gen-highlevel(1)`\fP\&.
.PP
To get started the basic invocation of the code-generator should be enough:
.PP
.PP
.nf
kdb gen -F ni=spec\&.ini highlevel "/sw/example/myapp/#0/current" conf
.fi
.PP
.PP
This tells the code-generator that your application uses the parent key \fC/sw/example/myapp/#0/current\fP and that the output files should be called \fCconf\&.*\fP\&. The argument \fChighlevel\fP just specifies which template to use and the option \fC-F ni=spec\&.ini\fP indicates that the file \fCspec\&.ini\fP (in the \fCni\fP plugin's format) contains the specification\&. While the code-generator can read a specification from the KDB, we recommend you use the \fC-F\fP option\&. It keeps the KDB clean and can avoid troubles later on, when installing your application\&.
.SH "Using the generated code"
.PP
You can now take a look at \fCconf\&.h\fP and \fCconf\&.c\fP (the files generated by the compiler)\&. Depending on the specification you used, these files may be very long\&. They might also be formatted strangely, because of limitations in the code-generator\&. Feel free to reformat them with your tool of choice, before inspecting them\&.
.PP
To explain how to use the generated code, lets take a look at some of \fCconf\&.h\fP\&. For brevity's sake some parts of the file have been replaced by placeholder comments\&.
.PP
.PP
.nf
/* file header \&.\&.\&. */

#ifndef CONF_H
#define CONF_H

#ifdef __cplusplus
extern "C" {
#endif

/* includes \&.\&.\&. */

/* helper macros \&.\&.\&. */
.fi
.PP
.PP
First there is some boilerplate, including the copyright header, include statements and some helper macros\&.
.PP
.PP
.nf

#define ELEKTRA_TAG_MYDOUBLE Mydouble

#define ELEKTRA_TAG_MYFLOATARRAY Myfloatarray
.fi
.PP
.PP
Next we see all the 'tag macros' used to refer to config values\&. These are essentially just aliases, but they allow for some flexibility in how we generate the names of the \fCstatic inline\fP functions further down\&. You should always refer to your config values via these macros, even if they are just aliases\&. This is because we might have to change the naming scheme for the functions, but we will try to keep the tag macros unchanged\&.
.PP
Additionally, the comments for these macros contain the documentation on what arguments are needed for accessing the tag in question\&. For example to access the elements of the array \fCmyfloatarray/#\fP, we obviously need to provide an index\&.
.PP
.PP
.nf
#define elektra_len19(x) ((x) < 10000000000000000000ULL ? 19 : 20)
/* local macros \&.\&.\&. */
#define elektra_len(x) elektra_len00 (x)
.fi
.PP
.PP
Then we see some local helper macros only used in this file\&.
.PP
.PP
.nf
static inline kdb_double_t ELEKTRA_GET (Mydouble) (Elektra * elektra) { /* \&.\&.\&. */ }
static inline void ELEKTRA_SET (Mydouble) (Elektra * elektra, kdb_double_t value, ElektraError ** error) { /* \&.\&.\&. */ }

static inline kdb_float_t ELEKTRA_GET (Myfloatarray) (Elektra * elektra, kdb_long_long_t index1) {  /* \&.\&.\&. */ }
static inline void ELEKTRA_SET (Myfloatarray) (Elektra * elektra, kdb_float_t value, kdb_long_long_t index1, ElektraError ** error) { /* \&.\&.\&. */ }
.fi
.PP
.PP
This is the most important part of the header\&. It is what makes the API work\&.
.PP
For each config value we generate an \fCELEKTRA_GET(*)\fP and an \fCELEKTRA_SET(*)\fP accessor function\&. All these functions are \fCstatic inline\fP, because they just call other getter/setter functions with partially fixed arguments\&. In fact many of these functions will only be a single line\&.
.PP
.PP
.nf
#undef elektra_len19
/* local macros \&.\&.\&. */
#undef elektra_len

int loadConfiguration (Elektra ** elektra, int argc, const char * const * argv, const char * const * envp, ElektraError ** error);
void printHelpMessage (Elektra * elektra, const char * usage, const char * prefix);
void exitForSpecload (int argc, const char ** argv);
.fi
.PP
.PP
Then we undefine the local macros we defined before and declare the three initialization functions \fCloadConfiguration\fP, \fCprintHelpMessage\fP and \fCexitForSpecload\fP\&.
.PP
.PP
.nf
/* elektra* macros \&.\&.\&. */

#ifdef __cplusplus
}
#endif

#endif // CONF_H
.fi
.PP
.PP
At the end of the file you will find the \fCelektra*\fP convenience macros\&. These macros can be used to make accessing config values look more like normal function calls and avoid the ugly double parentheses in e\&.g\&. \fCELEKTRA_GET (\&.\&.\&.) (\&.\&.\&.)\fP\&.
.SS "Obtaining an <tt>Elektra</tt> handle"
We start at the bottom of our \fCconf\&.h\fP excerpt\&. \fCexitForSpecload\fP is used to initiate specload mode, if needed\&. This mode makes your application provide its specification to Elektra\&. How this works exactly is not so important (see \fBspecload plugin\fP)\&. You only need to know, that \fCexitForSpecload\fP should be called immediately at the start of your \fCmain\fP function and that it only returns, when your application is not in specload mode\&.
.PP
.PP
.nf
int main (int argc, const char * const * argv, const char * const * envp) {
    exitForSpecload (argc, argv);
    // \&.\&.\&.
}
.fi
.PP
.PP
To access your configuration, you first need to call \fCloadConfiguration\fP to get an \fCElektra\fP handle for your application\&. This is done via a snippet that is more or less the same for all applications:
.PP
.PP
.nf
ElektraError * error = NULL;
Elektra * elektra = NULL;
int rc = loadConfiguration (&elektra, argc, argv, envp, &error);

if (rc == -1)
{
    fprintf (stderr, "An error occurred while opening Elektra: %s", elektraErrorDescription (error));
    elektraErrorReset (&error);
    exit (EXIT_FAILURE);
}

if (rc == 1)
{
    // help mode - application was called with '--help'
    // for more information see "Command line options" below
    printHelpMessage (elektra, NULL, NULL);
    elektraClose (elektra);
    exit (EXIT_SUCCESS);
}
.fi
.PP
.PP
Next it is recommended, you change the default handler for fatal errors\&. By default, we just call \fCexit (EXIT_FAILURE)\fP, since we don't know how you log your errors and what cleanup may be needed\&.
.PP
.PP
.nf
elektraFatalErrorHandler (elektra, onFatalError);
.fi
.PP
.PP
\fConFatalError\fP will receive the fatal \fCElektraError *\fP\&. It must at least call \fCelektraErrorReset\fP on the error and then call \fCexit()\fP\&.
.PP
If you want to try out the application immediately, skip down to the \fCsection about compiling\fP\&. You may also have to follow the section on \fCrunning your application\fP to get everything up and running\&.
.SS "Reading config values"
Once you have your \fCElektra\fP instance, reading config values is easy\&. You just call one of the getter functions\&.
.PP
.PP
.nf
kdb_double_t mydouble = elektraGet (elektra, ELEKTRA_TAG_MYDOUBLE);
.fi
.PP
.PP
Here we used the convenience macro \fCelektraGet\fP\&. You could also invoke the \fCstatic inline\fP accessor function directly:
.PP
.PP
.nf
kdb_double_t mydouble = ELEKTRA_GET (ELEKTRA_TAG_MYDOUBLE) (elektra);
.fi
.PP
.PP
No error handling is required, because getter functions are designed to not fail\&. In a correct setup, either the initialization fails and getters are never called, or getter calls always succeed\&.
.PP
To access config values that don't have a static key name, like arrays, you have to supply additional arguments (and use \fCelektraGetV\fP):
.PP
.PP
.nf
kdb_float_t myfloat0 = elektraGetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 0);
kdb_float_t myfloat1 = elektraGetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 1);
// or
kdb_float_t myfloat0 = ELEKTRA_GET (ELEKTRA_TAG_MYFLOATARRAY) (elektra, 0);
float myfloat1 = ELEKTRA_GET (ELEKTRA_TAG_MYFLOATARRAY) (elektra, 1);
.fi
.PP
.PP
Of course we also need to know, how big the \fCmyfloatarray/#\fP array actually is\&. To that end we can use \fCELEKTRA_SIZE\fP or \fCelektraSize\fP:
.PP
.PP
.nf
kdb_long_long_t myfloat_size = elektraSize (elektra, ELEKTRA_TAG_MYFLOATARRAY);
// or
kdb_long_long_t myfloat_size = ELEKTRA_SIZE (ELEKTRA_TAG_MYFLOATARRAY) (elektra);
.fi
.PP
.PP
\fCELEKTRA_SIZE\fP functions like their \fCELEKTRA_GET\fP counterparts are designed to not fail\&.
.PP
Please note that, while it shouldn't happen, if you setup everything correctly, calling a getter on a non-existent, wrongly typed or otherwise inconvertible key is a fatal error\&. All fatal errors result in a call to the fatal error handler and therefore exit the application\&.
.SS "Writing config values"
Writing config values is not quite as easy as reading, but it is still quite simple:
.PP
.PP
.nf
ElektraError * error = NULL;
ELEKTRA_SET (ELEKTRA_TAG_MYDOUBLE) (elektra, 3\&.141593, &error);
if (error == NULL) {
    // handle error
    elektraErrorReset (&error);
}
.fi
.PP
.PP
As you can see the complexity stems from the necessary error handling\&. Because setting values involves IO and other uncontrollable factors, setter calls cannot be designed to not fail\&. This is why they accept an additional \fCElektraError **\fP argument\&. It is important to call \fCelektraErrorReset\fP, if an error was set\&. Calling a setter with a non-null \fCElektraError **\fP parameter is a fatal error\&.
.PP
Of course you can also use \fCelektraSet\fP (error handling omitted):
.PP
.PP
.nf
elektraSet (elektra, ELEKTRA_TAG_MYDOUBLE, 3\&.141593, &error);
elektraSetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 2\&.718282f, &error, 2);
.fi
.PP
.PP
Note that \fCelektraSetV\fP takes the \fCElektraError\fP argument before the variable arguments, while in \fCELEKTA_SET\fP the error is always the last argument\&. This is because of limitations in the C macro system\&.
.PP
There is no setter for array sizes\&. Since Elektra's low-level part supports discontinuous arrays, we simply change the array size whenever necessary, if an array element setter is called\&. However, the high-level API has no support for discontinuous arrays, so take care not to create holes in your arrays, if you want to iterate over them\&. Remember, accessing non-existent keys (and this includes array elements) is a fatal error\&.
.SS "Command-line options"
The generated \fCloadConfiguration\fP function automatically mounts the \fCgopts\fP plugin\&. This means that command-line options (as described \fBhere\fP) are parsed and their values are set on the corresponding keys\&. You don't have to do anything, apart from setting the \fCopt\fP metadata\&. The only exception to that is the \fIhelp mode\fP\&.
.PP
When your application is called with \fC-h\fP or \fC--help\fP, we enter help mode\&. This is indicated by the return value \fC1\fP of \fCloadConfiguration\fP\&. As you can see in the example above, you should call \fCprintHelpMessage\fP to print an appropriate help message to \fCstdout\fP and then close the allocated \fCElektra\fP instance and \fCexit\fP\&. \fBBeware\fP an \fCElektra\fP instance created in help mode may not be fully functional, which is why you should immediately close it once you called \fCprintHelpMessage\fP\&.
.SS "Advanced concepts"
The code-generator has some more advanced features that are supported out of the box\&. For example, you can read multiple config values at once by utilizing structs\&. The use of structs also allows for recursive configurations like menus (a menu can have submenus)\&.
.PP
For more information take a look at the man-page \fB`kdb-gen-highlevel(1)`\fP\&.
.SH "Compiling your application"
.PP
Once you've written your application, you will want to compile it\&. This requires linking some libraries and adding to your include path\&. The easiest way is to use CMake or pkg-config to find the needed compiler options\&. Examples on how set this up can be found in \fBhere\fP and \fBhere\fP\&.
.PP
The compiler invocation should look something like this:
.PP
.PP
.nf
cc myapp\&.c conf\&.c `pkg-config --cflags --libs elektra-codegen` -I\&. -o myapp -Wl,-rpath `pkg-config --variable=libdir elektra-codegen`
.fi
.PP
.PP
Note: At least C99 is required, so if your compiler defaults to an older version you'll need to add \fC-std=c99\fP\&.
.SH "Running your application"
.PP
Running your application is easy, just run the executable (e\&.g\&. \fCmyapp\fP)\&. While this might work out of the box, you will just get the default configuration\&. To change the configuration you need to use \fCkdb\fP, which doesn't know about your specification yet\&. This means you would need to set the \fCtype\fP metadata and all the other stuff that your application expects by hand\&. For every single key\&. Obviously this is not the right solution\&.
.SS "Mounting the specification"
A better solution is to inform Elektra (and \fCkdb\fP) about our specification\&. Then Elektra automatically copies metadata to where it should be\&.
.PP
First you need to mount your specification itself into the KDB\&. Mounting is basically the process of informing Elektra about a new part of the KDB, similar to how mounting an external hard drive informs the OS about a new part of the file system\&.
.PP
.PP
.nf
sudo kdb mount -R noresolver /etc/myapp_spec\&.eqd "spec:/sw/example/myapp/#0/current" specload app="$PWD/myapp"
.fi
.PP
.PP
The command above assumes that you also used the \fCkdb gen\fP command from \fCabove\fP and that the \fCmyapp\fP executable is located in \fC$PWD\fP\&.
.PP
.RS 4
\fBNote:\fP Because of a limitation in \fCspecload\fP, we have to use the \fCnoresolver\fP resolver\&. This also means that the path to the config file (here \fC/etc/myapp_spec\&.eqd\fP) has to be absolute\&. Otherwise it will always be relative to the current working directory in which \fCkdb\fP or your application was executed\&. The file \fIshould not\fP exist when calling \fCkdb mount\fP\&. \fCspecload\fP works different to other plugins\&. The given config file is only used, if the user makes changes to the specification via \fCkdb set\fP\&. 
.RE
.PP
Now that Elektra knows about your specification, calling your application might work better, since metadata should now be copied, when you set a config value via \fCkdb set\fP\&. However, there won't be any type checking\&. For that we need to enable the \fCtype\fP plugin\&. While this could be done manually, we can just let Elektra figure out which plugins we need and activate all of them\&.
.PP
This can be done with the \fCspec-mount\fP command:
.PP
.PP
.nf
sudo kdb spec-mount "/sw/example/myapp/#0/current"
.fi
.PP
.PP
Now finally your application is all setup\&.
.SS "Configuring your application"
To configure your application you can use \fCkdb\fP:
.PP
.PP
.nf
kdb set "/sw/example/myapp/#0/current/mydouble" 15\&.4
.fi
.PP
.PP
If you want to set a value system-wide (not just for your user) you can use the system namespace:
.PP
.PP
.nf
kdb set "system:/sw/example/myapp/#0/current/mydouble" 15\&.4
.fi
.PP
.PP
Always use the cascading version of \fCkdb set\fP (i\&.e\&. the keyname begins with a slash \fC/\fP), otherwise type checking and other plugins might not be called correctly\&. 
