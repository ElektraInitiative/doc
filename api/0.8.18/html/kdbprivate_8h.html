<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Elektra: kdbprivate.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kdbprivate.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Private declarations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;kdb.h&gt;</code><br />
<code>#include &lt;kdbconfig.h&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbextension_8h.html">kdbextension.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbhelper_8h.html">kdbhelper.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbplugin_8h.html">kdbplugin.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbproposal_8h.html">kdbproposal.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbtypes_8h.html">kdbtypes.h</a>&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for kdbprivate.h:</div>
<div class="dyncontent">
<div class="center"><img src="kdbprivate_8h__incl.png" border="0" usemap="#kdbprivate_8h" alt=""/></div>
<map name="kdbprivate_8h" id="kdbprivate_8h">
<area shape="rect" id="node4" href="kdbextension_8h.html" title="Extension functionality. " alt="" coords="132,80,248,107"/><area shape="rect" id="node6" href="kdbproposal_8h.html" title="Proposed declarations. " alt="" coords="188,155,299,181"/><area shape="rect" id="node7" href="kdbhelper_8h.html" title="Helper for memory management. " alt="" coords="515,80,609,107"/><area shape="rect" id="node8" href="kdbtypes_8h.html" title="Elektra&#39;s data types for C and C++11. " alt="" coords="425,155,515,181"/><area shape="rect" id="node11" href="kdbplugin_8h.html" title="Methods for plugin programing. " alt="" coords="5,80,97,107"/><area shape="rect" id="node5" href="kdbmeta_8h.html" title="metadata functions " alt="" coords="77,155,164,181"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="kdbprivate_8h__dep__incl.png" border="0" usemap="#kdbprivate_8hdep" alt=""/></div>
<map name="kdbprivate_8hdep" id="kdbprivate_8hdep">
<area shape="rect" id="node2" href="key_8c.html" title="Methods for Key manipulation. " alt="" coords="5,80,60,107"/><area shape="rect" id="node3" href="keyhelpers_8c.html" title="Helpers for key manipulation. " alt="" coords="85,80,186,107"/><area shape="rect" id="node4" href="keymeta_8c.html" title="Methods to do various operations on Key meta data. " alt="" coords="210,80,295,107"/><area shape="rect" id="node5" href="keytest_8c.html" title="Methods for making tests. " alt="" coords="1710,155,1787,181"/><area shape="rect" id="node6" href="keyvalue_8c.html" title="Methods for Key value manipulation. " alt="" coords="371,80,457,107"/><area shape="rect" id="node7" href="owner_8c.html" title="Obsolete owner methods. " alt="" coords="481,80,552,107"/><area shape="rect" id="node8" href="elektra_2proposal_8c.html" title="Implementation of proposed API enhancements. " alt="" coords="576,80,663,107"/><area shape="rect" id="node9" href="meta_8c.html" title="Methods for meta data manipulation. " alt="" coords="687,80,749,107"/><area shape="rect" id="node10" href="proposal_2proposal_8c.html" title="Implementation of proposed API enhancements. " alt="" coords="773,80,860,107"/><area shape="rect" id="node11" href="src_2backend_8cpp.html" title="Implementation of backend. " alt="" coords="885,80,986,107"/><area shape="rect" id="node12" href="backendbuilder_8cpp.html" title="Implementation of backend builder. " alt="" coords="1011,80,1153,107"/><area shape="rect" id="node13" href="plugin_8cpp.html" title="Implementation of plugin. " alt="" coords="1178,80,1263,107"/><area shape="rect" id="node14" href="plugins_8cpp.html" title="Implementation of set/get/error plugins. " alt="" coords="1288,80,1380,107"/><area shape="rect" id="node15" href="mergetestutils_8cpp.html" title="Implements a helper class for merge related tests. " alt="" coords="1404,80,1539,107"/><area shape="rect" id="node17" href="testtool__mergecases_8cpp.html" title="Tests for the ThreeWayMerge. " alt="" coords="459,155,638,181"/><area shape="rect" id="node21" href="kdbinternal_8h.html" title="Includes most internal header files. " alt="" coords="2097,80,2200,107"/><area shape="rect" id="node16" href="testtool__automergestrategy_8cpp.html" title="Tests for the AutoMergeStrategy. " alt="" coords="764,155,984,181"/><area shape="rect" id="node18" href="testtool__metamergestrategy_8cpp.html" title="Tests for the MetaMergeStrategy. " alt="" coords="1009,155,1233,181"/><area shape="rect" id="node19" href="testtool__newkeystrategy_8cpp.html" title="Tests for the NewKeyStrategy. " alt="" coords="1257,155,1459,181"/><area shape="rect" id="node20" href="testtool__onesidestrategy_8cpp.html" title="Tests for the OneSideStrategy. " alt="" coords="1483,155,1686,181"/><area shape="rect" id="node22" href="backend_8c.html" title="Everything related to a backend. " alt="" coords="2157,155,2242,181"/><area shape="rect" id="node23" href="internal_8c.html" title="Internal methods for Elektra. " alt="" coords="2267,155,2345,181"/><area shape="rect" id="node24" href="kdb_8c.html" title="Low level functions for access the Key Database. " alt="" coords="2369,155,2424,181"/><area shape="rect" id="node25" href="elektra_2keyname_8c.html" title="Methods for Key name manipulation. " alt="" coords="2448,155,2537,181"/><area shape="rect" id="node26" href="keyset_8c.html" title="Methods for key sets. " alt="" coords="2561,155,2635,181"/><area shape="rect" id="node27" href="mount_8c.html" title="Interna of mount functionality. " alt="" coords="2659,155,2729,181"/><area shape="rect" id="node28" href="elektra_2plugin_8c.html" title="Interna of plugin functionality. " alt="" coords="1811,155,1881,181"/><area shape="rect" id="node29" href="split_8c.html" title="Interna of splitting functionality. " alt="" coords="1905,155,1963,181"/><area shape="rect" id="node30" href="trie_8c.html" title="Interna of trie functionality. " alt="" coords="1987,155,2039,181"/><area shape="rect" id="node31" href="plugin_2plugin_8c.html" title="Access plugin handle. " alt="" coords="2063,155,2133,181"/></map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acf20140d9b29c3edc782e72b05b25bd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#acf20140d9b29c3edc782e72b05b25bd1">KEYSET_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:acf20140d9b29c3edc782e72b05b25bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimal allocation size of a keyset inclusive NULL byte.  <a href="#acf20140d9b29c3edc782e72b05b25bd1">More...</a><br /></td></tr>
<tr class="separator:acf20140d9b29c3edc782e72b05b25bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05efd486827435a0e92220b69ae23519"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a05efd486827435a0e92220b69ae23519">NR_OF_PLUGINS</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a05efd486827435a0e92220b69ae23519"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many plugins can exist in an backend.  <a href="#a05efd486827435a0e92220b69ae23519">More...</a><br /></td></tr>
<tr class="separator:a05efd486827435a0e92220b69ae23519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05f21372b7a85668978778868e341f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae05f21372b7a85668978778868e341f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ae05f21372b7a85668978778868e341f3">COMMIT_PLUGIN</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:ae05f21372b7a85668978778868e341f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the commit plugin. <br /></td></tr>
<tr class="separator:ae05f21372b7a85668978778868e341f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88825343a6d2a664b06c61d0787132aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88825343a6d2a664b06c61d0787132aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a88825343a6d2a664b06c61d0787132aa">STORAGE_PLUGIN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a88825343a6d2a664b06c61d0787132aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the storage plugin. <br /></td></tr>
<tr class="separator:a88825343a6d2a664b06c61d0787132aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ac7247e2adc4bfc9c4d5a41743cb4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9ac7247e2adc4bfc9c4d5a41743cb4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#aa9ac7247e2adc4bfc9c4d5a41743cb4c">RESOLVER_PLUGIN</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa9ac7247e2adc4bfc9c4d5a41743cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the resolver plugin. <br /></td></tr>
<tr class="separator:aa9ac7247e2adc4bfc9c4d5a41743cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9dd0e80f70ba8ad12cc00fedf52fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98a9dd0e80f70ba8ad12cc00fedf52fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a98a9dd0e80f70ba8ad12cc00fedf52fb">APPROXIMATE_NR_OF_BACKENDS</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a98a9dd0e80f70ba8ad12cc00fedf52fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trie optimization. <br /></td></tr>
<tr class="separator:a98a9dd0e80f70ba8ad12cc00fedf52fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b6deccf1a55a100f74d2e076036f37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a93b6deccf1a55a100f74d2e076036f37">MAX_LEN_INT</a>&#160;&#160;&#160;31</td></tr>
<tr class="memdesc:a93b6deccf1a55a100f74d2e076036f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum of how many characters an integer needs as decimal number.  <a href="#a93b6deccf1a55a100f74d2e076036f37">More...</a><br /></td></tr>
<tr class="separator:a93b6deccf1a55a100f74d2e076036f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8891eaf029de761514dca775f19d6e18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a8891eaf029de761514dca775f19d6e18">KDB_SYSTEM_ELEKTRA</a>&#160;&#160;&#160;&quot;system/elektra&quot;</td></tr>
<tr class="memdesc:a8891eaf029de761514dca775f19d6e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend mounting information.  <a href="#a8891eaf029de761514dca775f19d6e18">More...</a><br /></td></tr>
<tr class="separator:a8891eaf029de761514dca775f19d6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e02bbe80b6081a6485b3f3d2caec14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a22e02bbe80b6081a6485b3f3d2caec14">test_bit</a>(var, bit)&#160;&#160;&#160;((var) &amp; (bit))</td></tr>
<tr class="memdesc:a22e02bbe80b6081a6485b3f3d2caec14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a bit.  <a href="#a22e02bbe80b6081a6485b3f3d2caec14">More...</a><br /></td></tr>
<tr class="separator:a22e02bbe80b6081a6485b3f3d2caec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4874f05226547f6afa54ed6d65dc54ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a4874f05226547f6afa54ed6d65dc54ae">set_bit</a>(var, bit)&#160;&#160;&#160;((var) |= (bit))</td></tr>
<tr class="memdesc:a4874f05226547f6afa54ed6d65dc54ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bit.  <a href="#a4874f05226547f6afa54ed6d65dc54ae">More...</a><br /></td></tr>
<tr class="separator:a4874f05226547f6afa54ed6d65dc54ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686cd59039c7112c10c8fbb82f9759e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a686cd59039c7112c10c8fbb82f9759e9">clear_bit</a>(var, bit)&#160;&#160;&#160;((var) &amp;= ~(bit))</td></tr>
<tr class="memdesc:a686cd59039c7112c10c8fbb82f9759e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a bit.  <a href="#a686cd59039c7112c10c8fbb82f9759e9">More...</a><br /></td></tr>
<tr class="separator:a686cd59039c7112c10c8fbb82f9759e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a351bbaa6e81f4d1d956bb71929dc7285"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285">keyflag_t</a> { <a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285abedbc8b9c2dcfc51908d35aec7e7c756">KEY_FLAG_SYNC</a> = 1, 
<a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285ab32b7424934246d1934c430408bd871f">KEY_FLAG_RO_NAME</a> = 1 &lt;&lt; 1, 
<a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285abbd77cb92bacff89ef2694ec2cefb135">KEY_FLAG_RO_VALUE</a> = 1 &lt;&lt; 2, 
<a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285a22971f649e6a7f6087a44e84ca0ff60d">KEY_FLAG_RO_META</a> = 1 &lt;&lt; 3
 }</td></tr>
<tr class="memdesc:a351bbaa6e81f4d1d956bb71929dc7285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Flags.  <a href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285">More...</a><br /></td></tr>
<tr class="separator:a351bbaa6e81f4d1d956bb71929dc7285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf34e9cffb5c9382ad09f0f1811a61d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61d">ksflag_t</a> { <a class="el" href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61da60841484247805681f2555220aa13a6b">KS_FLAG_SYNC</a> = 1
 }</td></tr>
<tr class="memdesc:afaf34e9cffb5c9382ad09f0f1811a61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ks Flags.  <a href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61d">More...</a><br /></td></tr>
<tr class="separator:afaf34e9cffb5c9382ad09f0f1811a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9ffc270c8970dedd83d9ef26bc1a08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d9ffc270c8970dedd83d9ef26bc1a08"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a3d9ffc270c8970dedd83d9ef26bc1a08">GlobalpluginPositions</a> </td></tr>
<tr class="memdesc:a3d9ffc270c8970dedd83d9ef26bc1a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for identifying global plugin positions. <br /></td></tr>
<tr class="separator:a3d9ffc270c8970dedd83d9ef26bc1a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad6ca41444a51395350791dbb2a0f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af7ad6ca41444a51395350791dbb2a0f8">splitflag_t</a> { <a class="el" href="kdbprivate_8h.html#af7ad6ca41444a51395350791dbb2a0f8a26d34995557a981ce39558eae0c516f9">SPLIT_FLAG_SYNC</a> = 1, 
<a class="el" href="kdbprivate_8h.html#af7ad6ca41444a51395350791dbb2a0f8a10600b1b4223a2f0d3938f8bbc48be06">SPLIT_FLAG_CASCADING</a> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="separator:af7ad6ca41444a51395350791dbb2a0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad2245a38809f28e325cd9b32089b4c68"><td class="memItemLeft" align="right" valign="top">Split *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ad2245a38809f28e325cd9b32089b4c68">elektraSplitNew</a> (void)</td></tr>
<tr class="memdesc:ad2245a38809f28e325cd9b32089b4c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new split object.  <a href="#ad2245a38809f28e325cd9b32089b4c68">More...</a><br /></td></tr>
<tr class="separator:ad2245a38809f28e325cd9b32089b4c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae569ef1bc4cd8e931b4a7840d8ce48e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ae569ef1bc4cd8e931b4a7840d8ce48e6">elektraSplitDel</a> (Split *keysets)</td></tr>
<tr class="memdesc:ae569ef1bc4cd8e931b4a7840d8ce48e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a split object.  <a href="#ae569ef1bc4cd8e931b4a7840d8ce48e6">More...</a><br /></td></tr>
<tr class="separator:ae569ef1bc4cd8e931b4a7840d8ce48e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af677c7c96b215a61d76c7b4a8f8db877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af677c7c96b215a61d76c7b4a8f8db877">elektraSplitResize</a> (Split *ret)</td></tr>
<tr class="memdesc:af677c7c96b215a61d76c7b4a8f8db877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doubles the size of how many parts of keysets can be appended.  <a href="#af677c7c96b215a61d76c7b4a8f8db877">More...</a><br /></td></tr>
<tr class="separator:af677c7c96b215a61d76c7b4a8f8db877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6067083cc1afb5d42180bf75f7f86ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ab6067083cc1afb5d42180bf75f7f86ef">elektraSplitRemove</a> (Split *split, size_t where)</td></tr>
<tr class="memdesc:ab6067083cc1afb5d42180bf75f7f86ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove one part of split.  <a href="#ab6067083cc1afb5d42180bf75f7f86ef">More...</a><br /></td></tr>
<tr class="separator:ab6067083cc1afb5d42180bf75f7f86ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8c5c6c26aa42404d8aa06e6476a0f6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a0c8c5c6c26aa42404d8aa06e6476a0f6">elektraSplitAppend</a> (Split *split, Backend *backend, Key *parentKey, int syncbits)</td></tr>
<tr class="memdesc:a0c8c5c6c26aa42404d8aa06e6476a0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the size of split and appends a new empty keyset.  <a href="#a0c8c5c6c26aa42404d8aa06e6476a0f6">More...</a><br /></td></tr>
<tr class="separator:a0c8c5c6c26aa42404d8aa06e6476a0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a36f0da2272fde84ecfc09090669cea"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a7a36f0da2272fde84ecfc09090669cea">elektraSplitSearchBackend</a> (Split *split, Backend *backend, Key *key)</td></tr>
<tr class="memdesc:a7a36f0da2272fde84ecfc09090669cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the backend is already inserted or not.  <a href="#a7a36f0da2272fde84ecfc09090669cea">More...</a><br /></td></tr>
<tr class="separator:a7a36f0da2272fde84ecfc09090669cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb25e1f946f07e5490a962a42320a0cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#afb25e1f946f07e5490a962a42320a0cc">elektraSplitSearchRoot</a> (Split *split, Key *parentKey)</td></tr>
<tr class="separator:afb25e1f946f07e5490a962a42320a0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7141dca0099564b12859a370fb060b6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a7141dca0099564b12859a370fb060b6d">elektraSplitBuildup</a> (Split *split, KDB *handle, Key *parentKey)</td></tr>
<tr class="memdesc:a7141dca0099564b12859a370fb060b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks through kdb-&gt;split and adds all backends below parentKey to split.  <a href="#a7141dca0099564b12859a370fb060b6d">More...</a><br /></td></tr>
<tr class="separator:a7141dca0099564b12859a370fb060b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dde14941040fe97dd036555e858bb69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a5dde14941040fe97dd036555e858bb69">elektraSplitUpdateFileName</a> (Split *split, KDB *handle, Key *key)</td></tr>
<tr class="memdesc:a5dde14941040fe97dd036555e858bb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the (configuration) file name for the parent key.  <a href="#a5dde14941040fe97dd036555e858bb69">More...</a><br /></td></tr>
<tr class="separator:a5dde14941040fe97dd036555e858bb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee68d5935a6875ece69945e32242895"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#afee68d5935a6875ece69945e32242895">elektraSplitAppoint</a> (Split *split, KDB *handle, KeySet *ks)</td></tr>
<tr class="memdesc:afee68d5935a6875ece69945e32242895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appoints all keys from ks to yet unsynced splits.  <a href="#afee68d5935a6875ece69945e32242895">More...</a><br /></td></tr>
<tr class="separator:afee68d5935a6875ece69945e32242895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9abad2c6146816e966976d9f18f0c88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ab9abad2c6146816e966976d9f18f0c88">elektraSplitGet</a> (Split *split, Key *warningKey, KDB *handle)</td></tr>
<tr class="memdesc:ab9abad2c6146816e966976d9f18f0c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some work after getting of backends is finished.  <a href="#ab9abad2c6146816e966976d9f18f0c88">More...</a><br /></td></tr>
<tr class="separator:ab9abad2c6146816e966976d9f18f0c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b1e5f1810964dddc3bd3a00822bca6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af3b1e5f1810964dddc3bd3a00822bca6">elektraSplitMerge</a> (Split *split, KeySet *dest)</td></tr>
<tr class="memdesc:af3b1e5f1810964dddc3bd3a00822bca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges together all parts of split into dest.  <a href="#af3b1e5f1810964dddc3bd3a00822bca6">More...</a><br /></td></tr>
<tr class="separator:af3b1e5f1810964dddc3bd3a00822bca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603c8c0fce6da478623a68367e2c7175"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a603c8c0fce6da478623a68367e2c7175">elektraSplitCheckSize</a> (Split *split)</td></tr>
<tr class="memdesc:a603c8c0fce6da478623a68367e2c7175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any of the split is uninitialized.  <a href="#a603c8c0fce6da478623a68367e2c7175">More...</a><br /></td></tr>
<tr class="separator:a603c8c0fce6da478623a68367e2c7175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447e430a045cef7b107762171fbdc104"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a447e430a045cef7b107762171fbdc104">elektraSplitDivide</a> (Split *split, KDB *handle, KeySet *ks)</td></tr>
<tr class="memdesc:a447e430a045cef7b107762171fbdc104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits up the keysets and search for a sync bit in every key.  <a href="#a447e430a045cef7b107762171fbdc104">More...</a><br /></td></tr>
<tr class="separator:a447e430a045cef7b107762171fbdc104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3176eff9c1b5a9bfcf3d2e648f537993"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a3176eff9c1b5a9bfcf3d2e648f537993">elektraSplitSync</a> (Split *split)</td></tr>
<tr class="memdesc:a3176eff9c1b5a9bfcf3d2e648f537993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add sync bits everywhere keys were removed/added.  <a href="#a3176eff9c1b5a9bfcf3d2e648f537993">More...</a><br /></td></tr>
<tr class="separator:a3176eff9c1b5a9bfcf3d2e648f537993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f9f801daa8ff1b29e48e31e49752f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a44f9f801daa8ff1b29e48e31e49752f7">elektraSplitPrepare</a> (Split *split)</td></tr>
<tr class="memdesc:a44f9f801daa8ff1b29e48e31e49752f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> mainloop afterwards.  <a href="#a44f9f801daa8ff1b29e48e31e49752f7">More...</a><br /></td></tr>
<tr class="separator:a44f9f801daa8ff1b29e48e31e49752f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7619472c17c782befa93d2e029bc328"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af7619472c17c782befa93d2e029bc328">elektraSplitUpdateSize</a> (Split *split)</td></tr>
<tr class="memdesc:af7619472c17c782befa93d2e029bc328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Also update sizes after <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> to recognize multiple <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> attempts.  <a href="#af7619472c17c782befa93d2e029bc328">More...</a><br /></td></tr>
<tr class="separator:af7619472c17c782befa93d2e029bc328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5b34cee8e0f62c0ea9f44c0e1cb675"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a1d5b34cee8e0f62c0ea9f44c0e1cb675">elektraBackendOpen</a> (KeySet *elektra_config, KeySet *modules, Key *errorKey)</td></tr>
<tr class="memdesc:a1d5b34cee8e0f62c0ea9f44c0e1cb675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a backend out of the configuration supplied from:  <a href="#a1d5b34cee8e0f62c0ea9f44c0e1cb675">More...</a><br /></td></tr>
<tr class="separator:a1d5b34cee8e0f62c0ea9f44c0e1cb675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d7927d2eee6d2003f38a5f8679883b"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af3d7927d2eee6d2003f38a5f8679883b">elektraBackendOpenMissing</a> (Key *mountpoint)</td></tr>
<tr class="memdesc:af3d7927d2eee6d2003f38a5f8679883b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the internal backend that indicates that a backend is missing at that place.  <a href="#af3d7927d2eee6d2003f38a5f8679883b">More...</a><br /></td></tr>
<tr class="separator:af3d7927d2eee6d2003f38a5f8679883b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecb7fc73f33af5353756068d90e7862"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a9ecb7fc73f33af5353756068d90e7862">elektraBackendOpenDefault</a> (KeySet *modules, const char *file, Key *errorKey)</td></tr>
<tr class="memdesc:a9ecb7fc73f33af5353756068d90e7862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a default backend using the plugin named KDB_RESOLVER and KDB_STORAGE.  <a href="#a9ecb7fc73f33af5353756068d90e7862">More...</a><br /></td></tr>
<tr class="separator:a9ecb7fc73f33af5353756068d90e7862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2875836c10c37e9ee4b86847a82f8b77"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a2875836c10c37e9ee4b86847a82f8b77">elektraBackendOpenModules</a> (KeySet *modules, Key *errorKey)</td></tr>
<tr class="separator:a2875836c10c37e9ee4b86847a82f8b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e47734bdace223415ecb804d5126c5"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a70e47734bdace223415ecb804d5126c5">elektraBackendOpenVersion</a> (Key *errorKey)</td></tr>
<tr class="memdesc:a70e47734bdace223415ecb804d5126c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the internal version backend.  <a href="#a70e47734bdace223415ecb804d5126c5">More...</a><br /></td></tr>
<tr class="separator:a70e47734bdace223415ecb804d5126c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf493c5336da5955af376dc1b7cdb264"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#adf493c5336da5955af376dc1b7cdb264">elektraBackendUpdateSize</a> (Backend *backend, Key *parent, int size)</td></tr>
<tr class="memdesc:adf493c5336da5955af376dc1b7cdb264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update internal size in backend.  <a href="#adf493c5336da5955af376dc1b7cdb264">More...</a><br /></td></tr>
<tr class="separator:adf493c5336da5955af376dc1b7cdb264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1bb87ce27fcf307fa71468206872c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a0c1bb87ce27fcf307fa71468206872c2">elektraProcessPlugin</a> (Key *cur, int *pluginNumber, char **pluginName, char **referenceName, Key *errorKey)</td></tr>
<tr class="separator:a0c1bb87ce27fcf307fa71468206872c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a9038eca54799559e3b9b7294fc689"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a42a9038eca54799559e3b9b7294fc689">elektraProcessPlugins</a> (Plugin **plugins, KeySet *modules, KeySet *referencePlugins, KeySet *config, KeySet *systemConfig, Key *errorKey)</td></tr>
<tr class="memdesc:a42a9038eca54799559e3b9b7294fc689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a plugin.  <a href="#a42a9038eca54799559e3b9b7294fc689">More...</a><br /></td></tr>
<tr class="separator:a42a9038eca54799559e3b9b7294fc689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853bd9e11745f72b944d56e0c521e454"><td class="memItemLeft" align="right" valign="top">Plugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a853bd9e11745f72b944d56e0c521e454">elektraPluginOpen</a> (const char *backendname, KeySet *modules, KeySet *config, Key *errorKey)</td></tr>
<tr class="memdesc:a853bd9e11745f72b944d56e0c521e454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a plugin.  <a href="#a853bd9e11745f72b944d56e0c521e454">More...</a><br /></td></tr>
<tr class="separator:a853bd9e11745f72b944d56e0c521e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd6d64636af0f06b703c1b0c32c0372"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trie.html#gafbd6d64636af0f06b703c1b0c32c0372">elektraTrieClose</a> (Trie *trie, Key *errorKey)</td></tr>
<tr class="memdesc:gafbd6d64636af0f06b703c1b0c32c0372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the trie and all opened backends within.  <a href="group__trie.html#gafbd6d64636af0f06b703c1b0c32c0372">More...</a><br /></td></tr>
<tr class="separator:gafbd6d64636af0f06b703c1b0c32c0372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01cd822dd59a8929211f9ec804c15561"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trie.html#ga01cd822dd59a8929211f9ec804c15561">elektraTrieLookup</a> (Trie *trie, const Key *key)</td></tr>
<tr class="memdesc:ga01cd822dd59a8929211f9ec804c15561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Datastructure for mountpoints.  <a href="group__trie.html#ga01cd822dd59a8929211f9ec804c15561">More...</a><br /></td></tr>
<tr class="separator:ga01cd822dd59a8929211f9ec804c15561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c84032644ff56feb44106a7924d3fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ad3c84032644ff56feb44106a7924d3fe">elektraMountOpen</a> (KDB *kdb, KeySet *config, KeySet *modules, Key *errorKey)</td></tr>
<tr class="memdesc:ad3c84032644ff56feb44106a7924d3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a trie from a given configuration.  <a href="#ad3c84032644ff56feb44106a7924d3fe">More...</a><br /></td></tr>
<tr class="separator:ad3c84032644ff56feb44106a7924d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c21e6fe8931013a0dd3f00c87833d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a10c21e6fe8931013a0dd3f00c87833d8">elektraMountDefault</a> (KDB *kdb, KeySet *modules, int inFallback, Key *errorKey)</td></tr>
<tr class="memdesc:a10c21e6fe8931013a0dd3f00c87833d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopens the default backend and mounts the default backend if needed.  <a href="#a10c21e6fe8931013a0dd3f00c87833d8">More...</a><br /></td></tr>
<tr class="separator:a10c21e6fe8931013a0dd3f00c87833d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e32ffc628b2ca1e1876efb6d28cfc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a54e32ffc628b2ca1e1876efb6d28cfc7">elektraMountModules</a> (KDB *kdb, KeySet *modules, Key *errorKey)</td></tr>
<tr class="memdesc:a54e32ffc628b2ca1e1876efb6d28cfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount all module configurations.  <a href="#a54e32ffc628b2ca1e1876efb6d28cfc7">More...</a><br /></td></tr>
<tr class="separator:a54e32ffc628b2ca1e1876efb6d28cfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6362fc7585d7a308c08005cb3cb1a4cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a6362fc7585d7a308c08005cb3cb1a4cd">elektraMountVersion</a> (KDB *kdb, Key *errorKey)</td></tr>
<tr class="memdesc:a6362fc7585d7a308c08005cb3cb1a4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount the version backend.  <a href="#a6362fc7585d7a308c08005cb3cb1a4cd">More...</a><br /></td></tr>
<tr class="separator:a6362fc7585d7a308c08005cb3cb1a4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746a6f6758e8cdfb985b4c46a0e246ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a746a6f6758e8cdfb985b4c46a0e246ff">elektraMountBackend</a> (KDB *kdb, Backend *backend, Key *errorKey)</td></tr>
<tr class="memdesc:a746a6f6758e8cdfb985b4c46a0e246ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a backend into the trie.  <a href="#a746a6f6758e8cdfb985b4c46a0e246ff">More...</a><br /></td></tr>
<tr class="separator:a746a6f6758e8cdfb985b4c46a0e246ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdbb658c5ac280672e4ac22419075f1"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a0cdbb658c5ac280672e4ac22419075f1">elektraMountGetMountpoint</a> (KDB *handle, const Key *where)</td></tr>
<tr class="memdesc:a0cdbb658c5ac280672e4ac22419075f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a mountpoint in a handle for a specific key.  <a href="#a0cdbb658c5ac280672e4ac22419075f1">More...</a><br /></td></tr>
<tr class="separator:a0cdbb658c5ac280672e4ac22419075f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66ed093e4c71d97018ffc66d46d0e1f"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#aa66ed093e4c71d97018ffc66d46d0e1f">elektraMountGetBackend</a> (KDB *handle, const Key *key)</td></tr>
<tr class="memdesc:aa66ed093e4c71d97018ffc66d46d0e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a backend handle for a specific key.  <a href="#aa66ed093e4c71d97018ffc66d46d0e1f">More...</a><br /></td></tr>
<tr class="separator:aa66ed093e4c71d97018ffc66d46d0e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a6c04aa1ff61c84a8cf9658c5ca5a2"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a17a6c04aa1ff61c84a8cf9658c5ca5a2">elektraKsPrev</a> (KeySet *ks)</td></tr>
<tr class="memdesc:a17a6c04aa1ff61c84a8cf9658c5ca5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the previous Key in a KeySet.  <a href="#a17a6c04aa1ff61c84a8cf9658c5ca5a2">More...</a><br /></td></tr>
<tr class="separator:a17a6c04aa1ff61c84a8cf9658c5ca5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b55b0908f9c9434fc0753a0d7089b8"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a97b55b0908f9c9434fc0753a0d7089b8">elektraKsPopAtCursor</a> (KeySet *ks, cursor_t pos)</td></tr>
<tr class="memdesc:a97b55b0908f9c9434fc0753a0d7089b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop key at given cursor position.  <a href="#a97b55b0908f9c9434fc0753a0d7089b8">More...</a><br /></td></tr>
<tr class="separator:a97b55b0908f9c9434fc0753a0d7089b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec09df442faca2e1e8cf233d22fefa63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#aec09df442faca2e1e8cf233d22fefa63">elektraKeyLock</a> (Key *key, enum <a class="el" href="group__proposal.html#ga824e384e248ed1e05448294bff7271c0">elektraLockOptions</a> what)</td></tr>
<tr class="memdesc:aec09df442faca2e1e8cf233d22fefa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permanently locks a part of the key.  <a href="#aec09df442faca2e1e8cf233d22fefa63">More...</a><br /></td></tr>
<tr class="separator:aec09df442faca2e1e8cf233d22fefa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6360a1271f6410f25fbb9b95e346da1a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a6360a1271f6410f25fbb9b95e346da1a">elektraMemcpy</a> (Key **array1, Key **array2, size_t size)</td></tr>
<tr class="memdesc:a6360a1271f6410f25fbb9b95e346da1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Methods for Elektra.  <a href="#a6360a1271f6410f25fbb9b95e346da1a">More...</a><br /></td></tr>
<tr class="separator:a6360a1271f6410f25fbb9b95e346da1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc60bdbe5d252a99734b0122687560be"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#abc60bdbe5d252a99734b0122687560be">elektraMemmove</a> (Key **array1, Key **array2, size_t size)</td></tr>
<tr class="memdesc:abc60bdbe5d252a99734b0122687560be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the key array2 into where array1 points.  <a href="#abc60bdbe5d252a99734b0122687560be">More...</a><br /></td></tr>
<tr class="separator:abc60bdbe5d252a99734b0122687560be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ad42d215b2ce5ed83e1a9354f6ba94"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a04ad42d215b2ce5ed83e1a9354f6ba94">elektraStrNDup</a> (const char *s, size_t l)</td></tr>
<tr class="memdesc:a04ad42d215b2ce5ed83e1a9354f6ba94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffer into new allocated memory.  <a href="#a04ad42d215b2ce5ed83e1a9354f6ba94">More...</a><br /></td></tr>
<tr class="separator:a04ad42d215b2ce5ed83e1a9354f6ba94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126bbb84c75bb98c1e3641dcdf32c6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a7126bbb84c75bb98c1e3641dcdf32c6b">elektraValidateKeyName</a> (const char *name, size_t size)</td></tr>
<tr class="memdesc:a7126bbb84c75bb98c1e3641dcdf32c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates whether the supplied keyname is valid.  <a href="#a7126bbb84c75bb98c1e3641dcdf32c6b">More...</a><br /></td></tr>
<tr class="separator:a7126bbb84c75bb98c1e3641dcdf32c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab436b020c8292d4c40ea2b27dc70305d"><td class="memItemLeft" align="right" valign="top">KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ab436b020c8292d4c40ea2b27dc70305d">elektraRenameKeys</a> (KeySet *config, const char *name)</td></tr>
<tr class="memdesc:ab436b020c8292d4c40ea2b27dc70305d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the first key and cuts off this common part for all other keys, instead name will be prepended.  <a href="#ab436b020c8292d4c40ea2b27dc70305d">More...</a><br /></td></tr>
<tr class="separator:ab436b020c8292d4c40ea2b27dc70305d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private declarations. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>BSD License (see doc/COPYING or <a href="http://www.libelektra.org">http://www.libelektra.org</a>) </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a686cd59039c7112c10c8fbb82f9759e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define clear_bit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((var) &amp;= ~(bit))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a bit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kdbprivate_8h.html#a4874f05226547f6afa54ed6d65dc54ae" title="Set a bit. ">set_bit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8891eaf029de761514dca775f19d6e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KDB_SYSTEM_ELEKTRA&#160;&#160;&#160;&quot;system/elektra&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backend mounting information. </p>
<p>This key directory tells you where each backend is mounted to which mountpoint. </p>

</div>
</div>
<a class="anchor" id="acf20140d9b29c3edc782e72b05b25bd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KEYSET_SIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimal allocation size of a keyset inclusive NULL byte. </p>
<p>ksGetAlloc() will return one less because it says how much can actually be stored. </p>

</div>
</div>
<a class="anchor" id="a93b6deccf1a55a100f74d2e076036f37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_LEN_INT&#160;&#160;&#160;31</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum of how many characters an integer needs as decimal number. </p>

</div>
</div>
<a class="anchor" id="a05efd486827435a0e92220b69ae23519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NR_OF_PLUGINS&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many plugins can exist in an backend. </p>

</div>
</div>
<a class="anchor" id="a4874f05226547f6afa54ed6d65dc54ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define set_bit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((var) |= (bit))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a bit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kdbprivate_8h.html#a686cd59039c7112c10c8fbb82f9759e9" title="Clear a bit. ">clear_bit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22e02bbe80b6081a6485b3f3d2caec14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define test_bit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((var) &amp; (bit))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test a bit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kdbprivate_8h.html#a4874f05226547f6afa54ed6d65dc54ae" title="Set a bit. ">set_bit()</a>, <a class="el" href="kdbprivate_8h.html#a686cd59039c7112c10c8fbb82f9759e9" title="Clear a bit. ">clear_bit()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a351bbaa6e81f4d1d956bb71929dc7285"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285">keyflag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key Flags. </p>
<p>Store a synchronizer state so that the Elektra knows if something has changed or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a351bbaa6e81f4d1d956bb71929dc7285abedbc8b9c2dcfc51908d35aec7e7c756"></a>KEY_FLAG_SYNC&#160;</td><td class="fielddoc">
<p>Key need sync. If name, value or metadata are changed this flag will be set, so that the backend will sync the key to database. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a351bbaa6e81f4d1d956bb71929dc7285ab32b7424934246d1934c430408bd871f"></a>KEY_FLAG_RO_NAME&#160;</td><td class="fielddoc">
<p>Read only flag for name. Key name is read only and not allowed to be changed. All attempts to change the name will lead to an error. Needed for meta keys and keys that are in a data structure that depends on name ordering. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a351bbaa6e81f4d1d956bb71929dc7285abbd77cb92bacff89ef2694ec2cefb135"></a>KEY_FLAG_RO_VALUE&#160;</td><td class="fielddoc">
<p>Read only flag for value. Key value is read only and not allowed to be changed. All attempts to change the value will lead to an error. Needed for meta keys </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a351bbaa6e81f4d1d956bb71929dc7285a22971f649e6a7f6087a44e84ca0ff60d"></a>KEY_FLAG_RO_META&#160;</td><td class="fielddoc">
<p>Read only flag for meta. Key meta is read only and not allowed to be changed. All attempts to change the value will lead to an error. Needed for meta keys. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="afaf34e9cffb5c9382ad09f0f1811a61d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61d">ksflag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ks Flags. </p>
<p>Store a synchronizer state so that the Elektra knows if something has changed or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="afaf34e9cffb5c9382ad09f0f1811a61da60841484247805681f2555220aa13a6b"></a>KS_FLAG_SYNC&#160;</td><td class="fielddoc">
<p>KeySet need sync. If keys were popped from the Keyset this flag will be set, so that the backend will sync the keys to database. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af7ad6ca41444a51395350791dbb2a0f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kdbprivate_8h.html#af7ad6ca41444a51395350791dbb2a0f8">splitflag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af7ad6ca41444a51395350791dbb2a0f8a26d34995557a981ce39558eae0c516f9"></a>SPLIT_FLAG_SYNC&#160;</td><td class="fielddoc">
<p>KeySet in Split need sync. Is there any key in there which need to be synced? If keys were popped from the Keyset this flag will be set, so that the backend will sync the keys to database. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af7ad6ca41444a51395350791dbb2a0f8a10600b1b4223a2f0d3938f8bbc48be06"></a>SPLIT_FLAG_CASCADING&#160;</td><td class="fielddoc">
<p>Do we need relative checks? Is this a cascading backend? </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1d5b34cee8e0f62c0ea9f44c0e1cb675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* elektraBackendOpen </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>elektraConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a backend out of the configuration supplied from: </p>
<pre class="fragment">system/elektra/mountpoints/&lt;name&gt;
</pre><p>The root key must be like the above example. You do not need to rewind the keyset. But every key must be below the root key.</p>
<p>The internal consistency will be checked in this function. If necessary parts are missing, like no plugins, they cant be loaded or similar 0 will be returned.</p>
<p><a class="el" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a" title="Cuts out a keyset at the cutpoint. ">ksCut()</a> is perfectly suitable for cutting out the configuration like needed.</p>
<dl class="section note"><dt>Note</dt><dd>The given KeySet will be deleted within the function, don't use it afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elektraConfig</td><td>the configuration to work with. It is used to build up this backend. </td></tr>
    <tr><td class="paramname">modules</td><td>used to load new modules or get references to existing one </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key where an error and warnings are added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a freshly allocated backend this could be the requested backend or a so called "missing backend". </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if out of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ecb7fc73f33af5353756068d90e7862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* elektraBackendOpenDefault </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a default backend using the plugin named KDB_RESOLVER and KDB_STORAGE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modules</td><td>the modules to work with </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key to issue warnings and errors to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fresh allocated default backend or 0 if it failed </dd></dl>

</div>
</div>
<a class="anchor" id="af3d7927d2eee6d2003f38a5f8679883b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* elektraBackendOpenMissing </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the internal backend that indicates that a backend is missing at that place. </p>
<dl class="section return"><dt>Returns</dt><dd>the fresh allocated backend or 0 if no memory </dd></dl>

</div>
</div>
<a class="anchor" id="a2875836c10c37e9ee4b86847a82f8b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* elektraBackendOpenModules </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a backend which gives plugin configuration of the module which is currently point to.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modules</td><td>the modules to work with </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key to issue warnings and errors to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70e47734bdace223415ecb804d5126c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* elektraBackendOpenVersion </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the internal version backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorKey</td><td>the key to issue warnings and errors to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fresh allocated default backend or 0 if it failed </dd></dl>

</div>
</div>
<a class="anchor" id="adf493c5336da5955af376dc1b7cdb264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraBackendUpdateSize </td>
          <td>(</td>
          <td class="paramtype">Backend *&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update internal size in backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>the backend to update </td></tr>
    <tr><td class="paramname">parent</td><td>for parent </td></tr>
    <tr><td class="paramname">size</td><td>to update (-1 default, 0 empty, &gt;0 otherwise)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>parent must be serializable namespace</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if invalid parent (assert) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec09df442faca2e1e8cf233d22fefa63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraKeyLock </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__proposal.html#ga824e384e248ed1e05448294bff7271c0">elektraLockOptions</a>&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permanently locks a part of the key. </p>
<p>This can be:</p><ul>
<li>KEY_FLAG_LOCK_NAME to lock the name</li>
<li>KEY_FLAG_LOCK_VALUE to lock the value</li>
<li>KEY_FLAG_LOCK_META to lock the meta data</li>
</ul>
<p>To unlock the key, duplicate it.</p>
<p>It is also possible to lock when the key is created with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>.</p>
<p>Some data structures need to lock the key (most likely its name), so that the ordering does not get confused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>which name should be locked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a>, <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>the bits that were successfully locked </td></tr>
    <tr><td class="paramname">0</td><td>if everything was locked before </td></tr>
    <tr><td class="paramname">-1</td><td>if it could not be locked (nullpointer) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97b55b0908f9c9434fc0753a0d7089b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* elektraKsPopAtCursor </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cursor_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop key at given cursor position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset to pop key from </td></tr>
    <tr><td class="paramname">c</td><td>where to pop</td></tr>
  </table>
  </dd>
</dl>
<p>The internal cursor will be rewinded using <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>. You can use <a class="el" href="group__keyset.html#gaffe507ab9281c322eb16c3e992075d29" title="Get the KeySet internal cursor. ">ksGetCursor()</a> and <a class="el" href="group__keyset.html#gad94c9ffaa3e8034564c0712fd407c345" title="Set the KeySet internal cursor. ">ksSetCursor()</a> jump back to the previous position. e.g. to pop at current position within <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> loop: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cursor_t c = ksGetCursor(ks);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;keyDel (ksPopAtCursor(ks, c));</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;ksSetCursor(ks, c);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ksPrev(ks); // to have correct key after next ksNext()</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>do not use, will be superseded by external iterator API</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the popped key </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ks is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17a6c04aa1ff61c84a8cf9658c5ca5a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* elektraKsPrev </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the previous Key in a KeySet. </p>
<p>KeySets have an internal cursor that can be reset with <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>. Every time <a class="el" href="group__api.html#gae7d268f13dd89a6e126b3718b117996f" title="Returns the previous Key in a KeySet. ">ksPrev()</a> is called the cursor is decremented and the new current Key is returned.</p>
<p>You'll get a NULL pointer if the key before begin of the KeySet was reached.</p>
<p>Don't delete the key, use <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a> if you want to delete it.</p>
<dl class="section return"><dt>Returns</dt><dd>the new current Key </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6360a1271f6410f25fbb9b95e346da1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t elektraMemcpy </td>
          <td>(</td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal Methods for Elektra. </p>
<p>To use them: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;kdbinternal.h&gt;</div>
</div><!-- fragment --><p>There are some areas where libraries have to reimplement some basic functions to archive support for non-standard systems, for testing purposes or to provide a little more convenience. Copies the key array2 into where array1 points. It copies size elements.</p>
<p>Overlapping is prohibited, use <a class="el" href="internal_8c.html#abc60bdbe5d252a99734b0122687560be" title="Copies the key array2 into where array1 points. ">elektraMemmove()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array1</td><td>the destination </td></tr>
    <tr><td class="paramname">array2</td><td>the source </td></tr>
    <tr><td class="paramname">size</td><td>how many pointer to Keys to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointers </td></tr>
    <tr><td class="paramname">0</td><td>if nothing was done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size how many keys were copied </dd></dl>

</div>
</div>
<a class="anchor" id="abc60bdbe5d252a99734b0122687560be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t elektraMemmove </td>
          <td>(</td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the key array2 into where array1 points. </p>
<p>It copies size elements.</p>
<p>Overlapping is ok. If they do not overlap consider <a class="el" href="internal_8c.html#a6360a1271f6410f25fbb9b95e346da1a" title="Internal Methods for Elektra. ">elektraMemcpy()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array1</td><td>the destination </td></tr>
    <tr><td class="paramname">array2</td><td>the source </td></tr>
    <tr><td class="paramname">size</td><td>how many pointer to Keys to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointers </td></tr>
    <tr><td class="paramname">0</td><td>if nothing was done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size how many keys were copied </dd></dl>

</div>
</div>
<a class="anchor" id="a746a6f6758e8cdfb985b4c46a0e246ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraMountBackend </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Backend *&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a backend into the trie. </p>
<dl class="section pre"><dt>Precondition</dt><dd>user must pass correctly allocated backend </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>sets reference counter of backend</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>in case of init and default backends, the reference counter needs to be modified <em>after</em> calling elektraMountBackend.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">backend</td><td>the backend to mount </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on failure </td></tr>
    <tr><td class="paramname">1</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10c21e6fe8931013a0dd3f00c87833d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraMountDefault </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inFallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reopens the default backend and mounts the default backend if needed. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Default Backend is closed. elektraMountOpen was executed before.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">modules</td><td>the current list of loaded modules </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa66ed093e4c71d97018ffc66d46d0e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* elektraMountGetBackend </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup a backend handle for a specific key. </p>
<p>The required canonical name is ensured by using a key as parameter, which will transform the key to canonical representation.</p>
<p>Will return handle when no more specific KDB could be found.</p>
<p>If key is 0 or invalid the default backend will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>is the data structure, where the mounted directories are saved. </td></tr>
    <tr><td class="paramname">key</td><td>the key, that should be looked up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the backend handle associated with the key </dd></dl>

</div>
</div>
<a class="anchor" id="a0cdbb658c5ac280672e4ac22419075f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* elektraMountGetMountpoint </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup a mountpoint in a handle for a specific key. </p>
<p>Will return a key representing the mountpoint or null if there is no appropriate mountpoint e.g. its the root mountpoint.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Key * key = keyNew (&quot;system/template&quot;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;KDB * handle = kdbOpen();</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Key *mountpoint=0;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;mountpoint=kdbGetMountpoint(handle, key);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;printf(&quot;The backend I am using is %s mounted in %s\n&quot;,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        keyValue(mountpoint),</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        keyName(mountpoint));</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;kdbClose (handle);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;keyDel (key);</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>is the data structure, where the mounted directories are saved. </td></tr>
    <tr><td class="paramname">where</td><td>the key, that should be looked up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mountpoint associated with the key </dd></dl>

</div>
</div>
<a class="anchor" id="a54e32ffc628b2ca1e1876efb6d28cfc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraMountModules </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount all module configurations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">modules</td><td>the current list of loaded modules </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if not rootkey was found </td></tr>
    <tr><td class="paramname">0</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3c84032644ff56feb44106a7924d3fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraMountOpen </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a trie from a given configuration. </p>
<p>The config will be deleted within this function.</p>
<dl class="section note"><dt>Note</dt><dd>elektraMountDefault is not allowed to be executed before</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">modules</td><td>the current list of loaded modules </td></tr>
    <tr><td class="paramname">config</td><td>the configuration which should be used to build up the trie. </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on failure </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6362fc7585d7a308c08005cb3cb1a4cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraMountVersion </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount the version backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a853bd9e11745f72b944d56e0c521e454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Plugin* elektraPluginOpen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a plugin. </p>
<p>The config will be used as is. So be sure to transfer ownership of the config to it, with e.g. <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a>. elektraPluginClose() will delete the config.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new created plugin or 0 on error </dd></dl>

</div>
</div>
<a class="anchor" id="a0c1bb87ce27fcf307fa71468206872c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraProcessPlugin </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pluginNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>referenceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>and an allocated string of the pluginName if a new plugins should be created. </td></tr>
    <tr><td class="paramname">2</td><td>and an allocated string of the referenceName if an old plugin should be used </td></tr>
    <tr><td class="paramname">3</td><td>and both if a new plugin should be created and made available for later back referencing. </td></tr>
    <tr><td class="paramname">-1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42a9038eca54799559e3b9b7294fc689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraProcessPlugins </td>
          <td>(</td>
          <td class="paramtype">Plugin **&#160;</td>
          <td class="paramname"><em>plugins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>referencePlugins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>systemConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a plugin. </p>
<p>The array of plugins must be set to 0. Its length is NR_OF_PLUGINS.</p>
<p>systemConfig will only be used, not deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>the config with the information how the plugins should be put together </td></tr>
    <tr><td class="paramname">systemConfig</td><td>the shared (system) config for the plugins. Every plugin additional get this config.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab436b020c8292d4c40ea2b27dc70305d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KeySet* elektraRenameKeys </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the first key and cuts off this common part for all other keys, instead name will be prepended. </p>
<dl class="section return"><dt>Returns</dt><dd>a new allocated keyset with keys in user namespace.</dd></dl>
<p>The first key is removed in the resulting keyset. </p>

</div>
</div>
<a class="anchor" id="a0c8c5c6c26aa42404d8aa06e6476a0f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t elektraSplitAppend </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Backend *&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>parentKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>syncbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the size of split and appends a new empty keyset. </p>
<p>Initializes the element with the given parameters at size-1 to be used.</p>
<p>Will automatically resize split if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">backend</td><td>the backend which should be appended </td></tr>
    <tr><td class="paramname">parentKey</td><td>the parentKey which should be appended </td></tr>
    <tr><td class="paramname">syncbits</td><td>the initial syncstate which should be appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if no split is found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the new element: size-1 </dd></dl>

</div>
</div>
<a class="anchor" id="afee68d5935a6875ece69945e32242895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitAppoint </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appoints all keys from ks to yet unsynced splits. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="split_8c.html#aabebbc4b0e47527f59942fcf95b9fcb5" title="Walks through kdb->split and adds all backends below parentKey to split. ">elektraSplitBuildup()</a> need to be executed before.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">handle</td><td>to determine to which backend a key belongs </td></tr>
    <tr><td class="paramname">ks</td><td>the keyset to appoint to split</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>if no backend was found for a key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7141dca0099564b12859a370fb060b6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitBuildup </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>parentKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walks through kdb-&gt;split and adds all backends below parentKey to split. </p>
<p>Sets syncbits to 2 if it is a default or root backend (which needs splitting). The information is copied from kdb-&gt;split.</p>
<dl class="section pre"><dt>Precondition</dt><dd>split needs to be empty, directly after creation with <a class="el" href="split_8c.html#ad2245a38809f28e325cd9b32089b4c68" title="Allocates a new split object. ">elektraSplitNew()</a>.</dd>
<dd>
there needs to be a valid defaultBackend but its ok not to have a trie inside KDB.</dd>
<dd>
parentKey must be a valid key! (could be implemented more generally, but that would require splitting up of keysets of the same backend)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>will get all backends appended </td></tr>
    <tr><td class="paramname">kdb</td><td>the handle to get information about backends </td></tr>
    <tr><td class="paramname">parentKey</td><td>the information below which key the backends are from interest</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a603c8c0fce6da478623a68367e2c7175"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitCheckSize </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if any of the split is uninitialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if size is wrong </td></tr>
    <tr><td class="paramname">1</td><td>if everything is ok </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae569ef1bc4cd8e931b4a7840d8ce48e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraSplitDel </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>keysets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a split object. </p>
<p>Will free all allocated resources of a split keyset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysets</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a447e430a045cef7b107762171fbdc104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitDivide </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits up the keysets and search for a sync bit in every key. </p>
<p>It does not check if there were removed keys, see <a class="el" href="split_8c.html#a3176eff9c1b5a9bfcf3d2e648f537993" title="Add sync bits everywhere keys were removed/added. ">elektraSplitSync()</a> for the next step.</p>
<p>It does not create new backends, this has to be done by buildup before.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="split_8c.html#aabebbc4b0e47527f59942fcf95b9fcb5" title="Walks through kdb->split and adds all backends below parentKey to split. ">elektraSplitBuildup()</a> need to be executed before.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">handle</td><td>to get information where the individual keys belong </td></tr>
    <tr><td class="paramname">ks</td><td>the keyset to divide</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if there were no sync bits </td></tr>
    <tr><td class="paramname">1</td><td>if there were sync bits </td></tr>
    <tr><td class="paramname">-1</td><td>if no backend was found for any key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9abad2c6146816e966976d9f18f0c88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitGet </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>warningKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does some work after getting of backends is finished. </p>
<ul>
<li>Update sizes</li>
<li>Removal of wrong keys</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="split_8c.html#afee68d5935a6875ece69945e32242895" title="Appoints all keys from ks to yet unsynced splits. ">elektraSplitAppoint()</a> needs to be executed before.</dd></dl>
<ul>
<li>check if keys are in correct backend</li>
<li>remove syncbits</li>
<li>update sizes in the backends</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">warningKey</td><td>postcondition violations are reported here </td></tr>
    <tr><td class="paramname">handle</td><td>the handle to preprocess the keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>if no backend was found for a key or split-&gt;parents has invalid namespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3b1e5f1810964dddc3bd3a00822bca6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitMerge </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges together all parts of split into dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">dest</td><td>the destination keyset where all keysets are appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2245a38809f28e325cd9b32089b4c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Split* elektraSplitNew </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new split object. </p>
<p>Splits up a keyset into multiple keysets where each of them will passed to the correct <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a>.</p>
<p>Initially the size is 0 and alloc is APPROXIMATE_NR_OF_BACKENDS.</p>
<dl class="section return"><dt>Returns</dt><dd>a fresh allocated split object</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="split_8c.html#ae569ef1bc4cd8e931b4a7840d8ce48e6" title="Delete a split object. ">elektraSplitDel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a44f9f801daa8ff1b29e48e31e49752f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraSplitPrepare </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> mainloop afterwards. </p>
<p>All splits which do not need sync are removed and a deep copy of the remaining keysets is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6067083cc1afb5d42180bf75f7f86ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraSplitRemove </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove one part of split. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">where</td><td>the position to cut away</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>where must be within the size of the split </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>split will be removed </dd></dl>

</div>
</div>
<a class="anchor" id="af677c7c96b215a61d76c7b4a8f8db877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraSplitResize </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Doubles the size of how many parts of keysets can be appended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a36f0da2272fde84ecfc09090669cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t elektraSplitSearchBackend </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Backend *&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the backend is already inserted or not. </p>
<dl class="section warning"><dt>Warning</dt><dd>If no parent Key is given, the default/root backends won't be searched.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">backend</td><td>the backend to search for </td></tr>
    <tr><td class="paramname">parent</td><td>the key to check for domains in default/root backends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pos of backend if it already exist </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if it does not exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb25e1f946f07e5490a962a42320a0cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitSearchRoot </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>parentKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if one of the backends in split has all keys below parentKey </td></tr>
    <tr><td class="paramname">0</td><td>if parentKey == 0 or there are keys below or same than parentKey which do not fit in any of split keysets </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">parentKey</td><td>the key which relation is searched for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3176eff9c1b5a9bfcf3d2e648f537993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitSync </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add sync bits everywhere keys were removed/added. </p>
<ul>
<li>checks if the size of a previous <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> is unchanged.</li>
<li>checks if in correct state (<a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> needs to be executed before)</li>
</ul>
<p>Only <a class="el" href="split_8c.html#a447e430a045cef7b107762171fbdc104" title="Splits up the keysets and search for a sync bit in every key. ">elektraSplitDivide()</a> together with this function can really decide if sync is needed or not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>split needs to be processed with <a class="el" href="split_8c.html#a447e430a045cef7b107762171fbdc104" title="Splits up the keysets and search for a sync bit in every key. ">elektraSplitDivide()</a> before.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> is not needed </td></tr>
    <tr><td class="paramname">1</td><td>if <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> is needed </td></tr>
    <tr><td class="paramname">-1</td><td>on wrong keys (also has assert, should not happen) </td></tr>
    <tr><td class="paramname">-2</td><td>wrong spec state: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> was not executed before </td></tr>
    <tr><td class="paramname">-3</td><td>wrong dir state: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> was not executed before </td></tr>
    <tr><td class="paramname">-4</td><td>wrong user state: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> was not executed before </td></tr>
    <tr><td class="paramname">-5</td><td>wrong system state: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> was not executed before </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>user/system was split before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dde14941040fe97dd036555e858bb69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraSplitUpdateFileName </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the (configuration) file name for the parent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split to work with </td></tr>
    <tr><td class="paramname">handle</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">key</td><td>the parentKey that should be updated (name must be correct) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7619472c17c782befa93d2e029bc328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraSplitUpdateSize </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Also update sizes after <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> to recognize multiple <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> attempts. </p>
<dl class="section warning"><dt>Warning</dt><dd>cant use the same code with elektraSplitGet because there is no default split part for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a04ad42d215b2ce5ed83e1a9354f6ba94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* elektraStrNDup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy buffer into new allocated memory. </p>
<p>You need to free the memory yourself.</p>
<p>This function also works with \0 characters in the buffer. The length is taken as given, it must be correct.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if out of memory, a pointer otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>must be a allocated buffer </td></tr>
    <tr><td class="paramname">l</td><td>the length of s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7126bbb84c75bb98c1e3641dcdf32c6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraValidateKeyName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates whether the supplied keyname is valid. </p>
<p>The function looks for tangling escape characters in the end and for a minimum length.</p>
<p>Does not check for valid namespaces</p>
<dl class="section pre"><dt>Precondition</dt><dd>size must be at least 2</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the key name that is to be checked </td></tr>
    <tr><td class="paramname">size</td><td>a elektraStrLen of the key name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the supplied keyname part is valid </td></tr>
    <tr><td class="paramname">false</td><td>if its invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
