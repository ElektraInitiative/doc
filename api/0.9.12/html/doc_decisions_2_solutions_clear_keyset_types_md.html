<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Types of &lt;tt&gt;KeySet&lt;/tt&gt;s</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
$darkmode
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Add mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_color_doxygen.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Elektra<span id="projectnumber">&#160;0.9.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Types of <code>KeySet</code>s </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_decisions_2_solutions_clear_keyset_types"></a> </p>
<h1><a class="anchor" id="autotoc_md2000"></a>
Problem</h1>
<p>A <code>KeySet</code> can be used in different ways. Among these are at least:</p>
<ul>
<li>As originally intended, a set of configuration data</li>
<li>Metadata of a <code>Key</code></li>
<li>General associative array data structure</li>
</ul>
<p>Only <code>KeySet</code>s with one kind of keys makes sense. These types have slightly different requirements, and therefore need to be treated differently. Currently, keys of different types can be arbitrary intermixed, leading to many error variants and error code that is time-consuming (full iteration is needed).</p>
<p>The <code>KeySet</code> for metadata (returned by <code>keyMeta</code>) also has the special requirement, that it must be restricted to metadata keys, even when it is empty.</p>
<h1><a class="anchor" id="autotoc_md2001"></a>
Constraints</h1>
<ul>
<li>API must be minimal</li>
<li>API must be safe to use for each of the different types</li>
<li><code>KeySet</code> returned by <code>keyMeta</code> must always be limited to <code>meta:/</code> keys</li>
</ul>
<h1><a class="anchor" id="autotoc_md2002"></a>
Assumptions</h1>
<ul>
<li>The types are not different enough to warrant the overhead of entirely different APIs and data structures.</li>
<li>Introducing a type safe API with different C-types for each type of <code>KeySet</code>, is not worth the necessary API duplication.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2003"></a>
Considered Alternatives</h1>
<h2><a class="anchor" id="autotoc_md2004"></a>
No restrictions</h2>
<p>Leave <code>KeySet</code> entirely unrestricted, so it can be used for each use case.</p>
<p>Sometimes there can be odd edge cases. For example, what should a storage plugin do, if it receives a <code>KeySet</code> with both configuration data and metadata.</p>
<h2><a class="anchor" id="autotoc_md2005"></a>
Restriction based on first &lt;tt&gt;Key&lt;/tt&gt;</h2>
<p>To effectively create different kinds of <code>KeySet</code>s, we restrict which <code>Key</code>s can be inserted into a <code>KeySet</code> based on the first <code>Key</code> in a <code>KeySet</code>.</p>
<p>Any <code>Key</code> except cascading keys can be inserted into an empty <code>KeySet</code>. Only <code>Key</code>s matching the type of a <code>KeySet</code> can be inserted into a non-empty <code>KeySet</code>. The type of a <code>KeySet</code> is determined by the first <code>Key</code>, i.e., <code>ksAtCursor(ks, 0)</code>. Transitively, this means the type of a <code>KeySet</code> is fixed when the first <code>Key</code> is inserted and when a <code>KeySet</code> is cleared, it becomes "type-less" again.</p>
<p>The different types of <code>KeySet</code> will be:</p>
<ol type="1">
<li>Metadata: Can only contain <code>Key</code>s with namespace <code>KEY_NS_META</code>.</li>
<li>General data: Can only contain <code>Key</code>s with namespace <code>KEY_NS_MISC</code>.</li>
<li>Config data: Can only contain a mix of <code>Key</code>s with namespace <code>KEY_NS_SPEC</code>, <code>KEY_NS_PROC</code>, <code>KEY_NS_DIR</code>, <code>KEY_NS_USER</code>, <code>KEY_NS_SYSTEM</code> and <code>KEY_NS_DEFAULT</code>.</li>
</ol>
<p>Importantly, <code>Key</code>s with namespace <code>KEY_NS_CASCADING</code> can never be inserted into a <code>KeySet</code>. This is a restriction that simplifies the logic for cascading lookups. Instead, the <code>KEY_NS_MISC</code> namespace should be used.</p>
<p>Cascading lookups always try the namespaces allowed in the type of <code>KeySet</code> in order, but never try <code>KEY_NS_SPEC</code>. This means cascading lookups work for all types of <code>KeySet</code> the way a user would expect.</p>
<p>The special restriction for the <code>KeySet</code> returned by <code>keyMeta</code> can be solved by adding a new flag to <code>struct _KeySet</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> forceMeta : 1; </div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2006"></a>
Different structs and APIs</h2>
<p>Extract the implementation of <code>KeySet</code> into an internal API (and possibly data structure). Expose a different type and API for each of the use cases.</p>
<p>This creates unnecessary overhead and at least some code duplication, even if it is minimized by extracting the implementation.</p>
<h2><a class="anchor" id="autotoc_md2007"></a>
KeySets also have Namespaces</h2>
<p>Add a <code>ksSetNamespace</code> API which allows to change the namespace of a KeySet. This requires an alias <code>KS_NS_CONFIG</code> to the namespaces <code>KEY_NS_SPEC</code>, <code>KEY_NS_PROC</code>, <code>KEY_NS_DIR</code>, <code>KEY_NS_USER</code>, <code>KEY_NS_SYSTEM</code> and <code>KEY_NS_DEFAULT</code>.</p>
<p>Only keys of the namespace set to <code>ksSetNamespace</code> can be added. <code>ksSetNamespace</code> fails if called after keys were added.</p>
<p>While the term "namespace" (<code>NS</code>) is used here, it may be better to use "type" to avoid confusion.</p>
<p>This alternative conflicts with the constraint of minimal API.</p>
<h1><a class="anchor" id="autotoc_md2008"></a>
Decision</h1>
<h1><a class="anchor" id="autotoc_md2009"></a>
Rationale</h1>
<h1><a class="anchor" id="autotoc_md2010"></a>
Implications</h1>
<h1><a class="anchor" id="autotoc_md2011"></a>
Related Decisions</h1>
<ul>
<li><a class="el" href="doc_decisions_4_decided_misc_namespace_md.html">Namespace for miscellaneous data</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2012"></a>
Notes</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark'
  });
</script>
</body>
</html>
