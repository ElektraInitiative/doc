<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Algorithm </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_dev_algorithm"></a> You might want to read <a class="el" href="doc_dev_architecture_md.html">about architecture</a> and <a class="el" href="doc_dev_data-structures_md.html">data structures</a> first.</p>
<h1><a class="anchor" id="autotoc_md2221"></a>
Introduction</h1>
<p>In this section, we will explain the heart of Elektra. <code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> is responsible for the setup and the construction of the data structures needed later. <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> does, together with the plugins, all actions necessary to read in the configuration. <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> orchestrates the plugins to write out the configuration correctly. <code><a class="el" href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f" title="Closes the session with the Key database.">kdbClose()</a></code> finally frees all previously allocated data structures.</p>
<h2><a class="anchor" id="autotoc_md2222"></a>
kdbOpen</h2>
<p><code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> retrieves the <em>mount point configuration</em> with <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> using the <em>default backend</em>. During this process, the function sets up the data structures which are needed for later invocations of <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> or <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>. All backends are opened and mounted in the appropriate parts of the key hierarchy. The resulting backends are added both to the <code>Split</code> and the <code>Trie</code> object. <code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> finally returns a <code>KDB</code> object that contains all this information.</p>
<p>The reading of the mount point configuration and the consequential self configuring of the system is called <em>bootstrapping</em>. Elektra builds itself up with a default backend (consisting of <code>libelektra-resolver</code> and <code>libelektra-storage</code>). <a class="el" href="doc_help_elektra-bootstrapping_md.html">Read more about bootstrapping here</a></p>
<p><code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> creates a <code>Split</code> object. It adds all backend handles and <code>parentKeys</code> during bootstrapping. So the buildup of the <code>Split</code> object takes place once. The resulting object is then used for both <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> and <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>. This approach is much better testable because the <code>Split</code> object is first initialised using the mount point configuration &ndash; separated from the filtering of the backends for every specific <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> and <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> request.</p>
<p>Afterwards the key hierarchy is static. Every application using Elektra will build up the same key database. Application-specific mount points are prohibited because changes of mount points would destroy the global key database. Elektra could not guarantee that every application retrieves the same configuration with the same key names any longer.</p>
<p>In <code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code>, nearly no checks are done regarding the expected behavior of the backend. The contract checker guarantees that only appropriate mount points are written into the mount point configuration. <code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> checks only if the opening of plugin was successful. If not, the backend enclosing the plugin is not mounted at all.</p>
<h2><a class="anchor" id="autotoc_md2223"></a>
Removing Keys</h2>
<p>In Elektra version 0.6, removing keys was an explicit request. Only a single <code>Key</code> object could be removed from the database. For configuration files this method is inapplicable. For <code>filesys</code>, however, it was easy to implement.</p>
<p>In Elektra version 0.7, the behavior changed. Removing keys was integrated into <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>. The user tagged keys that should be removed. After the next <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>, these keys were removed from the key database. On the one hand, backends writing configuration files simply ignored the keys marked for removal. On the other hand, <code>filesys</code> needed that information to remove the files. To make this approach work for <code>filesys</code>, the marked keys were located at the very end of the <code>KeySet</code> and sorted in reverse. With this trick, recursive removing worked well. But this approach had major defects in the usage of <code>KeySet</code>. Because marking a key to be removed changed the sort order of the key set <code><a class="el" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83" title="Convenience method to look for a Key contained in ks with name name.">ksLookupByName()</a></code> did not find this key anymore.</p>
<p>So in the present version removing keys is consistent again. A <code>KeySet</code> describes the current configuration. The user can reduce the <code>KeySet</code> object by <em>popping</em> keys out. The <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> function applies exactly this configuration as specified by the key set to the key database. Contrary to the previous versions, the popped keys of the key set will be permanently removed.</p>
<p>The new circumstance yields <b>idempotent</b> properties for <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>. The same <code>KeySet</code> can be applied multiple times, but after the first time, the key database will not be changed anymore. Note that <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> actually detects that there are no changes and will do nothing. To actually show the idempotent behavior the KeySet has to be regenerated or the key database needs to be reopened.</p>
<p>It is, however, not known if keys should be removed permanently only by investigating the <code>KeySet</code>. But only if this knowledge is present, the core can decide if the key set needs to be written out or if the configuration is unchanged. So we decided to track how many keys are delivered in <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code>. If the size of the <code>KeySet</code> is lower than this number determined at the previous <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code>, Elektra’s core knows that some keys were popped. Hence, the next <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> invocation needs to change the concerned key database.</p>
<p>The situation is now much clearer. The semantics of popping a key will result in removing the key from the key database. And the intuitive idea that a <code>KeySet</code> will be applied to the key database is correct again.</p>
<h1><a class="anchor" id="autotoc_md2224"></a>
kdbGet</h1>
<p>It is critical for application startup-time to retrieve the configuration as fast as possible. Hence, the design goal of the <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> algorithm is to be efficient while still enabling plugins to have relaxed postconditions. To achieve this, the sequence of <em>syscalls</em> must be optimal. On the other hand, it is not tolerable to waste time or memory inside Elektra’s core, especially during an initial request or when no update is available.</p>
<p>The synopsis of the function is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet</a>(KDB *handle, KeySet *returned, Key * parentKey);</div>
<div class="ttc" id="agroup__kdb_html_ga28e385fd9cb7ccfe0b2f1ed2f62453a1"><div class="ttname"><a href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet</a></div><div class="ttdeci">int kdbGet(KDB *handle, KeySet *ks, Key *parentKey)</div><div class="ttdoc">Retrieve Keys from a Key database in an atomic and universal way.</div><div class="ttdef"><b>Definition:</b> kdb.c:1211</div></div>
</div><!-- fragment --><p>The user passes a key set, called <code>returned</code>. If the user invokes <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> the first time, he or she will usually pass an empty key set. If the user wants to update the application's settings, <code>returned</code> will typically contain the configuration of the previous <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> request. The <code>parentKey</code> holds the information below which key the configuration should be retrieved. The <code>handle</code> contains the data structures needed for the algorithm, like the <code>Split</code> and the <code>Trie</code> objects.</p>
<p><code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> does a rather easy job, because <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> already guarantees that only well formatted, non-corrupted and well-typed configuration is written out in the key database. The task is to query all backends in question for their configuration and then merge everything.</p>
<h2><a class="anchor" id="autotoc_md2225"></a>
Responsibility</h2>
<p>A backend may yield keys that it is not responsible for. It is not possible for a backend to know that another backend has been mounted below and the other backend is now responsible for some of the keys that are still in the storage. Additionally, plugins are not able to determine if they are responsible for a key or not. Consequently, it can happen that more than one backend delivers a key with the same name.</p>
<p><code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> ensures that a key is uniquely identified by its name. Elektra’s core will <a class="el" href="doc_help_elektra-glossary_md.html">pop</a> keys that are outside of the backend's responsibility. Hence, these keys will not be passed to the user and we get the desired behavior: The nearest mounted backend to the key is responsible.</p>
<p>For example, a generator plugin in the backend (A) always emits following keys. (A) and (B) indicate from which backend the key comes from.</p>
<div class="fragment"><div class="line">user:/sw/generator/akey (A)</div>
<div class="line">user:/sw/generator/dir (A)</div>
<div class="line">user:/sw/generator/dir/outside1 (A)</div>
<div class="line">user:/sw/generator/dir/outside2 (A)</div>
</div><!-- fragment --><p>It will still return these keys even if the plugin is not responsible for some of them anymore. This can happen if another backend B is mounted to <code>user:/sw/generator/dir</code>. In the example it yields the following keys:</p>
<div class="fragment"><div class="line">user:/sw/generator/dir (B)</div>
<div class="line">user:/sw/generator/dir/new (B)</div>
<div class="line">user:/sw/generator/dir/outside1 (B)</div>
<div class="line">user:/sw/generator/outside (B)</div>
</div><!-- fragment --><p>In this situation <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> is responsible to pop all three keys at, and below, <code>user:/sw/generator/dir</code> of backend (A) and the key <code>user:/sw/generator/outside</code> of backend (B). The user will get the resulting key set:</p>
<div class="fragment"><div class="line">user:/sw/generator/akey (A)</div>
<div class="line">user:/sw/generator/dir (B)</div>
<div class="line">user:/sw/generator/dir/new (B)</div>
<div class="line">user:/sw/generator/dir/outside1 (B)</div>
</div><!-- fragment --><p>Note that the key exactly at the mount point comes from the backend mounted at <code>user:/sw/generator/dir</code>.</p>
<h2><a class="anchor" id="autotoc_md2226"></a>
Sequence</h2>
<p><code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> already creates a <code>Split</code> object for the whole configuration tree. In this object, <code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> will append a list of all backends available. A specific <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> request usually includes only a part of the configuration. For example, the user is only interested in keys below <code>user:/sw/apps/userapp</code>. All backends that cannot contribute to configuration below <code>user:/sw/apps/userapp</code> will be omitted for that request. To achieve this, parts of the <code>Split</code> object are filtered out. After this step we know the list of backends involved. The <code>Split</code> object allocates a key set for each of these backends.</p>
<p>Afterwards the first plugin of each backend is called to determine if an update is needed. If no update is needed, the algorithm has finished and returns zero.</p>
<p>Now we know which backends do not need an update. For these backends, the previous configuration from <code>returned</code> is appointed from to the key sets of the <code>Split</code> object. The algorithm will not set the <em>syncbits</em> of the <code>Split</code> object for these backends because the storage of the backends already contains up-to-date configuration.</p>
<p>The other backends will be requested to <em>retrieve</em> their configuration. The initial empty <code>KeySet</code> from the <code>Split</code> object and the relevant file name in the key value of <code>parentKey</code> are passed to each remaining plugin. The plugins extend, validate and process the key set. When an error has occurred, the algorithm can stop immediately because the user's <code>KeySet</code> <code>returned</code> is not changed at this point. When this part finishes, the <code>Split</code> object contains the whole requested configuration separated in various key sets.</p>
<p>Subsequently the freshly received keys need some <em>post-processing</em>:</p>
<ul>
<li>Newly allocated keys in Elektra always have the <em>sync flag</em> set. Because the plugins allocate and modify keys with the same functions as the user, the returned keys will also have their sync flag set. But from the user's point of view the configuration is unmodified. So some code needs to remove this sync flag. To relax the post conditions of the plugins, <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> removes it.</li>
<li>To detect removed keys in subsequent <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> calls, <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> needs to store the number of received keys of each backend.</li>
<li>Additionally, for every key it is checked if it belongs to this backend. This makes sure that every key comes from a single source only as designated by the <code>Trie</code>. In this process, Elektra pops all duplicated and overlapping keys in favor of the responsible backend.</li>
</ul>
<p>The last step is to <em>merge</em> all these key sets together. This step changes the configuration visible to the user. After some cleanup the algorithm finally finishes.</p>
<h2><a class="anchor" id="autotoc_md2227"></a>
Updating Configuration</h2>
<p>The user can call <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> often even if the configuration or parts of it are already up-to-date. This can happen when applications reread configuration in some events. Examples are signals (SIGHUP is the signal used for that on Unix systems. It is sent when the program's controlling terminal is closed. Daemons do not have a terminal so the signal is reused for reloading configuration.), notifications, user requests and in the worst case periodical attempts to reread configuration.</p>
<p>The given goal is to keep the sequence of needed syscalls low. If no update is needed, it is sufficient to request the timestamp (On POSIX systems using <code>stat()</code>) of every file. No other syscall is needed. Elektra’s core alone cannot check that because getting a timestamp is not defined within the standard C99. So instead the resolver plugin handles this problem. The resolver plugin returns 0 if nothing has changed.</p>
<p>This decision yields some advantages. Both the storage plugins and Elektra’s core can conform to C99. Because the resolver plugin is the very first in the chain of plugins, it is guaranteed that no useless work is done.</p>
<h2><a class="anchor" id="autotoc_md2228"></a>
Initial kdbGet Problem</h2>
<p>Because Elektra provides self-contained configuration, <code><a class="el" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5" title="Opens the session with the Key database.">kdbOpen()</a></code> has to retrieve settings in the <em>bootstrapping</em> process below <code>system:/elektra</code> as explained in <code>bootstrapping</code>. Because of the new way to keep track of removed keys, the internally executed <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> creates a problem. Without countermeasures even the first <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> of a user requesting the configuration below <code>system:/elektra</code> fails, because the resolver finds out that the configuration is already up-to-date. The configuration delivered by the user is empty at this point. As a result, the empty configuration will be appointed and returned to the user.</p>
<p>A simple way to resolve this issue is to reload the default backend after the internal configuration was fetched. Reloading resets the timestamps and <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> works as expected.</p>
<h1><a class="anchor" id="autotoc_md2229"></a>
kdbSet</h1>
<p>Not performance, but robust and reliable behavior is the most important issue for <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>. The design was chosen so that some additional in-memory comparisons are preferred to a suboptimal sequence of <code>syscalls</code>. The algorithm makes sure that keys are written out only if it is necessary, because applications can call <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> with an unchanged <code>KeySet</code>. For the code to decide this, performance is important.</p>
<h2><a class="anchor" id="autotoc_md2230"></a>
Properties</h2>
<p><code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> guarantees the following properties:</p>
<ul>
<li>Modifications to permanent storage are only made when the configuration was changed.</li>
<li>When errors occur, every plugin gets a chance to rollback its changes as described in <b>exception safety</b>.</li>
<li>If every plugin does this correctly, the whole <code>KeySet</code> is propagated to permanent storage. Otherwise nothing is changed in the key database. Plugins delivered with Elektra meet this requirement.</li>
</ul>
<p>The synopsis of the function is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet</a>(KDB *handle, KeySet *returned, Key * parentKey);</div>
<div class="ttc" id="agroup__kdb_html_ga11436b058408f83d303ca5e996832bcf"><div class="ttname"><a href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet</a></div><div class="ttdeci">int kdbSet(KDB *handle, KeySet *ks, Key *parentKey)</div><div class="ttdoc">Set Keys to a Key database in an atomic and universal way.</div><div class="ttdef"><b>Definition:</b> kdb.c:1783</div></div>
</div><!-- fragment --><p>The user passes the configuration using the <code>KeySet</code> <code>returned</code>. The key set will not be changed by <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>. The <code>parentKey</code> provides a way to limit which part of the configuration is written out. For example, the <code>parentKey</code> <code>user:/sw/org/app/#0/current</code> will induce <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> to only modify the key databases below <code>user:/sw/org/app</code> even if the <code>KeySet</code> <code>returned</code> also contains more configuration. Note that all backends with no keys in <code>returned</code> but that are below <code>parentKey</code> will completely wipe out their key database. The <code>KDB</code> handle contains the necessary data structures.</p>
<h2><a class="anchor" id="autotoc_md2231"></a>
Search for Changes</h2>
<p>As a first step, <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> <em>divides</em> the configuration passed in by the user to the key sets in the <code>Split</code> object. <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> searches for every key if the <em>sync flag</em> is checked. Then <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> decides if a key was removed from a backend by comparing the actual size of the key set with the size stored from the last <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> call. We see that it is necessary to call <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> first before invocations of <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> are allowed.</p>
<p>We know that data of a backend has to be written out if at least one key was changed or removed. If no backend has any changes, the algorithm will terminate at this point. The careful reader notices that the process involves no file operations.</p>
<h2><a class="anchor" id="autotoc_md2232"></a>
Duplicated Key Sets</h2>
<p>If some backends need synchronization, the algorithm continues by filtering out all backends in the <code>Split</code> object that do not have changes. At this point, the <code>Split</code> object has a list of backends with their respective key sets.</p>
<p>Plugins in <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> can change values. Other than in <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code>, the user is not interested in these changes. Instead, the values are transformed to be suitable for the storage. To make sure that the changed values are not passed to the user, the algorithm continues with a <em>deep duplication</em> of all key sets in the <code>Split</code> object.</p>
<h2><a class="anchor" id="autotoc_md2233"></a>
Resolver</h2>
<p>All plugins of each included backend are executed one by one up to the resolver plugin. If this succeeds, the resolver plugin is responsible for committing these changes. After the successful commit, <em>error codes</em> of plugins are ignored. Only logging and notification plugins are affected.</p>
<h2><a class="anchor" id="autotoc_md2234"></a>
Atomic Replacement</h2>
<p>Up to now only file-based storages with atomic properties were developed. The replacement of a file with another file that has not yet been written is not trivial. The straightforward way is to lock a file and start writing to it. But this approach can result in broken or partially finished files in events like “out of disc space”, signals or other asynchronous aborts of the program.</p>
<p>A temporary file solves most of this problem, because in problematic events the original file stays untouched. When the temporary file is written out properly, it is renamed and the original configuration file is overwritten. But another concurrent invocation of <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> can try to do the same with the result that one of the newly written files is lost.</p>
<p>To avoid this problem, locks are needed and protect cooperating processes (such as other processes using Elektra).</p>
<p>Additionally modification time is used to detect if a file was modified. Unfortunately the modification time on some file systems has a resolution of one second. So any changes within that time slot might not be recognized.</p>
<h2><a class="anchor" id="autotoc_md2235"></a>
Errors</h2>
<p>The plugins within <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> can fail for a variety of reasons. Conflicts occur most frequently. A conflict means that during executions of <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> and <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> another program has changed the key database. In order not to lose any data, <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> fails without doing anything. In conflict situations Elektra leaves the programmer no choice. The programmer has to retrieve the configuration using <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> again to be up-to-date with the key database. Afterwards it is up to the application to decide which configuration to use. In this situation it is the best to ask the user, by showing him the description and reason of the error, how to continue:</p>
<ol type="1">
<li>Save the configuration again. The changes of the other program will be lost in this case.</li>
<li>The key database can also be left unchanged as the other program wrote it. After using <code><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a></code> the application is already up-to-date with the new configuration. All configuration changes the user made before will be lost.</li>
<li>The application can try to merge the key sets to get the best result. If no key is changed on both sides the result is clear, otherwise the application has to decide if the own or the other configuration should be favored. The result of the merged key sets has to be written out with <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code>.</li>
<li>Merging the key sets can be done with <code><a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all Keys in toAppend to the end of the KeySet ks.">ksAppend()</a></code>. The source parameter is the preferred configuration. Note that the downside of the third option is that the merged configuration might not be valid.</li>
</ol>
<p>Sometimes a concrete key causes the problem that the whole key set cannot be stored. That can happen on validation or because of type errors. Such errors are usually caused by a mistake made by the user. So the user is responsible for changing the settings to make it valid again. In such situations, the <em>internal cursor</em> of the <code>KeySet</code> <code>returned</code> will point to the problematic key.</p>
<p>A completely different approach is to export the configuration when <code><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a></code> returned an error code. The user can then edit, change or merge this configuration with more powerful tools. Finally, the user can import the configuration into the global key database. The export and import mechanism is called "streaming" and will be explained in <em>streaming</em>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
