\hypertarget{group__split}{
\section{Split :: Represents splitted keysets}
\label{group__split}\index{Split :: Represents splitted keysets@{Split :: Represents splitted keysets}}
}


used internally for \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdbSet()}  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{struct__Split}{Split} $\ast$ \hyperlink{group__split_gad2245a38809f28e325cd9b32089b4c68}{elektraSplitNew} (void)
\item 
void \hyperlink{group__split_gae569ef1bc4cd8e931b4a7840d8ce48e6}{elektraSplitDel} (\hyperlink{struct__Split}{Split} $\ast$keysets)
\item 
void \hyperlink{group__split_ga9816931521a6a16bd553c08abb957c62}{elektraSplitResize} (\hyperlink{struct__Split}{Split} $\ast$split)
\item 
ssize\_\-t \hyperlink{group__split_ga0c8c5c6c26aa42404d8aa06e6476a0f6}{elektraSplitAppend} (\hyperlink{struct__Split}{Split} $\ast$split, \hyperlink{struct__Backend}{Backend} $\ast$backend, \hyperlink{struct__Key}{Key} $\ast$parentKey, int syncbits)
\item 
ssize\_\-t \hyperlink{group__split_ga887dd183bf21c635c6993cd480ff3b21}{elektraSplitSearchBackend} (\hyperlink{struct__Split}{Split} $\ast$split, \hyperlink{struct__Backend}{Backend} $\ast$backend, \hyperlink{struct__Key}{Key} $\ast$parent)
\item 
int \hyperlink{group__split_gafb25e1f946f07e5490a962a42320a0cc}{elektraSplitSearchRoot} (\hyperlink{struct__Split}{Split} $\ast$split, \hyperlink{struct__Key}{Key} $\ast$parentKey)
\item 
int \hyperlink{group__split_gaabebbc4b0e47527f59942fcf95b9fcb5}{elektraSplitBuildup} (\hyperlink{struct__Split}{Split} $\ast$split, \hyperlink{struct__KDB}{KDB} $\ast$kdb, \hyperlink{struct__Key}{Key} $\ast$parentKey)
\item 
int \hyperlink{group__split_ga447e430a045cef7b107762171fbdc104}{elektraSplitDivide} (\hyperlink{struct__Split}{Split} $\ast$split, \hyperlink{struct__KDB}{KDB} $\ast$handle, \hyperlink{struct__KeySet}{KeySet} $\ast$ks)
\item 
int \hyperlink{group__split_gafee68d5935a6875ece69945e32242895}{elektraSplitAppoint} (\hyperlink{struct__Split}{Split} $\ast$split, \hyperlink{struct__KDB}{KDB} $\ast$handle, \hyperlink{struct__KeySet}{KeySet} $\ast$ks)
\item 
int \hyperlink{group__split_ga311af3d964c45fc273dc1db5b5944895}{elektraSplitGet} (\hyperlink{struct__Split}{Split} $\ast$split, \hyperlink{struct__KDB}{KDB} $\ast$handle)
\item 
int \hyperlink{group__split_gaf3b1e5f1810964dddc3bd3a00822bca6}{elektraSplitMerge} (\hyperlink{struct__Split}{Split} $\ast$split, \hyperlink{struct__KeySet}{KeySet} $\ast$dest)
\item 
int \hyperlink{group__split_ga3176eff9c1b5a9bfcf3d2e648f537993}{elektraSplitSync} (\hyperlink{struct__Split}{Split} $\ast$split)
\item 
int \hyperlink{group__split_ga24cf74dcf95614923099bbccab3dd2c8}{elektraSplitPrepare} (\hyperlink{struct__Split}{Split} $\ast$split)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
used internally for \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdbSet()} Splits up a keyset into multiple keysets where each of them will passed to the correct \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdbSet()}. 

\subsection{Function Documentation}
\hypertarget{group__split_ga0c8c5c6c26aa42404d8aa06e6476a0f6}{
\index{split@{split}!elektraSplitAppend@{elektraSplitAppend}}
\index{elektraSplitAppend@{elektraSplitAppend}!split@{split}}
\subsubsection[{elektraSplitAppend}]{\setlength{\rightskip}{0pt plus 5cm}ssize\_\-t elektraSplitAppend (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split, }
\item[{{\bf Backend} $\ast$}]{ backend, }
\item[{{\bf Key} $\ast$}]{ parentKey, }
\item[{int}]{ syncbits}
\end{DoxyParamCaption}
)}}
\label{group__split_ga0c8c5c6c26aa42404d8aa06e6476a0f6}
Increases the size of split and appends a new empty keyset.

Initializes the element with the given parameters at size-\/1 to be used.

Will automatically resize split if needed.


\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \item[{\em backend}]the backend which should be appended \item[{\em parentKey}]the parentKey which should be appended \item[{\em syncbits}]the initial syncstate which should be appended\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
\item[{\em -\/1}]if no split is found \end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
the size of split -\/ 1 
\end{DoxyReturn}
\hypertarget{group__split_gafee68d5935a6875ece69945e32242895}{
\index{split@{split}!elektraSplitAppoint@{elektraSplitAppoint}}
\index{elektraSplitAppoint@{elektraSplitAppoint}!split@{split}}
\subsubsection[{elektraSplitAppoint}]{\setlength{\rightskip}{0pt plus 5cm}int elektraSplitAppoint (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split, }
\item[{{\bf KDB} $\ast$}]{ handle, }
\item[{{\bf KeySet} $\ast$}]{ ks}
\end{DoxyParamCaption}
)}}
\label{group__split_gafee68d5935a6875ece69945e32242895}
Appoints all keys from ks to yet unsynced splits.

\begin{DoxyPrecond}{Precondition}
\hyperlink{group__split_gaabebbc4b0e47527f59942fcf95b9fcb5}{elektraSplitBuildup()} need to be executed before.
\end{DoxyPrecond}

\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \item[{\em handle}]to determine to which backend a key belongs \item[{\em ks}]the keyset to appoint to split\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on success 

-\/1 if no backend was found for a key 
\end{DoxyReturn}
\hypertarget{group__split_gaabebbc4b0e47527f59942fcf95b9fcb5}{
\index{split@{split}!elektraSplitBuildup@{elektraSplitBuildup}}
\index{elektraSplitBuildup@{elektraSplitBuildup}!split@{split}}
\subsubsection[{elektraSplitBuildup}]{\setlength{\rightskip}{0pt plus 5cm}int elektraSplitBuildup (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split, }
\item[{{\bf KDB} $\ast$}]{ kdb, }
\item[{{\bf Key} $\ast$}]{ parentKey}
\end{DoxyParamCaption}
)}}
\label{group__split_gaabebbc4b0e47527f59942fcf95b9fcb5}
Walks through the trie and adds all backends below parentKey.

Sets syncbits to 2 if it is a default or root backend (which needs splitting).

\begin{DoxyPrecond}{Precondition}
split needs to be empty, directly after creation with \hyperlink{group__split_gad2245a38809f28e325cd9b32089b4c68}{elektraSplitNew()}.

there needs to be a valid defaultBackend but its ok not to have a trie inside KDB.

parentKey must be a valid key! (could be implemented more generally, but that would require splitting up of keysets of the same backend)
\end{DoxyPrecond}

\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \item[{\em kdb}]the handle to get information about backends \item[{\em parentKey}]the information below which key the backends are from interest\end{DoxyParams}
\begin{DoxyReturn}{Returns}
always 1 
\end{DoxyReturn}
\hypertarget{group__split_gae569ef1bc4cd8e931b4a7840d8ce48e6}{
\index{split@{split}!elektraSplitDel@{elektraSplitDel}}
\index{elektraSplitDel@{elektraSplitDel}!split@{split}}
\subsubsection[{elektraSplitDel}]{\setlength{\rightskip}{0pt plus 5cm}void elektraSplitDel (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ keysets}
\end{DoxyParamCaption}
)}}
\label{group__split_gae569ef1bc4cd8e931b4a7840d8ce48e6}
Delete a split object.

Will free all allocated resources of a splitted keyset.


\begin{DoxyParams}{Parameters}
\item[{\em keysets}]the split object to work with \end{DoxyParams}
\hypertarget{group__split_ga447e430a045cef7b107762171fbdc104}{
\index{split@{split}!elektraSplitDivide@{elektraSplitDivide}}
\index{elektraSplitDivide@{elektraSplitDivide}!split@{split}}
\subsubsection[{elektraSplitDivide}]{\setlength{\rightskip}{0pt plus 5cm}int elektraSplitDivide (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split, }
\item[{{\bf KDB} $\ast$}]{ handle, }
\item[{{\bf KeySet} $\ast$}]{ ks}
\end{DoxyParamCaption}
)}}
\label{group__split_ga447e430a045cef7b107762171fbdc104}
Splits up the keysets and search for a sync bit.

It does not check if there were removed keys, see elektraSplitRemove() for the next step.

It does not create new backends, this has to be done by buildup before.

\begin{DoxyPrecond}{Precondition}
\hyperlink{group__split_gaabebbc4b0e47527f59942fcf95b9fcb5}{elektraSplitBuildup()} need to be executed before.
\end{DoxyPrecond}

\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \item[{\em handle}]to get information where the individual keys belong \item[{\em ks}]the keyset to divide\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if there were no sync bits 

1 if there were sync bits 

-\/1 if no backend was found for a key 
\end{DoxyReturn}
\hypertarget{group__split_ga311af3d964c45fc273dc1db5b5944895}{
\index{split@{split}!elektraSplitGet@{elektraSplitGet}}
\index{elektraSplitGet@{elektraSplitGet}!split@{split}}
\subsubsection[{elektraSplitGet}]{\setlength{\rightskip}{0pt plus 5cm}int elektraSplitGet (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split, }
\item[{{\bf KDB} $\ast$}]{ handle}
\end{DoxyParamCaption}
)}}
\label{group__split_ga311af3d964c45fc273dc1db5b5944895}
Does some work after getting of backends is finished.

\begin{DoxyPrecond}{Precondition}
\hyperlink{group__split_gafee68d5935a6875ece69945e32242895}{elektraSplitAppoint()} needs to be executed before.
\end{DoxyPrecond}

\begin{DoxyItemize}
\item check if keys are in correct backend
\item remove syncbits
\item update usersize and systemsize
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \item[{\em handle}]the handle to preprocess the keys \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on success 

-\/1 if no backend was found for a key 
\end{DoxyReturn}
\hypertarget{group__split_gaf3b1e5f1810964dddc3bd3a00822bca6}{
\index{split@{split}!elektraSplitMerge@{elektraSplitMerge}}
\index{elektraSplitMerge@{elektraSplitMerge}!split@{split}}
\subsubsection[{elektraSplitMerge}]{\setlength{\rightskip}{0pt plus 5cm}int elektraSplitMerge (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split, }
\item[{{\bf KeySet} $\ast$}]{ dest}
\end{DoxyParamCaption}
)}}
\label{group__split_gaf3b1e5f1810964dddc3bd3a00822bca6}
Merges together all parts of split into dest.


\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \item[{\em dest}]the destination keyset where all keysets are appended. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 on success 
\end{DoxyReturn}
\hypertarget{group__split_gad2245a38809f28e325cd9b32089b4c68}{
\index{split@{split}!elektraSplitNew@{elektraSplitNew}}
\index{elektraSplitNew@{elektraSplitNew}!split@{split}}
\subsubsection[{elektraSplitNew}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Split}$\ast$ elektraSplitNew (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}}
\label{group__split_gad2245a38809f28e325cd9b32089b4c68}
Allocates a new split object.

Initially the size is APPROXIMATE\_\-NR\_\-OF\_\-BACKENDS.

\begin{DoxyReturn}{Returns}
a fresh allocated split object
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__split_gae569ef1bc4cd8e931b4a7840d8ce48e6}{elektraSplitDel()} 
\end{DoxySeeAlso}
\hypertarget{group__split_ga24cf74dcf95614923099bbccab3dd2c8}{
\index{split@{split}!elektraSplitPrepare@{elektraSplitPrepare}}
\index{elektraSplitPrepare@{elektraSplitPrepare}!split@{split}}
\subsubsection[{elektraSplitPrepare}]{\setlength{\rightskip}{0pt plus 5cm}int elektraSplitPrepare (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split}
\end{DoxyParamCaption}
)}}
\label{group__split_ga24cf74dcf95614923099bbccab3dd2c8}
Prepares for \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdbSet()} mainloop afterwards.

All splits which do not need sync are removed and a deep copy of the remaining keysets is done.


\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
\item[{\em 0}]on success \end{DoxyRetVals}
\hypertarget{group__split_ga9816931521a6a16bd553c08abb957c62}{
\index{split@{split}!elektraSplitResize@{elektraSplitResize}}
\index{elektraSplitResize@{elektraSplitResize}!split@{split}}
\subsubsection[{elektraSplitResize}]{\setlength{\rightskip}{0pt plus 5cm}void elektraSplitResize (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split}
\end{DoxyParamCaption}
)}}
\label{group__split_ga9816931521a6a16bd553c08abb957c62}
Doubles the size of how many parts of keysets can be appended.


\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \end{DoxyParams}
\hypertarget{group__split_ga887dd183bf21c635c6993cd480ff3b21}{
\index{split@{split}!elektraSplitSearchBackend@{elektraSplitSearchBackend}}
\index{elektraSplitSearchBackend@{elektraSplitSearchBackend}!split@{split}}
\subsubsection[{elektraSplitSearchBackend}]{\setlength{\rightskip}{0pt plus 5cm}ssize\_\-t elektraSplitSearchBackend (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split, }
\item[{{\bf Backend} $\ast$}]{ backend, }
\item[{{\bf Key} $\ast$}]{ parent}
\end{DoxyParamCaption}
)}}
\label{group__split_ga887dd183bf21c635c6993cd480ff3b21}
Determines if the backend is already inserted or not.

\begin{DoxyWarning}{Warning}
If no parent Key is given, the default/root backends won't be searched.
\end{DoxyWarning}

\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \item[{\em backend}]the backend to search for \item[{\em parent}]the key to check for domains in default/root backends. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
pos of backend if it already exist 

-\/1 if it does not exist 
\end{DoxyReturn}
\hypertarget{group__split_gafb25e1f946f07e5490a962a42320a0cc}{
\index{split@{split}!elektraSplitSearchRoot@{elektraSplitSearchRoot}}
\index{elektraSplitSearchRoot@{elektraSplitSearchRoot}!split@{split}}
\subsubsection[{elektraSplitSearchRoot}]{\setlength{\rightskip}{0pt plus 5cm}int elektraSplitSearchRoot (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split, }
\item[{{\bf Key} $\ast$}]{ parentKey}
\end{DoxyParamCaption}
)}}
\label{group__split_gafb25e1f946f07e5490a962a42320a0cc}
\begin{DoxyReturn}{Returns}
1 if one of the backends in split has all keys below parentKey 

0 if parentKey == 0 or there are keys below or same than parentKey which do not fit in any of splitted keysets 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \item[{\em parentKey}]the key which relation is searched for \end{DoxyParams}
\hypertarget{group__split_ga3176eff9c1b5a9bfcf3d2e648f537993}{
\index{split@{split}!elektraSplitSync@{elektraSplitSync}}
\index{elektraSplitSync@{elektraSplitSync}!split@{split}}
\subsubsection[{elektraSplitSync}]{\setlength{\rightskip}{0pt plus 5cm}int elektraSplitSync (
\begin{DoxyParamCaption}
\item[{{\bf Split} $\ast$}]{ split}
\end{DoxyParamCaption}
)}}
\label{group__split_ga3176eff9c1b5a9bfcf3d2e648f537993}
Add sync bits everywhere keys were removed.

Only this function can really decide if sync is needed or not.

\begin{DoxyPrecond}{Precondition}
split needs to be processed with \hyperlink{group__split_ga447e430a045cef7b107762171fbdc104}{elektraSplitDivide()} before.
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
0 if \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdbSet()} is not needed 

1 if \hyperlink{group__kdb_ga11436b058408f83d303ca5e996832bcf}{kdbSet()} is needed 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
user/system was splitted before. 
\end{DoxyPrecond}

\begin{DoxyParams}{Parameters}
\item[{\em split}]the split object to work with \end{DoxyParams}
