<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Elektra: kdb::KeySet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacekdb.html">kdb</a></li><li class="navelem"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">kdb::KeySet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A keyset holds together a set of keys.  
 <a href="classkdb_1_1KeySet.html#details">More...</a></p>

<p><code>#include &lt;keyset.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4eac9850fa4f06c07a5306befc3e4377"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> ()</td></tr>
<tr class="memdesc:a4eac9850fa4f06c07a5306befc3e4377"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a4eac9850fa4f06c07a5306befc3e4377"></a><br/></td></tr>
<tr class="separator:a4eac9850fa4f06c07a5306befc3e4377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f651ff310178951402038e590743e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a21f651ff310178951402038e590743e0">KeySet</a> (ckdb::KeySet *k)</td></tr>
<tr class="separator:a21f651ff310178951402038e590743e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d6df839ab852fded1739ff3398d0b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ad8d6df839ab852fded1739ff3398d0b1">KeySet</a> (const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;other)</td></tr>
<tr class="separator:ad8d6df839ab852fded1739ff3398d0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9c4225de42a465621e7e9f6bd06d70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#abd9c4225de42a465621e7e9f6bd06d70">KeySet</a> (size_t alloc, va_list ap)</td></tr>
<tr class="memdesc:abd9c4225de42a465621e7e9f6bd06d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new keyset.  <a href="#abd9c4225de42a465621e7e9f6bd06d70"></a><br/></td></tr>
<tr class="separator:abd9c4225de42a465621e7e9f6bd06d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bb5ec4e73eca8ea1bd0a843a6489d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ab4bb5ec4e73eca8ea1bd0a843a6489d4">KeySet</a> (size_t alloc,...)</td></tr>
<tr class="memdesc:ab4bb5ec4e73eca8ea1bd0a843a6489d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new keyset.  <a href="#ab4bb5ec4e73eca8ea1bd0a843a6489d4"></a><br/></td></tr>
<tr class="separator:ab4bb5ec4e73eca8ea1bd0a843a6489d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade654f92bddec24abad1b651e828f2b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ade654f92bddec24abad1b651e828f2b8">~KeySet</a> ()</td></tr>
<tr class="memdesc:ade654f92bddec24abad1b651e828f2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstruct a keyset.  <a href="#ade654f92bddec24abad1b651e828f2b8"></a><br/></td></tr>
<tr class="separator:ade654f92bddec24abad1b651e828f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2987b3fb1b12196399650726f1c18f02"><td class="memItemLeft" align="right" valign="top">ckdb::KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02">release</a> ()</td></tr>
<tr class="separator:a2987b3fb1b12196399650726f1c18f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79bbbfb6e2f3e9c48cb3e595f9cda51"><td class="memItemLeft" align="right" valign="top">ckdb::KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#aa79bbbfb6e2f3e9c48cb3e595f9cda51">getKeySet</a> () const </td></tr>
<tr class="memdesc:aa79bbbfb6e2f3e9c48cb3e595f9cda51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes out the raw keyset pointer.  <a href="#aa79bbbfb6e2f3e9c48cb3e595f9cda51"></a><br/></td></tr>
<tr class="separator:aa79bbbfb6e2f3e9c48cb3e595f9cda51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ec4eebe304185527b08a6fa01b77c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a9f3ec4eebe304185527b08a6fa01b77c">setKeySet</a> (ckdb::KeySet *k)</td></tr>
<tr class="memdesc:a9f3ec4eebe304185527b08a6fa01b77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of passed keyset.  <a href="#a9f3ec4eebe304185527b08a6fa01b77c"></a><br/></td></tr>
<tr class="separator:a9f3ec4eebe304185527b08a6fa01b77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c54736b7206bc2253d02a5bf4b3ccfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a1c54736b7206bc2253d02a5bf4b3ccfb">operator=</a> (<a class="el" href="classkdb_1_1KeySet.html">KeySet</a> const &amp;other)</td></tr>
<tr class="separator:a1c54736b7206bc2253d02a5bf4b3ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b332fe23a7f793f80f9b22b5727584"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a18b332fe23a7f793f80f9b22b5727584">size</a> () const </td></tr>
<tr class="memdesc:a18b332fe23a7f793f80f9b22b5727584"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the keyset.  <a href="#a18b332fe23a7f793f80f9b22b5727584"></a><br/></td></tr>
<tr class="separator:a18b332fe23a7f793f80f9b22b5727584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d0b50194fb1900c468b53e749369a2"><td class="memItemLeft" align="right" valign="top">ckdb::KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a72d0b50194fb1900c468b53e749369a2">dup</a> () const </td></tr>
<tr class="memdesc:a72d0b50194fb1900c468b53e749369a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a keyset.  <a href="#a72d0b50194fb1900c468b53e749369a2"></a><br/></td></tr>
<tr class="separator:a72d0b50194fb1900c468b53e749369a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fd33fdaecf1d57d4dddac7058f5d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a28fd33fdaecf1d57d4dddac7058f5d38">copy</a> (const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;other)</td></tr>
<tr class="memdesc:a28fd33fdaecf1d57d4dddac7058f5d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a keyset.  <a href="#a28fd33fdaecf1d57d4dddac7058f5d38"></a><br/></td></tr>
<tr class="separator:a28fd33fdaecf1d57d4dddac7058f5d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f5159e39758aa632421d2fe7440633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a38f5159e39758aa632421d2fe7440633">clear</a> ()</td></tr>
<tr class="memdesc:a38f5159e39758aa632421d2fe7440633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the keyset.  <a href="#a38f5159e39758aa632421d2fe7440633"></a><br/></td></tr>
<tr class="separator:a38f5159e39758aa632421d2fe7440633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4b2f3aa9f58d10053561135b50233e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a0d4b2f3aa9f58d10053561135b50233e">append</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;toAppend)</td></tr>
<tr class="memdesc:a0d4b2f3aa9f58d10053561135b50233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a key  <a href="#a0d4b2f3aa9f58d10053561135b50233e"></a><br/></td></tr>
<tr class="separator:a0d4b2f3aa9f58d10053561135b50233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cbdc933d7171037d47c6d4d78595d1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ac9cbdc933d7171037d47c6d4d78595d1">append</a> (const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;toAppend)</td></tr>
<tr class="memdesc:ac9cbdc933d7171037d47c6d4d78595d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a keyset  <a href="#ac9cbdc933d7171037d47c6d4d78595d1"></a><br/></td></tr>
<tr class="separator:ac9cbdc933d7171037d47c6d4d78595d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b65a3aedad1e495351c770b29cd5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ad2b65a3aedad1e495351c770b29cd5c4">head</a> () const </td></tr>
<tr class="memdesc:ad2b65a3aedad1e495351c770b29cd5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#ad2b65a3aedad1e495351c770b29cd5c4"></a><br/></td></tr>
<tr class="separator:ad2b65a3aedad1e495351c770b29cd5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ccd44a29326a0d9a5c2e60d3089b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ac6ccd44a29326a0d9a5c2e60d3089b5e">tail</a> () const </td></tr>
<tr class="memdesc:ac6ccd44a29326a0d9a5c2e60d3089b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#ac6ccd44a29326a0d9a5c2e60d3089b5e"></a><br/></td></tr>
<tr class="separator:ac6ccd44a29326a0d9a5c2e60d3089b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4476a586a48a64160c71ed480c681b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a4476a586a48a64160c71ed480c681b19">rewind</a> () const </td></tr>
<tr class="memdesc:a4476a586a48a64160c71ed480c681b19"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a4476a586a48a64160c71ed480c681b19"></a><br/></td></tr>
<tr class="separator:a4476a586a48a64160c71ed480c681b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f115c65cf2720411bb76d5f4e10c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a03f115c65cf2720411bb76d5f4e10c25">next</a> () const </td></tr>
<tr class="memdesc:a03f115c65cf2720411bb76d5f4e10c25"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a03f115c65cf2720411bb76d5f4e10c25"></a><br/></td></tr>
<tr class="separator:a03f115c65cf2720411bb76d5f4e10c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9c26dbbf5ec0ed82093e1793a79fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a2c9c26dbbf5ec0ed82093e1793a79fe1">current</a> () const </td></tr>
<tr class="memdesc:a2c9c26dbbf5ec0ed82093e1793a79fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a2c9c26dbbf5ec0ed82093e1793a79fe1"></a><br/></td></tr>
<tr class="separator:a2c9c26dbbf5ec0ed82093e1793a79fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844be268914882e5159424e9ee302119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a844be268914882e5159424e9ee302119">setCursor</a> (cursor_t cursor) const </td></tr>
<tr class="memdesc:a844be268914882e5159424e9ee302119"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a844be268914882e5159424e9ee302119"></a><br/></td></tr>
<tr class="separator:a844be268914882e5159424e9ee302119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b63a96df7100e58cbb812e3d4223f2"><td class="memItemLeft" align="right" valign="top">cursor_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ab3b63a96df7100e58cbb812e3d4223f2">getCursor</a> () const </td></tr>
<tr class="memdesc:ab3b63a96df7100e58cbb812e3d4223f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#ab3b63a96df7100e58cbb812e3d4223f2"></a><br/></td></tr>
<tr class="separator:ab3b63a96df7100e58cbb812e3d4223f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f207457a1c12633a1a5301a3a1bbaed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a7f207457a1c12633a1a5301a3a1bbaed">pop</a> ()</td></tr>
<tr class="memdesc:a7f207457a1c12633a1a5301a3a1bbaed"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a7f207457a1c12633a1a5301a3a1bbaed"></a><br/></td></tr>
<tr class="separator:a7f207457a1c12633a1a5301a3a1bbaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab283da798a7670d5c3f0e1a5b821e666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ab283da798a7670d5c3f0e1a5b821e666">cut</a> (<a class="el" href="classkdb_1_1Key.html">Key</a> k)</td></tr>
<tr class="memdesc:ab283da798a7670d5c3f0e1a5b821e666"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#ab283da798a7670d5c3f0e1a5b821e666"></a><br/></td></tr>
<tr class="separator:ab283da798a7670d5c3f0e1a5b821e666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816e7468abe296f8352e090738c215cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a816e7468abe296f8352e090738c215cc">lookup</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k, const <a class="el" href="group__keyset.html#ga98a3d6a4016c9dad9cbd1a99a9c2a45a">option_t</a> options=<a class="el" href="group__keyset.html#gga98a3d6a4016c9dad9cbd1a99a9c2a45aa00738455e0ae843c8720809d8287f370">KDB_O_NONE</a>) const </td></tr>
<tr class="memdesc:a816e7468abe296f8352e090738c215cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a816e7468abe296f8352e090738c215cc"></a><br/></td></tr>
<tr class="separator:a816e7468abe296f8352e090738c215cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb4b6f5c46eb54c4f495832672e1e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a2bb4b6f5c46eb54c4f495832672e1e98">lookup</a> (std::string const &amp;name, const <a class="el" href="group__keyset.html#ga98a3d6a4016c9dad9cbd1a99a9c2a45a">option_t</a> options=<a class="el" href="group__keyset.html#gga98a3d6a4016c9dad9cbd1a99a9c2a45aa00738455e0ae843c8720809d8287f370">KDB_O_NONE</a>) const </td></tr>
<tr class="memdesc:a2bb4b6f5c46eb54c4f495832672e1e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a key by name.  <a href="#a2bb4b6f5c46eb54c4f495832672e1e98"></a><br/></td></tr>
<tr class="separator:a2bb4b6f5c46eb54c4f495832672e1e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4aa72767cf702066e804ef054fc7e5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ad4aa72767cf702066e804ef054fc7e5b">at</a> (cursor_t pos) const </td></tr>
<tr class="memdesc:ad4aa72767cf702066e804ef054fc7e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a key by index.  <a href="#ad4aa72767cf702066e804ef054fc7e5b"></a><br/></td></tr>
<tr class="separator:ad4aa72767cf702066e804ef054fc7e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A keyset holds together a set of keys. </p>
<p>Methods to manipulate KeySets.  A KeySet is a sorted set of keys. So the correct name actually would be KeyMap.With <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a> you can create a new KeySet.You can add keys with <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey()</a> in the keyset. Using <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend()</a> you can append a whole keyset.<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a> will be shared. </dd></dl>
<a class="el" href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">ksGetSize()</a> tells you the current size of the keyset.With <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> you can navigate through the keyset. Don't expect any particular order, but it is assured that you will get every key of the set.KeySets have an <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">internal cursor </a>. This is used for <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004">ksLookup()</a> and <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a>.KeySet has a fundamental meaning inside elektra. It makes it possible to get and store many keys at once inside the database. In addition to that the class can be used as high level datastructure in applications. With <a class="el" href="group__keyset.html#gad2e30fb6d4739d917c5abb2ac2f9c1a1">ksLookupByName()</a> it is possible to fetch easily specific keys out of the list of keys.You can easily create and iterate keys: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kdb.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// create a new keyset with 3 keys</span></div>
<div class="line"><span class="comment">// with a hint that about 20 keys will be inside</span></div>
<div class="line">KeySet *myConfig = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(20,</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/name1&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/name2&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/name3&quot;</span>, 0),</div>
<div class="line">        KS_END);</div>
<div class="line"><span class="comment">// append a key in the keyset</span></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(myConfig, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/name4&quot;</span>, 0));</div>
<div class="line"></div>
<div class="line">Key *current;</div>
<div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a>(myConfig);</div>
<div class="line"><span class="keywordflow">while</span> ((current=<a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a>(myConfig))!=0)</div>
<div class="line">{</div>
<div class="line">        printf(<span class="stringliteral">&quot;Key name is %s.\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (current));</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (myConfig); <span class="comment">// delete keyset and all keys appended</span></div>
</div><!-- fragment --> </p>
<dl class="section invariant"><dt>Invariant</dt><dd>always holds an underlying elektra keyset.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>that the cursor is mutable, so it might be changed even in const functions as described. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4eac9850fa4f06c07a5306befc3e4377"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Creates a new empty keyset with no keys</p>
<p>Allocate, initialize and return a new <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> object.Objects created with <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a>.You can use a various long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be KEY_END.So, terminate with ksNew(0, KS_END) or ksNew(20, ..., KS_END)For most uses </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> *keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, KS_END);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment --><p> goes ok, the alloc size will be 16, defined in kdbprivate.h. The alloc size will be doubled whenever size reaches alloc size, so it also performs out large keysets.But if you have any clue how large your keyset may be you should read the next statements.If you want a keyset with length 15 (because you know of your application that you normally need about 12 up to 15 keys), use: </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (15,</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key01&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value01&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key02&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value02&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key03&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value03&quot;</span>, 0),</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key15&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value15&quot;</span>, 0),</div>
<div class="line">        KS_END);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment -->If you start having 3 keys, and your application needs approximately 200-500 keys, you can use: </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> * config = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (500,</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key1&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value1&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key2&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value2&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key3&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value3&quot;</span>, 0),</div>
<div class="line">        KS_END); <span class="comment">// don&#39;t forget the KS_END at the end!</span></div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (config);</div>
</div><!-- fragment --><p> Alloc size is 500, the size of the keyset will be 3 after ksNew. This means the keyset will reallocate when appending more than 497 keys.The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a>.<dl class="section post"><dt>Postcondition</dt><dd>the keyset is rewinded properly</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a> to free the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets.">KeySet</a> afterwards </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c">ksDup()</a> to duplicate an existing <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets.">KeySet</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>gives a hint for the size how many Keys may be stored initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready to use <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> object </dd>
<dd>
0 on memory error </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a21f651ff310178951402038e590743e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramtype">ckdb::KeySet *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes ownership of keyset!</p>
<p>Keyset will be destroyed at destructor you cant continue to use keyset afterwards!</p>
<p>Use <a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02">KeySet::release()</a> to avoid destruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the keyset to take the ownership from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02">release()</a> </dd>
<dd>
<a class="el" href="classkdb_1_1KeySet.html#a9f3ec4eebe304185527b08a6fa01b77c" title="Take ownership of passed keyset.">setKeySet()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8d6df839ab852fded1739ff3398d0b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Duplicate a keyset.</p>
<p>This keyset will be a duplicate of the other afterwards.</p>
<dl class="section note"><dt>Note</dt><dd>that they still reference to the same Keys, so if you change key values also the keys in the original keyset will be changed.</dd></dl>
<p>So it is shallow copy, to create a deep copy you have to <a class="el" href="classkdb_1_1KeySet.html#a72d0b50194fb1900c468b53e749369a2" title="Duplicate a keyset.">dup()</a> every key (it still won't copy meta data, but they are COW): </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">kdb::KeySet</a> ksDeepCopy(<a class="code" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">kdb::KeySet</a> orig)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">kdb::KeySet</a> deepCopy;</div>
<div class="line">        orig.<a class="code" href="classkdb_1_1KeySet.html#a4476a586a48a64160c71ed480c681b19">rewind</a>();</div>
<div class="line">        <span class="keywordflow">while</span>(orig.<a class="code" href="classkdb_1_1KeySet.html#a03f115c65cf2720411bb76d5f4e10c25">next</a>())</div>
<div class="line">        {</div>
<div class="line">                deepCopy.<a class="code" href="classkdb_1_1KeySet.html#a0d4b2f3aa9f58d10053561135b50233e" title="append a key">append</a>(orig.<a class="code" href="classkdb_1_1KeySet.html#a2c9c26dbbf5ec0ed82093e1793a79fe1">current</a>().<a class="code" href="classkdb_1_1Key.html#a43a1f28d7a0d40f0ded8473d480931ff">dup</a>());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> deepCopy;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a72d0b50194fb1900c468b53e749369a2" title="Duplicate a keyset.">dup</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd9c4225de42a465621e7e9f6bd06d70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new keyset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>minimum number of keys to allocate </td></tr>
    <tr><td class="paramname">ap</td><td>variable arguments list</td></tr>
  </table>
  </dd>
</dl>
<p>Allocate, initialize and return a new <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> object.Objects created with <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a>.You can use a various long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be KEY_END.So, terminate with ksNew(0, KS_END) or ksNew(20, ..., KS_END)For most uses </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> *keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, KS_END);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment --><p> goes ok, the alloc size will be 16, defined in kdbprivate.h. The alloc size will be doubled whenever size reaches alloc size, so it also performs out large keysets.But if you have any clue how large your keyset may be you should read the next statements.If you want a keyset with length 15 (because you know of your application that you normally need about 12 up to 15 keys), use: </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (15,</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key01&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value01&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key02&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value02&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key03&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value03&quot;</span>, 0),</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key15&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value15&quot;</span>, 0),</div>
<div class="line">        KS_END);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment -->If you start having 3 keys, and your application needs approximately 200-500 keys, you can use: </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> * config = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (500,</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key1&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value1&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key2&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value2&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key3&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value3&quot;</span>, 0),</div>
<div class="line">        KS_END); <span class="comment">// don&#39;t forget the KS_END at the end!</span></div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (config);</div>
</div><!-- fragment --><p> Alloc size is 500, the size of the keyset will be 3 after ksNew. This means the keyset will reallocate when appending more than 497 keys.The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a>.<dl class="section post"><dt>Postcondition</dt><dd>the keyset is rewinded properly</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a> to free the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets.">KeySet</a> afterwards </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c">ksDup()</a> to duplicate an existing <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets.">KeySet</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>gives a hint for the size how many Keys may be stored initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready to use <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> object </dd>
<dd>
0 on memory error </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>caller must call va_start and va_end </dd></dl>
<dl class="section user"><dt>va the list of arguments</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>the allocation size </td></tr>
    <tr><td class="paramname">va</td><td>the list of variable arguments </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ab4bb5ec4e73eca8ea1bd0a843a6489d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new keyset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>minimum number of keys to allocate </td></tr>
    <tr><td class="paramname">...</td><td>variable argument list</td></tr>
  </table>
  </dd>
</dl>
<p>Allocate, initialize and return a new <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> object.Objects created with <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a>.You can use a various long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be KEY_END.So, terminate with ksNew(0, KS_END) or ksNew(20, ..., KS_END)For most uses </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> *keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, KS_END);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment --><p> goes ok, the alloc size will be 16, defined in kdbprivate.h. The alloc size will be doubled whenever size reaches alloc size, so it also performs out large keysets.But if you have any clue how large your keyset may be you should read the next statements.If you want a keyset with length 15 (because you know of your application that you normally need about 12 up to 15 keys), use: </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (15,</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key01&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value01&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key02&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value02&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key03&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value03&quot;</span>, 0),</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key15&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value15&quot;</span>, 0),</div>
<div class="line">        KS_END);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment -->If you start having 3 keys, and your application needs approximately 200-500 keys, you can use: </p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> * config = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (500,</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key1&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value1&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key2&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value2&quot;</span>, 0),</div>
<div class="line">        <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/app/fixedConfiguration/key3&quot;</span>, KEY_SWITCH_VALUE, <span class="stringliteral">&quot;value3&quot;</span>, 0),</div>
<div class="line">        KS_END); <span class="comment">// don&#39;t forget the KS_END at the end!</span></div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (config);</div>
</div><!-- fragment --><p> Alloc size is 500, the size of the keyset will be 3 after ksNew. This means the keyset will reallocate when appending more than 497 keys.The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a>.<dl class="section post"><dt>Postcondition</dt><dd>the keyset is rewinded properly</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a> to free the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets.">KeySet</a> afterwards </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c">ksDup()</a> to duplicate an existing <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets.">KeySet</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>gives a hint for the size how many Keys may be stored initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready to use <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> object </dd>
<dd>
0 on memory error </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>caller must call va_start and va_end </dd></dl>
<dl class="section user"><dt>va the list of arguments</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>the allocation size </td></tr>
    <tr><td class="paramname">va</td><td>the list of variable arguments </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="ade654f92bddec24abad1b651e828f2b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::~KeySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deconstruct a keyset. </p>
<p>A destructor for <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> objects.Cleans all internal dynamic attributes, decrement all reference pointers to all keys and then <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel()</a> all contained Keys, and free()s the release the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> object memory (that was previously allocated by <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a>).<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when the keyset was freed </dd>
<dd>
-1 on null pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a> </dd></dl>
 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0d4b2f3aa9f58d10053561135b50233e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::KeySet::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>toAppend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append a key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toAppend</td><td>key to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of keys in the keyset</dd></dl>
<p>Appends a <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> to the end of <code>ks</code>.A pointer to the key will be stored, and not a private copy. So a future <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a> on <code>ks</code> may <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel()</a> the <code>toAppend</code> object, see <a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae">keyGetRef()</a>.The reference counter of the key will be incremented, and thus toAppend is not const.<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a> will be shared. </dd></dl>
If the keyname already existed, it will be replaced with the new key.The <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> internal cursor will be set to the new key.It is save to use ksAppendKey(ks, keyNew(..)).<dl class="section return"><dt>Returns</dt><dd>the size of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> after insertion </dd>
<dd>
-1 on NULL pointers </dd>
<dd>
-1 if insertion failed, the key will be deleted then. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td><a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> that will receive the key </td></tr>
    <tr><td class="paramname">toAppend</td><td><a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> that will be appended to ks or deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend()</a>, <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew()</a>, <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a> </dd>
<dd>
<a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1">keyIncRef()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ac9cbdc933d7171037d47c6d4d78595d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::KeySet::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>toAppend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append a keyset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toAppend</td><td>keyset to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of keys in the keyset</dd></dl>
<p>Append all <code>toAppend</code> contained keys to the end of the <code>ks</code>.<code>toAppend</code> <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> will be left unchanged.If a key is both in toAppend and ks, the <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> in ks will be overridden.<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a> will be shared. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Sorted <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> ks with all keys it had before and additionally the keys from toAppend </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> after transfer </dd>
<dd>
-1 on NULL pointers </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> that will receive the keys </td></tr>
    <tr><td class="paramname">toAppend</td><td>the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> that provides the keys that will be transferred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ad4aa72767cf702066e804ef054fc7e5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::at </td>
          <td>(</td>
          <td class="paramtype">cursor_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup a key by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>cursor position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found key </dd></dl>

</div>
</div>
<a class="anchor" id="a38f5159e39758aa632421d2fe7440633"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the keyset. </p>
<p>Keyset will have no keys afterwards. </p>

</div>
</div>
<a class="anchor" id="a28fd33fdaecf1d57d4dddac7058f5d38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a keyset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other keyset to copy</td></tr>
  </table>
  </dd>
</dl>
<p>This is only a shallow copy. For a deep copy you need to dup every key.</p>
<p>Copy a keyset.Most often you may want a duplicate of a keyset, see <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c">ksDup()</a> or append keys, see <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend()</a>. But in some situations you need to copy a keyset to a existing keyset, for that this function exists.You can also use it to clear a keyset when you pass a NULL pointer as <code>source</code>.Note that all keys in <code>dest</code> will be deleted. Afterwards the content of the source will be added to the destination and the <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> is set properly in <code>dest</code>.A flat copy is made, so the keys will not be duplicated, but there reference counter is updated, so both keysets need to be <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a>.<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a> will be shared. </dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f (<a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> *ks)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> *c = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (20, ..., KS_END);</div>
<div class="line">        <span class="comment">// c receives keys</span></div>
<div class="line">        <a class="code" href="group__keyset.html#gaba1f1dbea191f4d7e7eb3e4296ae7d5e">ksCopy</a> (ks, c); <span class="comment">// pass the keyset to the caller</span></div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (c);</div>
<div class="line">}       <span class="comment">// caller needs to ksDel (ks)</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>has to be an initialized source <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> or NULL </td></tr>
    <tr><td class="paramname">dest</td><td>has to be an initialized <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> where to write the keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 on success </dd>
<dd>
0 if dest was cleared successfully (source is NULL) </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a>, <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a>, <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c">ksDup()</a> </dd>
<dd>
<a class="el" href="group__key.html#ga6a12cbbe656a1ad9f41b8c681d7a2f92">keyCopy()</a> for copying keys </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a2c9c26dbbf5ec0ed82093e1793a79fe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return the current <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a>.The pointer is NULL if you reached the end or after <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a>.<dl class="section note"><dt>Note</dt><dd>You must not delete the key or change the key, use <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop()</a> if you want to delete it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> pointed by <code>ks's</code> cursor </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a>, <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ab283da798a7670d5c3f0e1a5b821e666"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a> kdb::KeySet::cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Cuts out a keyset at the cutpoint.Searches for the cutpoint inside the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> ks. If found it cuts out everything which is below (see <a class="el" href="group__keytest.html#ga03332b5d97c76a4fd2640aca4762b8df">keyIsBelow()</a>) this key. These keys will be missing in the keyset <code>ks</code>. Instead, they will be moved to the returned keyset. If <code>cutpoint</code> is not found an empty keyset is returned and <code>ks</code> is not changed.The cursor will stay at the same key as it was before. If the cursor was inside the region of cut (moved) keys, the cursor will be set to the key before the cutpoint.If you use <a class="el" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a">ksCut()</a> on a keyset you got from <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> and plan to make a <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a> later, make sure that you keep all keys that should not be removed permanently. You have to keep the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> that was returned and the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> <code>ks</code>.<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<p>You have the keyset <code>ks:</code> </p>
<ul>
<li><code>system/mountpoint/interest</code> </li>
<li><code>system/mountpoint/interest/folder</code> </li>
<li><code>system/mountpoint/interest/folder/key1</code> </li>
<li><code>system/mountpoint/interest/folder/key2</code> </li>
<li><code>system/mountpoint/other/key1</code> </li>
</ul>
When you use </p>
<div class="fragment"><div class="line">        Key *parentKey = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;system/mountpoint/interest&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line">        KDB *kdb = <a class="code" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca" title="Opens the session with the Key database.">kdbOpen</a>(parentKey);</div>
<div class="line">        <a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> *ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, KS_END);</div>
<div class="line">        <a class="code" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet</a>(kdb, ks, parentKey);</div>
<div class="line">        <a class="code" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> *returned = <a class="code" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a">ksCut</a>(ks, parentKey);</div>
<div class="line">        <a class="code" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet</a>(kdb, ks, parentKey); <span class="comment">// all keys below cutpoint are now removed</span></div>
<div class="line">        <a class="code" href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f">kdbClose</a>(kdb, parentKey);</div>
</div><!-- fragment --><p> Then in <code>returned</code> are:</p>
<ul>
<li><code>system/mountpoint/interest</code> </li>
<li><code>system/mountpoint/interest/folder</code> </li>
<li><code>system/mountpoint/interest/folder/key1</code> </li>
<li><code>system/mountpoint/interest/folder/key2</code> </li>
</ul>
And in <code>ks</code> are:</p>
<ul>
<li><code>system/mountpoint/other/key1</code> </li>
</ul>
So <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way.">kdbSet()</a> permanently removes all keys below <code>system/mountpoint/interest</code>.<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way.">kdbGet()</a> for explanation why you might get more keys than you requested.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a new allocated <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> which needs to deleted with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a>. The keyset consists of all keys (of the original keyset ks) below the cutpoint. If the key cutpoint exists, it will also be appended. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on null pointers, no key name or allocation problems </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset to cut. It will be modified by removing all keys below the cutpoint. The cutpoint itself will also be removed. </td></tr>
    <tr><td class="paramname">cutpoint</td><td>the point where to cut out the keyset </td></tr>
  </table>
  </dd>
</dl>
 </p>

</div>
</div>
<a class="anchor" id="a72d0b50194fb1900c468b53e749369a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::KeySet * kdb::KeySet::dup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate a keyset. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the keys</dd></dl>
<p>This is only a shallow copy. For a deep copy you need to dup every key.</p>
<p>Return a duplicate of a keyset.Objects created with <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c">ksDup()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a>.Memory will be allocated as needed for dynamic properties, so you need to <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a> the returned pointer.A flat copy is made, so the keys will not be duplicated, but there reference counter is updated, so both keysets need <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a>.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>has to be an initialized source <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a flat copy of source on success </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a>, <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel()</a> </dd>
<dd>
<a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3">keyDup()</a> for <a class="el" href="group__key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo .">Key</a> duplication </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="ab3b63a96df7100e58cbb812e3d4223f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cursor_t kdb::KeySet::getCursor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Get the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> internal cursor.Use it to get the cursor of the actual position.<dl class="section warning"><dt>Warning</dt><dd>Cursors are getting invalid when the key was <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop()</a>ed or <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004">ksLookup()</a> with KDB_O_POP was used.</dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="aa79bbbfb6e2f3e9c48cb3e595f9cda51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::KeySet * kdb::KeySet::getKeySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Passes out the raw keyset pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to internal ckdb <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02">release()</a> </dd>
<dd>
<a class="el" href="classkdb_1_1KeySet.html#a9f3ec4eebe304185527b08a6fa01b77c" title="Take ownership of passed keyset.">setKeySet()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2b65a3aedad1e495351c770b29cd5c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::head </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>alphabetical first key</dd></dl>
<p>Return the first key in the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a>.The KeySets cursor will not be effected.If <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a>==<a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5">ksHead()</a> you know you are on the first key.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> of a keyset </dd>
<dd>
0 on NULL pointer or empty keyset </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e">ksTail()</a> for the last <a class="el" href="group__key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo .">Key</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> for iterating over the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets.">KeySet</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a816e7468abe296f8352e090738c215cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__keyset.html#ga98a3d6a4016c9dad9cbd1a99a9c2a45a">option_t</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__keyset.html#gga98a3d6a4016c9dad9cbd1a99a9c2a45aa00738455e0ae843c8720809d8287f370">KDB_O_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Look for a <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> contained in <code>ks</code> that matches the name of the <code>key</code>.</p>
<dl class="section note"><dt>Note</dt><dd>That the internal key cursor will point to the found key </dd></dl>

</div>
</div>
<a class="anchor" id="a2bb4b6f5c46eb54c4f495832672e1e98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::lookup </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__keyset.html#ga98a3d6a4016c9dad9cbd1a99a9c2a45a">option_t</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__keyset.html#gga98a3d6a4016c9dad9cbd1a99a9c2a45aa00738455e0ae843c8720809d8287f370">KDB_O_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup a key by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name to look for </td></tr>
    <tr><td class="paramname">options</td><td>some options to pass</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found key </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a816e7468abe296f8352e090738c215cc">lookup</a> (const <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> &amp;<a class="el" href="group__key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo .">Key</a>, const <a class="el" href="group__keyset.html#ga98a3d6a4016c9dad9cbd1a99a9c2a45a">option_t</a> options)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>That the internal key cursor will point to the found key </dd></dl>

</div>
</div>
<a class="anchor" id="a03f115c65cf2720411bb76d5f4e10c25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Returns the next <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> in a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a>.KeySets have an internal cursor that can be reset with <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a>. Every time <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> is called the cursor is incremented and the new current <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> is returned.You'll get a NULL pointer if the key after the end of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> was reached. On subsequent calls of <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> it will still return the NULL pointer.The <code>ks</code> internal cursor will be changed, so it is not const.<dl class="section note"><dt>Note</dt><dd>You must not delete or change the key, use <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop()</a> if you want to delete it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new current <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> </dd>
<dd>
0 when the end is reached </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a1c54736b7206bc2253d02a5bf4b3ccfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp; kdb::KeySet::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Duplicate a keyset.</p>
<p>This keyset will be a duplicate of the other afterwards.</p>
<dl class="section note"><dt>Note</dt><dd>that they still reference to the same Keys, so if you change key values also the keys in the original keyset will be changed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f207457a1c12633a1a5301a3a1bbaed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Remove and return the last key of <code>ks</code>.The reference counter will be decremented by one.The KeySets cursor will not be effected if it did not point to the popped key.<dl class="section note"><dt>Note</dt><dd>You need to <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel()</a> the key afterwards, if you don't append it to another keyset. It has the same semantics like a key allocated with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew()</a> or <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3">keyDup()</a>.</dd></dl>
<div class="fragment"><div class="line">ks1=<a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, KS_END);</div>
<div class="line">ks2=<a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, KS_END);</div>
<div class="line"></div>
<div class="line">k1=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/name&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>); <span class="comment">// ref counter 0</span></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks1, k1); <span class="comment">// ref counter 1</span></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks2, k1); <span class="comment">// ref counter 2</span></div>
<div class="line"></div>
<div class="line">k1=<a class="code" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop</a> (ks1); <span class="comment">// ref counter 1</span></div>
<div class="line">k1=<a class="code" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop</a> (ks2); <span class="comment">// ref counter 0, like after keyNew()</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks1, k1); <span class="comment">// ref counter 1</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks1); <span class="comment">// key is deleted too</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks2);</div>
<div class="line"> *</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the last key of <code>ks</code> </dd>
<dd>
NULL if <code>ks</code> is empty or on NULL pointer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td><a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey()</a>, <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend()</a> </dd>
<dd>
commandList() for an example </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a2987b3fb1b12196399650726f1c18f02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::KeySet * kdb::KeySet::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If you don't want destruction of keyset at the end you can release the pointer. </p>

</div>
</div>
<a class="anchor" id="a4476a586a48a64160c71ed480c681b19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::rewind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Rewinds the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> internal cursor.Use it to set the cursor to the beginning of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a>. <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> will then always return NULL afterwards. So you want to <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> first.<div class="fragment"><div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (ks);</div>
<div class="line"><span class="keywordflow">while</span> ((key = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (ks))!=0) {}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a844be268914882e5159424e9ee302119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::setCursor </td>
          <td>(</td>
          <td class="paramtype">cursor_t&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Set the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a> internal cursor.Use it to set the cursor to a stored position. <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> will then be the position which you got with.<dl class="section warning"><dt>Warning</dt><dd>Cursors may get invalid when the key was <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop()</a>ed or <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004">ksLookup()</a> was used together with KDB_O_POP.</dd></dl>
<div class="fragment"><div class="line">cursor_t cursor;</div>
<div class="line">..</div>
<div class="line"><span class="comment">// key now in any position here</span></div>
<div class="line">cursor = <a class="code" href="group__keyset.html#gaffe507ab9281c322eb16c3e992075d29">ksGetCursor</a> (ks);</div>
<div class="line"><span class="keywordflow">while</span> ((key = <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (ks))!=0) {}</div>
<div class="line"><a class="code" href="group__keyset.html#gad94c9ffaa3e8034564c0712fd407c345">ksSetCursor</a> (ks, cursor); <span class="comment">// reset state</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent</a>(ks); <span class="comment">// in same position as before</span></div>
</div><!-- fragment -->An invalid cursor will set the keyset to its beginning like <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a>. When you set an invalid cursor <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> is 0 and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> == <a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5">ksHead()</a>.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>the cursor to use </td></tr>
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 when the keyset is <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a>ed </dd>
<dd>
1 otherwise </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a>, <a class="el" href="group__keyset.html#gaffe507ab9281c322eb16c3e992075d29">ksGetCursor()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a9f3ec4eebe304185527b08a6fa01b77c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::setKeySet </td>
          <td>(</td>
          <td class="paramtype">ckdb::KeySet *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take ownership of passed keyset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the keyset to take ownership from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02">release()</a> </dd>
<dd>
<a class="el" href="classkdb_1_1KeySet.html#aa79bbbfb6e2f3e9c48cb3e595f9cda51" title="Passes out the raw keyset pointer.">getKeySet()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a18b332fe23a7f793f80f9b22b5727584"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::KeySet::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the keyset. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of keys in the keyset </dd></dl>

</div>
</div>
<a class="anchor" id="ac6ccd44a29326a0d9a5c2e60d3089b5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::tail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>alphabetical last key</dd></dl>
<p>Return the last key in the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys.">KeySet</a>.The KeySets cursor will not be effected.If <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a>==<a class="el" href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e">ksTail()</a> you know you are on the last key. <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> will return a NULL pointer afterwards.<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last <a class="el" href="classkdb_1_1Key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo . ">Key</a> of a keyset </dd>
<dd>
0 on NULL pointer or empty keyset </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5">ksHead()</a> for the first <a class="el" href="group__key.html" title="A Key is the essential class that encapsulates key name , value  and metainfo .">Key</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> for iterating over the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets.">KeySet</a> </dd></dl>
 </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>keyset.hpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 2 2014 11:35:10 for Elektra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
