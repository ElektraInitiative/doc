<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Language Bindings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Language Bindings </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this section, we will explain the how to write a language binding for Elektra.</p>
<p>Writing bindings for the high-level API is described in a <a class="el" href="doc_tutorials_highlevel-bindings_md.html">different document</a>, since it is a bit less straightforward and needs additional considerations.</p>
<ol type="1">
<li>which parts of Elektra bindings make sense (application, plugin, tools, ...)</li>
<li>how to integrate bindings into CMake (if possible and useful)</li>
<li>which parts of the bindings can and should differ for every language. This includes:<ol type="a">
<li>iterators</li>
<li>conversion to native types (strings, int, ...)</li>
<li>operator overloading (if available)</li>
<li>other programming language integrations (streams, hash-codes, identity, ...)</li>
<li>returned errors from kdb functions (what this issue here is about)</li>
</ol>
</li>
</ol>
<p>To add the subdirectory containing our binding to the build, we have to modify <code>src/bindings/CMakeLists.txt</code>.</p>
<div class="fragment"><div class="line">check_binding_included (&quot;our_binding&quot; IS_INCLUDED)</div><div class="line">if (IS_INCLUDED)</div><div class="line">    add_subdirectory (our_binding_directory)</div><div class="line">endif ()</div></div><!-- fragment --><p>At first we want to make sure that the build tools and compilers we need for the binding are installed. We can use <code>find_program (BUILD_TOOL_EXECUTABLE build_tool)</code> to find our <code>build_tool</code> program. The result of the search will be stored in <code>BUILD_TOOL_EXECUTABLE</code>, so now we can use an if block to include the bindings in the build, if the program exists or exclude it, if it doesn't. To do that, we use <code>add_binding</code> which adds ours to the list of bindings that will be built. For more provided functions, <a href="/home/jenkins/workspace/libelektra-release/scripts/cmake/Modules/LibAddBinding.cmake">see here</a>.</p>
<p>If, for example, our bindings only support linking against a dynamic library we can express that, by using the <code>BUILD_*</code> variables in if blocks or by passing <code>ONLY_SHARED</code> to <code>add_binding</code>. You can read more in the <a class="el" href="doc_COMPILE_md.html">compile doc</a>.</p>
<div class="fragment"><div class="line">if (BUILD_TOOL_EXECUTABLE)</div><div class="line">    add_binding (our_binding ONLY_SHARED)</div><div class="line">else ()</div><div class="line">    exclude_binding (our_binding, &quot;build_tool not found&quot;)</div><div class="line">    return ()</div><div class="line">endif ()</div></div><!-- fragment --><p>Elektra uses out-of-source builds, so we have to copy all the needed files over to the build directory. The ${CMAKE_CURRENT_SOURCE_DIR} variable refers to the source directory, while ${CMAKE_CURRENT_BINARY_DIR} refers to the build directory. The copy is as simple as</p>
<div class="fragment"><div class="line"># Inside the previous if block</div><div class="line">file (COPY &quot;${CMAKE_CURRENT_SOURCE_DIR}/&quot; DESTINATION &quot;${CMAKE_CURRENT_BINARY_DIR}&quot;)</div></div><!-- fragment --><p>However for some files we may want to use some CMakes variables. Say we're writing a build script for our project and want to include the version number and the directory that <code>libelektra.so</code> resides in, so our build tool can find and link against it. We create our script named <code>build.script.in</code>. It looks like this</p>
<div class="fragment"><div class="line">version = &quot;@KDB_VERSION@&quot;</div><div class="line">link-search-path = &quot;@CMAKE_BINARY_DIR@/lib&quot;</div></div><!-- fragment --><p>Back in our CMake script, we tell CMake to replace the variables with their associated values.</p>
<div class="fragment"><div class="line">configure_file (&quot;${CMAKE_CURRENT_SOURCE_DIR}/build.script.in&quot; &quot;${CMAKE_CURRENT_BINARY_DIR}/build.script&quot; @ONLY)</div></div><!-- fragment --><p>Note how we leave off the <code>.in</code> ending on the target file.</p>
<p>Since we're building a foreign language project, it will most likely have its own build tool or compiler. So we have to tell CMake how to invoke it, in order to build the project. First we specify what file we expect to be generated by that command. In this example it's a <code>.lib</code> file that is generated in some target directory. We then call our build tool using the variable <code>BUILD_TOOL_EXECUTABLE</code> we created earlier with the <code>build</code> subcommand and the <code>--release</code> option. We can also specify one or multiple files that this command depends on, such that CMake can make sure they are built or generated before. Finally, we add a custom target that depends on the <code>.lib</code> file. To built this target, CMake will invoke our custom command and build the specified file.</p>
<div class="fragment"><div class="line">add_custom_command (OUTPUT &quot;${CMAKE_CURRENT_BINARY_DIR}/target/release/libelektra.lib&quot;</div><div class="line">            COMMAND ${BUILD_TOOL_EXECUTABLE} build --release</div><div class="line">            WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}</div><div class="line">            DEPENDS &quot;${CMAKE_CURRENT_BINARY_DIR}/build.script&quot; &quot;${CMAKE_CURRENT_BINARY_DIR}/other-dependency.file&quot;)</div><div class="line">add_custom_target (our_binding ALL DEPENDS &quot;${CMAKE_CURRENT_BINARY_DIR}/target/release/libelektra.lib&quot;)</div></div><!-- fragment --><p>We can then explicitly include the bindings using <code>cmake -DBINDINGS="our_binding" ..</code> in the build directory and follow the further steps for <a class="el" href="doc_COMPILE_md.html">compilation</a>.</p>
<p>To invoke our tests through CMake, we have to follow similar steps as in the build. We add a test by specifying a command that runs our tests. In our case, we're calling the same program for testing as in the building step.</p>
<div class="fragment"><div class="line">add_test (NAME test_our_binding COMMAND ${BUILD_TOOL_EXECUTABLE} test WORKING_DIRECTORY &quot;${CMAKE_CURRENT_BINARY_DIR}&quot;)</div></div><!-- fragment --><p>We may have to specify an additonal environment variable to tell the test command, where <code>libelektra.so</code> resides, so that the dynamic linker can find it.</p>
<div class="fragment"><div class="line">set_property (TEST test_our_binding PROPERTY ENVIRONMENT &quot;LD_LIBRARY_PATH=${CMAKE_BINARY_DIR}/lib&quot;)</div></div><!-- fragment --><p>Now our bindings can be tested through <code>ctest</code> alongside all other tests.</p>
<p>See the Java binding for examples.</p>
<p>Since v0.9.0, Elektra has a new error code system. You might want to take a look in the <a class="el" href="doc_decisions_error_codes_md.html">design decision</a> first to understand the concept of the error codes. These codes are hierarchically structured and are therefore perfectly suitable for inheritance if the language supports it.</p>
<p>Some error codes like the <code>Permanent Errors</code> are generalizations and used for developers who want to catch all specific types of errors (e.g., it does not matter if it is a Resource or Installation Error but the developer wants to check for both). Such errors should not be able to "instantiate" or emitted back to Elektra as we want to force developers to take a more specific category. In case of Java for example the <code>Permanent Error</code> is an abstract class. Which errors are instantiable or not can be seen in the <a class="el" href="doc_dev_error-categorization_md.html">error-categorization guideline</a> in the respective title saying either <code>abstract</code> or <code>concrete</code>. Here is an example of how Java has implemented it:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class </span>PermanentException <span class="keyword">extends</span> Exception {...}</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class </span>ResourceException <span class="keyword">extends</span> PermanentException {...}</div><div class="line">        <span class="keyword">public</span> <span class="keyword">class </span>MemoryAllocationException <span class="keyword">extends</span> ResourceException {...}</div><div class="line">    <span class="keyword">public</span> <span class="keyword">class </span>InstallationException <span class="keyword">extends</span> PermanentException {...}</div><div class="line">...</div></div><!-- fragment --><p>All error codes as well as the hierarchy itself is depicted in the <a class="el" href="doc_decisions_error_codes_md.html">design decision</a>.</p>
<p>If you have a language which does not support inheritance this way like GoLang, you can still use the error code itself since the hierarchy is integrated in it. For example you can check if the code starts with <code>C01...</code> to catch all <code>Permanent Errors</code>.</p>
<p>In Elektra every error has a predefined format. You can take a look at the <a class="el" href="doc_decisions_error_message_format_md.html">related design decision</a> to see how it looks like.</p>
<p>Every Exception/Error struct/etc. should have separate accessors to individual parts of the message. These include:</p>
<ol type="1">
<li>Module (getModule())</li>
<li>Error Code (getErrorCode())</li>
<li>Reason (getReason())</li>
<li>Configfile (getConfigFile())</li>
<li>Mountpoint (getMountpoint())</li>
<li>Debuginformation (text looks like "At: file:line") (getDebugInformation())</li>
</ol>
<p>In case of an error at least the following part has to be returned:</p>
<div class="fragment"><div class="line">Sorry, module getModule() issued error getErrorCode():</div><div class="line">getReason()</div></div><!-- fragment --><p>Please also keep the wording identical for consistency. Take a look how the Java Binding implemented it in the KDBException </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
