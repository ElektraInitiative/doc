<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Code-generator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Code-generator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This guide focuses on writing new templates for the code-generator. For using the code generator take a look at the man-page <a class="el" href="doc_help_kdb-gen_md.html">`kdb-gen(1)`</a>. For specifically using the code-generator for the high-level API you may want to follow <a class="el" href="doc_tutorials_highlevel_md.html">this guide</a>.</p>
<p>The underlying framework of <code>kdb gen</code> is quite flexible. It is based on the <a href="https://mustache.github.io/">mustache templating system</a>. Concretely we use <a href="https://github.com/kainjow/Mustache">this C++ library</a> as a basis.</p>
<p>To distinguish the user facing parts of <code>kdb gen</code> from the internal layer interfacing <code>kdb gen</code> to the mustache library, we will call the internal layer the <em>framework</em>.</p>
<p>The file <a href="/home/jenkins/workspace/libelektra-release/src/tools/kdb/gen.cpp"><code>src/tools/kdb/gen.cpp</code></a> implements the command-line interface (CLI) and is of little interest to this guide. Instead we will focus on the framework that is invoked via the CLI. The bulk of the framework is implemented in the classes <a href="/home/jenkins/workspace/libelektra-release/src/tools/kdb/gen/template.hpp"><code>GenTemplate</code> and <code>GenTemplateList</code></a> (and of course kainjow's mustache library).</p>
<p>First we need to define a few terms:</p>
<ul>
<li><em>template name</em>: This is the main identifier of a template. It is used in the command line to choose the template.</li>
<li><em>template base name</em>: Unlike the template name, this identifier is internal to the framework. It will not be seen by users of <code>kdb gen</code>. This is the base name of all mustache files belonging to the template. In most cases this will be the same as the template name.</li>
<li><em>input keyset</em>: This keyset contains the data with which the template will be instantiated by the code-generator.</li>
<li><em>parent key</em>: The parent key is given in the command line and defines the input keyset (the keys below the parent key).</li>
<li><em>output name</em>: The base name for the output files as given in the command line. Suffixes may be appended, if there are multiple output files.</li>
<li><em>parts</em>: Each template may consist of multiple parts. Each part corresponds to exactly one mustache file and therefore exactly one output file.</li>
<li><em>part suffix</em>: Parts are identified by there part suffix. This suffix is appended to the template base name to obtain the name of the mustache file corresponding to the part. Similarly it is appended to the output name to obtain the output file for this part. The empty string <code>""</code> is a valid part suffix, although it is only recommend for templates with a single output file.</li>
</ul>
<p>All templates consist of two pieces. The set of mustache files (on for each part) and an accompanying C++ class to supply the mustache rendering engine with data from the input keyset.</p>
<p>In this guide we will create a basic template, that generates a single file containing a simple list of all keys in our input keyset. An example output from running <code>kdb gen</code> with our to-be-developed template would be:</p>
<div class="fragment"><div class="line">user:/sw/myapp/#0/current</div><div class="line">user:/sw/myapp/#0/current/dir0</div><div class="line">user:/sw/myapp/#0/current/dir0/subdir0/key0</div><div class="line">user:/sw/myapp/#0/current/dir0/subdir0/key1</div><div class="line">user:/sw/myapp/#0/current/dir1</div></div><!-- fragment --><p>As you can see, the result matches that of redirecting the stdout of <code>kdb ls</code> into a file.</p>
<p>The first thing we need to create is a mustache template. You will need (at least) one template file for each output file. If you make use of partials (see <a href="#using-partials">below</a>), you of course have to write multiple files.</p>
<p>All template files must be located in the `src/tools/kdb/gen/templates` folder and must be named according to the scheme <code>&lt;template base name&gt;.&lt;part suffix&gt;.mustache</code>.</p>
<p>For our simple example we create the file <code>src/tools/kdb/gen/templates/example.txt.mustache</code> with the following content:</p>
<div class="fragment"><div class="line">{{# keys }}</div><div class="line">{{{ name }}}</div><div class="line">{{/ keys }}</div></div><!-- fragment --><p>Note: we will not go into detail on how mustache templates work, for more information see e.g. <a href="https://mustache.github.io/mustache.5.html">here</a>. All of features supported by the kainjow library should be supported by our framework as well.</p>
<p>Our CMake script will collect all <code>.mustache</code> files in <code>src/tools/kdb/gen/templates</code> into a header containing a <code>static const char *</code> field for each file and a <code>std::unordered_map</code> containing references to all the fields. The naming scheme is needed so that the other C++ code can access the files contents via the map. This approach was chosen to allow executing the code-generator without first running the install script.</p>
<p>When you create a new <code>.mustache</code> file (either for a new part or a new partial), you need to invoke <code>cmake</code> again, so that all the files are collected.</p>
<p>Since we need to some way of supplying data to our template, we have to create a subclass of <code>GenTemplate</code>.</p>
<p>First we create a new directory for our template class in <code>src/tools/kdb/gen</code>, for our template it should be <code>src/tools/kdb/gen/example</code>. In this directory we then create <code>example.cpp</code> and <code>example.hpp</code>. If your template class becomes sufficiently complex, it may make sense to split the code into multiple classes and into multiple files, for this reason we recommend creating a new directory for each template. The CMake script will also automatically recognize your files, if you put them directly into <code>src/tools/kdb/gen</code>, but using additional subdirectories (beyond the one matching your template name) like <code>src/tools/kdb/gen/example/src</code> would require modifying `src/tools/kdb/CMakeLists.txt`.</p>
<p>In <code>example.cpp</code> and <code>example.hpp</code> we create our subclass of <code>GenTemplate</code>. Therefore <code>example.hpp</code> should look like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ELEKTRA_EXAMPLE_HPP</span></div><div class="line"><span class="preprocessor">#define ELEKTRA_EXAMPLE_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;gen/template.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>ExampleGenTemplate : <span class="keyword">public</span> GenTemplate</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ExampleGenTemplate () : GenTemplate (<span class="stringliteral">&quot;example&quot;</span>, { <span class="stringliteral">&quot;.txt&quot;</span> }, {}, {})</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    kainjow::mustache::data getTemplateData (<span class="keyword">const</span> std::string &amp; outputName, <span class="keyword">const</span> std::string &amp; part, <span class="keyword">const</span> <a class="code" href="classkdb_1_1KeySet.html">kdb::KeySet</a> &amp; ks,</div><div class="line">                                             <span class="keyword">const</span> std::string &amp; parentKey) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // ELEKTRA_EXAMPLE_HPP</span></div></div><!-- fragment --><p>Apart from the line <code>ExampleGenTemplate () : GenTemplate ("example", { ".txt" }, {}, {})</code> everything should be more or less the same for all templates. Let's dissect this line:</p>
<ul>
<li><code>ExampleGenTemplate ()</code> we declare a zero argument constructor. All templates <em>must</em> have only a single zero argument constructor, otherwise the framework cannot instantiate them.</li>
<li><code>: GenTemplate (</code> the constructor must invoke the base-class constructor.</li>
<li><code>"example",</code> we decided to use <code>example</code> as the base name for our template files. This base name will be replaced by the <code>outputName</code> chosen by the user, when invoking the code-generator.</li>
<li><code>{ ".txt" },</code> this is the list of part suffixes for our template. We only have a single part (output file) with the suffix <code>.txt</code>.</li>
<li><code>{},</code> the first empty list would contain all the partials our template uses. We don't use any.</li>
<li><code>{},</code> the second empty list, is actually a map. It would contain all parameters and whether they are required or not. We don't have parameters.</li>
</ul>
<p>As you can see, the header is quite simple. The more important part is actually the source file. It contains the implementation of <code>getTemplateData</code>, the function that delivers all the template data to the framework.</p>
<p>For our example we will use this implementation:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;example.hpp&quot;</span></div><div class="line"></div><div class="line">kainjow::mustache::data ExampleGenTemplate::getTemplateData (<span class="keyword">const</span> std::string &amp; outputName, <span class="keyword">const</span> std::string &amp; part,</div><div class="line">                                                             <span class="keyword">const</span> <a class="code" href="classkdb_1_1KeySet.html">kdb::KeySet</a> &amp; ks, <span class="keyword">const</span> std::string &amp; parentKey)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <span class="keyword">using namespace </span>kdb;</div><div class="line">    <span class="keyword">using namespace </span>kainjow::mustache;</div><div class="line"></div><div class="line">    list keyList;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = ks.begin (); it != ks.end (); ++it)</div><div class="line">    {</div><div class="line">        <a class="code" href="classkdb_1_1Key.html">Key</a> key = *it;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> keyObject = object({ { <span class="stringliteral">&quot;name&quot;</span>, key.<a class="code" href="classkdb_1_1Key.html#a6c1812730e9cb714893c9f9b1e503303">getName</a>() } });</div><div class="line"></div><div class="line">        keyList.emplace_back(keyObject);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> data = object({ { <span class="stringliteral">&quot;keys&quot;</span>, keyList } });</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> data;</div><div class="line">}</div></div><!-- fragment --><p>The framework will invoke <code>getTemplateData</code> for each part of our template with the <code>outputName</code> and <code>parentKey</code> as given on the command line, as well as the current part suffix (<code>part</code>) and the input keyset <code>ks</code>. All keys of the input keyset are guaranteed to be below <code>parentKey</code>.</p>
<p>The code above simply iterates over the input KeySet and for each key creates an object <code>{ name: $keyName }</code>. All those objects are collected into a list, which is then stored under the key <code>keys</code> in the global object.</p>
<p>To make the framework aware of our class (and by extension our template), we have to then add it to <code>GenTemplateList</code>. This is simply done by adding a line to the implementation of <code>GenTemplateList::GenTemplateList ()</code> in <a href="/home/jenkins/workspace/libelektra-release/src/tools/kdb/gen/template.cpp"><code>template.cpp</code></a>.</p>
<p>For our example that is:</p>
<div class="fragment"><div class="line">addTemplate&lt;ExampleGenTemplate&gt; (<span class="stringliteral">&quot;example&quot;</span>);</div></div><!-- fragment --><p>We need to specify <code>"example"</code> again, because this string defines how our template shall be called, i.e. what we need to specify in the terminal to invoke it.</p>
<p>You also need to add the appropriate <code>#include</code> at the top of the file. In our case this is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;example/example.hpp&quot;</span></div></div><!-- fragment --><p>Now you should be able to use the new template by running (after compiling/installing Elektra again):</p>
<div class="fragment"><div class="line">kdb gen example user userkeys</div></div><!-- fragment --><p>This should produce the file <code>userkeys.txt</code>. The file should be the same, as if we had called <code>kdb ls user:/ &gt; userkeys.txt</code>.</p>
<p>Lastly, we will discuss a few more advanced concepts.</p>
<p>Switching the delimiters is fully supported and already in use in the high-level API template to allow for easier formatting.</p>
<p>Sometimes you want to incorporate user input beyond the contents of the input keyset into the code-generation. For example, if you generate a web page, you may need to now where it is going to be hosted, so that you can generate correct links. Another example would be letting the user choose the name of a generated function, when generating C code.</p>
<p>The first case would be required parameter. Without the domain name, we cannot generate the links. The second example meanwhile may be an optional parameter. We could just use a sensible default name for the function, since it doesn't matter much which function the user will call in their own code.</p>
<p>Our framework supports both required and optional parameters. To define the parameters of your template use the <code>parameters</code> argument of the <code>GenTemplate</code> constructor. This parameter is a map from strings to bools. The keys are the parameter names and the values define, whether the parameter is required (<code>true</code> means required).</p>
<p>Our two examples could use <code>{ { "domain_name", true } }</code> and <code>{ { "function_name", false } }</code> respectively.</p>
<p>To access the parameter value call one of the <code>getParameter</code> overloads. One takes a default value, the other takes a map of values and verifies that one of the given values has been chosen. For more information see the relevant code documentation. There is also <code>getBoolParameter</code> which a specialised version for boolean parameters. It accepts only <code>0</code> and <code>1</code> as values.</p>
<p>Calling <code>kdb gen</code> for the web page example (called <code>webpage</code> below) would then look like this:</p>
<div class="fragment"><div class="line">kdb gen webpage &lt;parentKey&gt; &lt;outputName&gt; domain_name=somedomain.xyz</div></div><!-- fragment --><p>Since <code>function_name</code> is optional in our other example (called <code>ccode</code> below), both of the following calls are valid:</p>
<div class="fragment"><div class="line">kdb gen ccode &lt;parentKey&gt; &lt;outputName&gt;</div><div class="line"></div><div class="line">kdb gen ccode &lt;parentKey&gt; &lt;outputName&gt; function_name=foo</div></div><!-- fragment --><p>The use of partials is bit more involved than in other mustache frameworks. All the partial files for template <code>X</code> must be placed in the folder <code>src/tools/kdb/gen/templates/X</code> and must use the file extension <code>.mustache</code>. Apart from the the filename can be chosen arbitrarily.</p>
<p>To use the partial named <code>Y</code> (i.e. the file <code>src/tools/kdb/gen/templates/X/Y.mustache</code>) you must use this mustache command:</p>
<div class="fragment"><div class="line">{{&gt; partial.enum.c }}</div></div><!-- fragment --><p>The prefix <code>partial.</code> is required by the framework, if you omit it, there will be an error.</p>
<p>By default mustache escapes values for use in HTML (unless <code>{{{ name }}}</code> or <code>{{&amp; name }}</code> is used). Since most of our templates are not HTML, the escape function can be customised. You simply have to override <code>GenTemplate::escapeFunction</code>. For an example see <code>HighlevelGenTemplate::escapeFunction</code> in <a href="/home/jenkins/workspace/libelektra-release/src/tools/kdb/gen/highlevel/highlevel.hpp"><code>src/tools/kdb/gen/highlevel/highlevel.hpp</code></a>, it is designed for C code instead of HTML.</p>
<p>For some templates it might be necessary to switch which parts are produced based on the given parameters. This can be done by overriding <code>getParts()</code> in your template class.</p>
<p>To achieve a dynamic parts list, simply pass <em>all possible</em> parts in the constructor invocation. Then in your override of <code>getParts()</code> you simply inspect the given parameters and remove any parts that should not be generated.</p>
<p>It may also be useful to generate some output files without a mustache template. You could of course just write a template that renders as its string input data, but that won't work for binary files.</p>
<p>The proper way to achieve non-mustache-based parts is to inspect the <code>part</code> value passed to <code>getTemplateData()</code>. When you detect a non-mustache-based part you write to the file named <code>outputName + part</code> and once you are done you return <code>kainjow::mustache::data(false)</code>. This tells the render function to not invoke mustache for this part and instead continue with the next part. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
