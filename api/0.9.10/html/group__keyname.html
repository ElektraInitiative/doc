<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Name Manipulation Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Name Manipulation Methods<div class="ingroups"><a class="el" href="group__key.html">Key</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Methods to do various operations on Key names.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Name Manipulation Methods:</div>
<div class="dyncontent">
<div class="center"><img src="group__keyname.png" border="0" usemap="#agroup____keyname" alt=""/></div>
<map name="agroup____keyname" id="agroup____keyname">
<area shape="rect" title="Methods to do various operations on Key names." alt="" coords="100,5,311,31"/>
<area shape="rect" href="group__key.html" title="Key is an essential class that encapsulates key name , value &#160;and metainfo ." alt="" coords="5,5,52,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8e805c726a60da921d3736cda7813513"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (const Key *key)</td></tr>
<tr class="memdesc:ga8e805c726a60da921d3736cda7813513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the abbreviated real internal <code>key</code> name.  <a href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">More...</a><br /></td></tr>
<tr class="separator:ga8e805c726a60da921d3736cda7813513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbcfa51ed8a387e47ead207affa2d2e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a> (const Key *key)</td></tr>
<tr class="memdesc:gabdbcfa51ed8a387e47ead207affa2d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes needed to store the Key's name (excluding owner).  <a href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">More...</a><br /></td></tr>
<tr class="separator:gabdbcfa51ed8a387e47ead207affa2d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe6af4c27b35d911a533f4ae4d698bb"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb">keyUnescapedName</a> (const Key *key)</td></tr>
<tr class="memdesc:ga6fe6af4c27b35d911a533f4ae4d698bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Key's name, separated by NULL bytes and without backslashes for escaping.  <a href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb">More...</a><br /></td></tr>
<tr class="separator:ga6fe6af4c27b35d911a533f4ae4d698bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7eff0c77678420199d0d2e8729152b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b">keyGetUnescapedNameSize</a> (const Key *key)</td></tr>
<tr class="memdesc:ga5e7eff0c77678420199d0d2e8729152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the Key's unescaped name including embedded and terminating NULL characters.  <a href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b">More...</a><br /></td></tr>
<tr class="separator:ga5e7eff0c77678420199d0d2e8729152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29a850168d9b31c9529e90cf9ab68be"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a> (const Key *key, char *returnedName, size_t maxSize)</td></tr>
<tr class="memdesc:gab29a850168d9b31c9529e90cf9ab68be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get abbreviated Key name (excluding owner).  <a href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">More...</a><br /></td></tr>
<tr class="separator:gab29a850168d9b31c9529e90cf9ab68be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a576c7919d5b03f28d3ed3afaa7cd1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga44a576c7919d5b03f28d3ed3afaa7cd1">keyGetUnescapedName</a> (const Key *key, char *returnedName, size_t maxSize)</td></tr>
<tr class="memdesc:ga44a576c7919d5b03f28d3ed3afaa7cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the unescaped name of a Key into <code>returnedName</code>.  <a href="group__keyname.html#ga44a576c7919d5b03f28d3ed3afaa7cd1">More...</a><br /></td></tr>
<tr class="separator:ga44a576c7919d5b03f28d3ed3afaa7cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7699091610e7f3f43d2949514a4b35d9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (Key *key, const char *newName)</td></tr>
<tr class="memdesc:ga7699091610e7f3f43d2949514a4b35d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new name to a Key.  <a href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">More...</a><br /></td></tr>
<tr class="separator:ga7699091610e7f3f43d2949514a4b35d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa70593a2c772c4b7bc33423b9b10a270"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270">keyAddName</a> (Key *key, const char *newName)</td></tr>
<tr class="memdesc:gaa70593a2c772c4b7bc33423b9b10a270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an already escaped name part to the Key's name.  <a href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270">More...</a><br /></td></tr>
<tr class="separator:gaa70593a2c772c4b7bc33423b9b10a270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22037aad3f76f4454de4e6400637b39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gae22037aad3f76f4454de4e6400637b39">keyReplacePrefix</a> (Key *key, const Key *oldPrefix, const Key *newPrefix)</td></tr>
<tr class="memdesc:gae22037aad3f76f4454de4e6400637b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a prefix of the key name of <code>key</code>.  <a href="group__keyname.html#gae22037aad3f76f4454de4e6400637b39">More...</a><br /></td></tr>
<tr class="separator:gae22037aad3f76f4454de4e6400637b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26bacb092ebca8f69f3fee72069733d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga26bacb092ebca8f69f3fee72069733d8">elektraKeyNameValidate</a> (const char *name, bool isComplete)</td></tr>
<tr class="memdesc:ga26bacb092ebca8f69f3fee72069733d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an escaped key name and validates it.  <a href="group__keyname.html#ga26bacb092ebca8f69f3fee72069733d8">More...</a><br /></td></tr>
<tr class="separator:ga26bacb092ebca8f69f3fee72069733d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ef3765a0ea0887c8ab72859ae2592e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga99ef3765a0ea0887c8ab72859ae2592e">elektraKeyNameCanonicalize</a> (const char *name, char **canonicalName, size_t *canonicalSizePtr, size_t offset, size_t *usizePtr)</td></tr>
<tr class="memdesc:ga99ef3765a0ea0887c8ab72859ae2592e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a valid (non-)canonical key name and produces its canonical form.  <a href="group__keyname.html#ga99ef3765a0ea0887c8ab72859ae2592e">More...</a><br /></td></tr>
<tr class="separator:ga99ef3765a0ea0887c8ab72859ae2592e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dd2a5169e900c6c8371c54c7944edb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga85dd2a5169e900c6c8371c54c7944edb">elektraKeyNameUnescape</a> (const char *canonicalName, char *unescapedName)</td></tr>
<tr class="memdesc:ga85dd2a5169e900c6c8371c54c7944edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a canonical key name and unescapes it.  <a href="group__keyname.html#ga85dd2a5169e900c6c8371c54c7944edb">More...</a><br /></td></tr>
<tr class="separator:ga85dd2a5169e900c6c8371c54c7944edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (const Key *key)</td></tr>
<tr class="memdesc:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the unescaped Key's name where the basename starts.  <a href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">More...</a><br /></td></tr>
<tr class="separator:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0b76c5d9e5367c7e72211e6c63d43a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">keyGetBaseNameSize</a> (const Key *key)</td></tr>
<tr class="memdesc:ga1a0b76c5d9e5367c7e72211e6c63d43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bytes needed to store basename of <code>key</code> (including NULL terminator).  <a href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">More...</a><br /></td></tr>
<tr class="separator:ga1a0b76c5d9e5367c7e72211e6c63d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0992d26bcfca767cb8e77053a483eb64"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName</a> (const Key *key, char *returned, size_t maxSize)</td></tr>
<tr class="memdesc:ga0992d26bcfca767cb8e77053a483eb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the Key's basename to <code>returned</code>.  <a href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">More...</a><br /></td></tr>
<tr class="separator:ga0992d26bcfca767cb8e77053a483eb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ac22f466de1a74ca72b05e8252980d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga35ac22f466de1a74ca72b05e8252980d">elektraKeyNameEscapePart</a> (const char *part, char **escapedPart)</td></tr>
<tr class="memdesc:ga35ac22f466de1a74ca72b05e8252980d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a single key name part and produces its escaped form.  <a href="group__keyname.html#ga35ac22f466de1a74ca72b05e8252980d">More...</a><br /></td></tr>
<tr class="separator:ga35ac22f466de1a74ca72b05e8252980d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa942091fc4bd5c2699e49ddc50829524"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (Key *key, const char *baseName)</td></tr>
<tr class="memdesc:gaa942091fc4bd5c2699e49ddc50829524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>baseName</code> to the name of <code>key</code>.  <a href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">More...</a><br /></td></tr>
<tr class="separator:gaa942091fc4bd5c2699e49ddc50829524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e804bd453f98c28b0ff51430d1df407"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (Key *key, const char *baseName)</td></tr>
<tr class="memdesc:ga6e804bd453f98c28b0ff51430d1df407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>baseName</code> as the new basename for <code>key</code>.  <a href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">More...</a><br /></td></tr>
<tr class="separator:ga6e804bd453f98c28b0ff51430d1df407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3ca03ed10f87eb59bdc02cf2a0de8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gafc3ca03ed10f87eb59bdc02cf2a0de8d">keyGetNamespace</a> (const Key *key)</td></tr>
<tr class="memdesc:gafc3ca03ed10f87eb59bdc02cf2a0de8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68" title="Elektra currently supported Key namespaces.">elektraNamespace</a> for a Key.  <a href="group__keyname.html#gafc3ca03ed10f87eb59bdc02cf2a0de8d">More...</a><br /></td></tr>
<tr class="separator:gafc3ca03ed10f87eb59bdc02cf2a0de8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c1c1307419e689c98e556e5c542073"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga98c1c1307419e689c98e556e5c542073">keySetNamespace</a> (Key *key, <a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a> ns)</td></tr>
<tr class="memdesc:ga98c1c1307419e689c98e556e5c542073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the namespace of a Key.  <a href="group__keyname.html#ga98c1c1307419e689c98e556e5c542073">More...</a><br /></td></tr>
<tr class="separator:ga98c1c1307419e689c98e556e5c542073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Methods to do various operations on Key names. </p>
<p>To use them: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kdb.h&gt;</span></div>
</div><!-- fragment --><p>These functions make it easier for C programmers to work with key names.</p>
<dl class="section user"><dt>Terminology of Key Names</dt><dd><ul>
<li>A <em>key name</em> (see <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> and <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a>) defines the place of a key within the key database. To be unique, it is always absolute and canonical.</li>
<li>Key names are composed out of many <em>key name parts</em> split by a separator. These <em>key name parts</em> do not contain an unescaped separator.</li>
<li>A <em>key base name</em> (see <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key.">keySetBaseName()</a> and <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName to the name of key.">keyAddBaseName()</a>) is the last part of the key name.</li>
<li>A <em>C-String</em> is a null terminated sequence of characters. So \0 (null-character) must not occur within a C-String.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Namespaces</dt><dd>A namespace denotes the place the key comes from:</dd></dl>
<ul>
<li><code>spec:/something</code> for specification of other keys.</li>
<li><code>proc:/something</code> for in-memory keys, e.g. commandline.</li>
<li><code>dir:/something</code> for dir keys in current working directory</li>
<li><code>system:/something</code> for system keys in /etc or /</li>
<li><code>user:/something</code> for user keys in home directory</li>
<li><code>user:username/something</code> for other users (deprecated: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> + <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> currently unsupported)</li>
<li><p class="startli"><code>/something</code> for cascading keys (actually refers to one of the above, see also <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a>)</p>
<dl class="section note"><dt>Note</dt><dd>The rules are currently not formally specified and are subject of change in the next major release. So, always prefer:<ul>
<li>To use <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> and <a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add an already escaped name part to the Key&#39;s name.">keyAddName()</a> to get the canonified version of the keyname</li>
<li>To use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key.">keySetBaseName()</a> and <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName to the name of key.">keyAddBaseName()</a> to get an escaped key name part.</li>
<li>Not to escape or canonify with your own algorithms!</li>
<li>To use <a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb" title="Returns a Key&#39;s name, separated by NULL bytes and without backslashes for escaping.">keyUnescapedName()</a> and <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the unescaped Key&#39;s name where the basename starts.">keyBaseName()</a> to have access to the key name without escape sequences (key name parts are null terminated)</li>
<li>Not to unescape the strings yourself!</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Syntax for Key Names</dt><dd>Key names and key name parts have following goals:<ul>
<li>The C-String passed to <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> and <a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add an already escaped name part to the Key&#39;s name.">keyAddName()</a> may be any C-String.</li>
<li>The <em>key name parts</em> (e.g. <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key.">keySetBaseName()</a>, <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the unescaped Key&#39;s name where the basename starts.">keyBaseName()</a>) may be any C-String. Escaping is needed to achieve both goals.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Semantics for Key Name Parts</dt><dd><ul>
<li>% denotes an empty key name part.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Canonicalization for Key Names</dt><dd><ul>
<li>/ (slash) is the separator between key name parts.</li>
<li>// is shortened to /</li>
<li>trailing / (slashes) are removed</li>
<li>. (dot) and .. (dot-dot) is removed in an canonical key name, with following rules:<ul>
<li>/./ is shortened to /</li>
<li>_/../ is shortened to _</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Conventions for key names</dt><dd><ul>
<li>Key name parts starting with # are array elements. Then only _ (underscore) followed by 0-9 is allowed. So we have the regular expression #[_]*[0-9]+ with the further limitation that the number of _ is defined by the number of digits-1.</li>
<li>Key name parts starting with _ are reserved for special purposes (if you use this within a plugin you still have to make sure _ is escaped properly)</li>
<li>Key name parts starting with @ are reserved for special purposes (if you use this within a plugin you still have to make sure @ is escaped properly)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Escaping rules</dt><dd><ul>
<li>\ (backslash) is the escape character for the situations as described here (and only these). The \ character must only be escaped, when one of the following rules apply.</li>
<li>Stray escape characters are only possible in the end of the string.</li>
<li>\/ allows one to escape / (any uneven number of \). Does not introduce a new part.</li>
<li>Any uneven number N of \ before / allows you to escape / with the N/2 of \ prefixed. Does not introduce a new part.</li>
<li>\\/ allows one to use \ as character before / and introduces a new part.</li>
<li>Any even number N of \ before / allows you to have N/2 of \ prefixed before a / which introduces a new part.</li>
<li>Use \. and \.. if you want your key name part to represent . and ..</li>
<li>\\. and \\.. allows us to use \ as character before . and .. (and so on)</li>
<li>Use \% if you want your key name part to start with % (and does not represent an empty name)</li>
<li>Using \\% allows one to use \ as character before % (and so on)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Semantics for Key Name Specifications</dt><dd><ul>
<li>_ denotes that the key name part is arbitrary (syntax as described above).</li>
<li># denotes that the key name part has array syntax.</li>
<li>names surrounded by % (e.g. %profile%) denotes a placeholder. </li>
</ul>
</dd></dl>
</li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga99ef3765a0ea0887c8ab72859ae2592e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99ef3765a0ea0887c8ab72859ae2592e">&#9670;&nbsp;</a></span>elektraKeyNameCanonicalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraKeyNameCanonicalize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>canonicalName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>canonicalSizePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>usizePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a valid (non-)canonical key name and produces its canonical form. </p>
<p>As a side-effect it can also calculate the size of the corresponding unescaped key name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key name that is processed </td></tr>
    <tr><td class="paramname">canonicalName</td><td>Output buffer for the canonical name </td></tr>
    <tr><td class="paramname">canonicalSizePtr</td><td>Pointer to size of <code>canonicalName</code> </td></tr>
    <tr><td class="paramname">offset</td><td>Offset into <code>canonicalName</code> </td></tr>
    <tr><td class="paramname">usizePtr</td><td>Output variable for the size of the unescaped name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>name</code> MUST be a valid (non-)canonical key name. If it is not, the result is undefined </dd>
<dd>
<code>canonicalName</code> MUST be a valid first argument for <a class="el" href="internal_8c.html#ab0432d6765c40a5408a204c43747f4d4" title="Reallocate Storage in a save way.">elektraRealloc()</a> when cast to void** </dd>
<dd>
<code>canonicalSizePtr</code> &gt;= <code>offset</code> </dd>
<dd>
<code>offset</code> MUST be 0 or <code>*canonicalName + offset</code> MUST point to the zero-termintor of a valid canonical key name that starts at <code>*canonicalName</code> </dd>
<dd>
if <code>offset</code> is 0 then <code>*usizePtr</code> MUST 0, otherwise <code>*usizePtr</code> MUST be the correct unescaped size of the existing canonical name in <code>*canonicalName</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga26bacb092ebca8f69f3fee72069733d8" title="Takes an escaped key name and validates it.">elektraKeyNameValidate</a> </dd></dl>

</div>
</div>
<a id="ga35ac22f466de1a74ca72b05e8252980d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35ac22f466de1a74ca72b05e8252980d">&#9670;&nbsp;</a></span>elektraKeyNameEscapePart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t elektraKeyNameEscapePart </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>escapedPart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a single key name part and produces its escaped form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part</td><td>A single key name part, i.e. contained '/' will be escaped, '\0' terminates part </td></tr>
    <tr><td class="paramname">escapedPart</td><td>Output buffer for the escaped form</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>escapedPart</code> MUST be a valid first argument for <a class="el" href="internal_8c.html#ab0432d6765c40a5408a204c43747f4d4" title="Reallocate Storage in a save way.">elektraRealloc()</a> when cast to <code>void**</code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the escaped form excluding the zero terminator </dd></dl>

</div>
</div>
<a id="ga85dd2a5169e900c6c8371c54c7944edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85dd2a5169e900c6c8371c54c7944edb">&#9670;&nbsp;</a></span>elektraKeyNameUnescape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraKeyNameUnescape </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>canonicalName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescapedName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a canonical key name and unescapes it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canonicalName</td><td>The canonical name to unescape </td></tr>
    <tr><td class="paramname">unescapedName</td><td>Output buffer for the unescaped name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>canonicalName</code> MUST be a canonical key name. If this is not the case, the result is undefined. </dd>
<dd>
<code>unescapedName</code> MUST be allocated to the correct size.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga99ef3765a0ea0887c8ab72859ae2592e" title="Takes a valid (non-)canonical key name and produces its canonical form.">elektraKeyNameCanonicalize</a> </dd></dl>

</div>
</div>
<a id="ga26bacb092ebca8f69f3fee72069733d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26bacb092ebca8f69f3fee72069733d8">&#9670;&nbsp;</a></span>elektraKeyNameValidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool elektraKeyNameValidate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isComplete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes an escaped key name and validates it. </p>
<p>Complete key names must inlcude a namespace or a leading slash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The escaped key name to check </td></tr>
    <tr><td class="paramname">isComplete</td><td>Whether or not <code>name</code> is supposed to be a complete key name</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">#true</td><td>If <code>name</code> is a valid key name. </td></tr>
    <tr><td class="paramname">#false</td><td>Otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa942091fc4bd5c2699e49ddc50829524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa942091fc4bd5c2699e49ddc50829524">&#9670;&nbsp;</a></span>keyAddBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyAddBaseName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <code>baseName</code> to the name of <code>key</code>. </p>
<p><code>baseName</code> will be escaped before adding it to the name of <code>key</code>. No other part of the Key's name will be affected.</p>
<p>Assumes that <code>key</code> is a directory and will append <code>baseName</code> to it. The function adds the path separator for concatenating.</p>
<p>If <code>key</code> has the name <code>"system:/dir1/dir2"</code> and this method is called with <code>baseName</code> <code>"mykey"</code>, the resulting key will have the name <code>"system:/dir1/dir2/mykey"</code>.</p>
<p>When <code>baseName</code> is 0, nothing will happen and the size of the name is returned.</p>
<p>The escaping rules apply as in <a class="el" href="group__keyname.html">above </a>.</p>
<p>A simple example is: </p><div class="fragment"><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/my/long&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;myname&quot;</span>);</div>
<div class="line">printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k)); <span class="comment">// will print user:/my/long/myname</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
<div class="ttc" id="agroup__key_html_ga3df95bbc2494e3e6703ece5639be5bb1"><div class="ttname"><a href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a></div><div class="ttdeci">int keyDel(Key *key)</div><div class="ttdoc">A destructor for Key objects.</div><div class="ttdef"><b>Definition:</b> key.c:482</div></div>
<div class="ttc" id="agroup__key_html_gad23c65b44bf48d773759e1f9a4d43b89"><div class="ttname"><a href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a></div><div class="ttdeci">Key * keyNew(const char *name,...)</div><div class="ttdoc">A practical way to fully create a Key object in one step.</div><div class="ttdef"><b>Definition:</b> key.c:138</div></div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a></div><div class="ttdeci">@ KEY_END</div><div class="ttdef"><b>Definition:</b> kdbenum.c:95</div></div>
<div class="ttc" id="agroup__keyname_html_ga8e805c726a60da921d3736cda7813513"><div class="ttname"><a href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a></div><div class="ttdeci">const char * keyName(const Key *key)</div><div class="ttdoc">Returns a pointer to the abbreviated real internal key name.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:256</div></div>
<div class="ttc" id="agroup__keyname_html_gaa942091fc4bd5c2699e49ddc50829524"><div class="ttname"><a href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a></div><div class="ttdeci">ssize_t keyAddBaseName(Key *key, const char *baseName)</div><div class="ttdoc">Adds baseName to the name of key.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:1594</div></div>
</div><!-- fragment --><p> E.g. if you add . it will be escaped: </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system:/valid&quot;</span>);</div>
<div class="line">        succeed_if (<a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;.&quot;</span>) &gt;= 0, <span class="stringliteral">&quot;could not add a base name&quot;</span>);</div>
<div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;system:/valid/\\.&quot;</span>);</div>
<div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;.&quot;</span>);</div>
<div class="ttc" id="agroup__keyname_html_ga7699091610e7f3f43d2949514a4b35d9"><div class="ttname"><a href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a></div><div class="ttdeci">ssize_t keySetName(Key *key, const char *newName)</div><div class="ttdoc">Set a new name to a Key.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:497</div></div>
<div class="ttc" id="agroup__keyname_html_gaaff35e7ca8af5560c47e662ceb9465f5"><div class="ttname"><a href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a></div><div class="ttdeci">const char * keyBaseName(const Key *key)</div><div class="ttdoc">Returns a pointer to the unescaped Key's name where the basename starts.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:1248</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key to add the basename to </td></tr>
    <tr><td class="paramname">baseName</td><td>the string to append to the Key's name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the Key's new name including the NULL terminator </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the Key has no name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if Key was inserted into KeySet before </td></tr>
    <tr><td class="paramname">-1</td><td>if the Key was read-only </td></tr>
    <tr><td class="paramname">-1</td><td>on memory allocation errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key.">keySetBaseName()</a> for setting the basename of a Key </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> for setting the name of a <a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo .">Key</a> </dd></dl>

</div>
</div>
<a id="gaa70593a2c772c4b7bc33423b9b10a270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa70593a2c772c4b7bc33423b9b10a270">&#9670;&nbsp;</a></span>keyAddName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyAddName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an already escaped name part to the Key's name. </p>
<p>The same way as in <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> this method finds the canonical pathname:</p><ul>
<li>it will ignore /./</li>
<li>it will remove a level when /../ is used</li>
<li>it will remove multiple slashes ////</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/x/r&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270">keyAddName</a> (k, <span class="stringliteral">&quot;../y/a//././z&quot;</span>);</div>
<div class="line">assert (!strcmp (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;user:/x/y/a/z&quot;</span>));</div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
<div class="ttc" id="agroup__keyname_html_gaa70593a2c772c4b7bc33423b9b10a270"><div class="ttname"><a href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270">keyAddName</a></div><div class="ttdeci">ssize_t keyAddName(Key *key, const char *newName)</div><div class="ttdoc">Add an already escaped name part to the Key's name.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:568</div></div>
</div><!-- fragment --><p> Unlike <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> it adds relative to the previous name and cannot change the namespace of a Key. For example: </p><div class="fragment"><div class="line">Key * n = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/away&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270">keyAddName</a> (n, <span class="stringliteral">&quot;../../../new/name&quot;</span>);</div>
<div class="line">assert (!strcmp (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (n), <span class="stringliteral">&quot;user:/new/name&quot;</span>));</div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (n);</div>
</div><!-- fragment --><p> The passed name needs to be valid according the <a class="el" href="group__keyname.html">key name rules </a>. It is not allowed to:</p><ul>
<li>be empty</li>
<li>end with unequal number of \</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><code>key</code> MUST be a valid #Key</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key where a name should be added </td></tr>
    <tr><td class="paramname">newName</td><td>the new name to add to the name of <code>key</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new size of the escaped name of <code>key</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if <code>key == NULL</code> or <code>newName == NULL</code> </td></tr>
    <tr><td class="paramname">-1</td><td><code>newName</code> is not a valid escaped name </td></tr>
    <tr><td class="paramname">-1</td><td><code>key</code> is read-only</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> for setting a Key's name </dd>
<dd>
<a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName to the name of key.">keyAddBaseName()</a> for adding a basename to a Key </dd></dl>

</div>
</div>
<a id="gaaff35e7ca8af5560c47e662ceb9465f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaff35e7ca8af5560c47e662ceb9465f5">&#9670;&nbsp;</a></span>keyBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyBaseName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the unescaped Key's name where the basename starts. </p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Copy the Key&#39;s basename to returned.">keyGetBaseName()</a> and you should use it if you are responsible enough to not mess up things. The name might change or even point to a wrong place after a <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a>. So make sure to copy the memory before the name changes.</p>
<p><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the unescaped Key&#39;s name where the basename starts.">keyBaseName()</a> returns "" when the Key has no basename. The reason is </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;user:/&quot;</span>);</div>
<div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> There is also support for really empty basenames: </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system:/valid&quot;</span>);</div>
<div class="line">        succeed_if (<a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;&quot;</span>) &gt;= 0, <span class="stringliteral">&quot;could not add a base name&quot;</span>);</div>
<div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;system:/valid/%&quot;</span>);</div>
<div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must never use the pointer returned by <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the unescaped Key&#39;s name where the basename starts.">keyBaseName()</a> method to change the name. You should use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key.">keySetBaseName()</a> instead.</dd>
<dd>
Do not assume that <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the unescaped Key&#39;s name where the basename starts.">keyBaseName()</a> points to the same region as <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a> does.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key to obtain the basename from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the Key's basename </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when the Key has no (base)name </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Copy the Key&#39;s basename to returned.">keyGetBaseName()</a> for getting a copy of the Key's basename </dd>
<dd>
<a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a" title="Calculates number of bytes needed to store basename of key (including NULL terminator).">keyGetBaseNameSize()</a> for getting the size of the Key's basename </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a> for getting a pointer to the Key's name </dd></dl>

</div>
</div>
<a id="ga0992d26bcfca767cb8e77053a483eb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0992d26bcfca767cb8e77053a483eb64">&#9670;&nbsp;</a></span>keyGetBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetBaseName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the Key's basename to <code>returned</code>. </p>
<p>The copy will include a NULL terminator which will be considered for the returned size. Nothing will be copied if <code>maxSize</code> is smaller than the size of the basename.</p>
<p>Some examples:</p><ul>
<li>basename of <code>system:/some/keyname</code> is <code>keyname</code> </li>
<li>basename of <code>"user:/tmp/some key"</code> is <code>"some key"</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key to extract basename from </td></tr>
    <tr><td class="paramname">returned</td><td>a pre-allocated buffer for storing the basename </td></tr>
    <tr><td class="paramname">maxSize</td><td>size of the buffer <code>returned</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes copied to <code>returned</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>when Key's name is empty </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>when maxSize is 0 or larger than SSIZE_MAX </td></tr>
    <tr><td class="paramname">-1</td><td>when maxSize is smaller than the size of the Key's basename</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the unescaped Key&#39;s name where the basename starts.">keyBaseName()</a> for getting a pointer to the Key's basename </dd>
<dd>
<a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a" title="Calculates number of bytes needed to store basename of key (including NULL terminator).">keyGetBaseNameSize()</a> for getting the size of a Key's basename </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated Key name (excluding owner).">keyGetName()</a> for getting a pointer / copy of the whole name </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> for setting a Key's name </dd></dl>

</div>
</div>
<a id="ga1a0b76c5d9e5367c7e72211e6c63d43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0b76c5d9e5367c7e72211e6c63d43a">&#9670;&nbsp;</a></span>keyGetBaseNameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetBaseNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates number of bytes needed to store basename of <code>key</code> (including NULL terminator). </p>
<p>Key names consisting of only root names (e.g. <code>"system:/"</code> or <code>"user:/"</code> or <code>"user:domain"</code> ) do not have basenames. In this case the function will return 1, because only a NULL terminator is needed for storage.</p>
<p>Basenames are denoted as:</p><ul>
<li><code>system:/some/thing/basename</code> -&gt; <code>basename</code> </li>
<li><code>user:domain/some/thing/base\/name</code> &gt; <code>base\/name</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key to get the size of the basename from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes of the Key's basename including NULL terminator </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the Key or the Key's basename is NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the unescaped Key&#39;s name where the basename starts.">keyBaseName()</a> for getting a pointer to a Key's basename </dd>
<dd>
<a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Copy the Key&#39;s basename to returned.">keyGetBaseName()</a> for getting a copy of a Key's basename </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated Key name (excluding owner).">keyGetName()</a> for getting a pointer / copy of the whole name </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> for setting a Key's name </dd></dl>

</div>
</div>
<a id="gab29a850168d9b31c9529e90cf9ab68be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab29a850168d9b31c9529e90cf9ab68be">&#9670;&nbsp;</a></span>keyGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get abbreviated Key name (excluding owner). </p>
<p>When there is not enough space to write the name, nothing will be written and -1 will be returned.</p>
<p><code>maxSize</code> is limited to SSIZE_MAX. When this value is exceeded, -1 will be returned. The reason for that is, that any value higher is just a negative return value passed by accident. <a class="el" href="internal_8c.html#a35cdc2e5caed3454cb73b4fc7f37858c" title="Allocate memory for Elektra.">elektraMalloc()</a> is not as failure tolerant and would try to allocate memory accordingly.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *getBack = <a class="code" href="internal_8c.html#a35cdc2e5caed3454cb73b4fc7f37858c">elektraMalloc</a> (<a class="code" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a>(key));</div>
<div class="line"><a class="code" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a>(key, getBack, <a class="code" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a>(key));</div>
<div class="ttc" id="agroup__keyname_html_gab29a850168d9b31c9529e90cf9ab68be"><div class="ttname"><a href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a></div><div class="ttdeci">ssize_t keyGetName(const Key *key, char *returnedName, size_t maxSize)</div><div class="ttdoc">Get abbreviated Key name (excluding owner).</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:381</div></div>
<div class="ttc" id="agroup__keyname_html_gabdbcfa51ed8a387e47ead207affa2d2e"><div class="ttname"><a href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a></div><div class="ttdeci">ssize_t keyGetNameSize(const Key *key)</div><div class="ttdoc">Bytes needed to store the Key's name (excluding owner).</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:282</div></div>
<div class="ttc" id="ainternal_8c_html_a35cdc2e5caed3454cb73b4fc7f37858c"><div class="ttname"><a href="internal_8c.html#a35cdc2e5caed3454cb73b4fc7f37858c">elektraMalloc</a></div><div class="ttdeci">void * elektraMalloc(size_t size)</div><div class="ttdoc">Allocate memory for Elektra.</div><div class="ttdef"><b>Definition:</b> internal.c:274</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key to get the name from </td></tr>
    <tr><td class="paramname">returnedName</td><td>pre-allocated buffer to write the Key's name </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that will fit in returnedName, including the NULL terminator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to <code>returnedName</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>when only NULL terminator was written </td></tr>
    <tr><td class="paramname">-1</td><td>when Key's name is longer than maxSize or maxSize is 0 or maxSize is greater than SSIZE_MAX </td></tr>
    <tr><td class="paramname">-1</td><td><code>key</code> or <code>returnedName</code> is NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the Key&#39;s name (excluding owner).">keyGetNameSize()</a> for getting the size of a Key's name </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a> for getting a pointer to a Key's name </dd>
<dd>
<a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Copy the Key&#39;s basename to returned.">keyGetBaseName()</a> for getting a Key's base name </dd>
<dd>
<a class="el" href="group__keyname.html#gafc3ca03ed10f87eb59bdc02cf2a0de8d" title="Returns the elektraNamespace for a Key.">keyGetNamespace()</a> for getting the namespace of a Key's name </dd></dl>

</div>
</div>
<a id="gabdbcfa51ed8a387e47ead207affa2d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdbcfa51ed8a387e47ead207affa2d2e">&#9670;&nbsp;</a></span>keyGetNameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bytes needed to store the Key's name (excluding owner). </p>
<p>For an empty Key name you need one byte to store the ending NULL. For that reason, 1 is returned when the name is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key to get the name size from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed, including NULL terminator, to store Key's name (excluding owner) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if Key has no name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated Key name (excluding owner).">keyGetName()</a> for getting the Key's name </dd>
<dd>
<a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b" title="Returns the size of the Key&#39;s unescaped name including embedded and terminating NULL characters.">keyGetUnescapedNameSize()</a> for getting the size of the unescaped name </dd></dl>

</div>
</div>
<a id="gafc3ca03ed10f87eb59bdc02cf2a0de8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc3ca03ed10f87eb59bdc02cf2a0de8d">&#9670;&nbsp;</a></span>keyGetNamespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a> keyGetNamespace </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68" title="Elektra currently supported Key namespaces.">elektraNamespace</a> for a Key. </p>
<p>To handle every namespace a Key could have, you can use the following snippet: </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span> (<a class="code" href="group__keyname.html#gafc3ca03ed10f87eb59bdc02cf2a0de8d">keyGetNamespace</a> (k))</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a2be047b124b1ca0e92b5ef124169f0d2">KEY_NS_SPEC</a>:</div>
<div class="line">        printf (<span class="stringliteral">&quot;spec namespace\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a470ecc9254fcdfccf9923a3e526c9c11">KEY_NS_PROC</a>:</div>
<div class="line">        printf (<span class="stringliteral">&quot;proc namespace\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68aa0006cf27dbb2586bafba6ff1ae4f4ec">KEY_NS_DIR</a>:</div>
<div class="line">        printf (<span class="stringliteral">&quot;dir namespace\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a8ce23c70010e8ac8bb540b0947e03a4e">KEY_NS_USER</a>:</div>
<div class="line">        printf (<span class="stringliteral">&quot;user namespace\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a61adca2f9dff47e65dfcdb492ffa7a20">KEY_NS_SYSTEM</a>:</div>
<div class="line">        printf (<span class="stringliteral">&quot;system namespace\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a3659698b0a07454ca8055ab693e8efd1">KEY_NS_NONE</a>:</div>
<div class="line">        printf (<span class="stringliteral">&quot;no key\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68ac5fbf2c3a7ae79fa2d60c48ae3e72688">KEY_NS_META</a>:</div>
<div class="line">        printf (<span class="stringliteral">&quot;metakey\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a2c9133e3095dccbcde5ca3bb13987b5d">KEY_NS_CASCADING</a>:</div>
<div class="line">        printf (<span class="stringliteral">&quot;cascading key\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__key_html_ggaec3b8d6f430ae49b91bafe8a86310a68a2be047b124b1ca0e92b5ef124169f0d2"><div class="ttname"><a href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a2be047b124b1ca0e92b5ef124169f0d2">KEY_NS_SPEC</a></div><div class="ttdeci">@ KEY_NS_SPEC</div><div class="ttdoc">spec contains the specification of the other namespaces</div><div class="ttdef"><b>Definition:</b> kdbenum.c:138</div></div>
<div class="ttc" id="agroup__key_html_ggaec3b8d6f430ae49b91bafe8a86310a68a2c9133e3095dccbcde5ca3bb13987b5d"><div class="ttname"><a href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a2c9133e3095dccbcde5ca3bb13987b5d">KEY_NS_CASCADING</a></div><div class="ttdeci">@ KEY_NS_CASCADING</div><div class="ttdoc">cascading key, starts with /, abstract name for any of the namespaces below</div><div class="ttdef"><b>Definition:</b> kdbenum.c:136</div></div>
<div class="ttc" id="agroup__key_html_ggaec3b8d6f430ae49b91bafe8a86310a68a3659698b0a07454ca8055ab693e8efd1"><div class="ttname"><a href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a3659698b0a07454ca8055ab693e8efd1">KEY_NS_NONE</a></div><div class="ttdeci">@ KEY_NS_NONE</div><div class="ttdoc">no key given as parameter to keyGetNamespace()</div><div class="ttdef"><b>Definition:</b> kdbenum.c:135</div></div>
<div class="ttc" id="agroup__key_html_ggaec3b8d6f430ae49b91bafe8a86310a68a470ecc9254fcdfccf9923a3e526c9c11"><div class="ttname"><a href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a470ecc9254fcdfccf9923a3e526c9c11">KEY_NS_PROC</a></div><div class="ttdeci">@ KEY_NS_PROC</div><div class="ttdoc">proc contains process-specific configuration</div><div class="ttdef"><b>Definition:</b> kdbenum.c:139</div></div>
<div class="ttc" id="agroup__key_html_ggaec3b8d6f430ae49b91bafe8a86310a68a61adca2f9dff47e65dfcdb492ffa7a20"><div class="ttname"><a href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a61adca2f9dff47e65dfcdb492ffa7a20">KEY_NS_SYSTEM</a></div><div class="ttdeci">@ KEY_NS_SYSTEM</div><div class="ttdoc">system key is shared for a computer system</div><div class="ttdef"><b>Definition:</b> kdbenum.c:142</div></div>
<div class="ttc" id="agroup__key_html_ggaec3b8d6f430ae49b91bafe8a86310a68a8ce23c70010e8ac8bb540b0947e03a4e"><div class="ttname"><a href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a8ce23c70010e8ac8bb540b0947e03a4e">KEY_NS_USER</a></div><div class="ttdeci">@ KEY_NS_USER</div><div class="ttdoc">user key in the home directory of the current user</div><div class="ttdef"><b>Definition:</b> kdbenum.c:141</div></div>
<div class="ttc" id="agroup__key_html_ggaec3b8d6f430ae49b91bafe8a86310a68aa0006cf27dbb2586bafba6ff1ae4f4ec"><div class="ttname"><a href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68aa0006cf27dbb2586bafba6ff1ae4f4ec">KEY_NS_DIR</a></div><div class="ttdeci">@ KEY_NS_DIR</div><div class="ttdoc">dir contains configuration from a specific directory</div><div class="ttdef"><b>Definition:</b> kdbenum.c:140</div></div>
<div class="ttc" id="agroup__key_html_ggaec3b8d6f430ae49b91bafe8a86310a68ac5fbf2c3a7ae79fa2d60c48ae3e72688"><div class="ttname"><a href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68ac5fbf2c3a7ae79fa2d60c48ae3e72688">KEY_NS_META</a></div><div class="ttdeci">@ KEY_NS_META</div><div class="ttdoc">metakey, i.e. any key name not under other categories</div><div class="ttdef"><b>Definition:</b> kdbenum.c:137</div></div>
<div class="ttc" id="agroup__keyname_html_gafc3ca03ed10f87eb59bdc02cf2a0de8d"><div class="ttname"><a href="group__keyname.html#gafc3ca03ed10f87eb59bdc02cf2a0de8d">keyGetNamespace</a></div><div class="ttdeci">elektraNamespace keyGetNamespace(const Key *key)</div><div class="ttdoc">Returns the elektraNamespace for a Key.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:1708</div></div>
</div><!-- fragment --><p> To loop over all valid namespaces use: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a> ns = KEY_NS_FIRST; ns &lt;= KEY_NS_LAST; ++ns)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// work with namespace</span></div>
<div class="line">        printf (<span class="stringliteral">&quot;%d\n&quot;</span>, ns);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__key_html_gaec3b8d6f430ae49b91bafe8a86310a68"><div class="ttname"><a href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a></div><div class="ttdeci">elektraNamespace</div><div class="ttdoc">Elektra currently supported Key namespaces.</div><div class="ttdef"><b>Definition:</b> kdbenum.c:134</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>This method might be extended. There is no guarantee that a Key with a specific namespace will retain that namespace after recompilation. Make sure that your compiler gives you a warning for unhandled switches (gcc: -Wswitch or -Wswitch-enum if you want to handle default) and look out for those warnings when recompiling.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key to get the namespace from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the namespace of the Key </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">KEY_NS_NONE</td><td>if Key is NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga98c1c1307419e689c98e556e5c542073" title="Changes the namespace of a Key.">keySetNamespace()</a> for setting a Key's namespace </dd></dl>

</div>
</div>
<a id="ga44a576c7919d5b03f28d3ed3afaa7cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44a576c7919d5b03f28d3ed3afaa7cd1">&#9670;&nbsp;</a></span>keyGetUnescapedName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetUnescapedName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the unescaped name of a Key into <code>returnedName</code>. </p>
<p>It will only copy the whole name. If the buffer is too small, an error code will be returned.</p>
<p>To ensure the buffer is big enough, you can use <a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b" title="Returns the size of the Key&#39;s unescaped name including embedded and terminating NULL characters.">keyGetUnescapedNameSize()</a> to get the correct size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key to extract the unescaped name from </td></tr>
    <tr><td class="paramname">returnedName</td><td>the buffer to write the unescaped name into </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that can be copied into <code>returnedName</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>key</code> MUST be a valid #Key and <code>key != NULL</code> </dd>
<dd>
<code>returnedName</code> MUST be allocated to be at least <code>maxSize</code> bytes big </dd>
<dd>
<code>returnedName</code> must not be NULL</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the actual size of the Key's unescaped name, i.e. the number of bytes copied into <code>returnedName</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>Precondition error </td></tr>
    <tr><td class="paramname">-2</td><td>the size of the unescaped name is greater than <code>maxSize</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b" title="Returns the size of the Key&#39;s unescaped name including embedded and terminating NULL characters.">keyGetUnescapedNameSize()</a> for getting the size of the unescaped name </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated Key name (excluding owner).">keyGetName()</a> for getting the Key's escaped name </dd></dl>

</div>
</div>
<a id="ga5e7eff0c77678420199d0d2e8729152b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7eff0c77678420199d0d2e8729152b">&#9670;&nbsp;</a></span>keyGetUnescapedNameSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetUnescapedNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the Key's unescaped name including embedded and terminating NULL characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key where to get the size of the unescaped name from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the Key's unescaped name </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
    <tr><td class="paramname">0</td><td>if Key has no name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb" title="Returns a Key&#39;s name, separated by NULL bytes and without backslashes for escaping.">keyUnescapedName()</a> for getting a pointer to the unescaped name </dd>
<dd>
<a class="el" href="group__keyname.html#ga44a576c7919d5b03f28d3ed3afaa7cd1" title="Copies the unescaped name of a Key into returnedName.">keyGetUnescapedName()</a> for getting a copy of the unescaped name </dd>
<dd>
<a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the Key&#39;s name (excluding owner).">keyGetNameSize()</a> for getting the size of the escaped name </dd></dl>

</div>
</div>
<a id="ga8e805c726a60da921d3736cda7813513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e805c726a60da921d3736cda7813513">&#9670;&nbsp;</a></span>keyName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the abbreviated real internal <code>key</code> name. </p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated Key name (excluding owner).">keyGetName()</a> and can use it if you are responsible enough to not mess up things. You are not allowed to change anything in the returned array. The content of that string may change after <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> and similar functions. If you need a copy of the name, consider using <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated Key name (excluding owner).">keyGetName()</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no keyName. The reason is <div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);</div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p>Valid key names are:</p>
<ul>
<li><code>spec:/something</code> for specification of other keys.</li>
<li><code>proc:/something</code> for in-memory keys, e.g. commandline.</li>
<li><code>dir:/something</code> for dir keys in current working directory</li>
<li><code>system:/something</code> for system keys in /etc or /</li>
<li><code>user:/something</code> for user keys in home directory</li>
<li><code>user:username/something</code> for other users (deprecated: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> + <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> currently unsupported)</li>
<li><p class="startli"><code>/something</code> for cascading keys (actually refers to one of the above, see also <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a>)</p>
<dl class="section note"><dt>Note</dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a> method to set a new value. Use <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key you want to get the name from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the Key's name which must not be changed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when Key's name is empty </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the Key&#39;s name (excluding owner).">keyGetNameSize()</a> for the string length </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated Key name (excluding owner).">keyGetName()</a> as alternative to get a copy </dd>
<dd>
<a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb" title="Returns a Key&#39;s name, separated by NULL bytes and without backslashes for escaping.">keyUnescapedName</a> to get an unescaped <a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo .">Key</a> name </dd></dl>
</li>
</ul>

</div>
</div>
<a id="gae22037aad3f76f4454de4e6400637b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae22037aad3f76f4454de4e6400637b39">&#9670;&nbsp;</a></span>keyReplacePrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keyReplacePrefix </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>oldPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>newPrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a prefix of the key name of <code>key</code>. </p>
<p>The function only modifies <code>key</code>, if is is below (or same as) <code>oldPrefix</code> (see <a class="el" href="keytest_8c.html#a6250a0bad75aa9abb20a98e69ad2d299" title="Check if a key is below or same.">keyIsBelowOrSame()</a>) and they both have the same namespace (this is not always the case with <a class="el" href="keytest_8c.html#a6250a0bad75aa9abb20a98e69ad2d299" title="Check if a key is below or same.">keyIsBelowOrSame()</a>).</p>
<p>In simple terms this function operates as follows:</p><ol type="1">
<li>If before calling this function <code>key</code> and <code>oldPrefix</code> had the same name, then afterwards <code>key</code> will have the same name as <code>newPrefix</code>.</li>
<li>If <code>key</code> was in the same namespace as and below <code>oldPrefix</code>, then after calling this function <code>key</code> will be in the same namespace as and below <code>newPrefix</code>.</li>
<li>Otherwise <code>key</code> will not be modified.</li>
</ol>
<p>Note: We use <code>const Key *</code> arguments for the prefixes instead of <code>const char *</code> to ensure only valid key names can be passed as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key that will be manipulated. </td></tr>
    <tr><td class="paramname">oldPrefix</td><td>The name of this key will be removed from the front of the name of <code>key</code>. </td></tr>
    <tr><td class="paramname">newPrefix</td><td>The name of this key will be added to the front of <code>key</code>, after the name of <code>oldPrefix</code> is removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if <code>key</code>, <code>oldPrefix</code> or <code>newPrefix</code> are NULL or the name of <code>key</code> is marked as read-only </td></tr>
    <tr><td class="paramname">0</td><td>if <code>key</code> is not below (or same as) <code>oldPrefix</code>, i.e. there is no prefix to replace </td></tr>
    <tr><td class="paramname">1</td><td>if the prefix was sucessfully replaced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e804bd453f98c28b0ff51430d1df407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e804bd453f98c28b0ff51430d1df407">&#9670;&nbsp;</a></span>keySetBaseName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetBaseName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>baseName</code> as the new basename for <code>key</code>. </p>
<p>Only the basename of the Key will be affected.</p>
<p>A simple example is: </p><div class="fragment"><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/my/long/name&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (k, <span class="stringliteral">&quot;myname&quot;</span>);</div>
<div class="line">printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k)); <span class="comment">// will print user:/my/long/myname</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
<div class="ttc" id="agroup__keyname_html_ga6e804bd453f98c28b0ff51430d1df407"><div class="ttname"><a href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a></div><div class="ttdeci">ssize_t keySetBaseName(Key *key, const char *baseName)</div><div class="ttdoc">Sets baseName as the new basename for key.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:1652</div></div>
</div><!-- fragment --><p> All text after the last <code>'/'</code> in the Key's name is erased and <code>baseName</code> is appended. If <code>baseName</code> is 0 (NULL), then the last part of the Key's name is removed without replacement. The root name of the Key will not be removed though.</p>
<p>Let us suppose <code>key</code> has name <code>"system:/dir1/dir2/key1"</code>. If <code>baseName</code> is <code>"key2"</code>, the resulting key name will be <code>"system:/dir1/dir2/key2"</code>. If <code>baseName</code> is 0 (NULL), the resulting key name will be <code>"system:/dir1/dir2"</code>. If <code>baseName</code> is empty, the resulting key name will be <code>"system:/dir1/dir2/%"</code>, where <code>"%"</code> denotes an empty base name, as also shown in the following code:</p>
<div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system:/valid&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (k, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (k), <span class="stringliteral">&quot;system:/%&quot;</span>);</div>
<div class="line">        succeed_if_same_string (<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key.">keySetBaseName()</a> does proper escaping on the supplied name argument.</p>
<p>You can use character sequences as <code>baseName</code> (e.g. <code>"."</code> (dot), <code>".."</code> (dot-dot), <code>"%"</code> (empty basename)). They will be properly escaped and will not have their usual meaning.</p>
<p>If you want to add to the basename instead of changing it, use <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName to the name of key.">keyAddBaseName()</a>. If you do not want any escaping, use <a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add an already escaped name part to the Key&#39;s name.">keyAddName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key whose basename to set </td></tr>
    <tr><td class="paramname">baseName</td><td>the new basename for the Key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the new key name </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if Key is NULL </td></tr>
    <tr><td class="paramname">-1</td><td>if Key was inserted into KeySet before </td></tr>
    <tr><td class="paramname">-1</td><td>if Key is read-only </td></tr>
    <tr><td class="paramname">-1</td><td>on allocation errors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName to the name of key.">keyAddBaseName()</a> for adding a basename instead of changing it </dd>
<dd>
<a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add an already escaped name part to the Key&#39;s name.">keyAddName()</a> for adding a name without escaping </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a> for setting a completely new name </dd>
<dd>
<a class="el" href="group__keyname.html" title="Methods to do various operations on Key names.">Name Manipulation Methods</a> for more details on special names </dd></dl>

</div>
</div>
<a id="ga7699091610e7f3f43d2949514a4b35d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7699091610e7f3f43d2949514a4b35d9">&#9670;&nbsp;</a></span>keySetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new name to a Key. </p>
<p>A valid name is one of the forms:</p><ul>
<li><code>spec:/something</code> for specification of other keys.</li>
<li><code>proc:/something</code> for in-memory keys, e.g. commandline.</li>
<li><code>dir:/something</code> for dir keys in current working directory</li>
<li><code>system:/something</code> for system keys in /etc or /</li>
<li><code>user:/something</code> for user keys in home directory</li>
<li><code>user:username/something</code> for other users (deprecated: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> + <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> currently unsupported)</li>
<li><code>/something</code> for cascading keys (actually refers to one of the above, see also <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a>)</li>
</ul>
<p>An invalid name either has an invalid namespace or a wrongly escaped \ at the end of the name.</p>
<p>See <a class="el" href="group__keyname.html">key names </a> for the exact rules.</p>
<p>The last form has explicitly set the owner, to let the library know in which user folder to save the Key. A owner is a user name. If it is not defined (the second form), current user is used.</p>
<p>You should always follow the guidelines for Key tree structure creation.</p>
<p>A private copy of the Key name will be stored, and the <code>newName</code> parameter can be freed after this call.</p>
<p>.., . and / will be handled as in filesystem paths. A valid name will be build out of the (valid) name what you pass, e.g. user:///sw/../sw//././MyApp -&gt; user:/sw/MyApp</p>
<p>Trailing slashes will be stripped.</p>
<p>On invalid names, the name stays unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd>size of the new Key name in bytes, including NULL terminator </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if <code>key</code> or <code>keyName</code> is NULL or <code>keyName</code> is empty or invalid </td></tr>
    <tr><td class="paramname">-1</td><td>if Key was inserted to a KeySet before </td></tr>
    <tr><td class="paramname">-1</td><td>if Key name is read-only</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key whose name to set </td></tr>
    <tr><td class="paramname">newName</td><td>the new name for the Key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated Key name (excluding owner).">keyGetName()</a> for getting a copy of the Key's name </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a> for getting a pointer to the Key's name </dd>
<dd>
<a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key.">keySetBaseName()</a>, <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName to the name of key.">keyAddBaseName()</a> for manipulating the base name </dd></dl>

</div>
</div>
<a id="ga98c1c1307419e689c98e556e5c542073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98c1c1307419e689c98e556e5c542073">&#9670;&nbsp;</a></span>keySetNamespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetNamespace </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key.html#gaec3b8d6f430ae49b91bafe8a86310a68">elektraNamespace</a>&#160;</td>
          <td class="paramname"><em>ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the namespace of a Key. </p>
<p>The rest of the Key's name remains unchanged.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>ns</code> MUST be a valid namespace and not <a class="el" href="group__key.html#ggaec3b8d6f430ae49b91bafe8a86310a68a3659698b0a07454ca8055ab693e8efd1" title="no key given as parameter to keyGetNamespace()">KEY_NS_NONE</a> </dd>
<dd>
<code>key</code> MUST be a valid #Key, especially <code>key != NULL</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The #Key whose namespace will be changed </td></tr>
    <tr><td class="paramname">ns</td><td>The new namespace of for <code>key</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new size in bytes of the Key's namespace </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>precondition error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gafc3ca03ed10f87eb59bdc02cf2a0de8d" title="Returns the elektraNamespace for a Key.">keyGetNamespace()</a> for getting a Key's namespace </dd></dl>

</div>
</div>
<a id="ga6fe6af4c27b35d911a533f4ae4d698bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fe6af4c27b35d911a533f4ae4d698bb">&#9670;&nbsp;</a></span>keyUnescapedName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* keyUnescapedName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Key's name, separated by NULL bytes and without backslashes for escaping. </p>
<p>Slashes are replaced with NULL bytes. Therefore unescaped names of cascading Keys start with a NULL byte. Otherwise escaped characters, e.g. non-hierarchy slashes, will be unescaped.</p>
<p>This name is essential if you want to iterate over parts of the Key's name, compare Key names or check relations of Keys in the hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key whose unescaped name to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name in its unescaped form </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">""</td><td>if Key's name is empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga44a576c7919d5b03f28d3ed3afaa7cd1" title="Copies the unescaped name of a Key into returnedName.">keyGetUnescapedName()</a> for getting a copy of the unescaped name </dd>
<dd>
<a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b" title="Returns the size of the Key&#39;s unescaped name including embedded and terminating NULL characters.">keyGetUnescapedNameSize()</a> for getting the size of the unescaped name </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name.">keyName()</a> for getting the escaped name of the Key </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
