<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Buildserver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Buildserver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_BUILDSERVER"></a> The <a href="https://build.libelektra.org/">Elektra buildserver</a> handles a variety of tasks that reaches from testing Pull Requests (PRs) to deploying new versions of the <a href="https://www.libelektra.org">Elektra website</a>.</p>
<p>We reworked our build system to use a more modern Jenkinsfile approach with benefits such as</p>
<ul>
<li>tracking modifications to our build process in SCM</li>
<li>tracking changes to the build environment</li>
<li>speeding up builds</li>
</ul>
<h1><a class="anchor" id="autotoc_md1547"></a>
Setup</h1>
<p>This section aims to give an introduction into this setup.</p>
<h2><a class="anchor" id="autotoc_md1548"></a>
Multibranch Pipeline Jobs (libelektra)</h2>
<p>We use the Jenkins Job type called <a href="https://jenkins.io/doc/book/pipeline/multibranch/#creating-a-multibranch-pipeline">Multibranch Pipeline</a> provided by the <a href="https://wiki.jenkins.io/display/JENKINS/Pipeline+Multibranch+Plugin">Pipeline Multibranch Plugin</a> for our CI tests called <code>libelektra</code>.</p>
<p>Simplified a multibranch pipeline job acts as an umbrella job that spawns child jobs for different branches (hence multibranch). The main purpose of the libelektra job is to scan the repository for changes to existing branches or to find new ones (for example branches that are used in PR's). It also contains the information on how to build the jobs in the form of a path that points to a Jenkinsfile containing more detailed instructions. The job also takes care of handling build artifacts that are archived and cleaning them out once the PR's are closed and a grace period has expired.</p>
<p>Summarized libelektra's job purpose is to combine the where (our GIT repository), with a when (tracking changes via polling or webhooks) with a how (pointing to the Jenkinsfile + configuration).</p>
<h2><a class="anchor" id="autotoc_md1549"></a>
Jenkins Shared Library</h2>
<p>We use a <a href="https://www.jenkins.io/doc/book/pipeline/shared-libraries/">shared library</a> to share common functionalities across multiple pipelines. This shared library contains all docker related functionalities, code to publish artifacts and various other directives and helper functions. After integrating this shared library with:</p>
<div class="fragment"><div class="line">@Library(&#39;libelektra-shared&#39;) _</div>
<div class="line"> </div>
<div class="line">pipelineConfig {</div>
<div class="line">  now = new Date()</div>
<div class="line">}</div>
</div><!-- fragment --><p>we can use any function that is declared in the shared library.</p>
<p>It is available in the <a href="https://github.com/ElektraInitiative/jenkins-library">following repository</a>. For more detailed usage instruction or instructions on how to integrate this shared library into Jenkins, see its <a href="https://github.com/ElektraInitiative/jenkins-library/blob/master/README.md">README.md</a>.</p>
<h2><a class="anchor" id="autotoc_md1550"></a>
Jenkinsfiles</h2>
<p>Jenkinsfiles describe what actions the build system should execute on which build slave. Currently Elektra uses four different files.</p>
<h3><a class="anchor" id="autotoc_md1551"></a>
Jenkinsfile.daily</h3>
<ul>
<li>Jenkinsfile.daily contains daily maintenance tasks, like cleaning up build servers.</li>
<li><a href="https://build.libelektra.org/job/libelektra-daily/">Buildjob: libelektra-daily</a></li>
<li><a href="https://master.libelektra.org/scripts/jenkins/Jenkinsfile.daily">Jenkinsfile.daily</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md1552"></a>
Jenkinsfile.monthly</h3>
<ul>
<li>Jenkinsfile.monthly contains monthly triggering of libelektra job on master.</li>
<li><a href="https://build.libelektra.org/job/libelektra-monthly/">Buildjob: libelektra-monthly</a></li>
<li><a href="https://master.libelektra.org/scripts/jenkins/Jenkinsfile.monthly">Jenkinsfile.monthly</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md1553"></a>
Jenkinsfile.release</h3>
<ul>
<li>Triggered manually with optional arguments. It is used for automated releasing a new version of Elektra.</li>
<li>Jenkinsfile.release contains description how to release a new version of Elektra.</li>
<li><a href="https://build.libelektra.org/job/libelektra-release/">Buildjob: libelektra-release</a></li>
<li><a href="https://master.libelektra.org/scripts/jenkins/Jenkinsfile.release">Jenkinsfile.release</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md1554"></a>
Jenkinsfile</h3>
<ul>
<li>Triggered on code changes and is for testing changes to the codebase.</li>
<li>Jenkinsfile contains descriptions how to build, test and deploy Elektra.</li>
<li><a href="https://build.libelektra.org/job/libelektra/">Buildjob: libelektra</a></li>
<li><a href="https://master.libelektra.org/scripts/jenkins/Jenkinsfile">Jenkinsfile</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md1555"></a>
DSL</h3>
<p>The language used is a groovy based DSL described in the <a href="https://jenkins.io/doc/book/pipeline/jenkinsfile/">Jenkinsfile book</a>. Most groovy syntax is allowed to describe pipelines in a Jenkinsfile, but it is executed in a sandbox which might block certain calls.</p>
<p>Since plugins might extend the pool of available commands or variables a full list of currently available syntax can be seen in <a href="https://build.libelektra.org/job/libelektra/pipeline-syntax/">pipeline syntax</a> after a login to the build server. Some functionality is not covered by this page when the responsible plugin is not implementing it. Usually an approach similar to what is described on <a href="https://stackoverflow.com/questions/51103359/jenkins-pipeline-return-value-of-build-step">stackoverflow</a> can be used to track down the responsible code inside the providing plugins source code.</p>
<p>We also provide a number of helper functions in our Jenkinsfiles that are documented at the function head. Most common use cases, for example adding a new build with certain cmake flags, are easy to add because of them. For example, the configuration that is responsible for the <code>debian-stable-full</code> stage is generated completely by a single helper function called <code>buildAndTest</code>:</p>
<div class="fragment"><div class="line">tasks &lt;&lt; buildAndTest(</div>
<div class="line">  &quot;debian-stable-full&quot;,</div>
<div class="line">  DOCKER_IMAGES.stretch,</div>
<div class="line">  CMAKE_FLAGS_BUILD_ALL +</div>
<div class="line">    CMAKE_FLAGS_BUILD_FULL +</div>
<div class="line">    CMAKE_FLAGS_BUILD_STATIC +</div>
<div class="line">    CMAKE_FLAGS_COVERAGE</div>
<div class="line">  ,</div>
<div class="line">  [TEST.ALL, TEST.MEM, TEST.NOKDB, TEST.INSTALL]</div>
<div class="line">)</div>
</div><!-- fragment --><p>When adding new stages to the build chain it is generally a good idea to look up an existing stage which does something similar and adapt it to the new use case.</p>
<h2><a class="anchor" id="autotoc_md1556"></a>
Security</h2>
<p>Since a malicious PR could easily destroy the build server and slaves or expose credentials some restrictions are introduced. Only PR authors that have the right to push to libelektra can modify the Jenkinsfile and have those changes be respected for the respective branch.</p>
<h2><a class="anchor" id="autotoc_md1557"></a>
Test Environments</h2>
<p>We use Docker containers to provide the various test environments.</p>
<p>They are described <a href="https://master.libelektra.org/scripts/docker">in the repository</a> and the Jenkinsfile describes how to build them. If a rebuild of the images is needed is determined by the hash of the Dockerfile used to describe it. If it has not changed the build step will be skipped. In the case that an image needed a build it will afterwards be uploaded into a private Docker image registry (on a7) and thus is shared between all Docker capable build slaves.</p>
<h1><a class="anchor" id="autotoc_md1558"></a>
Jenkinsfile (Main CI Pipeline)</h1>
<h2><a class="anchor" id="autotoc_md1559"></a>
Tests</h2>
<p>We will use the Docker images build as described earlier to run compilations and tests for Elektra. This allows us to run tests independent of which nodes are available (as the environment is portable).</p>
<p>The Jenkinsfile describes the steps used to run tests. Helper functions for easily adding new tests are available (<code>buildAndTest</code>, <code>BuildAndTestAsan</code>, ...).</p>
<p>The <code>withDockerEnv</code> helper, that is available in the shared library, makes sure to print the following information at the start of a test branch:</p>
<ul>
<li>branch name</li>
<li>build machine</li>
<li>docker image id</li>
</ul>
<p>Coverage reports are generated automatically when using the <code>buildAndTest</code> helper and the appropriate CMake flags for coverage generation have been set. They are uploaded to <a href="https://doc.libelektra.org/coverage/">https://doc.libelektra.org/coverage/</a>.</p>
<p>Artifacts from <code>ctest</code> are also preserved automatically when using <code>buildAndTest</code>. The function also takes care of providing a stage name based path so multiple tests can not overwrite files that share the same name.</p>
<p>Tests are executed in order dictated by the Jenkinsfile. In general new tests should be added to the 'full build stage' that will only run after a standard full test run succeeded. This saves execution time on the build server for the most common errors.</p>
<p>Since there is no strict way to enforce the way tests are added we encourage you to read the existing configuration and modify existing tests so they suite your needs.</p>
<h2><a class="anchor" id="autotoc_md1560"></a>
Deployment</h2>
<p>For runs of the build job that are run in the master branch we also execute deployment steps after all tests pass. We use these steps to build Debian and Fedora packages and move them into the repositories hosted on the community node.</p>
<p>Additionally we recompile the homepage and deploy it on the community node.</p>
<h1><a class="anchor" id="autotoc_md1561"></a>
Jenkinsfile.release (Release Pipeline)</h1>
<h2><a class="anchor" id="autotoc_md1562"></a>
Release Builds</h2>
<p>The <code>buildRelease</code> function runs various test suites and collects and archives debug information. It also generates source-packages and packages for Debian based distributions and Fedora.</p>
<p>The generated packages are additionally installed and tested on a clean Docker image.</p>
<h2><a class="anchor" id="autotoc_md1563"></a>
Manual approval</h2>
<p>In order to verify the correct behavior and results of the previous steps and their generated artifacts, we use the <a href="https://www.jenkins.io/doc/pipeline/steps/pipeline-input-step/">Input Step</a> to pause the pipeline. After manually verifying the correctness, the pipeline run can be resumed.</p>
<h2><a class="anchor" id="autotoc_md1564"></a>
Publishing</h2>
<p>The previously generated packages are published to the repositories, as described above in <em>Jenkinsfile (Main CI Pipeline)</em>. The API documentation and source packages get published to the relevant git repositories. Finally the Alpine release image is published to Docker Hub.</p>
<h1><a class="anchor" id="autotoc_md1565"></a>
Jenkins Setup</h1>
<p>This section describes how to replicate the current Jenkins configuration.</p>
<h2><a class="anchor" id="autotoc_md1566"></a>
Jenkins libelektra Configuration</h2>
<p>The <code>libelektra</code> build job is a multibranch pipeline job. It is easiest to add via the BlueOcean interface.</p>
<p>Most of the default settings should be ok, however some settings need to be verified or added to build Elektra correctly:</p>
<ul>
<li><code>Advanced clone behaviors</code> should be added and the path to the git mirror needs to be specified: <code>/home/jenkins/git_mirrors/libelektra</code>. This reference repository is created and maintained by our <a href="https://build.libelektra.org/job/libelektra-daily/">daily buildjob</a>.</li>
<li>Under Property strategy you can add <code>Trigger build on pull request comment</code>. <code>jenkins build (libelektra|all) please</code> is a good starting point. This functionality is provided by the <a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+PR+Comment+Build+Plugin">GitHub PR Comment Build Plugin</a>.</li>
<li>For Build Configuration you want to specify <code>by Jenkinsfile</code> and add the script path: <code>scripts/jenkins/Jenkinsfile</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1567"></a>
Jenkins libelektra-release Configuration</h2>
<p>The <code>libelektra-release</code> job is a normal pipeline job.</p>
<p>Most of the default settings can be used.</p>
<ul>
<li>Under General you need to enable <code>Permission to Copy Artifact</code> and set the field to <code>*</code>.</li>
<li>For Build Configuration you want to specify <code>by Jenkinsfile</code> and add the script path: <code>scripts/jenkins/Jenkinsfile.release</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1568"></a>
General Set-Up of a New Pipeline</h2>
<p>We will cover how to set-up a pipeline that uses a different git repository than this <code>libelektra</code> repository.</p>
<p>Most of the default settings can be used.</p>
<ul>
<li>If a private repository were to be used with a GitHub type job, a credentials pair of <code>elektrabot</code> must be selected to access this repository.</li>
<li>For Build Configuration you want to specify <code>by Jenkinsfile</code> and add the script path to the Jenkinsfile.</li>
</ul>
<p>We first start by including the shared library as described above in <em>Jenkins Shared Library</em>. Then we declare in a Jenkinsfile an empty map that will contain all Docker images we will use in this pipeline:</p>
<div class="fragment"><div class="line">DOCKER_IMAGES = [:]</div>
</div><!-- fragment --><p>This map will later be populated in a function. For a Docker image with Ubuntu Focal and the Dockerfile located at <code>./ci/Dockerfile</code> this function would need to look as follows:</p>
<div class="fragment"><div class="line">def dockerInit() {</div>
<div class="line">  node(&#39;master&#39;) {</div>
<div class="line">    checkout scm</div>
<div class="line"> </div>
<div class="line">    DOCKER_IMAGES.focal = dockerUtils.createDockerImageDesc(</div>
<div class="line">      &#39;ubuntu-focal&#39;, dockerUtils.&amp;idTesting,</div>
<div class="line">      &#39;./ci/&#39;,</div>
<div class="line">      &#39;./ci/Dockerfile&#39;</div>
<div class="line">    )</div>
<div class="line">    // more docker images ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>We can now begin to create the stages that initialize, pull and if necessary also build these Docker images:</p>
<div class="fragment"><div class="line">stage(&#39;Init docker images&#39;) {</div>
<div class="line">  dockerInit()</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">stage(&#39;Pull docker images&#39;) {</div>
<div class="line">  parallel dockerUtils.generateDockerPullStages(DOCKER_IMAGES)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">maybeStage(&#39;Build docker images&#39;, DOCKER_IMAGES.any { img -&gt; !img.value.exists }) {</div>
<div class="line">  lock(&#39;docker-images&#39;) {</div>
<div class="line">        parallel dockerUtils.generateDockerBuildStages(DOCKER_IMAGES)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now the actual stages that contain our CI/CD code can be created.</p>
<p>To allow parallel execution of stages we create generator functions that return a map of stages that can be executed in parallel. For example the following generator function would create a map of two tasks that could be run in parallel.</p>
<div class="fragment"><div class="line">def generateTestStages() {</div>
<div class="line">  def tasks = [:]</div>
<div class="line"> </div>
<div class="line">  tasks &lt;&lt; test(</div>
<div class="line">    &#39;ubuntu-focal-test&#39;,</div>
<div class="line">    DOCKER_IMAGES.focal</div>
<div class="line">  )</div>
<div class="line"> </div>
<div class="line">  tasks &lt;&lt; test(</div>
<div class="line">    &#39;ubuntu-bionic-test&#39;,</div>
<div class="line">    DOCKER_IMAGES.bionic</div>
<div class="line">  )</div>
<div class="line"> </div>
<div class="line">  return tasks</div>
<div class="line">}</div>
</div><!-- fragment --><p>Suppose we have a bash script <code>test.sh</code> in the root of our git repository. This script can be executed inside one of our Docker images by using the <code>withDockerEnv</code> function:</p>
<div class="fragment"><div class="line">def test(stageName, image) {</div>
<div class="line">  return [(stageName): {</div>
<div class="line">    stage(stageName) {</div>
<div class="line">      withDockerEnv(image) {</div>
<div class="line">        sh &quot;./test.sh&quot;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }]</div>
<div class="line">}</div>
</div><!-- fragment --><p>We can now call the generator function <code>generateTestStages</code> in a new stage:</p>
<div class="fragment"><div class="line">stage(&#39;Testing&#39;) {</div>
<div class="line">  parallel generateTestStages()</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1569"></a>
Adding a Jenkins Node</h2>
<p>A node needs to have a JRE (Java Runtime Environment) installed. Further it should run an SSH (Secure SHell) server. Docker need to be installed as well.</p>
<p>A <code>jenkins</code> user with 47110:47110 ids should be created as this is what is expected in Docker images. <code>useradd -u 47110 jenkins</code> Additionally a public key authentication should be set up so the jenkins master can establish an ssh connection with the node. If the node should be able to interact with Docker the jenkins user should be added to the <code>docker</code> group.</p>
<p>Nodes should be set to only build jobs matching their labels and to be online as much as possible. As for labels <code>gitmirror</code> should be if you want to cache repositories on this node. If Docker is available the <code>docker</code> label should be set.</p>
<p>All files and folders in the Node under <code>/home/jenkins</code> should be owned by user <code>jenkins</code>.</p>
<h1><a class="anchor" id="autotoc_md1570"></a>
Understanding Jenkins Output</h1>
<p>Our Jenkins build uses parallel steps inside a single build job to do most of the work. To reliable determine which stages failed it is best to look over the build results in the Jenkins Blue Ocean view. It is the default View opened when accessing the build results from GitHub. For libelektra the URLs are <a href="https://build.libelektra.org/job/libelektra/">https://build.libelektra.org/job/libelektra/</a> and <a href="https://build.libelektra.org/blue/organizations/jenkins/libelektra/branches/">https://build.libelektra.org/blue/organizations/jenkins/libelektra/branches/</a> Failed stages are marked in red. On selecting a stage you can further expand all steps in the stage. Of interest should be one of the first steps which echos out the Docker image used to run the stage. You also want to look for whatever failed (which should be in a step also marked red to indicate failure).</p>
<h1><a class="anchor" id="autotoc_md1571"></a>
Reproducing Build Server Errors Locally</h1>
<p>First you have to determine which image is used. This is described above in <em>Understanding Jenkins output</em>.</p>
<p>Afterwards you can download it from our registry via <code>docker pull</code>. Pay attention that you have to use <b>hub-public.libelektra.org</b> as this subdomain does not require authentication for GET operations used by the Docker client. As an example:</p>
<div class="fragment"><div class="line">docker pull hub-public.libelektra.org/build-elektra-alpine:201809-791f9f388cbdff0db544e02277c882ad6e8220fe280cda67e6ea6358767a065e</div>
</div><!-- fragment --><p>You can also rebuild the images locally, which is useful if you want to test changes you made to the Dockerfiles themselves. Locate which Dockerfile you need by looking up the reference the stage that used it in the Jenkinsfile. For <em>alpine</em> this would be <code>DOCKER_IMAGES.alpine</code>. You can search for this entry in the Jenkinsfile to find that this image is build from the context <code>./scripts/docker/alpine/*</code> and uses <code>./scripts/docker/alpine/*/Dockerfile</code> as a Dockerfile. Now you can build the image as described in <a href="https://master.libelektra.org/scripts/docker/README.md#building-images-locally">scripts/docker/README.md</a>.</p>
<p>You can find more information on how to use our images in <a href="https://master.libelektra.org/scripts/docker/README.md#testing-elektra-via-docker-images">scripts/docker/README.md</a>.</p>
<p>Alternatively, you can follow the <a class="el" href="doc_tutorials_run_all_tests_with_docker_md.html">tutorial</a>.</p>
<h1><a class="anchor" id="autotoc_md1572"></a>
Modify Test Environments</h1>
<p>You can also modify the test environments (update a dependency, install a new dependency, ...) by editing the Dockerfiles checked into SCM. Determine which ones you need to modify by tracing which images are used for what stages via the <code>DOCKER_IMAGES</code> map used in our Jenkinsfile. The <code>dockerInit</code> function should be a good start point.</p>
<p>Following docker best practises you should try to minimize layer count when possible. Our docker images are quite large and hence take a long time to build so make sure to test any modifications locally first.</p>
<h1><a class="anchor" id="autotoc_md1573"></a>
Triggers</h1>
<p>All Triggers are described in the configuration of the respective build jobs.</p>
<p>The <a href="https://build.libelektra.org/job/libelektra/">libelektra</a> build is triggered for all branches of the libelektra repository except for <code>debian</code>. Additionally all open branches in forks targeting libelektra's repository via PRs are going to be build. Pushes to any of those branches will trigger a new build automatically.</p>
<p>The <a href="https://build.libelektra.org/job/libelektra-daily/">daily build</a> and <a href="https://build.libelektra.org/job/libelektra-monthly/">monthly build</a> are executed according to a cron schedule.</p>
<p>The <a href="https://build.libelektra.org/job/libelektra-release/">release pipeline</a> is triggered manually with optional arguments.</p>
<p>The following phrases can be used as comments to manually trigger a specific build:</p>
<ul>
<li>jenkins build <a href="https://build.libelektra.org/job/libelektra/">libelektra</a> please</li>
<li>jenkins build <a href="https://build.libelektra.org/job/libelektra-daily/">daily</a> please</li>
<li>jenkins build <a href="https://build.libelektra.org/job/libelektra-monthly/">monthly</a> please</li>
</ul>
<p>Additionally <code>jenkins build all please</code> can be used to trigger all build jobs relevant for PR's. This is not necessary anymore as all relevant tests have been moved into the libelektra job.</p>
<h1><a class="anchor" id="autotoc_md1574"></a>
Authorization</h1>
<p>If you are not yet authorized, the following question will be asked (by user @markus2330): </p><pre class="fragment">Can one of the admins verify if this patch should be build?
</pre><p> Then one of the admins (sorted by activity):</p>
<ul>
<li>@sanssecours</li>
<li>@markus2330</li>
<li>@beku</li>
<li>@BernhardDenner</li>
<li>@fberlakovich</li>
<li>@manuelm</li>
</ul>
<p>need to confirm by saying: </p><pre class="fragment">.*add\W+to\W+whitelist.*
</pre><p> or if just the pull request should be checked: </p><pre class="fragment">.*build\W+allow.*
</pre> <h1><a class="anchor" id="autotoc_md1575"></a>
Issues with the Build Environment</h1>
<p>If you have issues that are related to the build system you can open a normal issue and tag it with <code>build</code> and <code>question</code>. If you feel like your inquiry does not warrant an issue on its own, please use <a href="https://issues.libelektra.org/160">our buildserver issue</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
