<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: kdb::KeySet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacekdb.html">kdb</a></li><li class="navelem"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkdb_1_1KeySet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kdb::KeySet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A keyset holds together a set of keys.  
 <a href="classkdb_1_1KeySet.html#details">More...</a></p>

<p><code>#include &lt;keyset.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4eac9850fa4f06c07a5306befc3e4377"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a4eac9850fa4f06c07a5306befc3e4377">KeySet</a> ()</td></tr>
<tr class="memdesc:a4eac9850fa4f06c07a5306befc3e4377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty keyset with no keys.  <a href="#a4eac9850fa4f06c07a5306befc3e4377">More...</a><br /></td></tr>
<tr class="separator:a4eac9850fa4f06c07a5306befc3e4377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f651ff310178951402038e590743e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a21f651ff310178951402038e590743e0">KeySet</a> (ckdb::KeySet *k)</td></tr>
<tr class="memdesc:a21f651ff310178951402038e590743e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of keyset!  <a href="#a21f651ff310178951402038e590743e0">More...</a><br /></td></tr>
<tr class="separator:a21f651ff310178951402038e590743e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d6df839ab852fded1739ff3398d0b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ad8d6df839ab852fded1739ff3398d0b1">KeySet</a> (const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;other)</td></tr>
<tr class="memdesc:ad8d6df839ab852fded1739ff3398d0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a keyset.  <a href="#ad8d6df839ab852fded1739ff3398d0b1">More...</a><br /></td></tr>
<tr class="separator:ad8d6df839ab852fded1739ff3398d0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6191e93cdd67bbca63df934498d191ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a6191e93cdd67bbca63df934498d191ba">KeySet</a> (size_t alloc,...) ELEKTRA_SENTINEL</td></tr>
<tr class="memdesc:a6191e93cdd67bbca63df934498d191ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new keyset.  <a href="#a6191e93cdd67bbca63df934498d191ba">More...</a><br /></td></tr>
<tr class="separator:a6191e93cdd67bbca63df934498d191ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b2996803b9c9124cf791a1d738855c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ae0b2996803b9c9124cf791a1d738855c">KeySet</a> (<a class="el" href="structkdb_1_1VaAlloc.html">VaAlloc</a> alloc, va_list ap)</td></tr>
<tr class="memdesc:ae0b2996803b9c9124cf791a1d738855c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new keyset.  <a href="#ae0b2996803b9c9124cf791a1d738855c">More...</a><br /></td></tr>
<tr class="separator:ae0b2996803b9c9124cf791a1d738855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade654f92bddec24abad1b651e828f2b8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ade654f92bddec24abad1b651e828f2b8">~KeySet</a> ()</td></tr>
<tr class="memdesc:ade654f92bddec24abad1b651e828f2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstruct a keyset.  <a href="#ade654f92bddec24abad1b651e828f2b8">More...</a><br /></td></tr>
<tr class="separator:ade654f92bddec24abad1b651e828f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2987b3fb1b12196399650726f1c18f02"><td class="memItemLeft" align="right" valign="top"><a id="a2987b3fb1b12196399650726f1c18f02"></a>
ckdb::KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02">release</a> ()</td></tr>
<tr class="memdesc:a2987b3fb1b12196399650726f1c18f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you don't want destruction of keyset at the end you can release the pointer. <br /></td></tr>
<tr class="separator:a2987b3fb1b12196399650726f1c18f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9a3906e0b18a783f8a6e8bdbec9ed0"><td class="memItemLeft" align="right" valign="top">ckdb::KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a4e9a3906e0b18a783f8a6e8bdbec9ed0">getKeySet</a> () const</td></tr>
<tr class="memdesc:a4e9a3906e0b18a783f8a6e8bdbec9ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes out the raw keyset pointer.  <a href="#a4e9a3906e0b18a783f8a6e8bdbec9ed0">More...</a><br /></td></tr>
<tr class="separator:a4e9a3906e0b18a783f8a6e8bdbec9ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ec4eebe304185527b08a6fa01b77c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a9f3ec4eebe304185527b08a6fa01b77c">setKeySet</a> (ckdb::KeySet *k)</td></tr>
<tr class="memdesc:a9f3ec4eebe304185527b08a6fa01b77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of passed keyset.  <a href="#a9f3ec4eebe304185527b08a6fa01b77c">More...</a><br /></td></tr>
<tr class="separator:a9f3ec4eebe304185527b08a6fa01b77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c54736b7206bc2253d02a5bf4b3ccfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a1c54736b7206bc2253d02a5bf4b3ccfb">operator=</a> (<a class="el" href="classkdb_1_1KeySet.html">KeySet</a> const &amp;other)</td></tr>
<tr class="memdesc:a1c54736b7206bc2253d02a5bf4b3ccfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a keyset.  <a href="#a1c54736b7206bc2253d02a5bf4b3ccfb">More...</a><br /></td></tr>
<tr class="separator:a1c54736b7206bc2253d02a5bf4b3ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01c5c46e4c0802560b8f15886af89c4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ab01c5c46e4c0802560b8f15886af89c4">size</a> () const</td></tr>
<tr class="memdesc:ab01c5c46e4c0802560b8f15886af89c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the keyset.  <a href="#ab01c5c46e4c0802560b8f15886af89c4">More...</a><br /></td></tr>
<tr class="separator:ab01c5c46e4c0802560b8f15886af89c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f2b936d66729690e8a8a45b5074baa"><td class="memItemLeft" align="right" valign="top">ckdb::KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ad3f2b936d66729690e8a8a45b5074baa">dup</a> () const</td></tr>
<tr class="memdesc:ad3f2b936d66729690e8a8a45b5074baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a keyset.  <a href="#ad3f2b936d66729690e8a8a45b5074baa">More...</a><br /></td></tr>
<tr class="separator:ad3f2b936d66729690e8a8a45b5074baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fd33fdaecf1d57d4dddac7058f5d38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a28fd33fdaecf1d57d4dddac7058f5d38">copy</a> (const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;other)</td></tr>
<tr class="memdesc:a28fd33fdaecf1d57d4dddac7058f5d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a keyset.  <a href="#a28fd33fdaecf1d57d4dddac7058f5d38">More...</a><br /></td></tr>
<tr class="separator:a28fd33fdaecf1d57d4dddac7058f5d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f5159e39758aa632421d2fe7440633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a38f5159e39758aa632421d2fe7440633">clear</a> ()</td></tr>
<tr class="memdesc:a38f5159e39758aa632421d2fe7440633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the keyset.  <a href="#a38f5159e39758aa632421d2fe7440633">More...</a><br /></td></tr>
<tr class="separator:a38f5159e39758aa632421d2fe7440633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4b2f3aa9f58d10053561135b50233e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a0d4b2f3aa9f58d10053561135b50233e">append</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;toAppend)</td></tr>
<tr class="memdesc:a0d4b2f3aa9f58d10053561135b50233e"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a key  <a href="#a0d4b2f3aa9f58d10053561135b50233e">More...</a><br /></td></tr>
<tr class="separator:a0d4b2f3aa9f58d10053561135b50233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cbdc933d7171037d47c6d4d78595d1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ac9cbdc933d7171037d47c6d4d78595d1">append</a> (const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;toAppend)</td></tr>
<tr class="memdesc:ac9cbdc933d7171037d47c6d4d78595d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">append a keyset  <a href="#ac9cbdc933d7171037d47c6d4d78595d1">More...</a><br /></td></tr>
<tr class="separator:ac9cbdc933d7171037d47c6d4d78595d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aca3689ed08cbc909976cdf874cfb59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a1aca3689ed08cbc909976cdf874cfb59">head</a> () const</td></tr>
<tr class="memdesc:a1aca3689ed08cbc909976cdf874cfb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first key in the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.  <a href="#a1aca3689ed08cbc909976cdf874cfb59">More...</a><br /></td></tr>
<tr class="separator:a1aca3689ed08cbc909976cdf874cfb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16deed50e0d8cfee023d4423a119df51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a16deed50e0d8cfee023d4423a119df51">tail</a> () const</td></tr>
<tr class="memdesc:a16deed50e0d8cfee023d4423a119df51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last key in the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.  <a href="#a16deed50e0d8cfee023d4423a119df51">More...</a><br /></td></tr>
<tr class="separator:a16deed50e0d8cfee023d4423a119df51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc5a16a726e959adaf3cf8506e7b849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a5bc5a16a726e959adaf3cf8506e7b849">rewind</a> () const</td></tr>
<tr class="memdesc:a5bc5a16a726e959adaf3cf8506e7b849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewinds the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> internal cursor.  <a href="#a5bc5a16a726e959adaf3cf8506e7b849">More...</a><br /></td></tr>
<tr class="separator:a5bc5a16a726e959adaf3cf8506e7b849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd52d130faf184361297f9e7f0c9f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#affd52d130faf184361297f9e7f0c9f16">next</a> () const</td></tr>
<tr class="memdesc:affd52d130faf184361297f9e7f0c9f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> in a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.  <a href="#affd52d130faf184361297f9e7f0c9f16">More...</a><br /></td></tr>
<tr class="separator:affd52d130faf184361297f9e7f0c9f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0fc4efecd6dcbfde5fc35301b60349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a0a0fc4efecd6dcbfde5fc35301b60349">current</a> () const</td></tr>
<tr class="memdesc:a0a0fc4efecd6dcbfde5fc35301b60349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a>.  <a href="#a0a0fc4efecd6dcbfde5fc35301b60349">More...</a><br /></td></tr>
<tr class="separator:a0a0fc4efecd6dcbfde5fc35301b60349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36d35d8f12233a4c8f88d9bb13429c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#aa36d35d8f12233a4c8f88d9bb13429c3">setCursor</a> (elektraCursor cursor) const</td></tr>
<tr class="memdesc:aa36d35d8f12233a4c8f88d9bb13429c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> internal cursor.  <a href="#aa36d35d8f12233a4c8f88d9bb13429c3">More...</a><br /></td></tr>
<tr class="separator:aa36d35d8f12233a4c8f88d9bb13429c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc11bcf2a4b5937ce9f0787c011c2d9"><td class="memItemLeft" align="right" valign="top">elektraCursor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#accc11bcf2a4b5937ce9f0787c011c2d9">getCursor</a> () const</td></tr>
<tr class="memdesc:accc11bcf2a4b5937ce9f0787c011c2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> internal cursor.  <a href="#accc11bcf2a4b5937ce9f0787c011c2d9">More...</a><br /></td></tr>
<tr class="separator:accc11bcf2a4b5937ce9f0787c011c2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f207457a1c12633a1a5301a3a1bbaed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a7f207457a1c12633a1a5301a3a1bbaed">pop</a> ()</td></tr>
<tr class="memdesc:a7f207457a1c12633a1a5301a3a1bbaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the last key of <code>ks</code>.  <a href="#a7f207457a1c12633a1a5301a3a1bbaed">More...</a><br /></td></tr>
<tr class="separator:a7f207457a1c12633a1a5301a3a1bbaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e32f2d9f34f03fa8ec85945f49b630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a40e32f2d9f34f03fa8ec85945f49b630">at</a> (elektraCursor pos) const</td></tr>
<tr class="memdesc:a40e32f2d9f34f03fa8ec85945f49b630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a key by index.  <a href="#a40e32f2d9f34f03fa8ec85945f49b630">More...</a><br /></td></tr>
<tr class="separator:a40e32f2d9f34f03fa8ec85945f49b630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab283da798a7670d5c3f0e1a5b821e666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#ab283da798a7670d5c3f0e1a5b821e666">cut</a> (<a class="el" href="classkdb_1_1Key.html">Key</a> k)</td></tr>
<tr class="memdesc:ab283da798a7670d5c3f0e1a5b821e666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts out a keyset at the cutpoint.  <a href="#ab283da798a7670d5c3f0e1a5b821e666">More...</a><br /></td></tr>
<tr class="separator:ab283da798a7670d5c3f0e1a5b821e666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8537e388edfbb6941d771106c0ae3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a2b8537e388edfbb6941d771106c0ae3a">lookup</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k, const <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a> options=<a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370">KDB_O_NONE</a>) const</td></tr>
<tr class="memdesc:a2b8537e388edfbb6941d771106c0ae3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> contained in <code>ks</code> that matches the name of the <code>key</code>.  <a href="#a2b8537e388edfbb6941d771106c0ae3a">More...</a><br /></td></tr>
<tr class="separator:a2b8537e388edfbb6941d771106c0ae3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef071747608900be478219e4a040612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a0ef071747608900be478219e4a040612">lookup</a> (std::string const &amp;name, const <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a> options=<a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370">KDB_O_NONE</a>) const</td></tr>
<tr class="memdesc:a0ef071747608900be478219e4a040612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a key by name.  <a href="#a0ef071747608900be478219e4a040612">More...</a><br /></td></tr>
<tr class="separator:a0ef071747608900be478219e4a040612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65208974b44da0162ef70dd7a173748f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65208974b44da0162ef70dd7a173748f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkdb_1_1KeySet.html#a65208974b44da0162ef70dd7a173748f">get</a> (std::string const &amp;name, const <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a> options=<a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370">KDB_O_NONE</a>) const</td></tr>
<tr class="memdesc:a65208974b44da0162ef70dd7a173748f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic lookup+get for keysets.  <a href="#a65208974b44da0162ef70dd7a173748f">More...</a><br /></td></tr>
<tr class="separator:a65208974b44da0162ef70dd7a173748f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A keyset holds together a set of keys. </p>
<p>Methods to manipulate KeySets. A <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> is a set of keys.</p>
<p>Most important properties of a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>:</p>
<ul>
<li>Allows us to iterate over all keys (in any depth)</li>
<li>Iteration is always sorted</li>
<li>Fast key lookup</li>
<li>A <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> may be shared among many KeySets.</li>
</ul>
<p>The most important methods of <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>:</p>
<ul>
<li>With <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object. ">ksNew()</a> you can create a new <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</li>
<li>You can append keys with <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a> or with <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a> you can append a whole keyset.</li>
<li>Using <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> you can lookup (or pop with <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984" title="Pop Parent out of keyset key in ksLookup(). ">KDB_O_POP</a>) a key.</li>
<li>With <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> you can iterate through the keyset. Be assured that you will get every key of the set in a stable order (parents before children).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a> will be shared.</dd></dl>
<p>KeySets have an <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">internal cursor </a>. Methods should avoid to change this cursor, unless they want to communicate something with it. The internal cursor is used:</p>
<ul>
<li>in <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a>: points to the found key</li>
<li>in <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a>: points to the key which caused an error</li>
</ul>
<p><a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> is the most important data structure in Elektra. It makes it possible to get and store many keys at once inside the database. In addition to that, the class can be used as high level datastructure in applications and it can be used in plugins to manipulate or check configuration.</p>
<p>With <a class="el" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83" title="Convenience method to look for a Key contained in ks that matches name. ">ksLookupByName()</a> it is possible to fetch easily specific keys out of the list of keys.</p>
<p>You can easily create and iterate keys:</p>
<div class="fragment"><div class="line"><span class="comment">// create a new keyset with 3 keys</span></div><div class="line"><span class="comment">// with a hint that about 20 keys will be inside</span></div><div class="line">KeySet * myConfig = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (20, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/name1&quot;</span>, 0), <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/name2&quot;</span>, 0), <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/name3&quot;</span>, 0), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// append a key in the keyset</span></div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (myConfig, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/name4&quot;</span>, 0));</div><div class="line"></div><div class="line">Key * <a class="code" href="classkdb_1_1KeySet.html#a0a0fc4efecd6dcbfde5fc35301b60349">current</a>;</div><div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (myConfig);</div><div class="line"><span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (myConfig)) != 0)</div><div class="line">{</div><div class="line">        printf (<span class="stringliteral">&quot;Key name is %s.\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (current));</div><div class="line">}</div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (myConfig); <span class="comment">// delete keyset and all keys appended</span></div></div><!-- fragment --> <dl class="section invariant"><dt>Invariant</dt><dd>always holds an underlying elektra keyset.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>that the cursor is mutable, so it might be changed even in const functions as described. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4eac9850fa4f06c07a5306befc3e4377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eac9850fa4f06c07a5306befc3e4377">&#9670;&nbsp;</a></span>KeySet() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new empty keyset with no keys. </p>
<p>Allocate, initialize and return a new <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> object. Objects created with <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object. ">ksNew()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a>.</p>
<p>You can use an arbitrary long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be KS_END.</p>
<p>So, terminate with ksNew(0, KS_END) or ksNew(20, ..., KS_END)</p>
<dl class="section warning"><dt>Warning</dt><dd>Never use ksNew(0, keyNew(...), KS_END). If the first parameter is 0, other arguments are ignored.</dd></dl>
<p>The first parameter <code>alloc</code> defines how many keys can be added without reallocation. If you pass any alloc size greater than 0, but less than 16, it will default to 16.</p>
<p>For most uses</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// enough memory for up to 16 keys, without needing reallocation</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> will be fine. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large keysets.</p>
<p>You can defer the allocation of the internal array that holds the keys, by passing 0 as the alloc size. This is useful if it is unclear whether your keyset will actually hold any keys and you want to avoid a malloc call.</p>
<div class="fragment"><div class="line"><span class="comment">// Create KeySet without allocating memory for keys</span></div><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// The first allocation will happen in ksAppendKey</span></div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(keys, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, 0));</div><div class="line"><span class="comment">// work with the KeySet</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> But if you have any clue how large your keyset may be, you should read the next statements.</p>
<p>If you want a keyset with length 15 (because you know of your application that you only need up to 15 keys), use:</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (15, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key01&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value01&quot;</span>, 0),</div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, 0),</div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key03&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value03&quot;</span>, 0),</div><div class="line">                       <span class="comment">// ...</span></div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key15&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value15&quot;</span>, 0), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// work with it</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> If you start having 3 keys, and your application needs approximately 200 up to 500 keys, you can use:</p>
<div class="fragment"><div class="line">KeySet * config = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (500, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key1&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value1&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key2&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value2&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key3&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value3&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>); <span class="comment">// don&#39;t forget the KS_END at the end!</span></div><div class="line"><span class="comment">// work with it</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (config);</div></div><!-- fragment --><p> Alloc size is 500, the size of the keyset will be 3 after ksNew. This means the keyset will reallocate when appending more than 497 keys.</p>
<p>The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>. If you prefer, you can always create an empty <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> and use <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>.</p>
<dl class="section post"><dt>Postcondition</dt><dd>the keyset is rewinded properly</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a> to free the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a> afterwards </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a> to duplicate an existing <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a> to <a class="el" href="classkdb_1_1KeySet.html#a0d4b2f3aa9f58d10053561135b50233e" title="append a key ">append</a> individual keys </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>gives a hint for the size how many Keys may be stored initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready to use <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> object </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on memory error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21f651ff310178951402038e590743e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f651ff310178951402038e590743e0">&#9670;&nbsp;</a></span>KeySet() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramtype">ckdb::KeySet *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of keyset! </p>
<p>Keyset will be destroyed at destructor you cant continue to use keyset afterwards!</p>
<p>Use <a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02" title="If you don&#39;t want destruction of keyset at the end you can release the pointer. ">KeySet::release()</a> to avoid destruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the keyset to take the ownership from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02" title="If you don&#39;t want destruction of keyset at the end you can release the pointer. ">release()</a> </dd>
<dd>
<a class="el" href="classkdb_1_1KeySet.html#a9f3ec4eebe304185527b08a6fa01b77c" title="Take ownership of passed keyset. ">setKeySet()</a> </dd></dl>

</div>
</div>
<a id="ad8d6df839ab852fded1739ff3398d0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d6df839ab852fded1739ff3398d0b1">&#9670;&nbsp;</a></span>KeySet() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate a keyset. </p>
<p>This keyset will be a duplicate of the other afterwards.</p>
<dl class="section note"><dt>Note</dt><dd>that they still reference to the same Keys, so if you change key values also the keys in the original keyset will be changed.</dd></dl>
<p>So it is shallow copy, to create a deep copy you have to <a class="el" href="classkdb_1_1KeySet.html#ad3f2b936d66729690e8a8a45b5074baa" title="Duplicate a keyset. ">dup()</a> every key (it still won't copy metadata, but they are COW): </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1KeySet.html">kdb::KeySet</a> ksDeepCopy (<a class="code" href="classkdb_1_1KeySet.html">kdb::KeySet</a> orig)</div><div class="line">{</div><div class="line">        <a class="code" href="classkdb_1_1KeySet.html">kdb::KeySet</a> deepCopy;</div><div class="line">        orig.<a class="code" href="classkdb_1_1KeySet.html#a5bc5a16a726e959adaf3cf8506e7b849">rewind</a> ();</div><div class="line">        <span class="keywordflow">while</span> (orig.<a class="code" href="classkdb_1_1KeySet.html#affd52d130faf184361297f9e7f0c9f16">next</a> ())</div><div class="line">        {</div><div class="line">                deepCopy.<a class="code" href="classkdb_1_1KeySet.html#a0d4b2f3aa9f58d10053561135b50233e">append</a> (orig.<a class="code" href="classkdb_1_1KeySet.html#a0a0fc4efecd6dcbfde5fc35301b60349">current</a> ().<a class="code" href="classkdb_1_1Key.html#ababb1ccd9f18db379eb4a62f8db87bf5">dup</a> ());</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> deepCopy;</div><div class="line">}</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#ad3f2b936d66729690e8a8a45b5074baa" title="Duplicate a keyset. ">dup</a> </dd></dl>

</div>
</div>
<a id="a6191e93cdd67bbca63df934498d191ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6191e93cdd67bbca63df934498d191ba">&#9670;&nbsp;</a></span>KeySet() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new keyset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>minimum number of keys to allocate </td></tr>
    <tr><td class="paramname">...</td><td>variable argument list</td></tr>
  </table>
  </dd>
</dl>
<p>Allocate, initialize and return a new <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> object. Objects created with <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object. ">ksNew()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a>.</p>
<p>You can use an arbitrary long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be KS_END.</p>
<p>So, terminate with ksNew(0, KS_END) or ksNew(20, ..., KS_END)</p>
<dl class="section warning"><dt>Warning</dt><dd>Never use ksNew(0, keyNew(...), KS_END). If the first parameter is 0, other arguments are ignored.</dd></dl>
<p>The first parameter <code>alloc</code> defines how many keys can be added without reallocation. If you pass any alloc size greater than 0, but less than 16, it will default to 16.</p>
<p>For most uses</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// enough memory for up to 16 keys, without needing reallocation</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> will be fine. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large keysets.</p>
<p>You can defer the allocation of the internal array that holds the keys, by passing 0 as the alloc size. This is useful if it is unclear whether your keyset will actually hold any keys and you want to avoid a malloc call.</p>
<div class="fragment"><div class="line"><span class="comment">// Create KeySet without allocating memory for keys</span></div><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// The first allocation will happen in ksAppendKey</span></div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(keys, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, 0));</div><div class="line"><span class="comment">// work with the KeySet</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> But if you have any clue how large your keyset may be, you should read the next statements.</p>
<p>If you want a keyset with length 15 (because you know of your application that you only need up to 15 keys), use:</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (15, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key01&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value01&quot;</span>, 0),</div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, 0),</div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key03&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value03&quot;</span>, 0),</div><div class="line">                       <span class="comment">// ...</span></div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key15&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value15&quot;</span>, 0), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// work with it</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> If you start having 3 keys, and your application needs approximately 200 up to 500 keys, you can use:</p>
<div class="fragment"><div class="line">KeySet * config = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (500, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key1&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value1&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key2&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value2&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key3&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value3&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>); <span class="comment">// don&#39;t forget the KS_END at the end!</span></div><div class="line"><span class="comment">// work with it</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (config);</div></div><!-- fragment --><p> Alloc size is 500, the size of the keyset will be 3 after ksNew. This means the keyset will reallocate when appending more than 497 keys.</p>
<p>The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>. If you prefer, you can always create an empty <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> and use <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>.</p>
<dl class="section post"><dt>Postcondition</dt><dd>the keyset is rewinded properly</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a> to free the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a> afterwards </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a> to duplicate an existing <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a> to <a class="el" href="classkdb_1_1KeySet.html#a0d4b2f3aa9f58d10053561135b50233e" title="append a key ">append</a> individual keys </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>gives a hint for the size how many Keys may be stored initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready to use <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> object </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on memory error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>caller must call va_start and va_end </dd></dl>
<dl class="section user"><dt>va the list of arguments</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>the allocation size </td></tr>
    <tr><td class="paramname">va</td><td>the list of variable arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b2996803b9c9124cf791a1d738855c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b2996803b9c9124cf791a1d738855c">&#9670;&nbsp;</a></span>KeySet() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::KeySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkdb_1_1VaAlloc.html">VaAlloc</a>&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>av</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new keyset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>minimum number of keys to allocate </td></tr>
    <tr><td class="paramname">ap</td><td>variable arguments list</td></tr>
  </table>
  </dd>
</dl>
<p>Use va as first argument to use this constructor, e.g.: </p><div class="fragment"><div class="line">KeySet ks(va, 23, ...);</div></div><!-- fragment --><p>Allocate, initialize and return a new <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> object. Objects created with <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object. ">ksNew()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a>.</p>
<p>You can use an arbitrary long list of parameters to preload the keyset with a list of keys. Either your first and only parameter is 0 or your last parameter must be KS_END.</p>
<p>So, terminate with ksNew(0, KS_END) or ksNew(20, ..., KS_END)</p>
<dl class="section warning"><dt>Warning</dt><dd>Never use ksNew(0, keyNew(...), KS_END). If the first parameter is 0, other arguments are ignored.</dd></dl>
<p>The first parameter <code>alloc</code> defines how many keys can be added without reallocation. If you pass any alloc size greater than 0, but less than 16, it will default to 16.</p>
<p>For most uses</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// enough memory for up to 16 keys, without needing reallocation</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> will be fine. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large keysets.</p>
<p>You can defer the allocation of the internal array that holds the keys, by passing 0 as the alloc size. This is useful if it is unclear whether your keyset will actually hold any keys and you want to avoid a malloc call.</p>
<div class="fragment"><div class="line"><span class="comment">// Create KeySet without allocating memory for keys</span></div><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// The first allocation will happen in ksAppendKey</span></div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(keys, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, 0));</div><div class="line"><span class="comment">// work with the KeySet</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> But if you have any clue how large your keyset may be, you should read the next statements.</p>
<p>If you want a keyset with length 15 (because you know of your application that you only need up to 15 keys), use:</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (15, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key01&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value01&quot;</span>, 0),</div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, 0),</div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key03&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value03&quot;</span>, 0),</div><div class="line">                       <span class="comment">// ...</span></div><div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key15&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value15&quot;</span>, 0), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><span class="comment">// work with it</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div></div><!-- fragment --><p> If you start having 3 keys, and your application needs approximately 200 up to 500 keys, you can use:</p>
<div class="fragment"><div class="line">KeySet * config = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (500, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key1&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value1&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key2&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value2&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/sw/org/app/#0/current/fixedConfiguration/key3&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value3&quot;</span>, 0),</div><div class="line">                         <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>); <span class="comment">// don&#39;t forget the KS_END at the end!</span></div><div class="line"><span class="comment">// work with it</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (config);</div></div><!-- fragment --><p> Alloc size is 500, the size of the keyset will be 3 after ksNew. This means the keyset will reallocate when appending more than 497 keys.</p>
<p>The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>. If you prefer, you can always create an empty <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> and use <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>.</p>
<dl class="section post"><dt>Postcondition</dt><dd>the keyset is rewinded properly</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a> to free the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a> afterwards </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a> to duplicate an existing <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a> to <a class="el" href="classkdb_1_1KeySet.html#a0d4b2f3aa9f58d10053561135b50233e" title="append a key ">append</a> individual keys </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>gives a hint for the size how many Keys may be stored initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready to use <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> object </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on memory error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>caller must call va_start and va_end </dd></dl>
<dl class="section user"><dt>va the list of arguments</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>the allocation size </td></tr>
    <tr><td class="paramname">va</td><td>the list of variable arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade654f92bddec24abad1b651e828f2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade654f92bddec24abad1b651e828f2b8">&#9670;&nbsp;</a></span>~KeySet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::KeySet::~KeySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deconstruct a keyset. </p>
<p>A destructor for <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> objects. Cleans all internal dynamic attributes, decrement all reference pointers to all keys and then <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> all contained Keys, and elektraFree ()s the release the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> object memory (that was previously allocated by <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object. ">ksNew()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the keyset was freed </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object. ">ksNew()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0d4b2f3aa9f58d10053561135b50233e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4b2f3aa9f58d10053561135b50233e">&#9670;&nbsp;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::KeySet::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>toAppend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append a key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toAppend</td><td>key to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of keys in the keyset</dd></dl>
<p>Appends a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> to the end of <code>ks</code>. Hands the ownership of the key <code>toAppend</code> to the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> <code>ks</code>. ksDel(ks) uses keyDel(k) to delete every key unless it got its refcount incremented by <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a>, e.g. by another keyset that contains this key.</p>
<p>The reference counter of the key will be incremented to show this ownership, and thus <code>toAppend</code> is not const.</p>
<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a> will be shared.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae" title="Return how many references the key has. ">keyGetRef()</a>.</dd></dl>
<p>If the keyname already existed in the keyset, it will be replaced with the new key.</p>
<p><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a> will also lock the key's name from <code>toAppend</code>. This is necessary so that the order of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> cannot be destroyed via calls to <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a>.</p>
<p>The <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> internal cursor will be set to the new key.</p>
<p>It is safe to directly append newly created keys: </p><div class="fragment"><div class="line">KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (ks, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/my/new/key&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>));</div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks);</div><div class="line"><span class="comment">// key deleted, too!</span></div></div><!-- fragment --><p> If you want the key to outlive the keyset, make sure to do proper ref counting: </p><div class="fragment"><div class="line">KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/ref/key&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div><div class="line"><a class="code" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1">keyIncRef</a> (k);</div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (ks, k);</div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks);</div><div class="line"><span class="comment">// now we still can work with the key k!</span></div><div class="line"><a class="code" href="group__key.html#ga2c6433ca22109e4e141946057eccb283">keyDecRef</a> (k);</div><div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div></div><!-- fragment --><p> Or if you want to avoid aliasing at all, you can duplicate the key. But then key in the keyset has another identity: </p><div class="fragment"><div class="line">KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/ref/key&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (ks, <a class="code" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3">keyDup</a> (k));</div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks);</div><div class="line"><span class="comment">// now we still can work with the key k!</span></div><div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the size of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> after appending </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if appending failed (only on memory problems), the key will be deleted then. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td><a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> that will receive the key </td></tr>
    <tr><td class="paramname">toAppend</td><td><a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> that will be appended to ks or deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a>, <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a> </dd>
<dd>
<a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a> </dd></dl>

</div>
</div>
<a id="ac9cbdc933d7171037d47c6d4d78595d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cbdc933d7171037d47c6d4d78595d1">&#9670;&nbsp;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::KeySet::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>toAppend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>append a keyset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toAppend</td><td>keyset to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of keys in the keyset</dd></dl>
<p>Append all <code>toAppend</code> contained keys to the end of the <code>ks</code>. <code>toAppend</code> <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> will be left unchanged.</p>
<p>If a key is both in toAppend and ks, the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> in ks will be overridden.</p>
<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a> will be shared.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Sorted <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> ks with all keys it had before and additionally the keys from toAppend </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> after transfer </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> that will receive the keys </td></tr>
    <tr><td class="paramname">toAppend</td><td>the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> that provides the keys that will be transferred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a> </dd></dl>

</div>
</div>
<a id="a40e32f2d9f34f03fa8ec85945f49b630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e32f2d9f34f03fa8ec85945f49b630">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::at </td>
          <td>(</td>
          <td class="paramtype">elektraCursor&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup a key by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>cursor position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found key </dd></dl>

</div>
</div>
<a id="a38f5159e39758aa632421d2fe7440633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f5159e39758aa632421d2fe7440633">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the keyset. </p>
<p>Keyset will have no keys afterwards. </p>

</div>
</div>
<a id="a28fd33fdaecf1d57d4dddac7058f5d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fd33fdaecf1d57d4dddac7058f5d38">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a keyset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other keyset to copy</td></tr>
  </table>
  </dd>
</dl>
<p>This is only a shallow copy. For a deep copy you need to dup every key.</p>
<p>Replace the content of a keyset with another one. Most often you may want a duplicate of a keyset, see <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a> or append keys, see <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a>. But in some situations you need to copy a keyset to an existing keyset, for which this function exists.</p>
<dl class="section note"><dt>Note</dt><dd>You can also use it to clear a keyset when you pass a NULL pointer as <code>source</code>.</dd></dl>
<dl class="section user"><dt>Implementation:</dt><dd>First all keys in <code>dest</code> will be deleted. Afterwards the content of the source will be added to the destination and the <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> is set properly in <code>dest</code>.</dd></dl>
<p>A flat copy is made, so the keys will not be duplicated, but there reference counter is updated, so both keysets need to be <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a> will be shared.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f (KeySet *ks)</div><div class="line">{</div><div class="line">        KeySet *c = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (20, ..., <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line">        <span class="comment">// c receives keys</span></div><div class="line">        <a class="code" href="group__keyset.html#gaba1f1dbea191f4d7e7eb3e4296ae7d5e">ksCopy</a> (ks, c); <span class="comment">// pass the keyset to the caller</span></div><div class="line"></div><div class="line">        <a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (c);</div><div class="line">}       <span class="comment">// caller needs to ksDel (ks)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>has to be an initialized source <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> or NULL </td></tr>
    <tr><td class="paramname">dest</td><td>has to be an initialized <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> where to write the keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
    <tr><td class="paramname">0</td><td>if dest was cleared successfully (source is NULL) </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object. ">ksNew()</a>, <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a>, <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a> </dd>
<dd>
<a class="el" href="group__key.html#ga6a12cbbe656a1ad9f41b8c681d7a2f92" title="Copy or Clear a key. ">keyCopy()</a> for copying keys </dd></dl>

</div>
</div>
<a id="a0a0fc4efecd6dcbfde5fc35301b60349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0fc4efecd6dcbfde5fc35301b60349">&#9670;&nbsp;</a></span>current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a>. </p>
<p>The pointer is NULL if you reached the end or after <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>You must not delete the key or change the key, use <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a> if you want to delete it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> pointed by <code>ks's</code> cursor </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a>, <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a> </dd></dl>

</div>
</div>
<a id="ab283da798a7670d5c3f0e1a5b821e666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab283da798a7670d5c3f0e1a5b821e666">&#9670;&nbsp;</a></span>cut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a> kdb::KeySet::cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts out a keyset at the cutpoint. </p>
<p>Searches for the cutpoint inside the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> ks. If found it cuts out everything which is below (see <a class="el" href="group__keytest.html#ga03332b5d97c76a4fd2640aca4762b8df" title="Check if the key check is below the key key or not. ">keyIsBelow()</a>) this key. These keys will be missing in the keyset <code>ks</code>. Instead, they will be moved to the returned keyset. If <code>cutpoint</code> is not found an empty keyset is returned and <code>ks</code> is not changed.</p>
<p>The cursor will stay at the same key as it was before. If the cursor was inside the region of cut (moved) keys, the cursor will be set to the key before the cutpoint.</p>
<p>If you use <a class="el" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a" title="Cuts out a keyset at the cutpoint. ">ksCut()</a> on a keyset you got from <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> and plan to make a <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> later, make sure that you keep all keys that should not be removed permanently. You have to keep the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> that was returned and the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> <code>ks</code>.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<p>You have the keyset <code>ks:</code> </p><ul>
<li><code>system/mountpoint/interest</code> </li>
<li><code>system/mountpoint/interest/folder</code> </li>
<li><code>system/mountpoint/interest/folder/key1</code> </li>
<li><code>system/mountpoint/interest/folder/key2</code> </li>
<li><code>system/mountpoint/other/key1</code> </li>
</ul>
<p>When you use </p><div class="fragment"><div class="line">        Key * parentKey = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;system/mountpoint/interest&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div><div class="line">        KDB * kdb = <a class="code" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca">kdbOpen</a> (parentKey);</div><div class="line">        KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line">        <a class="code" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet</a> (kdb, ks, parentKey);</div><div class="line">        KeySet * returned = <a class="code" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a">ksCut</a> (ks, parentKey);</div><div class="line">        <a class="code" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet</a> (kdb, ks, parentKey); <span class="comment">// all keys below cutpoint are now removed</span></div><div class="line">        <a class="code" href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f">kdbClose</a> (kdb, parentKey);</div></div><!-- fragment --><p> Then in <code>returned</code> are:</p><ul>
<li><code>system/mountpoint/interest</code> </li>
<li><code>system/mountpoint/interest/folder</code> </li>
<li><code>system/mountpoint/interest/folder/key1</code> </li>
<li><code>system/mountpoint/interest/folder/key2</code> </li>
</ul>
<p>And in <code>ks</code> are:</p><ul>
<li><code>system/mountpoint/other/key1</code> </li>
</ul>
<p>So <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> permanently removes all keys below <code>system/mountpoint/interest</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> for explanation why you might <a class="el" href="classkdb_1_1KeySet.html#a65208974b44da0162ef70dd7a173748f" title="Generic lookup+get for keysets. ">get</a> more keys than you requested.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a new allocated <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> which needs to deleted with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a>. The keyset consists of all keys (of the original keyset ks) below the cutpoint. If the key cutpoint exists, it will also be appended. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on null pointers, no key name or allocation problems </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset to cut. It will be modified by removing all keys below the cutpoint. The cutpoint itself will also be removed. </td></tr>
    <tr><td class="paramname">cutpoint</td><td>the point where to cut out the keyset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3f2b936d66729690e8a8a45b5074baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f2b936d66729690e8a8a45b5074baa">&#9670;&nbsp;</a></span>dup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::KeySet * kdb::KeySet::dup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate a keyset. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the keys</dd></dl>
<p>This is only a shallow copy. For a deep copy you need to dup every key.</p>
<p>Return a duplicate of a keyset. Objects created with <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a>.</p>
<p>Memory will be allocated as needed for dynamic properties, so you need to <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a> the returned pointer.</p>
<p>A flat copy is made, so the keys will not be duplicated, but their reference counter is updated, so both keysets need <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>has to be an initialized source <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a flat copy of source on success </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object. ">ksNew()</a>, <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects. ">ksDel()</a> </dd>
<dd>
<a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> for <a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> duplication </dd></dl>

</div>
</div>
<a id="a65208974b44da0162ef70dd7a173748f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65208974b44da0162ef70dd7a173748f">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T kdb::KeySet::get </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370">KDB_O_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic lookup+get for keysets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the key name to get </td></tr>
    <tr><td class="paramname">options</td><td>the options to be passed to <a class="el" href="classkdb_1_1KeySet.html#a2b8537e388edfbb6941d771106c0ae3a" title="Look for a Key contained in ks that matches the name of the key. ">lookup()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyNotFoundException</td><td>if no key found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To specialize more complex types (which are generic themselves) you can also specialize KeySetTypeWrapper&lt;T&gt;.</dd></dl>
<p>Use </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="keysetget_8hpp.html">keysetget.hpp</a>&gt;</span></div></div><!-- fragment --><p> to include specializations for std types.</p>
<dl class="section return"><dt>Returns</dt><dd>the requested type </dd></dl>

</div>
</div>
<a id="accc11bcf2a4b5937ce9f0787c011c2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc11bcf2a4b5937ce9f0787c011c2d9">&#9670;&nbsp;</a></span>getCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">elektraCursor kdb::KeySet::getCursor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> internal cursor. </p>
<p>Use it to get the cursor of the actual position.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cursors are getting invalid when the key was <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a>ed or <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> with KDB_O_POP was used.</dd></dl>
<h1><a class="anchor" id="readahead"></a>
Read ahead</h1>
<p>With the cursors it is possible to read ahead in a keyset:</p>
<div class="fragment"><div class="line">elektraCursor jump;</div><div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (ks);</div><div class="line"><span class="keywordflow">while</span> ((key = <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (ks))!=0)</div><div class="line">{</div><div class="line">        <span class="comment">// now mark this key</span></div><div class="line">        jump = <a class="code" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">ksGetCursor</a>(ks);</div><div class="line"></div><div class="line">        <span class="comment">//code..</span></div><div class="line">        <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (ks); <span class="comment">// now browse on</span></div><div class="line">        <span class="comment">// use ksCurrent(ks) to check the keys</span></div><div class="line">        <span class="comment">//code..</span></div><div class="line"></div><div class="line">        <span class="comment">// jump back to the position marked before</span></div><div class="line">        <a class="code" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">ksSetCursor</a>(ks, jump);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="restore"></a>
Restoring state</h1>
<p>It can also be used to restore the state of a keyset in a function</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f (KeySet *ks)</div><div class="line">{</div><div class="line">        elektraCursor state = <a class="code" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">ksGetCursor</a>(ks);</div><div class="line"></div><div class="line">        <span class="comment">// work with keyset</span></div><div class="line"></div><div class="line">        <span class="comment">// now bring the keyset to the state before</span></div><div class="line">        <a class="code" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">ksSetCursor</a> (ks, state);</div><div class="line">}</div></div><!-- fragment --><p>It is of course possible to make the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> const and cast its const away to set the cursor. Another way to achieve the same is to <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a> the keyset, but it is not as efficient.</p>
<p>An invalid cursor will be returned directly after <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>. When you set an invalid cursor <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> is 0 and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> == <a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5" title="Return the first key in the KeySet. ">ksHead()</a>.</p>
<h1><a class="anchor" id="cursor_directly"></a>
Using Cursor directly</h1>
<p>You can also use the cursor directly by initializing it to some index in the Keyset and then incrementing or decrementing it, to iterate over the keyset.</p>
<div class="fragment"><div class="line">        Key * cur;</div><div class="line">        <span class="keywordflow">for</span> (elektraCursor cursor = 0; (cur = <a class="code" href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">ksAtCursor</a> (ks, cursor)) != NULL; ++cursor)</div><div class="line">        {</div><div class="line">                printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (cur));</div><div class="line">        }</div></div><!-- fragment --><p> You can also use a while loop if you need access to the last cursor position.</p>
<div class="fragment"><div class="line">        elektraCursor cursor = 0;</div><div class="line">        Key * cur;</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> ((cur = <a class="code" href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">ksAtCursor</a> (ks, cursor)) != 0)</div><div class="line">        {</div><div class="line">                printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (cur));</div><div class="line">                ++cursor;</div><div class="line">        }</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Only use a cursor for the same keyset which it was made for.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid cursor on success </dd>
<dd>
an invalid cursor on NULL pointer or after <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a>, <a class="el" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f" title="Set the KeySet internal cursor. ">ksSetCursor()</a> </dd></dl>

</div>
</div>
<a id="a4e9a3906e0b18a783f8a6e8bdbec9ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9a3906e0b18a783f8a6e8bdbec9ed0">&#9670;&nbsp;</a></span>getKeySet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::KeySet * kdb::KeySet::getKeySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Passes out the raw keyset pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to internal ckdb <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02" title="If you don&#39;t want destruction of keyset at the end you can release the pointer. ">release()</a> </dd>
<dd>
<a class="el" href="classkdb_1_1KeySet.html#a9f3ec4eebe304185527b08a6fa01b77c" title="Take ownership of passed keyset. ">setKeySet()</a> </dd></dl>

</div>
</div>
<a id="a1aca3689ed08cbc909976cdf874cfb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aca3689ed08cbc909976cdf874cfb59">&#9670;&nbsp;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::head </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first key in the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>alphabetical first key</dd></dl>
<p>The KeySets cursor will not be affected.</p>
<p>If <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a>==<a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5" title="Return the first key in the KeySet. ">ksHead()</a> you know you are on the first key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> of a keyset </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer or empty keyset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e" title="Return the last key in the KeySet. ">ksTail()</a> for the last <a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> for iterating over the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a> </dd></dl>

</div>
</div>
<a id="a2b8537e388edfbb6941d771106c0ae3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8537e388edfbb6941d771106c0ae3a">&#9670;&nbsp;</a></span>lookup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370">KDB_O_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look for a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> contained in <code>ks</code> that matches the name of the <code>key</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Applications should only use <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> with cascading keys (key name starting with <code>/</code>). Furthermore, a lookup should be done for every key (also when iterating over keys) so that the specifications are honored correctly. Keys of all namespaces need to be present so that <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> can work correctly, so make sure to also use <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> with a cascading key.</dd></dl>
<p><code><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a></code> is designed to let you work with a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> containing all keys of the application. The idea is to fully <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> the whole configuration of your application and process it all at once with many <code><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a></code>.</p>
<p>This function is efficient (at least using binary search). Together with <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> which can you load the whole configuration you can write very effective but short code for configuration:</p>
<div class="fragment"><div class="line">Key * key = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;/sw/tests/myapp/#0/current/&quot;</span>,  <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div><div class="line">KDB * handle = <a class="code" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca">kdbOpen</a> (key);</div><div class="line"><a class="code" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet</a> (handle, myConfig, key);</div><div class="line">Key * result = <a class="code" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83">ksLookupByName</a> (myConfig, <span class="stringliteral">&quot;/sw/tests/myapp/#0/current/testkey1&quot;</span>, 0);</div></div><!-- fragment --><p> This is the way programs should get their configuration and search after the values. It is guaranteed that more namespaces can be added easily and that all values can be set by admin and user. Furthermore, using the kdb-tool, it is possible to introspect which values an application will get (by doing the same cascading lookup).</p>
<p>If found, <code>ks</code> internal cursor will be positioned in the matched key (also accessible by <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a>), and a pointer to the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> is returned. If not found, <code>ks</code> internal cursor will not move, and a NULL pointer is returned.</p>
<p>Cascading lookups will by default search in all namespaces (proc/, dir/, user/ and system/), but will also correctly consider the specification (=metadata) in spec/:</p>
<ul>
<li><code>override/#</code> will make sure that another key is considered before</li>
<li><code>namespace/#</code> will change the number and/or order in which the namespaces are searched</li>
<li><code>fallback/#</code> will search for other keys when the other possibilities up to now were not successful</li>
<li><code>default</code> to return the given value when not even <code>fallback</code> keys were found.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>override and fallback work recursively, while default does not.</dd></dl>
<p>This process is very flexible, but it would be boring to manually follow all this links to find out which key will be taken in the end. Use <code>kdb get -v</code> to trace the keys.</p>
<dl class="section user"><dt>KDB_O_POP</dt><dd>When <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984" title="Pop Parent out of keyset key in ksLookup(). ">KDB_O_POP</a> is set the key which was found will be <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a>ed. <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> will not be changed, only iff <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> is the searched key, then the keyset will be <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>ed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Like in <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a> the popped key always needs to be <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> afterwards, even if it is appended to another keyset.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All cursors on the keyset will be invalid iff you use <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984" title="Pop Parent out of keyset key in ksLookup(). ">KDB_O_POP</a>, so don't use this if you rely on a cursor, see <a class="el" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7" title="Get the KeySet internal cursor. ">ksGetCursor()</a>.</dd></dl>
<p>The invalidation of cursors does not matter if you use multiple keysets, e.g. by using <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a keyset. ">ksDup()</a>. E.g., to separate <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> with <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984" title="Pop Parent out of keyset key in ksLookup(). ">KDB_O_POP</a> and <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f (KeySet * iterator, KeySet * lookup)</div><div class="line">{</div><div class="line">        KeySet * append = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (<a class="code" href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">ksGetSize</a> (lookup), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line">        Key * <a class="code" href="classkdb_1_1KeySet.html#a0a0fc4efecd6dcbfde5fc35301b60349">current</a>;</div><div class="line"></div><div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (iterator);</div><div class="line">        <span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (iterator)))</div><div class="line">        {</div><div class="line">                Key * key = <a class="code" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f">ksLookup</a> (lookup, current, <a class="code" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984">KDB_O_POP</a>);</div><div class="line">                <span class="comment">// do something...</span></div><div class="line">                <a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (append, key); <span class="comment">// now append it to append, not lookup!</span></div><div class="line">                <a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (key);              <span class="comment">// make sure to ALWAYS delete poped keys.</span></div><div class="line">        }</div><div class="line">        <a class="code" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend</a> (lookup, append);</div><div class="line">        <span class="comment">// now lookup needs to be sorted only once, append never</span></div><div class="line">        <a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (append);</div><div class="line">}</div></div><!-- fragment --><p> This is also a nice example how a complete application with <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> can look like.</p>
<dl class="section user"><dt>KDB_O_DEL</dt><dd>Passing <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a66a5380c120f25f28f49848c4a863ead" title="Delete parentKey key in ksLookup(). ">KDB_O_DEL</a> will cause the deletion of the parameter <code>key</code> using <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a>.</dd></dl>
<dl class="section user"><dt>Hybrid search</dt><dd>When Elektra is compiled with <code>ENABLE_OPTIMIZATIONS=ON</code> a hybrid search decides dynamically between the binary search and the <a href="https://master.libelektra.org/doc/dev/data-structures.md#order-preserving-minimal-perfect-hash-map-aka-opmphm">OPMPHM</a>. The hybrid search can be overruled by passing <a class="el" href="group__proposal.html#gga93673533c4c8eb1fdfca76b98c5f49b0afe9f6ff6e374540baf600a918b07ee6e" title="Overrule ksLookup search predictor to use OPMPHM, make sure to set ENABLE_OPTIMIZATIONS=ON at cmake...">KDB_O_OPMPHM</a> or <a class="el" href="group__proposal.html#gga93673533c4c8eb1fdfca76b98c5f49b0ac67a43bd273203575090d26010f6c995" title="Overrule ksLookup search predictor to use Binary search for lookup. ">KDB_O_BINSEARCH</a> in the options to <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>where to look for </td></tr>
    <tr><td class="paramname">key</td><td>the key object you are looking for </td></tr>
    <tr><td class="paramname">options</td><td>of type <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914" title="Options to change the default behavior of ksLookup() functions. ">elektraLookupFlags</a> with some <code>KDB_O_*</code> option bits as explained above </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> found, 0 otherwise </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83" title="Convenience method to look for a Key contained in ks that matches name. ">ksLookupByName()</a> to search by a name given by a string </dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a>, <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>, <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> for iterating over a <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>That the internal key cursor will point to the found key </dd></dl>

</div>
</div>
<a id="a0ef071747608900be478219e4a040612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef071747608900be478219e4a040612">&#9670;&nbsp;</a></span>lookup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::lookup </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370">KDB_O_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup a key by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name to look for </td></tr>
    <tr><td class="paramname">options</td><td>some options to pass</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found key </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a2b8537e388edfbb6941d771106c0ae3a" title="Look for a Key contained in ks that matches the name of the key. ">lookup</a> (const <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> &amp;<a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a>, const <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914" title="Options to change the default behavior of ksLookup() functions. ">elektraLookupFlags</a> options)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>That the internal key cursor will point to the found key </dd></dl>

</div>
</div>
<a id="affd52d130faf184361297f9e7f0c9f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd52d130faf184361297f9e7f0c9f16">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> in a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>. </p>
<p>KeySets have an internal cursor that can be reset with <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>. Every time <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> is called the cursor is incremented and the new current <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> is returned.</p>
<p>You'll get a NULL pointer if the key after the end of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> was reached. On subsequent calls of <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> it will still return the NULL pointer.</p>
<p>The <code>ks</code> internal cursor will be changed, so it is not const.</p>
<dl class="section note"><dt>Note</dt><dd>You must not delete or change the key, use <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a> if you want to delete it.</dd>
<dd>
That applications must do <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> with an cascading key for every single key before using it, because specifications allow to hide or override keys.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new current <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the end is reached </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> </dd>
<dd>
<a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> to honor specifications </dd></dl>

</div>
</div>
<a id="a1c54736b7206bc2253d02a5bf4b3ccfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c54736b7206bc2253d02a5bf4b3ccfb">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a> &amp; kdb::KeySet::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkdb_1_1KeySet.html">KeySet</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate a keyset. </p>
<p>This keyset will be a duplicate of the other afterwards.</p>
<dl class="section note"><dt>Note</dt><dd>that they still reference to the same Keys, so if you change key values also the keys in the original keyset will be changed. </dd></dl>

</div>
</div>
<a id="a7f207457a1c12633a1a5301a3a1bbaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f207457a1c12633a1a5301a3a1bbaed">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and return the last key of <code>ks</code>. </p>
<p>The reference counter will be decremented by one.</p>
<p>The KeySets cursor will not be affected if it did not point to the popped key.</p>
<dl class="section note"><dt>Note</dt><dd>You need to <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> the key afterwards, if you don't append it to another keyset. It has the same semantics like a key allocated with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> or <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a>.</dd></dl>
<div class="fragment"><div class="line">ks1=<a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line">ks2=<a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div><div class="line"></div><div class="line">k1=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/name&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>); <span class="comment">// ref counter 0</span></div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks1, k1); <span class="comment">// ref counter 1</span></div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks2, k1); <span class="comment">// ref counter 2</span></div><div class="line"></div><div class="line">k1=<a class="code" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop</a> (ks1); <span class="comment">// ref counter 1</span></div><div class="line">k1=<a class="code" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop</a> (ks2); <span class="comment">// ref counter 0, like after keyNew()</span></div><div class="line"></div><div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks1, k1); <span class="comment">// ref counter 1</span></div><div class="line"></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks1); <span class="comment">// key is deleted too</span></div><div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks2);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the last key of <code>ks</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if <code>ks</code> is empty or on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td><a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> to <a class="el" href="classkdb_1_1KeySet.html#a7f207457a1c12633a1a5301a3a1bbaed" title="Remove and return the last key of ks. ">pop</a> keys by name </dd>
<dd>
<a class="el" href="group__keyset.html#gaba1f1dbea191f4d7e7eb3e4296ae7d5e" title="Replace the content of a keyset with another one. ">ksCopy()</a> to <a class="el" href="classkdb_1_1KeySet.html#a7f207457a1c12633a1a5301a3a1bbaed" title="Remove and return the last key of ks. ">pop</a> all keys </dd>
<dd>
commandList() for an example </dd></dl>

</div>
</div>
<a id="a5bc5a16a726e959adaf3cf8506e7b849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc5a16a726e959adaf3cf8506e7b849">&#9670;&nbsp;</a></span>rewind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::rewind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewinds the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> internal cursor. </p>
<p>Use it to set the cursor to the beginning of the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>. <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> will then always return NULL afterwards. So you want to <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> first.</p>
<div class="fragment"><div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (ks);</div><div class="line"><span class="keywordflow">while</span> ((key = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (ks))!=0) {}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> </dd></dl>

</div>
</div>
<a id="aa36d35d8f12233a4c8f88d9bb13429c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36d35d8f12233a4c8f88d9bb13429c3">&#9670;&nbsp;</a></span>setCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::setCursor </td>
          <td>(</td>
          <td class="paramtype">elektraCursor&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> internal cursor. </p>
<p>Use it to set the cursor to a stored position. <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> will then return the key at the position of the supplied cursor.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cursors may get invalid when the key was <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a>ed or <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> was used together with KDB_O_POP.</dd></dl>
<div class="fragment"><div class="line">elektraCursor cursor;</div><div class="line">..</div><div class="line"><span class="comment">// key now in any position here</span></div><div class="line">cursor = <a class="code" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">ksGetCursor</a> (ks);</div><div class="line"><span class="keywordflow">while</span> ((key = <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (ks))!=0) {}</div><div class="line"><a class="code" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">ksSetCursor</a> (ks, cursor); <span class="comment">// reset state</span></div><div class="line"><a class="code" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent</a>(ks); <span class="comment">// in same position as before</span></div></div><!-- fragment --><p>An invalid cursor will set the keyset to its beginning like <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>. When you set an invalid cursor <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> is 0 and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> == <a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5" title="Return the first key in the KeySet. ">ksHead()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>the cursor to use </td></tr>
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the keyset is <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>ed </td></tr>
    <tr><td class="paramname">1</td><td>otherwise </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a>, <a class="el" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7" title="Get the KeySet internal cursor. ">ksGetCursor()</a> </dd></dl>

</div>
</div>
<a id="a9f3ec4eebe304185527b08a6fa01b77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3ec4eebe304185527b08a6fa01b77c">&#9670;&nbsp;</a></span>setKeySet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::KeySet::setKeySet </td>
          <td>(</td>
          <td class="paramtype">ckdb::KeySet *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take ownership of passed keyset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the keyset to take ownership from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1KeySet.html#a2987b3fb1b12196399650726f1c18f02" title="If you don&#39;t want destruction of keyset at the end you can release the pointer. ">release()</a> </dd>
<dd>
<a class="el" href="classkdb_1_1KeySet.html#a4e9a3906e0b18a783f8a6e8bdbec9ed0" title="Passes out the raw keyset pointer. ">getKeySet()</a> </dd></dl>

</div>
</div>
<a id="ab01c5c46e4c0802560b8f15886af89c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01c5c46e4c0802560b8f15886af89c4">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::KeySet::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the keyset. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of keys in the keyset </dd></dl>

</div>
</div>
<a id="a16deed50e0d8cfee023d4423a119df51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16deed50e0d8cfee023d4423a119df51">&#9670;&nbsp;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> kdb::KeySet::tail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last key in the <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>alphabetical last key</dd></dl>
<p>The KeySets cursor will not be affected.</p>
<p>If <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a>==<a class="el" href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e" title="Return the last key in the KeySet. ">ksTail()</a> you know you are on the last key. <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> will return a NULL pointer afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> of a keyset </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer or empty keyset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5" title="Return the first key in the KeySet. ">ksHead()</a> for the first <a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> for iterating over the <a class="el" href="group__keyset.html" title="Methods to manipulate KeySets. ">KeySet</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="keyset_8hpp.html">keyset.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
