<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: 0.8.15 Release</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">0.8.15 Release </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>guid: 1ab4a560-c286-46d2-a058-1a8e7e208fe8</li>
<li>author: Markus Raab</li>
<li>pubDate: Tue, 16 Feb 2016 17:47:00 +0100</li>
<li>shortDesc: adds improved mounting, split of library &amp; configuration validation</li>
</ul>
<p>In case you do not yet know about it, here is an abstract about Elektra:</p>
<p>Elektra serves as a universal and secure framework to access configuration parameters in a global, hierarchical key database. Elektra provides a mature, consistent and easily comprehensible API. Its modularity effectively avoids code duplication across applications and tools regarding configuration tasks. Elektra abstracts from cross-platform-related issues and allows applications to be aware of other applications' configurations, leveraging easy application integration.</p>
<p>See <a href="https://libelektra.org">https://libelektra.org</a></p>
<p>This is one of the largest release up to now. It includes many user-visible improvements. Some highlights:</p>
<ul>
<li>Mounting is vastly improved: think about Debian's "dpkg" to "apt"-like functionality</li>
<li>In previous releases you could already specify the structure of the configuration. Now you can also automatically enforce this property.</li>
<li>We split the shared library <code>libelektra</code> into smaller parts. Now users can link against the parts of the library they need.</li>
<li>As always, the ABI and API is fully forward-compatible.</li>
<li>The release contains improvements in the https://github.com/ElektraInitiative/libelektra/blob/master/doc/decisions/bootstrap.md "bootstrapping process".</li>
<li>We improved the <code>ini</code>, <code>rename</code> and <code>crypto</code> plugins.</li>
<li>The tool <code>kdb</code> now supports bookmarks and profiles.</li>
<li>The new tool <code>kdb editor</code> allows you to edit KDB configuration in your favorite text editor.</li>
<li>We are glad of the new packages for Debian, Arch Linux and OpenWRT.</li>
</ul>
<p>The same text as follows is also available <a href="https://doc.libelektra.org/news/1ab4a560-c286-46d2-a058-1a8e7e208fe8.html">here as html</a> and https://github.com/ElektraInitiative/libelektra/blob/master/doc/news/2016-02-16_0.8.15.md "here on github"</p>
<p>Sometimes you simply want some functionality for the whole key database. For example, you want to enable logging or notification of configuration changes. In previous versions, you had to change every mountpoint individually. Even more problematic, every mountpoint created its individual logs and notifications, without any way for someone to know if an application has issued its last log/notification.</p>
<p>These problems are now solved by global plugins. The same plugins are reused for this purpose. Also the mounting works nearly in the same way, you only have to omit the configuration file and the mountpoint:</p>
<div class="fragment"><div class="line">kdb global-mount syslog journald dbus</div></div><!-- fragment --><p>Voil√†, from now on every configuration change gets logged to syslog and journald. Additionally, every application gets notified via dbus.</p>
<p>If you want it more verbose for debugging, you can easily do so by:</p>
<div class="fragment"><div class="line">kdb global-mount logchange counter</div></div><!-- fragment --><p>Which gives you detailed information to standard output which keys were changed/edited/deleted. Additionally, Elektra counts how often the <code>counter</code> plugin is invoked.</p>
<p>The underlying work for the global plugins, i.e. hooks in the core libraries and the <code>list</code> plugin that allows us to use many plugins without bloating the core was done by Thomas Waser.</p>
<p>It was already possible in earlier versions of Elektra to specify the configuration of your program. Until now, this specification could be mainly used to to generate code as described <a href="https://master.libelektra.org/src/tools/pythongen">here</a>. This release adds two more interesting options:</p>
<ol type="1">
<li>the spec plugin, and</li>
<li>the spec mount.</li>
</ol>
<p>The most important global plugin that is now newly introduced with this release (thanks to Thomas Waser) is the <code>spec</code> plugin. By default it will be added for every global-mount. So for a new installation make sure you executed at least once:</p>
<div class="fragment"><div class="line">kdb global-mount</div></div><!-- fragment --><p>The spec plugin is a global plugin that copies metadata from the <code>spec</code>-namespace to other namespaces. That means, it reads the specification, and makes sure that the configuration conforms to it. The actual validation is done by the many validation plugins already present.</p>
<p>Lets start by saying a key is a long and must have at least the value 10:</p>
<div class="fragment"><div class="line">kdb setmeta spec/example/longkey check/type long</div></div><!-- fragment --><p>Then we can create a key in a different namespace and see if the <code>spec</code> plugin applies the metadata correctly:</p>
<div class="fragment"><div class="line">kdb set /example/longkey 25</div><div class="line">kdb lsmeta /example/longkey</div></div><!-- fragment --><p>Should now at least print <code>check/type</code>. By itself, this is useful for documentation of keys. For example, the application developer says:</p>
<div class="fragment"><div class="line">kdb setmeta spec/example/longkey description &quot;Do not change&quot;</div><div class="line">kdb setmeta spec/example/longkey example 30</div></div><!-- fragment --><p>The user can retrieve this documentation by:</p>
<div class="fragment"><div class="line">kdb getmeta /example/longkey description</div></div><!-- fragment --><p>But we want <code>check/type</code> to be not only a documentation, but also enforced.</p>
<p>Using <code>kdb setmeta</code> extensively and always looking out that all plugins are mounted correctly is error-prone. So instead, one can directly mount the plugins as specified. For the example above one simply needs:</p>
<div class="fragment"><div class="line">kdb setmeta spec/example mountpoint example.ecf</div><div class="line">kdb spec-mount /example</div></div><!-- fragment --><p>Now, when we try to modify <code>/example/longkey</code> it will be validated:</p>
<div class="fragment"><div class="line">kdb set /example/longkey a</div><div class="line">#&gt; Error (#52) [...] long [not] matched [...] a</div></div><!-- fragment --><p>Based on the present metadata, the correct plugins (in this case <code>type</code> because of the metadata <code>check/type</code>) will be loaded.</p>
<p>We can also create a whole specification file, first mount the specification and then the mountpoint according the specification, e.g when we have <code>battery.ini</code> in the folder <code>$(dirname $(kdb file spec))</code> with following content:</p>
<div class="fragment"><div class="line">[]</div><div class="line">mountpoint = battery.ini</div><div class="line">infos/plugins = ini</div><div class="line"></div><div class="line">[level]</div><div class="line">check/enum = &#39;critical&#39;, &#39;low&#39;, &#39;high&#39;, &#39;full&#39;</div></div><!-- fragment --><p>Then we can use:</p>
<div class="fragment"><div class="line"># mount the file itself:</div><div class="line">kdb mount battery.ini spec/example/battery ni</div><div class="line"># make sure all plugins are present (e.g. enum for check/enum):</div><div class="line">kdb spec-mount /example/battery</div></div><!-- fragment --><p>Now lets verify if it worked:</p>
<div class="fragment"><div class="line">kdb lsmeta /example/battery/level</div><div class="line"># we see it has a check/enum</div><div class="line">kdb getmeta /example/battery/level check/enum</div><div class="line"># now we know allowed values</div><div class="line">kdb set /example/battery/level low</div><div class="line"># success, low is ok!</div><div class="line">kdb set /example/battery/level wrong</div><div class="line"># fails, not one of the allowed values!</div></div><!-- fragment --><p>The main idea of the spec-mount is: search a plugin for every specification (metadata) found in the spec-namespace.</p>
<p>In earlier versions <code>kdb mount</code> failed when plugin dependencies were not satisfied. Now dependencies will automatically be fulfilled, e.g.</p>
<div class="fragment"><div class="line">kdb mount /etc/modules system/modules line</div></div><!-- fragment --><p>In earlier versions you would have got an error because of the missing <code>null</code> plugin. Now it simply adds the needed plugins.</p>
<p>The plugins given in the command-line used to be real plugins. Now also so called providers are accepted.</p>
<p>To make providers useful we need to actually know which plugin is the best candidate. To get the information we added a <code>infos/status</code> clause in the contract. In this clause the plugin developer adds many details how well the plugin is tested, reviewed, documented, maintained and so on. Based on this information, the best suited plugin will be chosen. For example, you now can use:</p>
<div class="fragment"><div class="line">kdb mount /etc/security/limits.conf system/limits augeas \</div><div class="line">        lens=Limits.lns logging</div></div><!-- fragment --><p>And the best suitable logger will automatically be chosen.</p>
<p>The configuration variable <code>/sw/kdb/current/plugins</code> now allows us to pass plugin configuration with the same syntax as the plugin specification passed on the commandline. A subtle difference is that thus the shell-splitting of arguments is missing, it is not possible to include whitespaces in the plugin configuration that way.</p>
<p>Now it is also possible to include the same plugin multiple times and also give them individual names. This feature is essential for script-based plugins, e.g. you now might add:</p>
<div class="fragment"><div class="line">kdb mount file.x /example/mountpoint \</div><div class="line">        lua#resolver script=resolver.lua \</div><div class="line">        lua#storage script=storage.lua</div></div><!-- fragment --><p>Furthermore, <code>kdb mount</code> now supports recommendations, which can be enabled with <code>--with-recommends</code>. E.g. supplied to the mount command using augeas above, comments will automatically transformed to metadata to avoid cluttering of the real configuration.</p>
<p>Up to now, Elektra consisted only of a single shared library, <code>libelektra.so</code>. Not all symbols in it were relevant to end users, for example, some were only needed by plugins. Others were only proposed and not yet part of the stable API. And finally, other symbols were not needed in some situations, e.g. the plugins do not need the <code>kdb</code> interface.</p>
<p>Thus, we split <code>libelektra.so</code>, so that only coherent parts are in the same library:</p>
<ul>
<li><code>libelektra-core.so</code> only contains the <code>KeySet</code> data structure and module loading. Every binary using Elektra should link against it.</li>
<li><code>libelektra-kdb.so</code> contains the missing <code>KDB</code> symbols. Together with the <code>core</code> they contain everything declared in <code>kdb.h</code>. Michael Zehender plans to have multiple variants of <code>libelektra-kdb.so</code> that use different kinds of concurrency. Headerfile: <code>&lt;kdb.h&gt;</code></li>
<li><code>libelektra-ease.so</code> adds functionality missing in <code>core</code> to make the life for C programmers easier. New headerfile: <code>kdbease.h</code></li>
<li><code>libelektra-proposal.so</code> adds functionality proposed for <code>core</code>. It directly uses internal structures of <code>core</code>, thus they always need to have exactly the same version. Headerfile: <code><a class="el" href="kdbproposal_8h.html" title="Proposed declarations. ">kdbproposal.h</a></code></li>
</ul>
<p>The source code is now better organized by the introduction of a <code>libs</code> folder. The explanation of every library can be found in <a href="https://github.com/ElektraInitiative/libelektra/tree/master/src/libs">/src/libs/</a>.</p>
<p>The rationale of the library split is documented https://github.com/ElektraInitiative/libelektra/blob/master/doc/decisions/library_split.md "here". Shortly put, it was needed for further evolution and allowing us to grow and enhance without getting a fat core.</p>
<p>Thanks to Manuel Mausz for fixing many bugs related to the library split and also adapting all the bindings for it.</p>
<p>To show that the split does not make Elektra slower, Mihael Pranjiƒá made a small benchmark. The real time of <a href="https://github.com/ElektraInitiative/libelektra/blob/master/benchmarks/large.c">benchmarks/large</a> and revision 634ad924109d3cf5d9f83c33aacfdd341b8de17a</p>
<ol type="1">
<li>kdb-static: Median :0.8800</li>
<li>kdb-full: Median :0.8700</li>
<li>kdb: Median :0.8700</li>
</ol>
<p>So it seems that the split does not influence the time of running elektrified processes.</p>
<p><em>Times were measured with time(1) and the median is calculated for 21 runs of benchmarks/large. This was done using <a href="https://github.com/ElektraInitiative/libelektra/blob/524397669f800cb76b742514fd3aaae7a58a07da/scripts/benchmark_libsplit.sh">scripts/benchmark_libsplit.sh</a></em></p>
<p>As always, the ABI and API is fully forward-compatible, i.e. programs compiled against an older 0.8 version of Elektra will continue to work (ABI) and you will be able to recompile every program without errors (API).</p>
<p>We added <code>keyGetNamespace</code> which allows us to handle all namespaces in a switch and to iterate all namespaces. This is essential, when a new namespace is added, thus then the compiler can warn you about every part where the new namespace is not yet considered. We currently do not plan to add a new namespace, but better be safe than sorry.</p>
<p>The internal function <code>keyCompare</code> now also detects any metadata change.</p>
<p>libtools was nearly rewritten. Even though it is mostly API compatible (you should not use the low-level <code>Backend</code> anymore but instead use the <code>BackendBuilder</code>), it is certainly not ABI compatible. If you have an undefined symbol: <code>_ZN3kdb5tools7Backend9addPluginESsNS_6KeySetE</code> you need to recompile your tool. Even the merging part has ABI incompatibility (different size of <code>_ZTVN3kdb5tools7merging14NewKeyStrategyE</code>). Unfortunately, we still cannot guarantee compatibility in <code>libtools</code>, further changes are planned (e.g. implementing mounting of lazy plugins).</p>
<p>The python(2) and lua interfaces changed, an additional argument (the plugin configuration) is passed to <code>open</code>.</p>
<p>The INI plugin was rewritten, so many options changed in incompatible ways.</p>
<p>The default format plugin (e.g. for import/export) is no longer hard coded to be <code>dump</code>. Instead KDB_DEFAULT_STORAGE will be used. To get KDB_DEFAULT_STORAGE you can use the constants plugin:</p>
<div class="fragment"><div class="line">kdb mount-info</div><div class="line">kdb get system/info/elektra/constants/cmake/KDB_DEFAULT_STORAGE</div></div><!-- fragment --><p>Thanks to Manuel Mausz plugins do no longer export any method other than <code>elektraPluginSymbol</code>. It now will fail if you directly linked against plugins and did not correctly use their public interface. Please use the module loading and access functions via the contract.</p>
<p>The CMake and Pkgconfig Files now only link against <code>elektra-core</code> and <code>elektra-kdb</code>. If you used some symbols not present in <code>kdb.h</code>, your application might not work anymore.</p>
<p><code>libelektra.so</code> is still present for compatibility reasons. It should not be used for new applications. Some unimportant parts, however, moved to the "sugar" libraries. E.g. the symbol <code>elektraKeyCutNamePart</code> is no longer part of <code>libelektra.so</code>.</p>
<p>When you use <code>kdbOpen</code> in Elektra as first step it reads mountpoint configuration from <code>/elektra</code>. This step is the only hard coded one, and all other places of the KDB's tree can be customized as desired via mounting.</p>
<p>The bootstrapping now changed, so that <code>/elektra</code> is not part of the default configuration <code>default.ecf</code> (or as configured with <code>KDB_DB_FILE</code>), but instead we use <code>elektra.ecf</code> (or as configured with <code>KDB_DB_INIT</code>). This behaviour solves the problem that <code>default.ecf</code> was read twice (and even differently, once for <code>/elektra</code> and once for <code>/</code>).</p>
<p>To be fully compatible with previous mountpoints, Elektra will still read mountpoints from <code>default.ecf</code> as long as <code>elektra.ecf</code> is not present.</p>
<p>To migrate the mountpoints to the new method, simply use:</p>
<div class="fragment"><div class="line">kdb upgrade-bootstrap</div></div><!-- fragment --><p>which basically exports <code>system/elektra/mountpoints</code>, then does <code>kdb rm -r system/elektra/mountpoints</code> so that <code>default.ecf</code> will be without an mountpoint and thus the compatibility mode does not apply anymore. As last step it will import again what it exported before.</p>
<p>https://github.com/ElektraInitiative/libelektra/blob/master/doc/decisions/bootstrap.md "Details are here"</p>
<p>We already highlighted the new <code>spec</code> plugin, but also other plugins were improved at many places. Small other changes are:</p>
<ul>
<li>Conditionals now also support <code>assign/condition</code> syntax, thanks to Thomas Waser</li>
<li>Lua and Python are not tagged experimental anymore. They now correctly add their configuration to the open-call.</li>
<li>The plugin <code>yajl</code> (the json parser and generator) now also accepts the type <code>string</code> and yields better warnings on wrong types.</li>
<li>Improved error message in the <code>type</code> plugin.</li>
</ul>
<p>Larger changes were done in the following plugins:</p>
<p>The INI plugin was rewritten and a huge effort was taken so that it fully-roundtrips and additionally preserves all comments and ordering. Currently, it is brand new. It is planned that it will replace <code>dump</code> in the future.</p>
<p>Currently is has some minor problems when used as KDB_DEFAULT_STORAGE. You can avoid most problems by mounting a different file into root:</p>
<div class="fragment"><div class="line">kdb mount root.ini /</div></div><!-- fragment --><p>Read <a href="https://github.com/ElektraInitiative/libelektra/tree/master/src/plugins/ini">here about the details</a>.</p>
<p>A huge thanks to Thomas Waser.</p>
<p>Thanks to Thomas Waser <code>rename</code> is now fixed for cascading keys. Additionally, it does not change the <code>sync</code> status of the keys so that notification plugins work properly afterwards.</p>
<p>The crypto plugin is a facility for securing sensitive Keys by symmetric encryption of the value. It acts as a filter plugin and it will only operate on Keys, which have the meta-key ‚Äûcrypto/encrypt‚Äú set.</p>
<p>The key derivation is still work-in-progress, so the plugin does not work with kdb yet. A planned method for key derivation is to utilize the gpg-agent.</p>
<p>For now the plugin requires the following Keys within the plugin configuration in order to work properly:</p>
<ol type="1">
<li>/crypto/key - the cryptographic key (binary 256 bit long)</li>
<li>/crypto/iv - the initialization vector (binary 128 bit long)</li>
</ol>
<p>Please note that this method of key input is for testing purposes only and should never be used in a productive environment!</p>
<p>Thanks to Peter Nirschl, especially the patience for also supporting different platforms where dependencies need to be handled differently.</p>
<p>A technical preview of a new tool was added: <code>kdb editor</code> allows you to edit any part of Elektra‚Äôs configuration with any editor and any syntax. It uses 3-way merging and other stable technology, but it currently does not provides a way to abort editing. So you only should use it with care.</p>
<p>The tool <code>kdb list</code> now searches in the rpath for libraries and thus will also find plugins not present at compile time (using <code>glob</code>). Additionally, it sorts the plugins by <code>infos/status</code> score, which can also be printed with <code>-v</code>. The last plugins printed are the ones ranked highest.</p>
<p>When running as root, <code>kdb</code> will now use the <code>system</code> namespace when writing configuration to cascading key names.</p>
<p>Long paths are cumbersome to enter in the CLI. Thus one can define bookmarks now. Bookmarks are key names that start with <code>+</code>. They are only recognized by the <code>kdb</code> tool or tools that explicitly have support for it. Applications should not depend on the presence of a bookmark. For example, if you set the bookmark kdb:</p>
<div class="fragment"><div class="line">kdb set user/sw/elektra/kdb/#0/current/bookmarks</div><div class="line">kdb set user/sw/elektra/kdb/#0/current/bookmarks/kdb user/sw/elektra/kdb/#0/current</div></div><!-- fragment --><p>You are able to use:</p>
<div class="fragment"><div class="line">kdb ls +kdb/bookmarks</div><div class="line">kdb set +kdb/format ini</div></div><!-- fragment --><p>The kdb tool got much more robust when the initial configuration is broken, no man page viewer is present or Elektra was installed wrongly.</p>
<p>The <code>--help</code> usage is unified and improved.</p>
<p>The new key naming conventions are now used for configuration of the <code>kdb</code>-tool itself: <code>/sw/elektra/kdb/#0/%/</code> and <code>/sw/elektra/kdb/#0/current/</code> are additionally read. The option <code>-p</code>/<code>--profile</code> is now supported for every command, it allows to fetch configuration from <code>/sw/elektra/kdb/#0/&lt;profile&gt;/</code> instead of <code>current</code>. KDB is more robust when it cannot fetch its own configuration due to KDB errors.</p>
<p>Thanks to Kurt Micheli the code guidelines are https://github.com/ElektraInitiative/libelektra/blob/master/doc/CODING.md "now properly documented". Thanks to Ren√© Schwaiger we also provide a style file for clang-format.</p>
<p>Furthermore we unified and fixed the source:</p>
<ul>
<li>only use @ for doxygen commands</li>
<li>always use <code>elektra*</code> functions for allocation</li>
<li>added a file header for every file</li>
</ul>
<p>Since we now only use C++11, we applied <code>clang-modernize</code> which simplified many loops and replaced many <code>0</code> to <code>nullptr</code>. Additionally, we added <code>override</code> and <code>default</code> at many places.</p>
<p>We removed all places where we had <code>ifdefs</code> to use <code>auto_ptr</code> if no modern smart pointer is available.</p>
<p>Because of these changes there is no easy way to compile Elektra without C++11 support, except by avoiding the C++ parts all together.</p>
<p>The C++ <code>KeySet</code> now also supports a <code>get</code> to retrieve whole containers at once. By specializing <code>KeySetTypeWrapper</code> you can support your own containers. Currently only <code>map&lt;string, T&gt;</code> is supported (T is any type supported by <code>Key::get</code>).</p>
<p>If you haven't removed it from your flags already, there is no use anymore to set <code>ENABLE_CXX11</code>.</p>
<p>The documentation was improved vastly. Most thanks to Kurt Micheli who did a lot of editing and fixed many places throughout the documentation Also thanks to Michael Zehender who added two paragraphs in the main README.md.</p>
<p>Key names of applications should be called <code>/sw/org/app/#0/current</code>, where <code>current</code> is the default profile (non given). <code>org</code> and <code>app</code> is supposed to not contain <code>/</code> and be completely lowercase. Key names are documented <a class="el" href="doc_help_elektra-key-names_md.html">here</a>. <a class="el" href="doc_tutorials_application-integration_md.html">See also here</a>. The main reason for long paths is the provided flexibility in the future (e.g. to use profiles and have a compatible path for new major versions of configuration). By using bookmarks, users should not be confronted by it too often.</p>
<ul>
<li>many man pages were improved</li>
<li>many typos were fixed, thanks to Pino Toscano!</li>
<li>Fix documentation for kdb list, thanks to Christian Berrer</li>
<li>Compilation variants are explained better, thanks to Peter Nirschl for pointing out what was missing</li>
<li>document ronn as dependency, thanks to Michael Zehender</li>
<li>fix broken links, thanks to Daniel Bugl</li>
</ul>
<p>Thanks to Kurt Micheli, developers are now warned during compilation on broken links in Markdown. The output format is the same as for gcc. Additionally, the markdown documentation of plugins now get a proper title in the pdf and html output of doxygen.</p>
<p>Raffael Pancheri again updated qt-gui with many nice improvements:</p>
<ul>
<li>update existing nodes in case the config was changed outside the gui</li>
<li>safely update tree</li>
<li>add update signal to metadata</li>
<li>fix crash when closing the GUI</li>
<li>move Actions in separate file to make main.qml less clustered</li>
<li>plugins do not output messages at startup</li>
<li><code>BackendBuilder</code> is now used, which automatically takes cares of the correct ordering of plugins</li>
<li>Qt 5.4 compatibility is still ensured</li>
<li>C++11 is now used in Qt-Gui, too</li>
</ul>
<p>Elektra 0.8.14 now in Debian with qt-gui, man pages, thanks to Pino Toscano <a href="https://packages.qa.debian.org/e/elektra/news/20151215T000031Z.html">read more here</a></p>
<p>Thanks to Gustavo Alvarez for updating and splitting the packages on Arch Linux!</p>
<p>Thanks to <a href="http://friends.ccbib.org/harald/supporting/">Harald Geyer</a>, Elektra is now packaged for OpenWRT. We fixed a number of cross-compilation issues and now officially support building against musl libc, with one minor limitation: RPATH works differently on musl so you need to install all plugins directly in /usr/lib/ or set LD_LIBRARY_PATH. Report any bugs in <a href="https://github.com/haraldg/packages">Harald's OpenWRT packaging issue tracker</a>.</p>
<ul>
<li>export errors/symbols are now called <code>elektra-export-symbols</code> and <code>elektra-export-symbols</code> and can be installed using <code>INSTALL_BUILD_TOOLS</code> (by default off). This is needed for cross-compilation. Thanks to Harald Geyer for reporting.</li>
<li>some header files are renamed because they endlessly included themselves if the header files were found in wrong order. Thanks to Harald Geyer for reporting.</li>
<li>fixed compilation when built on more than 20 cores with &gt;= -j15, thanks to Gustavo Alvarez for reporting and Manuel Mausz for analyzing</li>
<li>lua 5.1 now works too (except for iterators), thanks to Harald Geyer for reporting. thanks to Manuel Mausz for adding a new FindLua.cmake</li>
<li>pdf builds do not fail due to half written files, reported by Ren√© Schwaiger and fixed by Kurt Micheli</li>
</ul>
<p>Read about <a href="https://github.com/ElektraInitiative/libelektra#packages">other packages here</a>.</p>
<ul>
<li>3 way merge now properly deals with binary data, thanks to Felix Berlakovich</li>
<li>getenv: fix wrapping on powerpc, thanks to Pino Toscano</li>
<li>markdownlinkconverter: fix char/int mismatch, thanks to Pino Toscano</li>
<li>wresolver: use KDB_MAX_PATH_LENGTH instead of PATH_MAX, thanks to Pino Toscano</li>
<li>Cleaning up #ifdefs that break statements, thanks to Romero Malaquias</li>
<li>Daniel Bugl tested the INI plugin</li>
<li>cmake list_filter was broken because of different behaviour in cmake_parse_arguments, thanks to Christian Berrer for reporting</li>
<li>g++5.3 is now supported</li>
<li>gtest does not link against pthread if not needed</li>
<li>test cases that are built with BUILD_SHARED also successfully work</li>
<li>kdb list works when libs are in same path as plugins, thanks to Harald Geyer for reporting</li>
<li>fix macOS issues, thanks to Peter Nirschl, Ren√© Schwaiger and Mihael Pranjic</li>
<li>fix resolver-baseflag docu, thanks to Harald Geyer for reporting</li>
<li>do not create wrong directories called <code>(</code> and <code>)</code> in source, thanks to Ren√© Schwaiger</li>
<li>fix cmake for systems where iconv is not part of libc, thanks to Michael Zehender and Peter K√ºmmel (for FindIconv.cmake)</li>
<li>fix segfault in libgetenv if root keys are present</li>
<li>lua: fix Key:tostring(), thanks to Manuel Mausz</li>
<li>add list of <a href="https://github.com/ElektraInitiative/libelektra/tree/master/src/bindings">supported bindings</a>, thanks to Manuel Mausz</li>
</ul>
<p>You can download the release from <a href="https://www.libelektra.org/ftp/elektra/releases/elektra-0.8.15.tar.gz">here</a> and now also <a href="https://github.com/ElektraInitiative/ftp/tree/master/releases/elektra-0.8.15.tar.gz">here on github</a></p>
<ul>
<li>name: elektra-0.8.15.tar.gz</li>
<li>size: 2338297</li>
<li>md5sum: 33ec1e5982fb7fbd8893bf7b579b80f0</li>
<li>sha1: 6b1fdd5aa5aaad6ba377b4bb5ef437e0c85319ff</li>
<li>sha256: 6a406986cecb8d4a44485ced118ee803bc039b0824b72298e123b4dd47eb0b22</li>
<li>sha512: 86a408dd546b33e3b437f92f415de7aee6a235189f9eab0762b3f44ab4c453ee369a53de10a9f5b0df1b446460b12c57c6b8b77c282648ec2a49f2328d9af13d</li>
</ul>
<p>This release tarball now is also available <a href="https://www.libelektra.org/ftp/elektra/releases/elektra-0.8.15.tar.gz.gpg">signed by me using gpg</a></p>
<p>already built API-Docu can be found <a href="https://doc.libelektra.org/api/0.8.15/html/">here</a></p>
<p>Subscribe to the <a href="https://doc.libelektra.org/news/feed.rss">RSS feed</a> to always get the release notifications.</p>
<p>For any questions and comments, please contact the <a href="https://lists.sourceforge.net/lists/listinfo/registry-list">Mailing List</a> the issue tracker <a href="https://git.libelektra.org/issues">on github</a> or by mail <a href="#" onclick="location.href='mai'+'lto:'+'ele'+'kt'+'ra@'+'ma'+'rku'+'s-'+'raa'+'b.'+'org'; return false;">elekt<span style="display: none;">.nosp@m.</span>ra@m<span style="display: none;">.nosp@m.</span>arkus<span style="display: none;">.nosp@m.</span>-raa<span style="display: none;">.nosp@m.</span>b.org</a>.</p>
<p><a href="https://doc.libelektra.org/news/1ab4a560-c286-46d2-a058-1a8e7e208fe8.html">Permalink to this NEWS entry</a></p>
<p>For more information, see <a href="https://libelektra.org">https://libelektra.org</a></p>
<p>Best regards, Markus </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
