<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Meta Info Manipulation Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Meta Info Manipulation Methods<div class="ingroups"><a class="el" href="group__key.html">Key</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Methods to do various operations on Key metadata.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Meta Info Manipulation Methods:</div>
<div class="dyncontent">
<div class="center"><img src="group__keymeta.png" border="0" usemap="#agroup____keymeta" alt=""/></div>
<map name="agroup____keymeta" id="agroup____keymeta">
<area shape="rect" href="group__key.html" title="Key is an essential class that encapsulates key name , value &#160;and metainfo ." alt="" coords="5,13,52,38"/>
<area shape="rect" title="Methods to do various operations on Key metadata." alt="" coords="100,5,273,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5dbb669802eea27e106ee3a5e39717a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">keyRewindMeta</a> (Key *key)</td></tr>
<tr class="memdesc:ga5dbb669802eea27e106ee3a5e39717a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind the internal iterator to the first entry in metadata keyset.  <a href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">More...</a><br /></td></tr>
<tr class="separator:ga5dbb669802eea27e106ee3a5e39717a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c88342f580a4291455a801af71ce048"><td class="memItemLeft" align="right" valign="top">const Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (Key *key)</td></tr>
<tr class="memdesc:ga4c88342f580a4291455a801af71ce048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next metadata entry of a Key.  <a href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">More...</a><br /></td></tr>
<tr class="separator:ga4c88342f580a4291455a801af71ce048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a273f529030f4947df52e14fdd2869"><td class="memItemLeft" align="right" valign="top">const Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869">keyCurrentMeta</a> (const Key *key)</td></tr>
<tr class="memdesc:ga74a273f529030f4947df52e14fdd2869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the metadata Key at the internal iterator's current position.  <a href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869">More...</a><br /></td></tr>
<tr class="separator:ga74a273f529030f4947df52e14fdd2869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a22b992478e613c8788bd460b4a1f0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a> (Key *dest, const Key *source, const char *metaName)</td></tr>
<tr class="memdesc:ga9a22b992478e613c8788bd460b4a1f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a shallow copy of metadata with name <code>metaName</code> from source to dest.  <a href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">More...</a><br /></td></tr>
<tr class="separator:ga9a22b992478e613c8788bd460b4a1f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e63720a65610a29597494d0671f9401"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a> (Key *dest, const Key *source)</td></tr>
<tr class="memdesc:ga8e63720a65610a29597494d0671f9401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a shallow copy of all metadata from source to dest.  <a href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">More...</a><br /></td></tr>
<tr class="separator:ga8e63720a65610a29597494d0671f9401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed3875495ddb3d8a8d29158a60a147c"><td class="memItemLeft" align="right" valign="top">const Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta</a> (const Key *key, const char *metaName)</td></tr>
<tr class="memdesc:ga9ed3875495ddb3d8a8d29158a60a147c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Key for a metadata entry with name <code>metaName</code>.  <a href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">More...</a><br /></td></tr>
<tr class="separator:ga9ed3875495ddb3d8a8d29158a60a147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f15546b234ffb6007d8a31178652b9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a> (Key *key, const char *metaName, const char *newMetaString)</td></tr>
<tr class="memdesc:gae1f15546b234ffb6007d8a31178652b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new metadata Key.  <a href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">More...</a><br /></td></tr>
<tr class="separator:gae1f15546b234ffb6007d8a31178652b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11706f1753e67933f7cffc5c0345cd29"><td class="memItemLeft" align="right" valign="top">KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29">keyMeta</a> (Key *key)</td></tr>
<tr class="memdesc:ga11706f1753e67933f7cffc5c0345cd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the KeySet holding the given Key's metadata.  <a href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29">More...</a><br /></td></tr>
<tr class="separator:ga11706f1753e67933f7cffc5c0345cd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Methods to do various operations on Key metadata. </p>
<p>To use them: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kdb.h&gt;</span></div>
</div><!-- fragment --><p>Next to <a class="el" href="group__keyname.html">Name (key and owner) </a> and <a class="el" href="group__keyvalue.html">value (data and comment) </a> there is the so called meta information inside every key.</p>
<p>Key meta information are an unlimited number of key/value pairs strongly related to a key. It main purpose is to give keys special semantics, so that plugins can treat them differently.</p>
<p>Metakey, as opposed to Key, deliberately has following limitations:</p><ul>
<li>no null values</li>
<li>no binary data</li>
<li>no modification of references (COW)</li>
<li>no guarantee of ordering</li>
</ul>
<h2><a class="anchor" id="autotoc_md0"></a>
Examples for metadata</h2>
<p>File system information (see stat(2) for more information):</p><ul>
<li>uid: the user id (positive number)</li>
<li>gid: the group id (positive number)</li>
<li>mode: filesystem-like mode permissions (positive octal number)</li>
<li>atime: When was the key accessed the last time.</li>
<li>mtime: When was the key modified the last time.</li>
<li>ctime: When the uid, gid or mode of a key changes. (times are represented through a positive number as unix timestamp)</li>
</ul>
<p>The comment can contain userdata which directly belong to that key. The name of the meta information is "comment" for a general purpose comment about the key. Multi-Language comments are also supported by appending [LANG] to the name.</p>
<p>Validators are regular expressions which are tested against the key value. The metakey "validator" can hold a regular expression which will be matched against.</p>
<p>Types can be expressed with the meta information "type".</p>
<p>The relevance of the key can be tagged with a value from -20 to 20. Negative numbers are the more important and must be present in order to start the program.</p>
<p>A version of a key may be stored with "version". Its format is full.major.minor where all of these are integers.</p>
<p>The order inside a persistent storage can be described with the tag "order" which contains a positive number.</p>
<p>The metakey "app" describes to which application a key belongs. It can be used to remove keys from an application no longer installed.</p>
<p>The metakey "path" describes where the key is physically stored.</p>
<p>The "owner" is the user that owns the key. It only works for the user:/ hierarchy. It rather says where the key is stored and says nothing about the filesystem properties. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8e63720a65610a29597494d0671f9401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e63720a65610a29597494d0671f9401">&#9670;&nbsp;</a></span>keyCopyAllMeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keyCopyAllMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a shallow copy of all metadata from source to dest. </p>
<p>The key dest will additionally have all metadata the source had. Metadata not present in source will not be changed. Metadata which was present in source and dest will be overwritten. If the <code>dest</code> Key is read-only it will not be changed.</p>
<p>For example the metadata type is copied into the Key k:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> l (Key * k)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// receive copy</span></div>
<div class="line">        <a class="code" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a> (k, copy);</div>
<div class="line">        <span class="comment">// the caller will see the changed key k</span></div>
<div class="line">        <span class="comment">// with all the metadata from copy</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__keymeta_html_ga8e63720a65610a29597494d0671f9401"><div class="ttname"><a href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a></div><div class="ttdeci">int keyCopyAllMeta(Key *dest, const Key *source)</div><div class="ttdoc">Do a shallow copy of all metadata from source to dest.</div><div class="ttdef"><b>Definition:</b> keymeta.c:399</div></div>
</div><!-- fragment --><p> The main purpose of this function is for plugins or applications which want to add the same metadata to n keys. When you do that with <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a> it will take n times the memory for the key. This can be considerable amount of memory for many keys with some metadata for each.</p>
<p>To avoid that problem you can use <a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401" title="Do a shallow copy of all metadata from source to dest.">keyCopyAllMeta()</a> or <a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c" title="Do a shallow copy of metadata with name metaName from source to dest.">keyCopyMeta()</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> o (KeySet * ks)</div>
<div class="line">{</div>
<div class="line">        Key * current;</div>
<div class="line">        Key * shared = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;/&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a> (shared, <span class="stringliteral">&quot;shared1&quot;</span>, <span class="stringliteral">&quot;this metadata should be shared among many keys&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a> (shared, <span class="stringliteral">&quot;shared2&quot;</span>, <span class="stringliteral">&quot;this metadata should be shared among many keys also&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a> (shared, <span class="stringliteral">&quot;shared3&quot;</span>, <span class="stringliteral">&quot;this metadata should be shared among many keys too&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (ks);</div>
<div class="line">        <span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (ks)) != 0)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (needsSharedData (current)) <a class="code" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a> (current, shared);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (shared);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__key_html_ga3df95bbc2494e3e6703ece5639be5bb1"><div class="ttname"><a href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a></div><div class="ttdeci">int keyDel(Key *key)</div><div class="ttdoc">A destructor for Key objects.</div><div class="ttdef"><b>Definition:</b> key.c:482</div></div>
<div class="ttc" id="agroup__key_html_gad23c65b44bf48d773759e1f9a4d43b89"><div class="ttname"><a href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a></div><div class="ttdeci">Key * keyNew(const char *name,...)</div><div class="ttdoc">A practical way to fully create a Key object in one step.</div><div class="ttdef"><b>Definition:</b> key.c:138</div></div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a></div><div class="ttdeci">@ KEY_END</div><div class="ttdef"><b>Definition:</b> kdbenum.c:95</div></div>
<div class="ttc" id="agroup__keymeta_html_gae1f15546b234ffb6007d8a31178652b9"><div class="ttname"><a href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a></div><div class="ttdeci">ssize_t keySetMeta(Key *key, const char *metaName, const char *newMetaString)</div><div class="ttdoc">Set a new metadata Key.</div><div class="ttdef"><b>Definition:</b> keymeta.c:517</div></div>
<div class="ttc" id="agroup__keyset_html_ga317321c9065b5a4b3e33fe1c399bcec9"><div class="ttname"><a href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a></div><div class="ttdeci">Key * ksNext(KeySet *ks)</div><div class="ttdoc">Returns the next Key in a KeySet.</div><div class="ttdef"><b>Definition:</b> keyset.c:1609</div></div>
<div class="ttc" id="agroup__keyset_html_gabe793ff51f1728e3429c84a8a9086b70"><div class="ttname"><a href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a></div><div class="ttdeci">int ksRewind(KeySet *ks)</div><div class="ttdoc">Rewinds the KeySet internal cursor.</div><div class="ttdef"><b>Definition:</b> keyset.c:1571</div></div>
</div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd><code>dest's</code> metadata is not read-only </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>for every metaName present in source: keyGetMeta(source, metaName) == keyGetMeta(dest, metaName)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination where the metadata should be copied too </td></tr>
    <tr><td class="paramname">source</td><td>the key where the metadata should be copied from</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if metadata was successfully copied </td></tr>
    <tr><td class="paramname">0</td><td>if source did not have any metadata </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointer of dest or source </td></tr>
    <tr><td class="paramname">-1</td><td>on memory problems</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c" title="Do a shallow copy of metadata with name metaName from source to dest.">keyCopyMeta()</a> for copying one metadata Key from <code>dest</code> to <code>source</code> </dd></dl>

</div>
</div>
<a id="ga9a22b992478e613c8788bd460b4a1f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a22b992478e613c8788bd460b4a1f0c">&#9670;&nbsp;</a></span>keyCopyMeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keyCopyMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a shallow copy of metadata with name <code>metaName</code> from source to dest. </p>
<p>Afterwards <code>source</code> and <code>dest</code> will have the same metadata referred with <code>metaName</code>. If the Key with name <code>metaName</code> doesn't exist in <code>source</code> - it gets deleted in <code>dest</code>.</p>
<p>For example the metadata type is copied into the Key k.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> l(Key *k)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// receive c</span></div>
<div class="line">        <a class="code" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a>(k, c, <span class="stringliteral">&quot;type&quot;</span>);</div>
<div class="line">        <span class="comment">// the caller will see the changed key k</span></div>
<div class="line">        <span class="comment">// with the metadata &quot;type&quot; from c</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__keymeta_html_ga9a22b992478e613c8788bd460b4a1f0c"><div class="ttname"><a href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a></div><div class="ttdeci">int keyCopyMeta(Key *dest, const Key *source, const char *metaName)</div><div class="ttdoc">Do a shallow copy of metadata with name metaName from source to dest.</div><div class="ttdef"><b>Definition:</b> keymeta.c:303</div></div>
</div><!-- fragment --><p>The main purpose of this function is for plugins or applications, which want to add the same metadata to n keys. When you do that <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a> will take n times the memory for the key. This can be a considerable amount of memory for many keys with some metadata for each.</p>
<p>To avoid that problem you can use <a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401" title="Do a shallow copy of all metadata from source to dest.">keyCopyAllMeta()</a> or <a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c" title="Do a shallow copy of metadata with name metaName from source to dest.">keyCopyMeta()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> o(KeySet *ks)</div>
<div class="line">{</div>
<div class="line">        Key *current;</div>
<div class="line">        Key *shared = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;/&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared&quot;</span>, <span class="stringliteral">&quot;this metadata should be shared among many keys&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a>(ks);</div>
<div class="line">        <span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a>(ks)) != 0)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (needs_shared_data(current)) <a class="code" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a>(current, shared, <span class="stringliteral">&quot;shared&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd><code>dest's</code> metadata is not read-only </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>keyGetMeta(source, metaName) == keyGetMeta(dest, metaName)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination where the metadata should be copied to </td></tr>
    <tr><td class="paramname">source</td><td>the key where the metadata should be copied from </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the metadata Key which should be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if was successfully copied </td></tr>
    <tr><td class="paramname">0</td><td>if the metadata in dest was removed too </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointers (source or dest) </td></tr>
    <tr><td class="paramname">-1</td><td>on memory problems </td></tr>
    <tr><td class="paramname">-1</td><td>if metadata is read-only</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401" title="Do a shallow copy of all metadata from source to dest.">keyCopyAllMeta()</a> copies all metadata from <code>dest</code> to <code>src</code> </dd></dl>

</div>
</div>
<a id="ga74a273f529030f4947df52e14fdd2869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74a273f529030f4947df52e14fdd2869">&#9670;&nbsp;</a></span>keyCurrentMeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Key* keyCurrentMeta </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the metadata Key at the internal iterator's current position. </p>
<p>The returned pointer is NULL if the end has been reached or after calling <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to get the current metadata from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer to the value pointed by <code>key's</code> cursor </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> for getting the next value </dd>
<dd>
<a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9" title="Rewind the internal iterator to the first entry in metadata keyset.">keyRewindMeta()</a> for rewinding the internal iterator </dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> KeySets's equivalent function for getting the current Key </dd></dl>

</div>
</div>
<a id="ga9ed3875495ddb3d8a8d29158a60a147c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed3875495ddb3d8a8d29158a60a147c">&#9670;&nbsp;</a></span>keyGetMeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Key* keyGetMeta </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Key for a metadata entry with name <code>metaName</code>. </p>
<p>You are not allowed to modify the resulting key.</p>
<p>If <code>metaName</code> does not start with 'meta:/', it will be prefixed with 'meta:/'.</p>
<div class="fragment"><div class="line">Key metaData = <a class="code" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta</a>(k, <span class="stringliteral">&quot;type&quot;</span>)</div>
<div class="line"><span class="comment">// keyType == &quot;boolean&quot;</span></div>
<div class="line">char keyType[] = <a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(metaData)</div>
<div class="ttc" id="agroup__keymeta_html_ga9ed3875495ddb3d8a8d29158a60a147c"><div class="ttname"><a href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta</a></div><div class="ttdeci">const Key * keyGetMeta(const Key *key, const char *metaName)</div><div class="ttdoc">Returns the Key for a metadata entry with name metaName.</div><div class="ttdef"><b>Definition:</b> keymeta.c:454</div></div>
<div class="ttc" id="agroup__keyvalue_html_ga6f29609c5da53c6dc26a98678d5752af"><div class="ttname"><a href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a></div><div class="ttdeci">const void * keyValue(const Key *key)</div><div class="ttdoc">Return a pointer to the real internal key value.</div><div class="ttdef"><b>Definition:</b> keyvalue.c:168</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>key</code> contains metadata </dd>
<dd>
<code>metaName</code> is prefixed with "meta:/"</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key from which to get metadata </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the meta information you want the Key from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of meta-information if meta-information is found </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if key or metaName is NULL </td></tr>
    <tr><td class="paramname">0</td><td>if no such metaName is found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a> for setting metadata </dd>
<dd>
<a class="el" href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29" title="Returns the KeySet holding the given Key&#39;s metadata.">keyMeta()</a> for getting the KeySet containing metadata </dd></dl>

</div>
</div>
<a id="ga11706f1753e67933f7cffc5c0345cd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11706f1753e67933f7cffc5c0345cd29">&#9670;&nbsp;</a></span>keyMeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KeySet* keyMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the KeySet holding the given Key's metadata. </p>
<p>Use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a> to populate the metadata KeySet of a Key.</p>
<div class="fragment"><div class="line">        Key * key = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/test/key&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a> (key, <span class="stringliteral">&quot;meta1&quot;</span>, <span class="stringliteral">&quot;value1&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a> (key, <span class="stringliteral">&quot;meta2&quot;</span>, <span class="stringliteral">&quot;value2&quot;</span>);</div>
</div><!-- fragment --><p> Iterate the returned metadata KeySet like any other KeySet.</p>
<div class="fragment"><div class="line">        Key * cur;</div>
<div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (<a class="code" href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29">keyMeta</a> (key));</div>
<div class="line">        <span class="keywordflow">while</span> ((cur = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (<a class="code" href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29">keyMeta</a> (key))) != NULL)</div>
<div class="line">        {</div>
<div class="line">                printf (<span class="stringliteral">&quot;meta name: %s, meta value: %s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (cur), <a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a> (cur));</div>
<div class="line">        }</div>
<div class="ttc" id="agroup__keymeta_html_ga11706f1753e67933f7cffc5c0345cd29"><div class="ttname"><a href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29">keyMeta</a></div><div class="ttdeci">KeySet * keyMeta(Key *key)</div><div class="ttdoc">Returns the KeySet holding the given Key's metadata.</div><div class="ttdef"><b>Definition:</b> keymeta.c:637</div></div>
<div class="ttc" id="agroup__keyname_html_ga8e805c726a60da921d3736cda7813513"><div class="ttname"><a href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a></div><div class="ttdeci">const char * keyName(const Key *key)</div><div class="ttdoc">Returns a pointer to the abbreviated real internal key name.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:256</div></div>
<div class="ttc" id="agroup__keyvalue_html_ga880936f2481d28e6e2acbe7486a21d05"><div class="ttname"><a href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a></div><div class="ttdeci">const char * keyString(const Key *key)</div><div class="ttdoc">Get a pointer to the c-string representing the value.</div><div class="ttdef"><b>Definition:</b> keyvalue.c:213</div></div>
</div><!-- fragment --><p> Use <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> or <a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c" title="Returns the Key for a metadata entry with name metaName.">keyGetMeta()</a> to retrieve a single value for a given Key.</p>
<div class="fragment"><div class="line">        Key * lookupKey = <a class="code" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83">ksLookupByName</a> (<a class="code" href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29">keyMeta</a> (key), <span class="stringliteral">&quot;meta2&quot;</span>, 0);</div>
<div class="line">        printf (<span class="stringliteral">&quot;meta name: %s, meta value: %s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (lookupKey), <a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a> (lookupKey));</div>
<div class="line">        <a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (key);</div>
<div class="ttc" id="agroup__keyset_html_gad65d2cdcbb5381194a1688e169af8a83"><div class="ttname"><a href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83">ksLookupByName</a></div><div class="ttdeci">Key * ksLookupByName(KeySet *ks, const char *name, elektraLookupFlags options)</div><div class="ttdoc">Convenience method to look for a Key contained in ks with name name.</div><div class="ttdef"><b>Definition:</b> keyset.c:2616</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You are not allowed to modify the name of KeySet's Keys or delete them. </dd>
<dd>
You must not delete the returned KeySet. </dd>
<dd>
Adding a key with metadata to the KeySet is an error.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>for the returned KeySet ks: keyGetMeta(key, metaName) == ksLookupByName(ks, metaName) </dd>
<dd>
<code>key</code> contains a KeySet for the metadata</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key from which to get the metadata KeySet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the KeySet holding the metadata </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the Key is 0 </td></tr>
    <tr><td class="paramname">0</td><td>if the Key has no metadata</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a> for setting a metadata Key </dd>
<dd>
<a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c" title="Returns the Key for a metadata entry with name metaName.">keyGetMeta()</a> for getting a metadata Key </dd></dl>

</div>
</div>
<a id="ga4c88342f580a4291455a801af71ce048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c88342f580a4291455a801af71ce048">&#9670;&nbsp;</a></span>keyNextMeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Key* keyNextMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next metadata entry of a Key. </p>
<p>Keys have an internal cursor that can be reset with <a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9" title="Rewind the internal iterator to the first entry in metadata keyset.">keyRewindMeta()</a>. Every time <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> is called the cursor is incremented and the new current Name of Meta Information is returned.</p>
<p>You'll get a NULL pointer if the metadata after the end of the Key was reached. On subsequent calls of <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> it will still return the NULL pointer.</p>
<p>The <code>key</code> internal cursor will be changed, so it is not const.</p>
<dl class="section note"><dt>Note</dt><dd>That the resulting key is guaranteed to have a value, because meta information has no binary or null pointer semantics.</dd>
<dd>
You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new metadata Key.">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the Key object to work with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a key containing metadata </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the last Key has been reached </td></tr>
    <tr><td class="paramname">0</td><td>when Key is a NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> for pedant in iterator interface of KeySet </dd>
<dd>
<a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9" title="Rewind the internal iterator to the first entry in metadata keyset.">keyRewindMeta()</a> for rewinding the internal iterator </dd>
<dd>
<a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869" title="Returns the metadata Key at the internal iterator&#39;s current position.">keyCurrentMeta()</a> for getting the current metadata Key </dd></dl>

</div>
</div>
<a id="ga5dbb669802eea27e106ee3a5e39717a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dbb669802eea27e106ee3a5e39717a9">&#9670;&nbsp;</a></span>keyRewindMeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keyRewindMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewind the internal iterator to the first entry in metadata keyset. </p>
<p>Use this function to set the cursor to the beginning of the Key Meta Infos. <a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869" title="Returns the metadata Key at the internal iterator&#39;s current position.">keyCurrentMeta()</a> will always return NULL after rewinding, so you need to call <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> first.</p>
<div class="fragment"><div class="line">Key *key;</div>
<div class="line"><span class="keyword">const</span> Key *meta;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">keyRewindMeta</a> (key);</div>
<div class="line"><span class="keywordflow">while</span> ((meta = <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (key))!=0)</div>
<div class="line">{</div>
<div class="line">        printf (<span class="stringliteral">&quot;name: %s, value: %s&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(meta), <a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(meta));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__keymeta_html_ga4c88342f580a4291455a801af71ce048"><div class="ttname"><a href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a></div><div class="ttdeci">const Key * keyNextMeta(Key *key)</div><div class="ttdoc">Get the next metadata entry of a Key.</div><div class="ttdef"><b>Definition:</b> keymeta.c:197</div></div>
<div class="ttc" id="agroup__keymeta_html_ga5dbb669802eea27e106ee3a5e39717a9"><div class="ttname"><a href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">keyRewindMeta</a></div><div class="ttdeci">int keyRewindMeta(Key *key)</div><div class="ttdoc">Rewind the internal iterator to the first entry in metadata keyset.</div><div class="ttdef"><b>Definition:</b> keymeta.c:158</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose internal iterator should be rewinded</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">0</td><td>if there is no metadata for that key (<a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> will always return 0 in that case) </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a>, <a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869" title="Returns the metadata Key at the internal iterator&#39;s current position.">keyCurrentMeta()</a> for iterating after rewinding </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a> KeySet's equivalent function for rewinding </dd></dl>

</div>
</div>
<a id="gae1f15546b234ffb6007d8a31178652b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1f15546b234ffb6007d8a31178652b9">&#9670;&nbsp;</a></span>keySetMeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newMetaString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new metadata Key. </p>
<p>Will set a new metadata pair with name <code>metaName</code> and value <code>newMetaString</code>.</p>
<p>Will add a new metadata Key, if <code>metaName</code> was unused until now.</p>
<p>It will modify an existing Pair of metadata if <code>metaName</code> was already present.</p>
<p>It will remove a metadata Key if <code>newMetaString</code> is 0.</p>
<p>If <code>metaName</code> does not start with 'meta:/', it will be prefixed with 'meta:/'.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>metaName</code> is prefixed with "meta:/" </dd>
<dd>
<code>key's</code> metadata is not read-only </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The value in <code>key's</code> metadata Keyset for <code>metaName</code> is <code>newMetaString</code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose metadata should be set </td></tr>
    <tr><td class="paramname">metaName</td><td>name of the metadata Key that should be set </td></tr>
    <tr><td class="paramname">newMetaString</td><td>new value for the metadata Key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size (&gt;0) of <code>newMetaString</code> if metadata has been successfully added </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the meta-information for metaName was removed </td></tr>
    <tr><td class="paramname">-1</td><td>if key or metaName is 0 </td></tr>
    <tr><td class="paramname">-1</td><td>if system is out of memory </td></tr>
    <tr><td class="paramname">-1</td><td>if <code>metaName</code> is not a valid metadata name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c" title="Returns the Key for a metadata entry with name metaName.">keyGetMeta()</a> for getting the value of a metadata Key </dd>
<dd>
<a class="el" href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29" title="Returns the KeySet holding the given Key&#39;s metadata.">keyMeta()</a> for getting the KeySet containing metadata </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
