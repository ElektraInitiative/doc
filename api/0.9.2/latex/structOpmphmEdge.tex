\hypertarget{structOpmphmEdge}{}\doxysection{Opmphm\+Edge Struct Reference}
\label{structOpmphmEdge}\index{OpmphmEdge@{OpmphmEdge}}


Order Preserving Minimal Perfect Hash Map.  




{\ttfamily \#include $<$kdbopmphm.\+h$>$}

\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \mbox{\hyperlink{structOpmphmEdge_a0d125d2d8a97f191896b816123c09d14}{order}}
\item 
uint32\+\_\+t $\ast$ \mbox{\hyperlink{structOpmphmEdge_a4a0e9a3d422a25a57f52530f003c3a5e}{next\+Edge}}
\item 
uint32\+\_\+t $\ast$ \mbox{\hyperlink{structOpmphmEdge_ae8d5721fe78750b17b5d4a9b8e3fc2b2}{vertices}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Order Preserving Minimal Perfect Hash Map. 

Based on the work of

Fabiano C. Botelho and Nivio Ziviani \char`\"{}\+Near-\/\+Optimal Space Perfect Hashing Algorithms\char`\"{}

and

Zbigniew J. Czech, George Havas, and Bohdan S. Majewski \char`\"{}\+An Optimal Algorithm for Generating Minimal Perfect Hash Functions\char`\"{} In\+: Information Processing Letters 43 (1992), pp. 257â€“264

For usage look in datastructures.md

Theoretical limit of elements\+:

The whole O\+P\+M\+P\+HM is limited to the opmphm\+Hashfunction (...) that returns a uint32\+\_\+t. The limit of elements is than ((2$^\wedge$32) -\/ 1) $\ast$ r / c, since (2$^\wedge$32) -\/ 1 is the maximum component size of the r-\/uniform r-\/partite hypergraph.

To save space the limit of elements is set to (2$^\wedge$32) -\/ 1. The r-\/uniform r-\/partite hypergraph 

\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{structOpmphmEdge_a4a0e9a3d422a25a57f52530f003c3a5e}\label{structOpmphmEdge_a4a0e9a3d422a25a57f52530f003c3a5e}} 
\index{OpmphmEdge@{OpmphmEdge}!nextEdge@{nextEdge}}
\index{nextEdge@{nextEdge}!OpmphmEdge@{OpmphmEdge}}
\doxysubsubsection{\texorpdfstring{nextEdge}{nextEdge}}
{\footnotesize\ttfamily uint32\+\_\+t$\ast$ Opmphm\+Edge\+::next\+Edge}

arary with Opmphm-\/$>$r\+Uni\+Par indices of the next edge in the lists \mbox{\Hypertarget{structOpmphmEdge_a0d125d2d8a97f191896b816123c09d14}\label{structOpmphmEdge_a0d125d2d8a97f191896b816123c09d14}} 
\index{OpmphmEdge@{OpmphmEdge}!order@{order}}
\index{order@{order}!OpmphmEdge@{OpmphmEdge}}
\doxysubsubsection{\texorpdfstring{order}{order}}
{\footnotesize\ttfamily uint32\+\_\+t Opmphm\+Edge\+::order}

desired hash map return value \mbox{\Hypertarget{structOpmphmEdge_ae8d5721fe78750b17b5d4a9b8e3fc2b2}\label{structOpmphmEdge_ae8d5721fe78750b17b5d4a9b8e3fc2b2}} 
\index{OpmphmEdge@{OpmphmEdge}!vertices@{vertices}}
\index{vertices@{vertices}!OpmphmEdge@{OpmphmEdge}}
\doxysubsubsection{\texorpdfstring{vertices}{vertices}}
{\footnotesize\ttfamily uint32\+\_\+t$\ast$ Opmphm\+Edge\+::vertices}

array with Opmphm-\/$>$r\+Uni\+Par indices of vertices that the edge connects 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{kdbopmphm_8h}{kdbopmphm.\+h}}\end{DoxyCompactItemize}
