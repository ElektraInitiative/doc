<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: KeySet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">KeySet</div>  </div>
</div><!--header-->
<div class="contents">

<p>Methods to manipulate KeySets.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7a28fce3773b2c873c94ac80b8b4cd54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>&#160;&#160;&#160;((Key *) 0)</td></tr>
<tr class="memdesc:ga7a28fce3773b2c873c94ac80b8b4cd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of a list of keys.  <a href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">More...</a><br /></td></tr>
<tr class="separator:ga7a28fce3773b2c873c94ac80b8b4cd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gada05f4bbf46fde81d0d57df86e73d914"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a> { <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370">KDB_O_NONE</a> = 0
, <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a66a5380c120f25f28f49848c4a863ead">KDB_O_DEL</a> = 1
, <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984">KDB_O_POP</a> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="memdesc:gada05f4bbf46fde81d0d57df86e73d914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to change the default behavior of <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> functions.  <a href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">More...</a><br /></td></tr>
<tr class="separator:gada05f4bbf46fde81d0d57df86e73d914"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga671e1aaee3ae9dc13b4834a4ddbd2c3c"><td class="memItemLeft" align="right" valign="top">KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (size_t alloc,...)</td></tr>
<tr class="memdesc:ga671e1aaee3ae9dc13b4834a4ddbd2c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate, initialize and return a new KeySet object.  <a href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">More...</a><br /></td></tr>
<tr class="separator:ga671e1aaee3ae9dc13b4834a4ddbd2c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff760f56693b51ab785ed7ce628e649"><td class="memItemLeft" align="right" valign="top">KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga4ff760f56693b51ab785ed7ce628e649">ksVNew</a> (size_t alloc, va_list va)</td></tr>
<tr class="memdesc:ga4ff760f56693b51ab785ed7ce628e649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate, initialize and return a new KeySet object.  <a href="group__keyset.html#ga4ff760f56693b51ab785ed7ce628e649">More...</a><br /></td></tr>
<tr class="separator:ga4ff760f56693b51ab785ed7ce628e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59e4b328245463f1451f68d5106151c"><td class="memItemLeft" align="right" valign="top">KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c">ksDup</a> (const KeySet *source)</td></tr>
<tr class="memdesc:gac59e4b328245463f1451f68d5106151c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a duplicate of a KeySet.  <a href="group__keyset.html#gac59e4b328245463f1451f68d5106151c">More...</a><br /></td></tr>
<tr class="separator:gac59e4b328245463f1451f68d5106151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1f1dbea191f4d7e7eb3e4296ae7d5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gaba1f1dbea191f4d7e7eb3e4296ae7d5e">ksCopy</a> (KeySet *dest, const KeySet *source)</td></tr>
<tr class="memdesc:gaba1f1dbea191f4d7e7eb3e4296ae7d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the content of a KeySet with another one.  <a href="group__keyset.html#gaba1f1dbea191f4d7e7eb3e4296ae7d5e">More...</a><br /></td></tr>
<tr class="separator:gaba1f1dbea191f4d7e7eb3e4296ae7d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e5c16473b02a422238c8d970db7ac8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (KeySet *ks)</td></tr>
<tr class="memdesc:ga27e5c16473b02a422238c8d970db7ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A destructor for KeySet objects.  <a href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">More...</a><br /></td></tr>
<tr class="separator:ga27e5c16473b02a422238c8d970db7ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f210432e664d8ba06d7d55a2aba2d0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga8f210432e664d8ba06d7d55a2aba2d0f">ksNeedSync</a> (const KeySet *ks)</td></tr>
<tr class="memdesc:ga8f210432e664d8ba06d7d55a2aba2d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if KeySet needs sync.  <a href="group__keyset.html#ga8f210432e664d8ba06d7d55a2aba2d0f">More...</a><br /></td></tr>
<tr class="separator:ga8f210432e664d8ba06d7d55a2aba2d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7474ad6b0a0fa969dbdf267ba5770eee"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">ksGetSize</a> (const KeySet *ks)</td></tr>
<tr class="memdesc:ga7474ad6b0a0fa969dbdf267ba5770eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of Keys that <code>ks</code> contains.  <a href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">More...</a><br /></td></tr>
<tr class="separator:ga7474ad6b0a0fa969dbdf267ba5770eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a1d467a4d71041edce68ea7748ce45"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (KeySet *ks, Key *toAppend)</td></tr>
<tr class="memdesc:gaa5a1d467a4d71041edce68ea7748ce45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a Key to the end of <code>ks</code>.  <a href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">More...</a><br /></td></tr>
<tr class="separator:gaa5a1d467a4d71041edce68ea7748ce45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21eb9c3a14a604ee3a8bdc779232e7b7"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend</a> (KeySet *ks, const KeySet *toAppend)</td></tr>
<tr class="memdesc:ga21eb9c3a14a604ee3a8bdc779232e7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append all Keys in <code>toAppend</code> to the end of the KeySet <code>ks</code>.  <a href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">More...</a><br /></td></tr>
<tr class="separator:ga21eb9c3a14a604ee3a8bdc779232e7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b59d3a7ccd58511b562755454d1fae"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gaa9b59d3a7ccd58511b562755454d1fae">ksRename</a> (KeySet *ks, const Key *root, const Key *newRoot)</td></tr>
<tr class="memdesc:gaa9b59d3a7ccd58511b562755454d1fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all keys below <code>root</code> to below <code>newRoot</code>.  <a href="group__keyset.html#gaa9b59d3a7ccd58511b562755454d1fae">More...</a><br /></td></tr>
<tr class="separator:gaa9b59d3a7ccd58511b562755454d1fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29e567a3a733160303a452cc2366e69"><td class="memItemLeft" align="right" valign="top">elektraCursor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gaf29e567a3a733160303a452cc2366e69">ksFindHierarchy</a> (const KeySet *ks, const Key *root, elektraCursor *end)</td></tr>
<tr class="memdesc:gaf29e567a3a733160303a452cc2366e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the start and optionally end of the key hierachy rooted at <code>root</code> in <code>ks</code>.  <a href="group__keyset.html#gaf29e567a3a733160303a452cc2366e69">More...</a><br /></td></tr>
<tr class="separator:gaf29e567a3a733160303a452cc2366e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b00cf82b59af4d883a9bad6cf4a4a4a"><td class="memItemLeft" align="right" valign="top">KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a">ksCut</a> (KeySet *ks, const Key *cutpoint)</td></tr>
<tr class="memdesc:ga6b00cf82b59af4d883a9bad6cf4a4a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts out all Keys from KeySet <code>ks</code> that are below or at <code>cutpoint</code>.  <a href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a">More...</a><br /></td></tr>
<tr class="separator:ga6b00cf82b59af4d883a9bad6cf4a4a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae42530b04defb772059de0600159cf69"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop</a> (KeySet *ks)</td></tr>
<tr class="memdesc:gae42530b04defb772059de0600159cf69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the last Key of <code>ks</code>.  <a href="group__keyset.html#gae42530b04defb772059de0600159cf69">More...</a><br /></td></tr>
<tr class="separator:gae42530b04defb772059de0600159cf69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe793ff51f1728e3429c84a8a9086b70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (KeySet *ks)</td></tr>
<tr class="memdesc:gabe793ff51f1728e3429c84a8a9086b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewinds the KeySet internal cursor.  <a href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">More...</a><br /></td></tr>
<tr class="separator:gabe793ff51f1728e3429c84a8a9086b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317321c9065b5a4b3e33fe1c399bcec9"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (KeySet *ks)</td></tr>
<tr class="memdesc:ga317321c9065b5a4b3e33fe1c399bcec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next Key in a KeySet.  <a href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">More...</a><br /></td></tr>
<tr class="separator:ga317321c9065b5a4b3e33fe1c399bcec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4287b9416912c5f2ab9c195cb74fb094"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent</a> (const KeySet *ks)</td></tr>
<tr class="memdesc:ga4287b9416912c5f2ab9c195cb74fb094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current Key.  <a href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">More...</a><br /></td></tr>
<tr class="separator:ga4287b9416912c5f2ab9c195cb74fb094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7dbf3aef70e67b5328475eb3d1f92f5"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5">ksHead</a> (const KeySet *ks)</td></tr>
<tr class="memdesc:gae7dbf3aef70e67b5328475eb3d1f92f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first Key in the KeySet.  <a href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5">More...</a><br /></td></tr>
<tr class="separator:gae7dbf3aef70e67b5328475eb3d1f92f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca442c4ab43cf532b15091d7711559e"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e">ksTail</a> (const KeySet *ks)</td></tr>
<tr class="memdesc:gadca442c4ab43cf532b15091d7711559e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last Key in the KeySet.  <a href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e">More...</a><br /></td></tr>
<tr class="separator:gadca442c4ab43cf532b15091d7711559e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0444eb8ec958a429794f8586fc72e7"><td class="memItemLeft" align="right" valign="top">elektraCursor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">ksGetCursor</a> (const KeySet *ks)</td></tr>
<tr class="memdesc:gace0444eb8ec958a429794f8586fc72e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal cursor of the KeySet.  <a href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">More...</a><br /></td></tr>
<tr class="separator:gace0444eb8ec958a429794f8586fc72e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12b8fefaa20546e4790d60338b0db836"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">ksAtCursor</a> (KeySet *ks, elektraCursor pos)</td></tr>
<tr class="memdesc:ga12b8fefaa20546e4790d60338b0db836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Key at given position <code>pos</code>.  <a href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">More...</a><br /></td></tr>
<tr class="separator:ga12b8fefaa20546e4790d60338b0db836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b2a7d13c620b3c9d4815a0608c738f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">ksSetCursor</a> (KeySet *ks, elektraCursor cursor)</td></tr>
<tr class="memdesc:ga28b2a7d13c620b3c9d4815a0608c738f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the KeySet internal cursor to <code>cursor</code>.  <a href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">More...</a><br /></td></tr>
<tr class="separator:ga28b2a7d13c620b3c9d4815a0608c738f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f1ddcf23272f2b29b90e92ebe9b56f"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f">ksLookup</a> (KeySet *ks, Key *key, <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a> options)</td></tr>
<tr class="memdesc:ga60f1ddcf23272f2b29b90e92ebe9b56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for a Key contained in <code>ks</code> that matches the name of the <code>key</code>.  <a href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f">More...</a><br /></td></tr>
<tr class="separator:ga60f1ddcf23272f2b29b90e92ebe9b56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65d2cdcbb5381194a1688e169af8a83"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83">ksLookupByName</a> (KeySet *ks, const char *name, <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a> options)</td></tr>
<tr class="memdesc:gad65d2cdcbb5381194a1688e169af8a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to look for a Key contained in <code>ks</code> with name <code>name</code>.  <a href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83">More...</a><br /></td></tr>
<tr class="separator:gad65d2cdcbb5381194a1688e169af8a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Methods to manipulate KeySets. </p>
<p>A KeySet is a set of keys.</p>
<p>Most important properties of a KeySet:</p>
<ul>
<li>Allows us to iterate over all keys (in any depth)</li>
<li>Iteration is always sorted</li>
<li>Fast key lookup</li>
<li>A Key may be shared among many KeySets.</li>
</ul>
<p>The most important methods of KeySet:</p>
<ul>
<li>With <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a> you can create a new KeySet.</li>
<li>You can append keys with <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks.">ksAppendKey()</a> or with <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all Keys in toAppend to the end of the KeySet ks.">ksAppend()</a> you can append a whole keyset.</li>
<li>Using <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> you can lookup (or pop with <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984" title="Pop Parent out of keyset key in ksLookup().">KDB_O_POP</a>) a key.</li>
<li>With <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> you can iterate through the keyset. Be assured that you will get every key of the set in a stable order (parents before children).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> will be shared.</dd></dl>
<p>KeySets have an <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">internal cursor </a>. Methods should avoid to change this cursor, unless they want to communicate something with it. The internal cursor is used:</p>
<ul>
<li>in <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a>: points to the found key</li>
<li>in <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a>: points to the key which caused an error</li>
</ul>
<p>KeySet is the most important data structure in Elektra. It makes it possible to get and store many keys at once inside the database. In addition to that, the class can be used as high level datastructure in applications and it can be used in plugins to manipulate or check configuration.</p>
<p>With <a class="el" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83" title="Convenience method to look for a Key contained in ks with name name.">ksLookupByName()</a> it is possible to fetch easily specific keys out of the list of keys.</p>
<p>You can easily create and iterate keys:</p>
<div class="fragment"><div class="line"><span class="comment">// create a new keyset with 3 keys</span></div>
<div class="line"><span class="comment">// with a hint that about 20 keys will be inside</span></div>
<div class="line">KeySet * myConfig = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (20, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/name1&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>), <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/name2&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>), <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/name3&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"><span class="comment">// append a key in the keyset</span></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (myConfig, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/name4&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>));</div>
<div class="line"> </div>
<div class="line">Key * current;</div>
<div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (myConfig);</div>
<div class="line"><span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (myConfig)) != 0)</div>
<div class="line">{</div>
<div class="line">        printf (<span class="stringliteral">&quot;Key name is %s.\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (current));</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (myConfig); <span class="comment">// delete keyset and all keys appended</span></div>
<div class="ttc" id="agroup__key_html_gad23c65b44bf48d773759e1f9a4d43b89"><div class="ttname"><a href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a></div><div class="ttdeci">Key * keyNew(const char *name,...)</div><div class="ttdoc">A practical way to fully create a Key object in one step.</div><div class="ttdef"><b>Definition:</b> key.c:141</div></div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a></div><div class="ttdeci">@ KEY_END</div><div class="ttdef"><b>Definition:</b> kdbenum.c:97</div></div>
<div class="ttc" id="agroup__keyname_html_ga8e805c726a60da921d3736cda7813513"><div class="ttname"><a href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a></div><div class="ttdeci">const char * keyName(const Key *key)</div><div class="ttdoc">Returns a pointer to the abbreviated real internal key name.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:254</div></div>
<div class="ttc" id="agroup__keyset_html_ga27e5c16473b02a422238c8d970db7ac8"><div class="ttname"><a href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a></div><div class="ttdeci">int ksDel(KeySet *ks)</div><div class="ttdoc">A destructor for KeySet objects.</div><div class="ttdef"><b>Definition:</b> keyset.c:451</div></div>
<div class="ttc" id="agroup__keyset_html_ga317321c9065b5a4b3e33fe1c399bcec9"><div class="ttname"><a href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a></div><div class="ttdeci">Key * ksNext(KeySet *ks)</div><div class="ttdoc">Returns the next Key in a KeySet.</div><div class="ttdef"><b>Definition:</b> keyset.c:1489</div></div>
<div class="ttc" id="agroup__keyset_html_ga671e1aaee3ae9dc13b4834a4ddbd2c3c"><div class="ttname"><a href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a></div><div class="ttdeci">KeySet * ksNew(size_t alloc,...)</div><div class="ttdoc">Allocate, initialize and return a new KeySet object.</div><div class="ttdef"><b>Definition:</b> keyset.c:229</div></div>
<div class="ttc" id="agroup__keyset_html_ga7a28fce3773b2c873c94ac80b8b4cd54"><div class="ttname"><a href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a></div><div class="ttdeci">#define KS_END</div><div class="ttdoc">End of a list of keys.</div><div class="ttdef"><b>Definition:</b> kdbenum.c:158</div></div>
<div class="ttc" id="agroup__keyset_html_gaa5a1d467a4d71041edce68ea7748ce45"><div class="ttname"><a href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a></div><div class="ttdeci">ssize_t ksAppendKey(KeySet *ks, Key *toAppend)</div><div class="ttdoc">Appends a Key to the end of ks.</div><div class="ttdef"><b>Definition:</b> keyset.c:786</div></div>
<div class="ttc" id="agroup__keyset_html_gabe793ff51f1728e3429c84a8a9086b70"><div class="ttname"><a href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a></div><div class="ttdeci">int ksRewind(KeySet *ks)</div><div class="ttdoc">Rewinds the KeySet internal cursor.</div><div class="ttdef"><b>Definition:</b> keyset.c:1451</div></div>
</div><!-- fragment --><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7a28fce3773b2c873c94ac80b8b4cd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a28fce3773b2c873c94ac80b8b4cd54">&#9670;&nbsp;</a></span>KS_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KS_END&#160;&#160;&#160;((Key *) 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of a list of keys. </p>
<p>Use this macro to define the end of a variable-length list of keys.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a> and <a class="el" href="group__keyset.html#ga4ff760f56693b51ab785ed7ce628e649" title="Allocate, initialize and return a new KeySet object.">ksVNew()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gada05f4bbf46fde81d0d57df86e73d914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada05f4bbf46fde81d0d57df86e73d914">&#9670;&nbsp;</a></span>elektraLookupFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options to change the default behavior of <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> functions. </p>
<p>These options can be ORed. That is the |-Operator in C.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a>, <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada05f4bbf46fde81d0d57df86e73d914a00738455e0ae843c8720809d8287f370"></a>KDB_O_NONE&#160;</td><td class="fielddoc"><p>No Option set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggada05f4bbf46fde81d0d57df86e73d914a66a5380c120f25f28f49848c4a863ead"></a>KDB_O_DEL&#160;</td><td class="fielddoc"><p>Delete parentKey key in <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984"></a>KDB_O_POP&#160;</td><td class="fielddoc"><p>Pop Parent out of keyset key in <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a>. </p>
<pre class="fragment">   @see ksPop().
</pre> </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga21eb9c3a14a604ee3a8bdc779232e7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21eb9c3a14a604ee3a8bdc779232e7b7">&#9670;&nbsp;</a></span>ksAppend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ksAppend </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>toAppend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append all Keys in <code>toAppend</code> to the end of the KeySet <code>ks</code>. </p>
<p><code>toAppend</code> KeySet will be left unchanged.</p>
<p>If a Key is both in <code>toAppend</code> and <code>ks</code>, the Key in <code>ks</code> will be overwritten.</p>
<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> will be shared.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Sorted KeySet ks with all Keys it had before and additionally the Keys from toAppend</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet that will receive the Keys </td></tr>
    <tr><td class="paramname">toAppend</td><td>the KeySet that provides the Keys that will be transferred</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the KeySet <code>ks</code> after transfer </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks.">ksAppendKey()</a> </dd></dl>

</div>
</div>
<a id="gaa5a1d467a4d71041edce68ea7748ce45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5a1d467a4d71041edce68ea7748ce45">&#9670;&nbsp;</a></span>ksAppendKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ksAppendKey </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>toAppend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a Key to the end of <code>ks</code>. </p>
<p>Hands the ownership of the Key <code>toAppend</code> to the KeySet <code>ks</code>. ksDel(ks) uses keyDel(k) to delete every Key unless it got its reference counter incremented by <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the reference counter of a Key object.">keyIncRef()</a>, e.g. by another KeySet that contains this Key.</p>
<p>The reference counter of the Key will be incremented to indicate this ownership, and thus <code>toAppend</code> is not const.</p>
<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> will be shared.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae" title="Return how many references the Key has.">keyGetRef()</a>.</dd></dl>
<p>If the Key's name already exists in the KeySet, it will be replaced with the new Key.</p>
<p><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks.">ksAppendKey()</a> will also lock the Key's name from <code>toAppend</code>. This is necessary so that the order of the KeySet cannot be destroyed via calls to <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a Key.">keySetName()</a>.</p>
<p>The KeySet internal cursor will be set to the new Key.</p>
<p>It is safe to directly append newly created Keys: </p><div class="fragment"><div class="line">KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (ks, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/my/new/key&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>));</div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks);</div>
<div class="line"><span class="comment">// key deleted, too!</span></div>
</div><!-- fragment --><p> If you want the key to outlive the KeySet, make sure to do proper ref counting: </p><div class="fragment"><div class="line">KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/ref/key&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1">keyIncRef</a> (k);</div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (ks, k);</div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks);</div>
<div class="line"><span class="comment">// now we still can work with the key k!</span></div>
<div class="line"><a class="code" href="group__key.html#ga2c6433ca22109e4e141946057eccb283">keyDecRef</a> (k);</div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
<div class="ttc" id="agroup__key_html_ga2c6433ca22109e4e141946057eccb283"><div class="ttname"><a href="group__key.html#ga2c6433ca22109e4e141946057eccb283">keyDecRef</a></div><div class="ttdeci">ssize_t keyDecRef(Key *key)</div><div class="ttdoc">Decrement the reference counter of a Key object.</div><div class="ttdef"><b>Definition:</b> key.c:648</div></div>
<div class="ttc" id="agroup__key_html_ga3df95bbc2494e3e6703ece5639be5bb1"><div class="ttname"><a href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a></div><div class="ttdeci">int keyDel(Key *key)</div><div class="ttdoc">A destructor for Key objects.</div><div class="ttdef"><b>Definition:</b> key.c:500</div></div>
<div class="ttc" id="agroup__key_html_ga6970a6f254d67af7e39f8e469bb162f1"><div class="ttname"><a href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1">keyIncRef</a></div><div class="ttdeci">ssize_t keyIncRef(Key *key)</div><div class="ttdoc">Increment the reference counter of a Key object.</div><div class="ttdef"><b>Definition:</b> key.c:610</div></div>
</div><!-- fragment --><p> You can duplicate the Key to avoid aliasing, but then the Key in the KeySet has another identity: </p><div class="fragment"><div class="line">KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/ref/key&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (ks, keyDup (k, <a class="code" href="group__key.html#gga9ff42b1e9a97222562bfda3dd1f8c735a3e04e17514f102f1e9217308d44e7612">KEY_CP_ALL</a>));</div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks);</div>
<div class="line"><span class="comment">// now we still can work with the key k!</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
<div class="ttc" id="agroup__key_html_gga9ff42b1e9a97222562bfda3dd1f8c735a3e04e17514f102f1e9217308d44e7612"><div class="ttname"><a href="group__key.html#gga9ff42b1e9a97222562bfda3dd1f8c735a3e04e17514f102f1e9217308d44e7612">KEY_CP_ALL</a></div><div class="ttdeci">@ KEY_CP_ALL</div><div class="ttdef"><b>Definition:</b> kdbenum.c:112</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>KeySet where <code>toAppend</code> should be append </td></tr>
    <tr><td class="paramname">toAppend</td><td>Key that will be appended to <code>ks</code> or deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the KeySet after appending </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if appending failed (only on memory problems). The Key will be deleted then.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all Keys in toAppend to the end of the KeySet ks.">ksAppend()</a> for appending a KeySet to another KeySet </dd>
<dd>
<a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the reference counter of a Key object.">keyIncRef()</a> for manually increasing a Key's reference counter </dd></dl>

</div>
</div>
<a id="ga12b8fefaa20546e4790d60338b0db836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12b8fefaa20546e4790d60338b0db836">&#9670;&nbsp;</a></span>ksAtCursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* ksAtCursor </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">elektraCursor&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Key at given position <code>pos</code>. </p>
<p>The position is a number starting from 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet to get the Key from </td></tr>
    <tr><td class="paramname">pos</td><td>the position of the Key that should be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Key at the cursor <code>pos</code> on success </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on NULL pointer, negative cursor position or a position that does not lie within the KeySet <code>ks</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7" title="Get the internal cursor of the KeySet.">ksGetCursor()</a> for getting the cursor at the current position </dd>
<dd>
<a class="el" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f" title="Set the KeySet internal cursor to cursor.">ksSetCursor()</a> for setting the cursor to a specific position </dd></dl>

</div>
</div>
<a id="gaba1f1dbea191f4d7e7eb3e4296ae7d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba1f1dbea191f4d7e7eb3e4296ae7d5e">&#9670;&nbsp;</a></span>ksCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ksCopy </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the content of a KeySet with another one. </p>
<p>Most often you may want a duplicate of a KeySet, see <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup()</a> or append keys, see <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all Keys in toAppend to the end of the KeySet ks.">ksAppend()</a>. In some situations you need to copy Keys from a KeySet to another KeySet, for which this function exists.</p>
<dl class="section note"><dt>Note</dt><dd>You can also use it to clear a KeySet when you pass a NULL pointer as <code>source</code>.</dd></dl>
<dl class="section user"><dt>Implementation:</dt><dd>First all Keys in <code>dest</code> will be deleted. Afterwards the content of <code>source</code> will be added to the destination and <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> will be set properly in <code>dest</code>.</dd></dl>
<p>A flat copy is made, so Keys will not be duplicated, but their reference counter is updated, so both KeySets need to be deleted via <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Because the key is not copied, also the pointer to the current metadata <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Get the next metadata entry of a Key.">keyNextMeta()</a> will be shared.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f (KeySet *ks)</div>
<div class="line">{</div>
<div class="line">        KeySet *c = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (20, ..., <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line">        <span class="comment">// c receives keys</span></div>
<div class="line">        <a class="code" href="group__keyset.html#gaba1f1dbea191f4d7e7eb3e4296ae7d5e">ksCopy</a> (ks, c); <span class="comment">// pass the KeySet to the caller</span></div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (c);</div>
<div class="line">}       <span class="comment">// caller needs to ksDel (ks)</span></div>
<div class="ttc" id="agroup__keyset_html_gaba1f1dbea191f4d7e7eb3e4296ae7d5e"><div class="ttname"><a href="group__keyset.html#gaba1f1dbea191f4d7e7eb3e4296ae7d5e">ksCopy</a></div><div class="ttdeci">int ksCopy(KeySet *dest, const KeySet *source)</div><div class="ttdoc">Replace the content of a KeySet with another one.</div><div class="ttdef"><b>Definition:</b> keyset.c:421</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>an initialized KeySet or NULL </td></tr>
    <tr><td class="paramname">dest</td><td>an initialized KeySet, where the Keys from <code>source</code> get copied to</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
    <tr><td class="paramname">0</td><td>if <code>dest</code> was cleared successfully (<code>source</code> is NULL) </td></tr>
    <tr><td class="paramname">-1</td><td>when <code>dest</code> is a NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a> for creating a new KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a> for deleting an existing KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup()</a> for duplicating an existing KeySet </dd>
<dd>
<a class="el" href="group__key.html#ga505575ebef060066984fe0f590081e37" title="Copy or clear a key.">keyCopy()</a> for copying Keys </dd></dl>

</div>
</div>
<a id="ga4287b9416912c5f2ab9c195cb74fb094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4287b9416912c5f2ab9c195cb74fb094">&#9670;&nbsp;</a></span>ksCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* ksCurrent </td>
          <td>(</td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current Key. </p>
<p>The returned pointer is NULL if you reached the end or after <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>You must not delete the Key or change the Key, use <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last Key of ks.">ksPop()</a> if you want to delete it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet object to get the current Key from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the Key pointed by <code>ks's</code> cursor </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> to get the next Key in the KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a> for resetting the internal cursor of the KeySet </dd></dl>

</div>
</div>
<a id="ga6b00cf82b59af4d883a9bad6cf4a4a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b00cf82b59af4d883a9bad6cf4a4a4a">&#9670;&nbsp;</a></span>ksCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KeySet* ksCut </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>cutpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts out all Keys from KeySet <code>ks</code> that are below or at <code>cutpoint</code>. </p>
<p>Searches for the <code>cutpoint</code> inside the KeySet <code>ks</code>. If found, it cuts out this Key and everything which is below (see <a class="el" href="group__keytest.html#ga03332b5d97c76a4fd2640aca4762b8df" title="Check if the Key check is below the Key key or not.">keyIsBelow()</a>) this Key. These Keys will be missing in the keyset <code>ks</code>. Instead, they will be moved to the returned KeySet. If <code>cutpoint</code> is not found an empty KeySet is returned and <code>ks</code> is not changed.</p>
<p>The cursor will stay at the same Key as it was before. If the cursor was inside the region of cut (moved) Keys, the cursor will be set to the Key before the <code>cutpoint</code>.</p>
<p>If you use <a class="el" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a" title="Cuts out all Keys from KeySet ks that are below or at cutpoint.">ksCut()</a> on a KeySet you got from <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> and plan to use <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> later, make sure that you keep all Keys that should not be removed permanently. You have to keep the KeySet that was returned and the KeySet <code>ks</code>.</p>
<dl class="section user"><dt>Example:</dt><dd></dd></dl>
<p>You have the keyset <code>ks:</code> </p><ul>
<li><code>system:/mountpoint/interest</code> </li>
<li><code>system:/mountpoint/interest/folder</code> </li>
<li><code>system:/mountpoint/interest/folder/key1</code> </li>
<li><code>system:/mountpoint/interest/folder/key2</code> </li>
<li><code>system:/mountpoint/other/key1</code> </li>
</ul>
<p>When you use </p><div class="fragment"><div class="line">        Key * parentKey = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;system:/mountpoint/interest&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line">        KDB * <a class="code" href="namespacekdb.html">kdb</a> = <a class="code" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5">kdbOpen</a> (NULL, parentKey);</div>
<div class="line">        KeySet * ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line">        <a class="code" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet</a> (<a class="code" href="namespacekdb.html">kdb</a>, ks, parentKey);</div>
<div class="line">        KeySet * returned = <a class="code" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a">ksCut</a> (ks, parentKey);</div>
<div class="line">        <a class="code" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet</a> (<a class="code" href="namespacekdb.html">kdb</a>, ks, parentKey); <span class="comment">// all keys below cutpoint are now removed</span></div>
<div class="line">        <a class="code" href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f">kdbClose</a> (<a class="code" href="namespacekdb.html">kdb</a>, parentKey);</div>
<div class="ttc" id="agroup__kdb_html_ga11436b058408f83d303ca5e996832bcf"><div class="ttname"><a href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet</a></div><div class="ttdeci">int kdbSet(KDB *handle, KeySet *ks, Key *parentKey)</div><div class="ttdoc">Set Keys to a Key database in an atomic and universal way.</div><div class="ttdef"><b>Definition:</b> kdb.c:1743</div></div>
<div class="ttc" id="agroup__kdb_html_ga28e385fd9cb7ccfe0b2f1ed2f62453a1"><div class="ttname"><a href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet</a></div><div class="ttdeci">int kdbGet(KDB *handle, KeySet *ks, Key *parentKey)</div><div class="ttdoc">Retrieve Keys from a Key database in an atomic and universal way.</div><div class="ttdef"><b>Definition:</b> kdb.c:1191</div></div>
<div class="ttc" id="agroup__kdb_html_ga844e1299a84c3fbf1d3a905c5c893ba5"><div class="ttname"><a href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5">kdbOpen</a></div><div class="ttdeci">KDB * kdbOpen(const KeySet *contract, Key *errorKey)</div><div class="ttdoc">Opens the session with the Key database.</div><div class="ttdef"><b>Definition:</b> kdb.c:417</div></div>
<div class="ttc" id="agroup__kdb_html_gadb54dc9fda17ee07deb9444df745c96f"><div class="ttname"><a href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f">kdbClose</a></div><div class="ttdeci">int kdbClose(KDB *handle, Key *errorKey)</div><div class="ttdoc">Closes the session with the Key database.</div><div class="ttdef"><b>Definition:</b> kdb.c:590</div></div>
<div class="ttc" id="agroup__keyset_html_ga6b00cf82b59af4d883a9bad6cf4a4a4a"><div class="ttname"><a href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a">ksCut</a></div><div class="ttdeci">KeySet * ksCut(KeySet *ks, const Key *cutpoint)</div><div class="ttdoc">Cuts out all Keys from KeySet ks that are below or at cutpoint.</div><div class="ttdef"><b>Definition:</b> keyset.c:1281</div></div>
<div class="ttc" id="anamespacekdb_html"><div class="ttname"><a href="namespacekdb.html">kdb</a></div><div class="ttdoc">This is the main namespace for the C++ binding and libraries.</div><div class="ttdef"><b>Definition:</b> backend.hpp:31</div></div>
</div><!-- fragment --><p> Then in <code>returned</code> are:</p><ul>
<li><code>system:/mountpoint/interest</code> </li>
<li><code>system:/mountpoint/interest/folder</code> </li>
<li><code>system:/mountpoint/interest/folder/key1</code> </li>
<li><code>system:/mountpoint/interest/folder/key2</code> </li>
</ul>
<p>And in <code>ks</code> are:</p><ul>
<li><code>system:/mountpoint/other/key1</code> </li>
</ul>
<p>So <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> permanently removes all keys at or below <code>system:/mountpoint/interest</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the Keyset to cut. It will be modified by removing all Keys at or below the cutpoint. </td></tr>
    <tr><td class="paramname">cutpoint</td><td>the point where to cut out the Keyset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new allocated KeySet which needs to deleted with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a>. The KeySet consists of all Keys (of the original KeySet ks) below the cutpoint. If the Key cutpoint exists, it will also be appended. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointers, no Key name or allocation problems</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> for an explanation on why you might get more Keys than you requested. </dd></dl>

</div>
</div>
<a id="ga27e5c16473b02a422238c8d970db7ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27e5c16473b02a422238c8d970db7ac8">&#9670;&nbsp;</a></span>ksDel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ksDel </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A destructor for KeySet objects. </p>
<p>Cleans all internal dynamic attributes, decrements all reference pointers to all Keys and then calls <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects.">keyDel()</a> on all contained Keys. Afterwards <a class="el" href="internal_8c.html#a7f572149d2e0bfe18023a6ac969f195c" title="Free memory of Elektra or its backends.">elektraFree()</a> is used to release the KeySet's object memory (that was previously allocated by <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet that should be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the KeySet was successfully freed </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a> for creating a new KeySet </dd></dl>

</div>
</div>
<a id="gac59e4b328245463f1451f68d5106151c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac59e4b328245463f1451f68d5106151c">&#9670;&nbsp;</a></span>ksDup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KeySet* ksDup </td>
          <td>(</td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a duplicate of a KeySet. </p>
<p>Objects created with <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a>.</p>
<p>Memory will be allocated as needed for dynamic properties, so you need to <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a> the returned pointer.</p>
<p>A flat copy is made, so the Keys will not be duplicated, but their reference counter is updated, so both KeySets need to be deleted via <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>has to be an initialized KeySet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a flat copy of source on success </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a> for creating a new KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a> for deleting a KeySet </dd>
<dd>
keyDup() for Key duplication </dd></dl>

</div>
</div>
<a id="gaf29e567a3a733160303a452cc2366e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf29e567a3a733160303a452cc2366e69">&#9670;&nbsp;</a></span>ksFindHierarchy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">elektraCursor ksFindHierarchy </td>
          <td>(</td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">elektraCursor *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the start and optionally end of the key hierachy rooted at <code>root</code> in <code>ks</code>. </p>
<p>The main use-case for this function is this kind of loop:</p>
<div class="fragment"><div class="line">elektraCursor end;</div>
<div class="line"><span class="keywordflow">for</span> (elektraCursor it = <a class="code" href="group__keyset.html#gaf29e567a3a733160303a452cc2366e69">ksFindHierarchy</a> (ks, root, &amp;end); it &lt; end; ++it)</div>
<div class="line">{</div>
<div class="line">        Key * cur = <a class="code" href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">ksAtCursor</a> (ks, it);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__keyset_html_ga12b8fefaa20546e4790d60338b0db836"><div class="ttname"><a href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">ksAtCursor</a></div><div class="ttdeci">Key * ksAtCursor(KeySet *ks, elektraCursor pos)</div><div class="ttdoc">Return Key at given position pos.</div><div class="ttdef"><b>Definition:</b> keyset.c:1697</div></div>
<div class="ttc" id="agroup__keyset_html_gaf29e567a3a733160303a452cc2366e69"><div class="ttname"><a href="group__keyset.html#gaf29e567a3a733160303a452cc2366e69">ksFindHierarchy</a></div><div class="ttdeci">elektraCursor ksFindHierarchy(const KeySet *ks, const Key *root, elektraCursor *end)</div><div class="ttdoc">Searches for the start and optionally end of the key hierachy rooted at root in ks.</div><div class="ttdef"><b>Definition:</b> keyset.c:1111</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>The keyset to search in </td></tr>
    <tr><td class="paramname">root</td><td>The root of the hierachy to find </td></tr>
    <tr><td class="paramname">end</td><td>If this is not NULL, it will be set to position of the first key after <code>root</code> that is not below <code>root</code>. This is useful for loops like the one above. If not keys below <code>root</code> exist in <code>ks</code>, <code>end</code> will always be set to the size of <code>ks</code>. This way a loop like the one above will still work correctly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if <code>ks</code> or <code>root</code> are NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of either <code>root</code> itself or the first key below <code>root</code> that is part of <code>ks</code>. If no keys below <code>root</code> exist in <code>ks</code>, the size of <code>ks</code> is returned. The snippet above shows why this is useful. </dd></dl>

</div>
</div>
<a id="gace0444eb8ec958a429794f8586fc72e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace0444eb8ec958a429794f8586fc72e7">&#9670;&nbsp;</a></span>ksGetCursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">elektraCursor ksGetCursor </td>
          <td>(</td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the internal cursor of the KeySet. </p>
<dl class="section warning"><dt>Warning</dt><dd>Cursors are getting invalid when the Key was <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last Key of ks.">ksPop()</a>ed or <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> with KDB_O_POP was used.</dd></dl>
<h1><a class="anchor" id="readahead"></a>
Read ahead</h1>
<p>With the cursors it is possible to read ahead in a KeySet:</p>
<div class="fragment"><div class="line">elektraCursor jump;</div>
<div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (ks);</div>
<div class="line"><span class="keywordflow">while</span> ((key = <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (ks))!=0)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// now mark this key</span></div>
<div class="line">        jump = <a class="code" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">ksGetCursor</a>(ks);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">//code..</span></div>
<div class="line">        <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (ks); <span class="comment">// now browse on</span></div>
<div class="line">        <span class="comment">// use ksCurrent(ks) to check the keys</span></div>
<div class="line">        <span class="comment">//code..</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// jump back to the position marked before</span></div>
<div class="line">        <a class="code" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">ksSetCursor</a>(ks, jump);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__keymeta_html_ga4c88342f580a4291455a801af71ce048"><div class="ttname"><a href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a></div><div class="ttdeci">const Key * keyNextMeta(Key *key)</div><div class="ttdoc">Get the next metadata entry of a Key.</div><div class="ttdef"><b>Definition:</b> keymeta.c:197</div></div>
<div class="ttc" id="agroup__keyset_html_ga28b2a7d13c620b3c9d4815a0608c738f"><div class="ttname"><a href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">ksSetCursor</a></div><div class="ttdeci">int ksSetCursor(KeySet *ks, elektraCursor cursor)</div><div class="ttdoc">Set the KeySet internal cursor to cursor.</div><div class="ttdef"><b>Definition:</b> keyset.c:1742</div></div>
<div class="ttc" id="agroup__keyset_html_gace0444eb8ec958a429794f8586fc72e7"><div class="ttname"><a href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">ksGetCursor</a></div><div class="ttdeci">elektraCursor ksGetCursor(const KeySet *ks)</div><div class="ttdoc">Get the internal cursor of the KeySet.</div><div class="ttdef"><b>Definition:</b> keyset.c:1671</div></div>
</div><!-- fragment --><h1><a class="anchor" id="restore"></a>
Restoring state</h1>
<p>It can also be used to restore the state of a KeySet in a function</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f (KeySet *ks)</div>
<div class="line">{</div>
<div class="line">        elektraCursor state = <a class="code" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">ksGetCursor</a>(ks);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// work with keyset</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// now bring the keyset to the state before</span></div>
<div class="line">        <a class="code" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">ksSetCursor</a> (ks, state);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is of course possible to make the KeySet const and cast its const away to set the cursor. Another way to achieve the same is to <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup()</a> the KeySet, but it is not as efficient.</p>
<p>An invalid cursor will be returned directly after <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>. When you set an invalid cursor <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> is 0 and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> == <a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5" title="Return the first Key in the KeySet.">ksHead()</a>.</p>
<h1><a class="anchor" id="cursor_directly"></a>
Using Cursor directly</h1>
<p>You can also use the cursor directly by initializing it to some index in the KeySet and then incrementing or decrementing it, to iterate over the KeySet.</p>
<div class="fragment"><div class="line">        Key * cur;</div>
<div class="line">        <span class="keywordflow">for</span> (elektraCursor cursor = 0; (cur = <a class="code" href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">ksAtCursor</a> (ks, cursor)) != NULL; ++cursor)</div>
<div class="line">        {</div>
<div class="line">                printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (cur));</div>
<div class="line">        }</div>
</div><!-- fragment --><p> You can also use a while loop if you need access to the last cursor position.</p>
<div class="fragment"><div class="line">        elektraCursor cursor = 0;</div>
<div class="line">        Key * cur;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span> ((cur = <a class="code" href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">ksAtCursor</a> (ks, cursor)) != 0)</div>
<div class="line">        {</div>
<div class="line">                printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (cur));</div>
<div class="line">                ++cursor;</div>
<div class="line">        }</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Only use a cursor for the same KeySet which it was made for.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet object to get the cursor from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid cursor on success </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
    <tr><td class="paramname">-1</td><td>on an invalid internal cursor or after ksRewind</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> for moving the internal cursor forward </dd>
<dd>
<a class="el" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f" title="Set the KeySet internal cursor to cursor.">ksSetCursor()</a> for setting the cursor to a specific position </dd>
<dd>
<a class="el" href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836" title="Return Key at given position pos.">ksAtCursor()</a> for getting the Key at a specific position </dd></dl>

</div>
</div>
<a id="ga7474ad6b0a0fa969dbdf267ba5770eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7474ad6b0a0fa969dbdf267ba5770eee">&#9670;&nbsp;</a></span>ksGetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ksGetSize </td>
          <td>(</td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of Keys that <code>ks</code> contains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet object to get the size from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of Keys that <code>ks</code> contains. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>

</div>
</div>
<a id="gae7dbf3aef70e67b5328475eb3d1f92f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7dbf3aef70e67b5328475eb3d1f92f5">&#9670;&nbsp;</a></span>ksHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* ksHead </td>
          <td>(</td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first Key in the KeySet. </p>
<p>The KeySet's cursor will not be affected.</p>
<p>If <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a>==<a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5" title="Return the first Key in the KeySet.">ksHead()</a> you know you are on the first Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet object to get the first Key from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first Key of a KeySet </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer or empty KeySet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e" title="Return the last Key in the KeySet.">ksTail()</a> for getting the last Key of the KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> for iterating over the KeySet </dd></dl>

</div>
</div>
<a id="ga60f1ddcf23272f2b29b90e92ebe9b56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60f1ddcf23272f2b29b90e92ebe9b56f">&#9670;&nbsp;</a></span>ksLookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* ksLookup </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for a Key contained in <code>ks</code> that matches the name of the <code>key</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Applications should only use <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> with cascading Keys (Key name starting with <code>/</code>). Furthermore, a lookup should be done for every Key (also when iterating over Keys) so that the specifications are honored correctly. Keys of all namespaces need to be present so that <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> can work correctly, so make sure to also use <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> with a cascading Key.</dd></dl>
<p><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> is designed to let you work with a KeySet containing all Keys of the application. The idea is to fully <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> the whole configuration of your application and process it all at once with many <code><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a></code>.</p>
<p>This function is efficient (at least using binary search). Together with <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a>, which you can use to load the whole configuration, you can write very effective and short code for configuration:</p>
<div class="fragment"><div class="line">Key * key = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;/sw/tests/myapp/#0/current/&quot;</span>,  <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line">KDB * handle = <a class="code" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5">kdbOpen</a> (NULL, key);</div>
<div class="line"><a class="code" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet</a> (handle, myConfig, key);</div>
<div class="line">Key * result = <a class="code" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83">ksLookupByName</a> (myConfig, <span class="stringliteral">&quot;/sw/tests/myapp/#0/current/testkey1&quot;</span>, 0);</div>
<div class="ttc" id="agroup__keyset_html_gad65d2cdcbb5381194a1688e169af8a83"><div class="ttname"><a href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83">ksLookupByName</a></div><div class="ttdeci">Key * ksLookupByName(KeySet *ks, const char *name, elektraLookupFlags options)</div><div class="ttdoc">Convenience method to look for a Key contained in ks with name name.</div><div class="ttdef"><b>Definition:</b> keyset.c:2496</div></div>
</div><!-- fragment --><p> This is the way programs should get their configuration and search for the values. It is guaranteed, that more namespaces can be added easily and that all values can be set by admin and user. Furthermore, using the kdb-tool, it is possible to introspect which values an application will get (by doing the same cascading lookup).</p>
<p>If found, <code>ks</code> internal cursor will be positioned in the matched Key (also accessible by <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a>), and a pointer to the Key is returned. If not found, <code>ks</code> internal cursor will not move, and a NULL pointer is returned.</p>
<p>Cascading lookups will by default search in all namespaces (proc:/, dir:/, user:/ and system:/), but will also correctly consider the specification (=metadata) in spec:/:</p>
<ul>
<li><code>override/#</code> will make sure that another Key is considered before</li>
<li><code>namespace/#</code> will change the number and/or order in which the namespaces are searched</li>
<li><code>fallback/#</code> will search for other Keys when the other possibilities up to now were not successful</li>
<li><code>default</code> to return the given value when not even <code>fallback</code> Keys were found.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>override and fallback work recursively, while default does not.</dd></dl>
<p>This process is very flexible, but it would be boring to manually follow all this links to find out which Key will be taken in the end. Use <code>kdb get -v</code> to trace the Keys.</p>
<dl class="section user"><dt>KDB_O_POP</dt><dd>When <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984" title="Pop Parent out of keyset key in ksLookup().">KDB_O_POP</a> is set the Key which was found will be <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last Key of ks.">ksPop()</a>ed. <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> will not be changed, only iff <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> is the searched Key, then the KeySet will be <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>ed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Like in <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last Key of ks.">ksPop()</a> the popped Key always needs to be <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects.">keyDel()</a> afterwards, even if it is appended to another KeySet.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All cursors on the KeySet will be invalid iff you use <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984" title="Pop Parent out of keyset key in ksLookup().">KDB_O_POP</a>, so don't use this if you rely on a cursor, see <a class="el" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7" title="Get the internal cursor of the KeySet.">ksGetCursor()</a>.</dd></dl>
<p>The invalidation of cursors does not matter if you use multiple KeySets, e.g. by using <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup()</a>. E.g., to separate <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> with <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984" title="Pop Parent out of keyset key in ksLookup().">KDB_O_POP</a> and <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks.">ksAppendKey()</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f (KeySet * iterator, KeySet * lookup)</div>
<div class="line">{</div>
<div class="line">        KeySet * append = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (<a class="code" href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">ksGetSize</a> (lookup), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line">        Key * current;</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (iterator);</div>
<div class="line">        <span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (iterator)))</div>
<div class="line">        {</div>
<div class="line">                Key * key = <a class="code" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f">ksLookup</a> (lookup, current, <a class="code" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984">KDB_O_POP</a>);</div>
<div class="line">                <span class="comment">// do something...</span></div>
<div class="line">                <a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (append, key); <span class="comment">// now append it to append, not lookup!</span></div>
<div class="line">                <a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (key);              <span class="comment">// make sure to ALWAYS delete poped keys.</span></div>
<div class="line">        }</div>
<div class="line">        <a class="code" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend</a> (lookup, append);</div>
<div class="line">        <span class="comment">// now lookup needs to be sorted only once, append never</span></div>
<div class="line">        <a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (append);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__keyset_html_ga21eb9c3a14a604ee3a8bdc779232e7b7"><div class="ttname"><a href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7">ksAppend</a></div><div class="ttdeci">ssize_t ksAppend(KeySet *ks, const KeySet *toAppend)</div><div class="ttdoc">Append all Keys in toAppend to the end of the KeySet ks.</div><div class="ttdef"><b>Definition:</b> keyset.c:898</div></div>
<div class="ttc" id="agroup__keyset_html_ga60f1ddcf23272f2b29b90e92ebe9b56f"><div class="ttname"><a href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f">ksLookup</a></div><div class="ttdeci">Key * ksLookup(KeySet *ks, Key *key, elektraLookupFlags options)</div><div class="ttdoc">Look for a Key contained in ks that matches the name of the key.</div><div class="ttdef"><b>Definition:</b> keyset.c:2432</div></div>
<div class="ttc" id="agroup__keyset_html_ga7474ad6b0a0fa969dbdf267ba5770eee"><div class="ttname"><a href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">ksGetSize</a></div><div class="ttdeci">ssize_t ksGetSize(const KeySet *ks)</div><div class="ttdoc">Return the number of Keys that ks contains.</div><div class="ttdef"><b>Definition:</b> keyset.c:646</div></div>
<div class="ttc" id="agroup__keyset_html_ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984"><div class="ttname"><a href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a52fb5f2cc86773d393da62bebebf7984">KDB_O_POP</a></div><div class="ttdeci">@ KDB_O_POP</div><div class="ttdoc">Pop Parent out of keyset key in ksLookup().</div><div class="ttdef"><b>Definition:</b> kdbenum.c:188</div></div>
</div><!-- fragment --><p> This is also a nice example how a complete application with <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> can look like.</p>
<dl class="section user"><dt>KDB_O_DEL</dt><dd>Passing <a class="el" href="group__keyset.html#ggada05f4bbf46fde81d0d57df86e73d914a66a5380c120f25f28f49848c4a863ead" title="Delete parentKey key in ksLookup().">KDB_O_DEL</a> will cause the deletion of the parameter <code>key</code> using <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects.">keyDel()</a>.</dd></dl>
<dl class="section user"><dt>Hybrid search</dt><dd>When Elektra is compiled with <code>ENABLE_OPTIMIZATIONS=ON</code> a hybrid search decides dynamically between the binary search and the <a href="https://master.libelektra.org/doc/dev/data-structures.md#order-preserving-minimal-perfect-hash-map-aka-opmphm">OPMPHM</a>. The hybrid search can be overruled by passing <a class="el" href="kdbhelper_8h.html#a93673533c4c8eb1fdfca76b98c5f49b0afe9f6ff6e374540baf600a918b07ee6e" title="Overrule ksLookup search predictor to use OPMPHM, make sure to set ENABLE_OPTIMIZATIONS=ON at cmake.">KDB_O_OPMPHM</a> or <a class="el" href="kdbhelper_8h.html#a93673533c4c8eb1fdfca76b98c5f49b0ac67a43bd273203575090d26010f6c995" title="Overrule ksLookup search predictor to use Binary search for lookup.">KDB_O_BINSEARCH</a> in the options to <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet that should be searched </td></tr>
    <tr><td class="paramname">key</td><td>the Key object you are looking for </td></tr>
    <tr><td class="paramname">options</td><td>of type <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914" title="Options to change the default behavior of ksLookup() functions.">elektraLookupFlags</a> with some <code>KDB_O_*</code> option bits - as explained above</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the Key found </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no Key has been found </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gad65d2cdcbb5381194a1688e169af8a83" title="Convenience method to look for a Key contained in ks with name name.">ksLookupByName()</a> to search by a name given by a string </dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a>, <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>, <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> for iterating over a KeySet </dd></dl>

</div>
</div>
<a id="gad65d2cdcbb5381194a1688e169af8a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65d2cdcbb5381194a1688e169af8a83">&#9670;&nbsp;</a></span>ksLookupByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* ksLookupByName </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914">elektraLookupFlags</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to look for a Key contained in <code>ks</code> with name <code>name</code>. </p>
<p>There are several options that can be used in conjunction with this function. All possible option flags can be found in <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914" title="Options to change the default behavior of ksLookup() functions.">elektraLookupFlags</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet that should be searched </td></tr>
    <tr><td class="paramname">name</td><td>name of the Key you are looking for </td></tr>
    <tr><td class="paramname">options</td><td>some <code>KDB_O_*</code> option bits (KDB_O_POP, KDB_O_DEL):<ul>
<li>See <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> or <a class="el" href="group__keyset.html#gada05f4bbf46fde81d0d57df86e73d914" title="Options to change the default behavior of ksLookup() functions.">elektraLookupFlags</a> for possible options</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the Key found </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no Key has been found </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> for explanation of the functionality and examples. </dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a>, <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>, <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> for iterating over a KeySet </dd></dl>

</div>
</div>
<a id="ga8f210432e664d8ba06d7d55a2aba2d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f210432e664d8ba06d7d55a2aba2d0f">&#9670;&nbsp;</a></span>ksNeedSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ksNeedSync </td>
          <td>(</td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if KeySet needs sync. </p>
<p>When Keys are changed, this is reflected into <a class="el" href="group__keytest.html#gaf247df0de7aca04b32ef80e39ef12950" title="Test if a key needs to be synced to backend storage.">keyNeedSync()</a>.</p>
<p>But when Keys are popped from a KeySet this can't be seen by looking at individual Keys.</p>
<p><a class="el" href="group__keyset.html#ga8f210432e664d8ba06d7d55a2aba2d0f" title="Checks if KeySet needs sync.">ksNeedSync()</a> allows the backends to know if a Key was popped from the KeySet, to know that this KeySet needs to be written out.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Backends now work differently and do not rely on this information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet to work with</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL KeySet </td></tr>
    <tr><td class="paramname">0</td><td>if <code>ks</code> does not need sync </td></tr>
    <tr><td class="paramname">1</td><td>if <code>ks</code> needs sync</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keytest.html#gaf247df0de7aca04b32ef80e39ef12950" title="Test if a key needs to be synced to backend storage.">keyNeedSync()</a> for checking whether a single Key needs to be synced </dd></dl>

</div>
</div>
<a id="ga671e1aaee3ae9dc13b4834a4ddbd2c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">&#9670;&nbsp;</a></span>ksNew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KeySet* ksNew </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate, initialize and return a new KeySet object. </p>
<p>Objects created with <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a>.</p>
<p>You can use an arbitrary long list of parameters to preload the KeySet with a list of Keys. Either your first and only parameter is 0 or your last parameter must be KS_END.</p>
<p>So, terminate with ksNew(0, KS_END) or ksNew(20, ..., KS_END)</p>
<dl class="section warning"><dt>Warning</dt><dd>Never use ksNew(0, keyNew(...), KS_END). If the first parameter is 0, other arguments are ignored.</dd></dl>
<p>The first parameter <code>alloc</code> defines how many Keys can be added without reallocation. If you pass any alloc size greater than 0, but less than 16, it will default to 16.</p>
<p>For most uses</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"><span class="comment">// enough memory for up to 16 keys, without needing reallocation</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment --><p> will be fine. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large KeySets.</p>
<p>You can defer the allocation of the internal array that holds the Keys, by passing 0 as the alloc size. This is useful if it is unclear whether your KeySet will actually hold any Keys and you want to avoid a malloc call.</p>
<div class="fragment"><div class="line"><span class="comment">// Create KeySet without allocating memory for keys</span></div>
<div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"><span class="comment">// The first allocation will happen in ksAppendKey</span></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(keys, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>));</div>
<div class="line"><span class="comment">// work with the KeySet</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a></div><div class="ttdeci">@ KEY_VALUE</div><div class="ttdef"><b>Definition:</b> kdbenum.c:89</div></div>
</div><!-- fragment --><p> If the size of the KeySet is known in advance, use the <code>alloc</code> parameter to hint the size of the KeySet.</p>
<p>If your application only needs up to 15 Keys you can request a KeySet of size 15:</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (15, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key01&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value01&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key03&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value03&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                       <span class="comment">// ...</span></div>
<div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key15&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value15&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment --><p> If you start having 3 Keys, and your application needs approximately 200 up to 500 Keys, you can use:</p>
<div class="fragment"><div class="line">KeySet * config = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (500, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key1&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value1&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key2&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value2&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key3&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value3&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                         <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>); <span class="comment">// don&#39;t forget the KS_END at the end!</span></div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (config);</div>
</div><!-- fragment --><p> Alloc size is 500, the size of the KeySet will be 3 after ksNew. This means the KeySet will reallocate when appending more than 497 keys.</p>
<p>The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible KeySet. If you prefer, you can always create an empty KeySet and use <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks.">ksAppendKey()</a>.</p>
<dl class="section post"><dt>Postcondition</dt><dd>the KeySet is rewinded properly</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>gives a hint for how many Keys may be stored initially</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready to use KeySet object </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on memory error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a> to free the KeySet afterwards </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup()</a> to duplicate an existing KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks.">ksAppendKey()</a> to append individual Keys to a KeySet </dd></dl>

</div>
</div>
<a id="ga317321c9065b5a4b3e33fe1c399bcec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga317321c9065b5a4b3e33fe1c399bcec9">&#9670;&nbsp;</a></span>ksNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* ksNext </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the next Key in a KeySet. </p>
<p>KeySets have an internal cursor that can be reset with <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>. Every time <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> is called, the cursor is incremented and the new current Key is returned.</p>
<p>You'll get a NULL pointer if the Key at the end of the KeySet has been reached. On subsequent calls of <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> it will still return the NULL pointer.</p>
<p>The <code>ks</code> internal cursor will be changed, so it is not const.</p>
<dl class="section note"><dt>Note</dt><dd>You must not delete or change the Key, use <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last Key of ks.">ksPop()</a> if you want to delete it.</dd>
<dd>
That applications must do <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> with an cascading Key for every single Key before using it, because specifications allow to hide or override Keys.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet object to work with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new current Key </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the end of the KeySet has been reached </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a> for resetting the internal cursor of the KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> for getting the Key the cursor currently points at </dd>
<dd>
<a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> to honor specifications </dd></dl>

</div>
</div>
<a id="gae42530b04defb772059de0600159cf69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae42530b04defb772059de0600159cf69">&#9670;&nbsp;</a></span>ksPop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* ksPop </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and return the last Key of <code>ks</code>. </p>
<p>The reference counter of the Key will be decremented by one.</p>
<p>The KeySet's cursor will not be affected if it did not point to the popped Key.</p>
<dl class="section note"><dt>Note</dt><dd>You need to <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects.">keyDel()</a> the Key afterwards, if you don't append it to another KeySet. It has the same semantics like a Key allocated with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step.">keyNew()</a> or keyDup().</dd></dl>
<div class="fragment"><div class="line">ks1=<a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line">ks2=<a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"> </div>
<div class="line">k1=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user:/name&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>); <span class="comment">// ref counter 0</span></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks1, k1); <span class="comment">// ref counter 1</span></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks2, k1); <span class="comment">// ref counter 2</span></div>
<div class="line"> </div>
<div class="line">k1=<a class="code" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop</a> (ks1); <span class="comment">// ref counter 1</span></div>
<div class="line">k1=<a class="code" href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop</a> (ks2); <span class="comment">// ref counter 0, like after keyNew()</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(ks1, k1); <span class="comment">// ref counter 1</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks1); <span class="comment">// key is deleted too</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks2);</div>
<div class="ttc" id="agroup__keyset_html_gae42530b04defb772059de0600159cf69"><div class="ttname"><a href="group__keyset.html#gae42530b04defb772059de0600159cf69">ksPop</a></div><div class="ttdeci">Key * ksPop(KeySet *ks)</div><div class="ttdoc">Remove and return the last Key of ks.</div><div class="ttdef"><b>Definition:</b> keyset.c:1403</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>KeySet to pop a Key from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last Key of <code>ks</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if <code>ks</code> is empty or a NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> to pop Keys by name </dd>
<dd>
<a class="el" href="group__keyset.html#gaba1f1dbea191f4d7e7eb3e4296ae7d5e" title="Replace the content of a KeySet with another one.">ksCopy()</a> to pop all Keys </dd>
<dd>
<a class="el" href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e" title="Return the last Key in the KeySet.">ksTail()</a> for getting the last Key of a KeySet without removing it </dd></dl>

</div>
</div>
<a id="gaa9b59d3a7ccd58511b562755454d1fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9b59d3a7ccd58511b562755454d1fae">&#9670;&nbsp;</a></span>ksRename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ksRename </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>newRoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves all keys below <code>root</code> to below <code>newRoot</code>. </p>
<p>Only keys below <code>root</code> will be modified. The rest of <code>ks</code> remains untouched.</p>
<p>This functions is similar to the following snippet, but there are some differences.</p>
<div class="fragment"><div class="line">KeySet * toRename = <a class="code" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a">ksCut</a> (ks, root);</div>
<div class="line"><span class="keywordflow">for</span> (elektraCursor cursor = 0; cursor &lt; <a class="code" href="group__keyset.html#ga7474ad6b0a0fa969dbdf267ba5770eee">ksGetSize</a> (toRename); cursor++)</div>
<div class="line">{</div>
<div class="line">    Key * cur = keyDup (<a class="code" href="group__keyset.html#ga12b8fefaa20546e4790d60338b0db836">ksAtCursor</a> (ks, cursor));</div>
<div class="line">    <a class="code" href="group__keyname.html#gae22037aad3f76f4454de4e6400637b39">keyReplacePrefix</a> (cur, root, newRoot);</div>
<div class="line">    <a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (ks, cur);</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (toRename);</div>
<div class="ttc" id="agroup__keyname_html_gae22037aad3f76f4454de4e6400637b39"><div class="ttname"><a href="group__keyname.html#gae22037aad3f76f4454de4e6400637b39">keyReplacePrefix</a></div><div class="ttdeci">int keyReplacePrefix(Key *key, const Key *oldPrefix, const Key *newPrefix)</div><div class="ttdoc">Replaces a prefix of the key name of key.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:677</div></div>
</div><!-- fragment --><p>Firstly, the optimizations only work, if <code>ks</code> doesn't contain any keys below <code>newRoot</code> that aren't below <code>root</code>. If such keys exist, <a class="el" href="group__keyset.html#gaa9b59d3a7ccd58511b562755454d1fae" title="Moves all keys below root to below newRoot.">ksRename()</a> will still work, but it will fall back to code similar to the for-loop above.</p>
<p>The second difference is that <a class="el" href="group__keyset.html#gaa9b59d3a7ccd58511b562755454d1fae" title="Moves all keys below root to below newRoot.">ksRename()</a> will modify the keys in <code>ks</code> directly, if they aren't referenced from anywhere else (if their reference count is 1 (see <a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae" title="Return how many references the Key has.">keyGetRef()</a>)). Normally, this shouldn't cause problems, but if you have a direct <code>Key *</code> pointer to a key in <code>ks</code> or hold a reference to some data within a key of <code>ks</code>, you may need to call <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the reference counter of a Key object.">keyIncRef()</a> to ensure the key isn't modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset to manipulate </td></tr>
    <tr><td class="paramname">root</td><td>the old prefix that will be removed, must not be a cascading key </td></tr>
    <tr><td class="paramname">newRoot</td><td>the new prefix the will replace the old one, must not be a cascading key</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if any of <code>ks</code>, <code>root</code>, <code>newRoot</code> is NULL, or if <code>root</code> or <code>newRoot</code> are cascading keys </td></tr>
    <tr><td class="paramname">-2</td><td>if <code>ks</code> already contains keys below <code>newRoot</code> </td></tr>
    <tr><td class="paramname">0</td><td>if <code>ks</code> contains no keys below <code>root</code> (and also not <code>root</code> itself) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>otherwise, the number of keys that have been renamed </dd></dl>

</div>
</div>
<a id="gabe793ff51f1728e3429c84a8a9086b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe793ff51f1728e3429c84a8a9086b70">&#9670;&nbsp;</a></span>ksRewind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ksRewind </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewinds the KeySet internal cursor. </p>
<p>Use it to set the cursor to the beginning of the KeySet. <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> will always return NULL afterwards. So you want to use <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> first.</p>
<div class="fragment"><div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (ks);</div>
<div class="line"><span class="keywordflow">while</span> ((key = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (ks))!=0) {}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet that should be rewound</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> for moving the cursor to the next entry in the KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> for getting the current element in the KeySet </dd></dl>

</div>
</div>
<a id="ga28b2a7d13c620b3c9d4815a0608c738f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28b2a7d13c620b3c9d4815a0608c738f">&#9670;&nbsp;</a></span>ksSetCursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ksSetCursor </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">elektraCursor&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the KeySet internal cursor to <code>cursor</code>. </p>
<p>Use it to set the cursor to a stored position. <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> will then return the Key at the position of the supplied cursor.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cursors may get invalid when the Key was <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last Key of ks.">ksPop()</a>ed or <a class="el" href="group__keyset.html#ga60f1ddcf23272f2b29b90e92ebe9b56f" title="Look for a Key contained in ks that matches the name of the key.">ksLookup()</a> was used together with KDB_O_POP.</dd></dl>
<div class="fragment"><div class="line">elektraCursor cursor;</div>
<div class="line">..</div>
<div class="line"><span class="comment">// key now in any position here</span></div>
<div class="line">cursor = <a class="code" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7">ksGetCursor</a> (ks);</div>
<div class="line"><span class="keywordflow">while</span> ((key = <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (ks))!=0) {}</div>
<div class="line"><a class="code" href="group__keyset.html#ga28b2a7d13c620b3c9d4815a0608c738f">ksSetCursor</a> (ks, cursor); <span class="comment">// reset state</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent</a>(ks); <span class="comment">// in same position as before</span></div>
<div class="ttc" id="agroup__keyset_html_ga4287b9416912c5f2ab9c195cb74fb094"><div class="ttname"><a href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent</a></div><div class="ttdeci">Key * ksCurrent(const KeySet *ks)</div><div class="ttdoc">Return the current Key.</div><div class="ttdef"><b>Definition:</b> keyset.c:1522</div></div>
</div><!-- fragment --><p>An invalid cursor will set the KeySet to its beginning like <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>. When you set an invalid cursor <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> is 0 and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> == <a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5" title="Return the first Key in the KeySet.">ksHead()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet object where the cursor should be set </td></tr>
    <tr><td class="paramname">cursor</td><td>the cursor to set for <code>ks</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the KeySet has been <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>ed </td></tr>
    <tr><td class="paramname">1</td><td>otherwise </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gace0444eb8ec958a429794f8586fc72e7" title="Get the internal cursor of the KeySet.">ksGetCursor()</a> for getting the cursor at the current position </dd>
<dd>
<a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> for moving the internal cursor forward </dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> for getting the Key at the current position </dd></dl>

</div>
</div>
<a id="gadca442c4ab43cf532b15091d7711559e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadca442c4ab43cf532b15091d7711559e">&#9670;&nbsp;</a></span>ksTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* ksTail </td>
          <td>(</td>
          <td class="paramtype">const KeySet *&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the last Key in the KeySet. </p>
<p>The KeySet's cursor will not be affected.</p>
<p>If <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a>==<a class="el" href="group__keyset.html#gadca442c4ab43cf532b15091d7711559e" title="Return the last Key in the KeySet.">ksTail()</a> you know you are on the last key. <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> will return a NULL pointer afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the KeySet object to get the last Key from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last Key of a KeySet </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer or empty KeySet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gae7dbf3aef70e67b5328475eb3d1f92f5" title="Return the first Key in the KeySet.">ksHead()</a> for getting the first Key of a KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor.">ksRewind()</a>, <a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key.">ksCurrent()</a> and <a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet.">ksNext()</a> for iterating over the KeySet </dd></dl>

</div>
</div>
<a id="ga4ff760f56693b51ab785ed7ce628e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ff760f56693b51ab785ed7ce628e649">&#9670;&nbsp;</a></span>ksVNew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KeySet* ksVNew </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate, initialize and return a new KeySet object. </p>
<p>Objects created with <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c" title="Allocate, initialize and return a new KeySet object.">ksNew()</a> must be destroyed with <a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a>.</p>
<p>You can use an arbitrary long list of parameters to preload the KeySet with a list of Keys. Either your first and only parameter is 0 or your last parameter must be KS_END.</p>
<p>So, terminate with ksNew(0, KS_END) or ksNew(20, ..., KS_END)</p>
<dl class="section warning"><dt>Warning</dt><dd>Never use ksNew(0, keyNew(...), KS_END). If the first parameter is 0, other arguments are ignored.</dd></dl>
<p>The first parameter <code>alloc</code> defines how many Keys can be added without reallocation. If you pass any alloc size greater than 0, but less than 16, it will default to 16.</p>
<p>For most uses</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"><span class="comment">// enough memory for up to 16 keys, without needing reallocation</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment --><p> will be fine. The alloc size will be 16 and will double whenever size reaches alloc size, so it also performs well with large KeySets.</p>
<p>You can defer the allocation of the internal array that holds the Keys, by passing 0 as the alloc size. This is useful if it is unclear whether your KeySet will actually hold any Keys and you want to avoid a malloc call.</p>
<div class="fragment"><div class="line"><span class="comment">// Create KeySet without allocating memory for keys</span></div>
<div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (0, <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"><span class="comment">// The first allocation will happen in ksAppendKey</span></div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(keys, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>));</div>
<div class="line"><span class="comment">// work with the KeySet</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment --><p> If the size of the KeySet is known in advance, use the <code>alloc</code> parameter to hint the size of the KeySet.</p>
<p>If your application only needs up to 15 Keys you can request a KeySet of size 15:</p>
<div class="fragment"><div class="line">KeySet * keys = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (15, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key01&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value01&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value02&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key03&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value03&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                       <span class="comment">// ...</span></div>
<div class="line">                       <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key15&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value15&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>), <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (keys);</div>
</div><!-- fragment --><p> If you start having 3 Keys, and your application needs approximately 200 up to 500 Keys, you can use:</p>
<div class="fragment"><div class="line">KeySet * config = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (500, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key1&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value1&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key2&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value2&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                         <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user:/sw/org/app/#0/current/fixedConfiguration/key3&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;value3&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>),</div>
<div class="line">                         <a class="code" href="group__keyset.html#ga7a28fce3773b2c873c94ac80b8b4cd54">KS_END</a>); <span class="comment">// don&#39;t forget the KS_END at the end!</span></div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (config);</div>
</div><!-- fragment --><p> Alloc size is 500, the size of the KeySet will be 3 after ksNew. This means the KeySet will reallocate when appending more than 497 keys.</p>
<p>The main benefit of taking a list of variant length parameters is to be able to have one C-Statement for any possible KeySet. If you prefer, you can always create an empty KeySet and use <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks.">ksAppendKey()</a>.</p>
<dl class="section post"><dt>Postcondition</dt><dd>the KeySet is rewinded properly</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>gives a hint for how many Keys may be stored initially</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a ready to use KeySet object </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on memory error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8" title="A destructor for KeySet objects.">ksDel()</a> to free the KeySet afterwards </dd>
<dd>
<a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup()</a> to duplicate an existing KeySet </dd>
<dd>
<a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks.">ksAppendKey()</a> to append individual Keys to a KeySet</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>caller must call va_start and va_end </dd></dl>
<dl class="section user"><dt>va the list of arguments</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>the allocation size </td></tr>
    <tr><td class="paramname">va</td><td>the list of variable arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
