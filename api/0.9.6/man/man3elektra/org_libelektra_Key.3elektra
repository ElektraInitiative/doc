.TH "org.libelektra.Key" 3elektra "Mon Jun 7 2021" "Version 0.9.6" "Elektra" \" -*- nroff -*-
.ad l
.nh
.SH NAME
org.libelektra.Key \- \fBKey\fP represents an native \fBElektra\fP key providing access to its name, value and meta information\&.  

.SH SYNOPSIS
.br
.PP
.PP
Inherits Iterable< String >\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "enum \fBCreateArgumentTag\fP"
.br
.RI "Argument tags for use with \fBcreate(String, Object\&.\&.\&.)\fP\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBrelease\fP ()"
.br
.RI "Clean-up method to release key reference by first decrementing its reference counter and then trying to free the native reference
.br
 
.br
 Call this method if you do not longer need a \fBKey\fP and obtained it via any of its public methods or the public methods of \fBKeySet\fP\&. "
.ti -1c
.RI "String \fBtoString\fP ()"
.br
.ti -1c
.RI "Iterator< String > \fBiterator\fP ()"
.br
.ti -1c
.RI "boolean \fBgetBoolean\fP ()"
.br
.ti -1c
.RI "boolean \fBgetBooleanAndRelease\fP ()"
.br
.RI "Return the key's value and releases this key\&. "
.ti -1c
.RI "byte \fBgetByte\fP ()"
.br
.ti -1c
.RI "byte \fBgetByteAndRelease\fP ()"
.br
.RI "Return the key's value and releases this key\&. "
.ti -1c
.RI "short \fBgetShort\fP ()"
.br
.ti -1c
.RI "short \fBgetShortAndRelease\fP ()"
.br
.RI "Return the key's value and releases this key\&. "
.ti -1c
.RI "int \fBgetInt\fP ()"
.br
.ti -1c
.RI "int \fBgetIntAndRelease\fP ()"
.br
.RI "Return the key's value and releases this key\&. "
.ti -1c
.RI "long \fBgetLong\fP ()"
.br
.ti -1c
.RI "long \fBgetLongAndRelease\fP ()"
.br
.RI "Return the key's value and releases this key\&. "
.ti -1c
.RI "float \fBgetFloat\fP ()"
.br
.ti -1c
.RI "float \fBgetFloatAndRelease\fP ()"
.br
.RI "Return the key's value and releases this key\&. "
.ti -1c
.RI "double \fBgetDouble\fP ()"
.br
.ti -1c
.RI "double \fBgetDoubleAndRelease\fP ()"
.br
.RI "Return the key's value and releases this key\&. "
.ti -1c
.RI "String \fBgetString\fP ()  throws KeyBinaryTypeNotSupportedException 	"
.br
.ti -1c
.RI "String \fBgetStringAndRelease\fP ()  throws KeyBinaryTypeNotSupportedException 	"
.br
.RI "Return the key's value and releases this key\&. "
.ti -1c
.RI "\fBKey\fP \fBsetBoolean\fP (boolean value)"
.br
.RI "Sets the key's value by converting\&. "
.ti -1c
.RI "\fBKey\fP \fBsetByte\fP (byte value)"
.br
.RI "Sets the key's value by converting\&. "
.ti -1c
.RI "\fBKey\fP \fBsetShort\fP (short value)"
.br
.RI "Sets the key's value by converting\&. "
.ti -1c
.RI "\fBKey\fP \fBsetInt\fP (int value)"
.br
.RI "Sets the key's value by converting\&. "
.ti -1c
.RI "\fBKey\fP \fBsetLong\fP (long value)"
.br
.RI "Sets the key's value by converting\&. "
.ti -1c
.RI "\fBKey\fP \fBsetFloat\fP (float value)"
.br
.RI "Sets the key's value by converting\&. "
.ti -1c
.RI "\fBKey\fP \fBsetDouble\fP (double value)"
.br
.RI "Sets the key's value by converting\&. "
.ti -1c
.RI "\fBKey\fP \fBsetString\fP (String value)"
.br
.RI "Sets the key's value\&. "
.ti -1c
.RI "\fBKey\fP \fBsetError\fP (String text, Object\&.\&.\&. args)"
.br
.RI "Sets proper error meta for key\&. "
.ti -1c
.RI "\fBKey\fP \fBaddWarning\fP (String text, Object\&.\&.\&. args)"
.br
.RI "Adds warning meta for key\&. "
.ti -1c
.RI "\fBKey\fP \fBdup\fP ()"
.br
.RI "Duplicates the key\&. "
.ti -1c
.RI "\fBKey\fP \fBdup\fP (int flags)"
.br
.RI "Duplicates the key\&. "
.ti -1c
.RI "\fBKey\fP \fBcopy\fP (\fBKey\fP source, int flags)"
.br
.RI "Copies the information from the\&. "
.ti -1c
.RI "\fBKey\fP \fBrewindMeta\fP ()"
.br
.RI "Rewinds the internal iterator for meta information of this key\&. "
.ti -1c
.RI "\fBKey\fP \fBnextMeta\fP ()"
.br
.RI "Gets the next element of this key's internal meta information iterator\&. "
.ti -1c
.RI "\fBKey\fP \fBcurrentMeta\fP ()"
.br
.RI "Gets the current element of this key's internal meta information iterator\&. "
.ti -1c
.RI "boolean \fBcopyMeta\fP (\fBKey\fP source, String metaName)"
.br
.RI "Copies some meta information from a\&. "
.ti -1c
.RI "boolean \fBcopyAllMeta\fP (\fBKey\fP source)"
.br
.RI "Copies all meta information from a\&. "
.ti -1c
.RI "Optional< \fBKey\fP > \fBgetMeta\fP (String metaName)"
.br
.RI "Getter for meta information\&. "
.ti -1c
.RI "\fBKey\fP \fBsetMeta\fP (String metaName, String newMetaString)"
.br
.RI "Sets meta information\&. "
.ti -1c
.RI "\fBKey\fP \fBremoveMeta\fP (String metaName)"
.br
.RI "Removes meta information\&. "
.ti -1c
.RI "int \fBcmp\fP (\fBKey\fP other)"
.br
.RI "Compares this key with the\&. "
.ti -1c
.RI "boolean \fBisBelow\fP (\fBKey\fP other)"
.br
.RI "Checks whether this key is sub-key of the\&. "
.ti -1c
.RI "boolean \fBisBelowOrSame\fP (\fBKey\fP other)"
.br
.RI "Checks whether this key is the same as the\&. "
.ti -1c
.RI "boolean \fBisDirectBelow\fP (\fBKey\fP other)"
.br
.RI "Checks whether this key is direct sub-key of the\&. "
.ti -1c
.RI "boolean \fBisBinary\fP ()"
.br
.ti -1c
.RI "boolean \fBisString\fP ()"
.br
.ti -1c
.RI "String \fBgetName\fP ()"
.br
.ti -1c
.RI "int \fBgetNameSize\fP ()"
.br
.ti -1c
.RI "\fBKey\fP \fBsetName\fP (String name)"
.br
.RI "Sets the key's name\&. "
.ti -1c
.RI "String \fBgetBaseName\fP ()"
.br
.ti -1c
.RI "int \fBgetBaseNameSize\fP ()"
.br
.ti -1c
.RI "\fBKey\fP \fBsetBaseName\fP (String baseName)  throws KeyNameException 	"
.br
.RI "Sets the key's base name; will replace current base name with new base name\&. "
.ti -1c
.RI "\fBKey\fP \fBaddBaseName\fP (String baseName)"
.br
.RI "Adds key base name; will add given base name to current key so that new key is sub key of current key\&. "
.ti -1c
.RI "int \fBgetValueSize\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBKey\fP \fBcreateNameless\fP ()"
.br
.RI "Constructs a temporary nameless \fBKey\fP which cannot be saved to the key data base but used for transferring warnings and error information\&. "
.ti -1c
.RI "static \fBKey\fP \fBcreate\fP (String name, @Nullable Object value, Key\&.\&.\&. meta)"
.br
.RI "Constructs a new \fBKey\fP with the specified content and arguments
.br
 "
.ti -1c
.RI "static \fBKey\fP \fBcreate\fP (String name, Key\&.\&.\&. meta)"
.br
.RI "Basic constructor of key class\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static final int \fBKEY_CP_NAME\fP = 1 << 0"
.br
.RI "Flag for use with \fBcopy(Key, int)\fP for copying the key name\&. "
.ti -1c
.RI "static final int \fBKEY_CP_STRING\fP = 1 << 1"
.br
.RI "Flag for use with \fBcopy(Key, int)\fP for copying the key value, if it is a string\&. "
.ti -1c
.RI "static final int \fBKEY_CP_VALUE\fP = 1 << 2"
.br
.RI "Flag for use with \fBcopy(Key, int)\fP for copying the key value\&. "
.ti -1c
.RI "static final int \fBKEY_CP_META\fP = 1 << 3"
.br
.RI "Flag for use with \fBcopy(Key, int)\fP for copying the key metadata\&. "
.ti -1c
.RI "static final int \fBKEY_CP_ALL\fP = \fBKEY_CP_NAME\fP | \fBKEY_CP_VALUE\fP | \fBKEY_CP_META\fP"
.br
.RI "Flag for use with \fBcopy(Key, int)\fP for copying the key name, value and metadata\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBKey\fP (long nativePointer)"
.br
.RI "Constructor associating a new \fBKey\fP instance with a native pointer in long format\&. "
.ti -1c
.RI "\fBKey\fP (long nativePointer, boolean suppressCleanUp)"
.br
.RI "Constructor associating a new \fBKey\fP instance with a native pointer in long format
.br
 
.br
 Suppressing clean-up has been introduced for usage of this binding as JNI plug-in and should normally not be used in any other case\&. "
.ti -1c
.RI "\fBKey\fP (Pointer pointer)"
.br
.RI "Constructor associating a new \fBKey\fP instance with a JNA pointer\&. "
.ti -1c
.RI "\fBKey\fP \fBincRef\fP ()"
.br
.RI "Increments the reference counter for the underlying native key\&. "
.ti -1c
.RI "void \fBdecRef\fP ()"
.br
.RI "Decrements the reference counter for the underlying native key\&. "
.ti -1c
.RI "int \fBgetRef\fP ()"
.br
.RI "Gets the reference counter for the underlying native key\&. "
.ti -1c
.RI "Pointer \fBgetPointer\fP ()"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static Optional< \fBKey\fP > \fBcreate\fP (@Nullable Pointer pointer)"
.br
.RI "Constructs a new \fBKey\fP instance associated with a JNA pointer\&. "
.ti -1c
.RI "static \fBKey\fP \fBcreate\fP (String name, Object\&.\&.\&. args)"
.br
.RI "Constructs a new \fBKey\fP with the specified content and arguments
.br
 "
.in -1c
.SH "Detailed Description"
.PP 
\fBKey\fP represents an native \fBElektra\fP key providing access to its name, value and meta information\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "org\&.libelektra\&.Key\&.Key (long nativePointer)\fC [inline]\fP, \fC [protected]\fP"

.PP
Constructor associating a new \fBKey\fP instance with a native pointer in long format\&. 
.PP
\fBParameters\fP
.RS 4
\fInativePointer\fP Native pointer to key in long format 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP @implNote Increased the native \fBKey\fP's reference counter 
.RE
.PP

.SS "org\&.libelektra\&.Key\&.Key (long nativePointer, boolean suppressCleanUp)\fC [inline]\fP, \fC [protected]\fP"

.PP
Constructor associating a new \fBKey\fP instance with a native pointer in long format
.br
 
.br
 Suppressing clean-up has been introduced for usage of this binding as JNI plug-in and should normally not be used in any other case\&. 
.PP
\fBParameters\fP
.RS 4
\fInativePointer\fP Native pointer to key in long format 
.br
\fIsuppressCleanUp\fP True to suppress native reference clean-up as soon as this \fBKey\fP instance becomes phantom reachable, false otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP @implNote Increased the native \fBKey\fP's reference counter, even if 
.PP
.nf
suppressCleanUp 

.fi
.PP
 is
.PP
.nf
true 

.fi
.PP
 
.RE
.PP

.SS "org\&.libelektra\&.Key\&.Key (Pointer pointer)\fC [inline]\fP, \fC [protected]\fP"

.PP
Constructor associating a new \fBKey\fP instance with a JNA pointer\&. 
.PP
\fBParameters\fP
.RS 4
\fIpointer\fP JNA \fBPointer\fP to key 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "\fBKey\fP org\&.libelektra\&.Key\&.addBaseName (String baseName)\fC [inline]\fP"

.PP
Adds key base name; will add given base name to current key so that new key is sub key of current key\&. 
.PP
\fBParameters\fP
.RS 4
\fIbaseName\fP New key base name to add 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyNameException\fP if
.PP
.nf
baseName 

.fi
.PP
 is invalid, the key was inserted in a key set before or the key name is read-only 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
baseName 

.fi
.PP
 is \fBblank\fP 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.addWarning (String text, Object\&.\&.\&. args)\fC [inline]\fP"

.PP
Adds warning meta for key\&. 
.PP
\fBParameters\fP
.RS 4
\fItext\fP Reason for the warning 
.br
\fIargs\fP Custom arguments 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP

.SS "int org\&.libelektra\&.Key\&.cmp (\fBKey\fP other)\fC [inline]\fP"

.PP
Compares this key with the\&. 
.PP
.nf
other 

.fi
.PP
 keys by comparing the key name with string comparison
.PP
\fBParameters\fP
.RS 4
\fIother\fP Other key to compare this key to 
.RE
.PP
\fBReturns\fP
.RS 4
.PD 0
.IP "\(bu" 2
0 if key name is equal 
.IP "\(bu" 2
-1 if this key name has lower alphabetical order than the 
.PP
.nf
other 

.fi
.PP
 key 
.IP "\(bu" 2
1 if this key has higher alphabetical order 
.PP
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this or the
.PP
.nf
other 

.fi
.PP
 \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
other 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.copy (\fBKey\fP source, int flags)\fC [inline]\fP"

.PP
Copies the information from the\&. 
.PP
.nf
source 

.fi
.PP
 key into \fBthis\fP key\&.
.PP
\fBParameters\fP
.RS 4
\fIsource\fP Source \fBKey\fP object containing the information to copy 
.br
\fIflags\fP Flags indicating which parts of the key to copy
.br
 Example:
.br
 \fBKEY_CP_NAME\fP | \fBKEY_CP_VALUE\fP 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyException\fP if copying failed 
.br
\fIKeyReleasedException\fP if this or the
.PP
.nf
source 

.fi
.PP
 \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
source 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 
.RE
.PP
\fBSee also\fP
.RS 4
\fBdup()\fP 
.PP
\fBdup(int)\fP 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.copyAllMeta (\fBKey\fP source)\fC [inline]\fP"

.PP
Copies all meta information from a\&. 
.PP
.nf
source 

.fi
.PP
 key to this key
.PP
\fBParameters\fP
.RS 4
\fIsource\fP \fBKey\fP used as source 
.RE
.PP
\fBReturns\fP
.RS 4
True, if meta was successfully copied, false if
.PP
.nf
source 

.fi
.PP
 does not contain any meta and nothing had to be done 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyMetaException\fP if copying failed 
.br
\fIKeyReleasedException\fP if this or the
.PP
.nf
source 

.fi
.PP
 \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
source 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 
.RE
.PP
\fBSee also\fP
.RS 4
\fBcopyMeta(Key, String)\fP 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.copyMeta (\fBKey\fP source, String metaName)\fC [inline]\fP"

.PP
Copies some meta information from a\&. 
.PP
.nf
source 

.fi
.PP
 key to this key
.PP
\fBParameters\fP
.RS 4
\fIsource\fP \fBKey\fP used as source 
.br
\fImetaName\fP \fBKey\fP name of the meta information to be copied 
.RE
.PP
\fBReturns\fP
.RS 4
True, if meta was successfully copied, false if source does not contain the specified meta information and nothing had to be done 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyMetaException\fP if this key's meta information is read-only of copying failed 
.br
\fIKeyReleasedException\fP if this or the
.PP
.nf
source 

.fi
.PP
 \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
source 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 or 
.PP
.nf
metaName 

.fi
.PP
 is \fBblank\fP 
.RE
.PP
\fBSee also\fP
.RS 4
\fBcopyAllMeta(Key)\fP 
.RE
.PP

.SS "static Optional<\fBKey\fP> org\&.libelektra\&.Key\&.create (@Nullable Pointer pointer)\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP"

.PP
Constructs a new \fBKey\fP instance associated with a JNA pointer\&. 
.PP
\fBParameters\fP
.RS 4
\fIpointer\fP Optional JNA \fBPointer\fP to key 
.RE
.PP
\fBReturns\fP
.RS 4
New \fBKey\fP instance if
.PP
.nf
pointer 

.fi
.PP
 is non-null, \fBOptional#empty()\fP otherwise 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP 
.RE
.PP

.SS "static \fBKey\fP org\&.libelektra\&.Key\&.create (String name, @Nullable Object value, Key\&.\&.\&. meta)\fC [inline]\fP, \fC [static]\fP"

.PP
Constructs a new \fBKey\fP with the specified content and arguments
.br
 
.PP
\fBParameters\fP
.RS 4
\fIname\fP \fBKey\fP name; first part of key-value pair 
.br
\fIvalue\fP \fBKey\fP value; will be determine from the object by calling \fBObject#toString()\fP, null is supported too 
.br
\fImeta\fP Metadata that should be added to this key, null keys will be filtered away 
.RE
.PP
\fBReturns\fP
.RS 4
New key 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyNameException\fP if the key name is invalid 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP 
.RE
.PP

.SS "static \fBKey\fP org\&.libelektra\&.Key\&.create (String name, Key\&.\&.\&. meta)\fC [inline]\fP, \fC [static]\fP"

.PP
Basic constructor of key class\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP \fBKey\fP name; first part of key-value pair 
.br
\fImeta\fP Metadata that should be added to this key\&. Will filter null values\&. 
.RE
.PP
\fBReturns\fP
.RS 4
New key object 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyNameException\fP if the key name is invalid 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP 
.RE
.PP

.SS "static \fBKey\fP org\&.libelektra\&.Key\&.create (String name, Object\&.\&.\&. args)\fC [inline]\fP, \fC [static]\fP, \fC [protected]\fP"

.PP
Constructs a new \fBKey\fP with the specified content and arguments
.br
 
.PP
\fBParameters\fP
.RS 4
\fIname\fP \fBKey\fP name; first part of key-value pair 
.br
\fIargs\fP Arguments used for key value
.br
 Example:
.br
 \fBCreateArgumentTag#KEY_VALUE\fP, 'custom key value', \fBCreateArgumentTag#KEY_END\fP 
.RE
.PP
\fBReturns\fP
.RS 4
New key 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyNameException\fP if the key name is invalid 
.RE
.PP
\fBSee also\fP
.RS 4
\fBCreateArgumentTag\fP 
.PP
\fBrelease()\fP 
.RE
.PP

.SS "static \fBKey\fP org\&.libelektra\&.Key\&.createNameless ()\fC [inline]\fP, \fC [static]\fP"

.PP
Constructs a temporary nameless \fBKey\fP which cannot be saved to the key data base but used for transferring warnings and error information\&. 
.PP
\fBReturns\fP
.RS 4
New nameless key 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.currentMeta ()\fC [inline]\fP"

.PP
Gets the current element of this key's internal meta information iterator\&. 
.PP
\fBReturns\fP
.RS 4
new \fBKey\fP object containing the current meta information 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.br
\fINoSuchElementException\fP if no next meta key is available or internal iterator has been reset 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrewindMeta()\fP 
.PP
\fBnextMeta()\fP 
.PP
\fBrelease()\fP 
.RE
.PP

.SS "void org\&.libelektra\&.Key\&.decRef ()\fC [inline]\fP, \fC [protected]\fP"

.PP
Decrements the reference counter for the underlying native key\&. 
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.dup ()\fC [inline]\fP"

.PP
Duplicates the key\&. 
.PP
\fBReturns\fP
.RS 4
New \fBKey\fP object containing the same information as this key 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyException\fP if copying failed 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP
\fBSee also\fP
.RS 4
\fBdup(int)\fP 
.PP
\fBcopy(Key, int)\fP 
.PP
\fBrelease()\fP 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.dup (int flags)\fC [inline]\fP"

.PP
Duplicates the key\&. 
.PP
\fBParameters\fP
.RS 4
\fIflags\fP Flags indicating which parts of the key to copy
.br
 Example:
.br
 \fBKEY_CP_NAME\fP | \fBKEY_CP_VALUE\fP 
.RE
.PP
\fBReturns\fP
.RS 4
New \fBKey\fP object containing the same information as this key 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyException\fP if copying failed 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP
\fBSee also\fP
.RS 4
\fBdup()\fP 
.PP
\fBcopy(Key, int)\fP 
.PP
\fBrelease()\fP 
.RE
.PP

.SS "String org\&.libelektra\&.Key\&.getBaseName ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBKey\fP's base name as String 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "int org\&.libelektra\&.Key\&.getBaseNameSize ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
Length of key's base name 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.getBoolean ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP interpreted as boolean value 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.getBooleanAndRelease ()\fC [inline]\fP"

.PP
Return the key's value and releases this key\&. 
.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP interpreted as boolean value 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released @apiNote This convenience method is primarily intended for facilityting early clean up in the case when a \fC\fBKey\fP\fP obtained via any of its public methods or the public methods of \fBKeySet\fP is just being read once and is not needed afterwards\&. 
.RE
.PP

.SS "byte org\&.libelektra\&.Key\&.getByte ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
byte 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable
.PP
.nf
byte 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "byte org\&.libelektra\&.Key\&.getByteAndRelease ()\fC [inline]\fP"

.PP
Return the key's value and releases this key\&. 
.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
byte 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable
.PP
.nf
byte 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released @apiNote This convenience method is primarily intended for facilityting early clean up in the case when a \fC\fBKey\fP\fP obtained via any of its public methods or the public methods of \fBKeySet\fP is just being read once and is not needed afterwards\&. 
.RE
.PP

.SS "double org\&.libelektra\&.Key\&.getDouble ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
double 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable 
.PP
.nf
double 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "double org\&.libelektra\&.Key\&.getDoubleAndRelease ()\fC [inline]\fP"

.PP
Return the key's value and releases this key\&. 
.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
double 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable 
.PP
.nf
double 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released @apiNote This convenience method is primarily intended for facilityting early clean up in the case when a \fC\fBKey\fP\fP obtained via any of its public methods or the public methods of \fBKeySet\fP is just being read once and is not needed afterwards\&. 
.RE
.PP

.SS "float org\&.libelektra\&.Key\&.getFloat ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
float 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable 
.PP
.nf
float 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "float org\&.libelektra\&.Key\&.getFloatAndRelease ()\fC [inline]\fP"

.PP
Return the key's value and releases this key\&. 
.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
float 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable 
.PP
.nf
float 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released @apiNote This convenience method is primarily intended for facilityting early clean up in the case when a \fC\fBKey\fP\fP obtained via any of its public methods or the public methods of \fBKeySet\fP is just being read once and is not needed afterwards\&. 
.RE
.PP

.SS "int org\&.libelektra\&.Key\&.getInt ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as integer 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable integer 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "int org\&.libelektra\&.Key\&.getIntAndRelease ()\fC [inline]\fP"

.PP
Return the key's value and releases this key\&. 
.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as integer 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable integer 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released @apiNote This convenience method is primarily intended for facilityting early clean up in the case when a \fC\fBKey\fP\fP obtained via any of its public methods or the public methods of \fBKeySet\fP is just being read once and is not needed afterwards\&. 
.RE
.PP

.SS "long org\&.libelektra\&.Key\&.getLong ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
long 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable
.PP
.nf
long 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "long org\&.libelektra\&.Key\&.getLongAndRelease ()\fC [inline]\fP"

.PP
Return the key's value and releases this key\&. 
.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
long 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable
.PP
.nf
long 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released @apiNote This convenience method is primarily intended for facilityting early clean up in the case when a \fC\fBKey\fP\fP obtained via any of its public methods or the public methods of \fBKeySet\fP is just being read once and is not needed afterwards\&. 
.RE
.PP

.SS "Optional<\fBKey\fP> org\&.libelektra\&.Key\&.getMeta (String metaName)\fC [inline]\fP"

.PP
Getter for meta information\&. 
.PP
\fBParameters\fP
.RS 4
\fImetaName\fP \fBKey\fP name of meta information to be fetched 
.RE
.PP
\fBReturns\fP
.RS 4
New \fBKey\fP object containing the requested meta information or \fBOptional#empty()\fP, if
.PP
.nf
metaName 

.fi
.PP
 was not found 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
metaName 

.fi
.PP
 is \fBblank\fP 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP 
.RE
.PP

.SS "String org\&.libelektra\&.Key\&.getName ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBKey\fP name (key part of 'key-value' pair) 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "int org\&.libelektra\&.Key\&.getNameSize ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
Length of key name 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "Pointer org\&.libelektra\&.Key\&.getPointer ()\fC [inline]\fP, \fC [protected]\fP"

.PP
\fBReturns\fP
.RS 4
JNA pointer to the native pointer for this key 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "int org\&.libelektra\&.Key\&.getRef ()\fC [inline]\fP, \fC [protected]\fP"

.PP
Gets the reference counter for the underlying native key\&. 
.PP
\fBReturns\fP
.RS 4
Current reference counter value 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "short org\&.libelektra\&.Key\&.getShort ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
short 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable 
.PP
.nf
short 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "short org\&.libelektra\&.Key\&.getShortAndRelease ()\fC [inline]\fP"

.PP
Return the key's value and releases this key\&. 
.PP
\fBReturns\fP
.RS 4
\fBgetString()\fP parsed as
.PP
.nf
short 

.fi
.PP
 
.RE
.PP
\fBExceptions\fP
.RS 4
\fINumberFormatException\fP if the \fBgetString()\fP does not return a parsable 
.PP
.nf
short 

.fi
.PP
 
.br
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released @apiNote This convenience method is primarily intended for facilityting early clean up in the case when a \fC\fBKey\fP\fP obtained via any of its public methods or the public methods of \fBKeySet\fP is just being read once and is not needed afterwards\&. 
.RE
.PP

.SS "String org\&.libelektra\&.Key\&.getString () throws \fBKeyBinaryTypeNotSupportedException\fP\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
This key's value as string 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "String org\&.libelektra\&.Key\&.getStringAndRelease () throws \fBKeyBinaryTypeNotSupportedException\fP\fC [inline]\fP"

.PP
Return the key's value and releases this key\&. 
.PP
\fBReturns\fP
.RS 4
This key's value as string 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyBinaryTypeNotSupportedException\fP if the underlying native key is of type binary 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released @apiNote This convenience method is primarily intended for facilityting early clean up in the case when a \fC\fBKey\fP\fP obtained via any of its public methods or the public methods of \fBKeySet\fP is just being read once and is not needed afterwards\&. 
.RE
.PP

.SS "int org\&.libelektra\&.Key\&.getValueSize ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
Length/Size of key value 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.incRef ()\fC [inline]\fP, \fC [protected]\fP"

.PP
Increments the reference counter for the underlying native key\&. 
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.isBelow (\fBKey\fP other)\fC [inline]\fP"

.PP
Checks whether this key is sub-key of the\&. 
.PP
.nf
other 

.fi
.PP
 key
.PP
\fBParameters\fP
.RS 4
\fIother\fP \fBKey\fP that is used in check as parent key 
.RE
.PP
\fBReturns\fP
.RS 4
Boolean if this key is (non-direct) sub-key of other-key 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this or the
.PP
.nf
other 

.fi
.PP
 \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
other 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.isBelowOrSame (\fBKey\fP other)\fC [inline]\fP"

.PP
Checks whether this key is the same as the\&. 
.PP
.nf
other 

.fi
.PP
 key or a sub-key of the
.PP
.nf
other 

.fi
.PP
 key
.PP
\fBParameters\fP
.RS 4
\fIother\fP \fBKey\fP that is used in check as parent key 
.RE
.PP
\fBReturns\fP
.RS 4
Boolean if this key is other key or (non-direct) sub-key of other-key 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this or the
.PP
.nf
other 

.fi
.PP
 \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
other 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.isBinary ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
True if the underlying native key's value is of type binary, false otherwise 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.isDirectBelow (\fBKey\fP other)\fC [inline]\fP"

.PP
Checks whether this key is direct sub-key of the\&. 
.PP
.nf
other 

.fi
.PP
 key
.PP
\fBParameters\fP
.RS 4
\fIother\fP \fBKey\fP that is used in check as parent key 
.RE
.PP
\fBReturns\fP
.RS 4
Boolean if this key is direct sub-key of other key ('child') 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this or the
.PP
.nf
other 

.fi
.PP
 \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
other 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 
.RE
.PP

.SS "boolean org\&.libelektra\&.Key\&.isString ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
True if the underlying native key's value is a valid string, false otherwise 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "Iterator<String> org\&.libelektra\&.Key\&.iterator ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
New \fBKeyNameIterator\fP backed by this \fBKey\fP 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.nextMeta ()\fC [inline]\fP"

.PP
Gets the next element of this key's internal meta information iterator\&. 
.PP
\fBReturns\fP
.RS 4
new \fBKey\fP object containing the next meta information 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.br
\fINoSuchElementException\fP if no next meta key is available 
.RE
.PP
\fBSee also\fP
.RS 4
\fBrewindMeta()\fP 
.PP
\fBcurrentMeta()\fP 
.PP
\fBrelease()\fP 
.RE
.PP

.SS "void org\&.libelektra\&.Key\&.release ()\fC [inline]\fP"

.PP
Clean-up method to release key reference by first decrementing its reference counter and then trying to free the native reference
.br
 
.br
 Call this method if you do not longer need a \fBKey\fP and obtained it via any of its public methods or the public methods of \fBKeySet\fP\&. If you do not manually release such \fBkeys\fP, they will get cleaned up by garbage collection as soon as they get phantom reachable\&. Therefore its encouraged to release \fBkey instances\fP as soon as you do not use them anymore\&. 
.SS "\fBKey\fP org\&.libelektra\&.Key\&.removeMeta (String metaName)\fC [inline]\fP"

.PP
Removes meta information\&. 
.PP
\fBParameters\fP
.RS 4
\fImetaName\fP \fBKey\fP name of meta information to be removed 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyMetaException\fP if
.PP
.nf
metaName 

.fi
.PP
 is invalid 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
metaName 

.fi
.PP
 is \fBblank\fP 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.rewindMeta ()\fC [inline]\fP"

.PP
Rewinds the internal iterator for meta information of this key\&. 
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBSee also\fP
.RS 4
\fBnextMeta()\fP 
.PP
\fBcurrentMeta()\fP 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setBaseName (String baseName) throws \fBKeyNameException\fP\fC [inline]\fP"

.PP
Sets the key's base name; will replace current base name with new base name\&. 
.PP
\fBParameters\fP
.RS 4
\fIbaseName\fP New key base name to use 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyNameException\fP if
.PP
.nf
baseName 

.fi
.PP
 is invalid, the key was inserted in a key set before or the key name is read-only 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
baseName 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setBoolean (boolean value)\fC [inline]\fP"

.PP
Sets the key's value by converting\&. 
.PP
.nf
value 

.fi
.PP
 to string
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setByte (byte value)\fC [inline]\fP"

.PP
Sets the key's value by converting\&. 
.PP
.nf
value 

.fi
.PP
 to string
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setDouble (double value)\fC [inline]\fP"

.PP
Sets the key's value by converting\&. 
.PP
.nf
value 

.fi
.PP
 to string
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setError (String text, Object\&.\&.\&. args)\fC [inline]\fP"

.PP
Sets proper error meta for key\&. 
.PP
\fBParameters\fP
.RS 4
\fItext\fP Reason for the error 
.br
\fIargs\fP Custom arguments 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setFloat (float value)\fC [inline]\fP"

.PP
Sets the key's value by converting\&. 
.PP
.nf
value 

.fi
.PP
 to string
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setInt (int value)\fC [inline]\fP"

.PP
Sets the key's value by converting\&. 
.PP
.nf
value 

.fi
.PP
 to string
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setLong (long value)\fC [inline]\fP"

.PP
Sets the key's value by converting\&. 
.PP
.nf
value 

.fi
.PP
 to string
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setMeta (String metaName, String newMetaString)\fC [inline]\fP"

.PP
Sets meta information\&. 
.PP
\fBParameters\fP
.RS 4
\fImetaName\fP \fBKey\fP name of meta information to be set 
.br
\fInewMetaString\fP Meta value to be set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyMetaException\fP if
.PP
.nf
metaName 

.fi
.PP
 is invalid 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
metaName 

.fi
.PP
 is \fBblank\fP or 
.PP
.nf
newMetaString 

.fi
.PP
 is
.PP
.nf
null 

.fi
.PP
 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setName (String name)\fC [inline]\fP"

.PP
Sets the key's name\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP New key name to use 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyNameException\fP if
.PP
.nf
name 

.fi
.PP
 is invalid, the key was inserted in a key set before or the key name is read-only 
.br
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.br
\fIIllegalArgumentException\fP if
.PP
.nf
baseName 

.fi
.PP
 is \fBblank\fP 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setShort (short value)\fC [inline]\fP"

.PP
Sets the key's value by converting\&. 
.PP
.nf
value 

.fi
.PP
 to string
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "\fBKey\fP org\&.libelektra\&.Key\&.setString (String value)\fC [inline]\fP"

.PP
Sets the key's value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to set 
.RE
.PP
\fBReturns\fP
.RS 4
This \fBKey\fP, enabling a fluent interface 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyReleasedException\fP if this \fBKey\fP has already been released 
.RE
.PP

.SS "String org\&.libelektra\&.Key\&.toString ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
\fBKey\fP name in string format as returned by \fBgetName()\fP 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "final int org\&.libelektra\&.Key\&.KEY_CP_STRING = 1 << 1\fC [static]\fP"

.PP
Flag for use with \fBcopy(Key, int)\fP for copying the key value, if it is a string\&. @apiNote Do not use together with \fBKEY_CP_VALUE\fP 
.SS "final int org\&.libelektra\&.Key\&.KEY_CP_VALUE = 1 << 2\fC [static]\fP"

.PP
Flag for use with \fBcopy(Key, int)\fP for copying the key value\&. @apiNote Do not use together with \fBKEY_CP_STRING\fP 

.SH "Author"
.PP 
Generated automatically by Doxygen for Elektra from the source code\&.
