<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Elektra: Name Manipulation Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Name Manipulation Methods</div>  </div>
<div class="ingroups"><a class="el" href="group__key.html">Key</a></div></div><!--header-->
<div class="contents">

<p>Methods to do various operations on Key names.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Name Manipulation Methods:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__keyname.png" border="0" alt="" usemap="#group____keyname"/>
<map name="group____keyname" id="group____keyname">
<area shape="rect" id="node2" href="group__key.html" title="A Key is the essential class that encapsulates key name , value &#160;and metainfo ." alt="" coords="7,5,49,33"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8e805c726a60da921d3736cda7813513"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (const Key *key)</td></tr>
<tr class="separator:ga8e805c726a60da921d3736cda7813513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbcfa51ed8a387e47ead207affa2d2e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a> (const Key *key)</td></tr>
<tr class="separator:gabdbcfa51ed8a387e47ead207affa2d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29a850168d9b31c9529e90cf9ab68be"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a> (const Key *key, char *returnedName, size_t maxSize)</td></tr>
<tr class="separator:gab29a850168d9b31c9529e90cf9ab68be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7699091610e7f3f43d2949514a4b35d9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (Key *key, const char *newName)</td></tr>
<tr class="separator:ga7699091610e7f3f43d2949514a4b35d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65dc9d43d3ee08d5e936a20ebbddd23"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize</a> (const Key *key)</td></tr>
<tr class="separator:gab65dc9d43d3ee08d5e936a20ebbddd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba1494a5ffc976e0e56c43f4334a23c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName</a> (const Key *key, char *returnedName, size_t maxSize)</td></tr>
<tr class="separator:gaaba1494a5ffc976e0e56c43f4334a23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a> (const Key *key)</td></tr>
<tr class="memdesc:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal unescaped key name where the <code>basename</code> starts.  <a href="#gaaff35e7ca8af5560c47e662ceb9465f5"></a><br/></td></tr>
<tr class="separator:gaaff35e7ca8af5560c47e662ceb9465f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0b76c5d9e5367c7e72211e6c63d43a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">keyGetBaseNameSize</a> (const Key *key)</td></tr>
<tr class="separator:ga1a0b76c5d9e5367c7e72211e6c63d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0992d26bcfca767cb8e77053a483eb64"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName</a> (const Key *key, char *returned, size_t maxSize)</td></tr>
<tr class="separator:ga0992d26bcfca767cb8e77053a483eb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa942091fc4bd5c2699e49ddc50829524"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (Key *key, const char *baseName)</td></tr>
<tr class="separator:gaa942091fc4bd5c2699e49ddc50829524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e804bd453f98c28b0ff51430d1df407"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a> (Key *key, const char *baseName)</td></tr>
<tr class="separator:ga6e804bd453f98c28b0ff51430d1df407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6485fb8599714b6bbd830cf915ffea5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner</a> (const Key *key)</td></tr>
<tr class="separator:gaf6485fb8599714b6bbd830cf915ffea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4561895741ba2ad10acf007c188593"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga4a4561895741ba2ad10acf007c188593">keyGetOwnerSize</a> (const Key *key)</td></tr>
<tr class="separator:ga4a4561895741ba2ad10acf007c188593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35922a017bee8b4bcb493bbdfad9d6f5"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner</a> (const Key *key, char *returnedOwner, size_t maxSize)</td></tr>
<tr class="separator:ga35922a017bee8b4bcb493bbdfad9d6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d6ec200ba0707b7c1b4a88133d2be4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner</a> (Key *key, const char *newOwner)</td></tr>
<tr class="separator:ga88d6ec200ba0707b7c1b4a88133d2be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Methods to do various operations on Key names. </p>
<p>To use them: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kdb.h&gt;</span></div>
</div><!-- fragment --><p>These functions make it easier for C programmers to work with key names.</p>
<dl class="section user"><dt>Terminology of Key Names</dt><dd><ul>
<li>A <em>key name</em> (see <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> and <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a>) defines the place of a key within the key database. To be unique, it is always absolute and canonical.</li>
<li>Key names are composed out of many <em>key name parts</em> split by a separator. These <em>key name parts</em> do not contain a unescaped separator.</li>
<li>A <em>key base name</em> (see <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a> and <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName()</a>) is the last part of the key name.</li>
<li>A namespace denotes the place the key comes from:<ul>
<li><em>user</em> keys come from user's home directories</li>
<li><em>system</em> keys come from systems etc directories</li>
</ul>
</li>
<li>A <em>C-String</em> is a null terminated sequence of characters. So \0 (null-character) must not occur within a C-String.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The rules are currently not formally specified and are subject of change in the next major release. So, always prefer:<ul>
<li>To use <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> and keyAddName() to get the canonified version of the keyname</li>
<li>To use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a> and <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName()</a> to get an escaped key name part.</li>
<li>Not to escape or canonify with your own algorithms!</li>
<li>To use keyUnescapedName() and <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName()</a> to have access to the key name without escape sequences (key name parts are null terminated)</li>
<li>Not to unescape the strings yourself!</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Syntax for Key Names</dt><dd>Key names and key name parts have following goals:<ul>
<li>The C-String passed to <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> and keyAddName() may be any C-String.</li>
<li>The <em>key name parts</em> (e.g. <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a>, <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName()</a>) may be any C-String. Escaping is needed to achieve both goals.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Semantics for Key Name Parts</dt><dd><ul>
<li>% denotes an empty key name part.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Canonicalization for Key Names</dt><dd><ul>
<li>/ (slash) is the separator between key name parts.</li>
<li>// is shortened to /</li>
<li>trailing / (slashes) are removed</li>
<li>. (dot) and .. (dot-dot) is removed in an canonical key name, with following rules:<ul>
<li>/./ is shortened to /</li>
<li>_/../ is shortened to _</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Conventions for key names</dt><dd><ul>
<li>Key name parts starting with # are array elements. Then only _ (underscore) followed by 0-9 is allowed. So we have the regular expression #[_]*[0-9]+ with the further limitation that the number of _ is defined by the number of digits-1.</li>
<li>Key name parts starting with _ are reserved for special purposes (if you use this within a plugin you still have to make sure _ is escaped properly)</li>
<li>Key name parts starting with @ are reserved for special purposes (if you use this within a plugin you still have to make sure @ is escaped properly)</li>
<li>If any key name part starts with . (dot) it means the key is inactive, see <a class="el" href="group__keytest.html#gaa25f699f592031c1a0abc1504d14e13e">keyIsInactive()</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Escaping rules</dt><dd><ul>
<li>\ (backslash) is the escape character for the situations as described here (and only these). The \ character must only be escaped, when one of the following rules apply. So there is no stray escape character possible.</li>
<li>\/ allows to escape /</li>
<li>\\/ allows to use \ as character before / (and so on)</li>
<li>Use  and . if you want your key name part to represent . and ..</li>
<li>\ and \. allows to use \ as character before . and .. (and so on)</li>
<li>Use \% if you want your key name part to start with % (and does not represent an empty name)</li>
<li>Use \\% allows to use \ as character before % (and so on)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Semantics for Key Name Specifications</dt><dd><ul>
<li>_ denotes that the key name part is arbitrary (syntax as described above).</li>
<li># denotes that the key name part has array syntax.</li>
<li>names surrounded by % (e.g. %profile%) denotes a placeholder.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Usage of Key Names</dt><dd>When using Elektra to store your application's configuration and state, please keep in mind the following rules:<ul>
<li>Avoid to have your applications root right under <code>system</code> or <code>user</code>. (rationale: it would make the hierarchy too flat.)</li>
<li>Avoid the usage of characters other then a-z, 0-9 and _. (rationale: it would allow too many similar, confusing names.) (exceptions: if the user or a technology, decide about parts of the key name, this restriction does not apply, e.g. if the wlan essid is used as part of the key name)</li>
<li>It is suggested to make your application look for default keys under <code>/sw/myapp/#/%/</code> where # is a major version number, e.g. #3 for the 4th version and % is a profile (% for default profile). This way, from a sysadmin perspective, it will be possible to copy the <code>system/sw/myapp/#3/%/</code> tree to something like <code>system/sw/myapp/#3/old/</code> and keep system clean and organized. Additionally, it is possible to start the old version of the app, using <code>/sw/myapp/#2</code>. </li>
</ul>
</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa942091fc4bd5c2699e49ddc50829524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyAddBaseName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds <code>baseName</code> (that will be escaped) to the current key name.</p>
<p>A new baseName will be added, no other part of the key name will be affected.</p>
<p>Assumes that <code>key</code> is a directory and will append <code>baseName</code> to it. The function adds the path separator for concatenating.</p>
<p>So if <code>key</code> has name <code>"system/dir1/dir2"</code> and this method is called with <code>baseName</code> <code>"mykey"</code>, the resulting key will have the name <code>"system/dir1/dir2/mykey"</code>.</p>
<p>When <code>baseName</code> is 0 nothing will happen and the size of the name is returned.</p>
<p>The escaping rules apply as in <a class="el" href="group__keyname.html">above </a>.</p>
<p>A simple example is: </p>
<div class="fragment"><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/my/long&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a>(k, <span class="stringliteral">&quot;myname&quot;</span>);</div>
<div class="line">printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k)); <span class="comment">// will print user/my/long/myname</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(k);</div>
</div><!-- fragment --><p> E.g. if you add . it will be escaped: </p>
<div class="fragment"><div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div>
<div class="line">succeed_if (<a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;.&quot;</span>) &gt;= 0, <span class="stringliteral">&quot;could not add a base name&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k), <span class="stringliteral">&quot;system/valid/\\.&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName</a>(k), <span class="stringliteral">&quot;.&quot;</span>);</div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a> to set a base name </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> to set a new name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">baseName</td><td>the string to append to the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the new key name including the ending NULL </dd>
<dd>
-1 if the key had no name </dd>
<dd>
-1 on NULL pointers </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaff35e7ca8af5560c47e662ceb9465f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyBaseName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the internal unescaped key name where the <code>basename</code> starts. </p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName()</a> and you should use it if you are responsible enough to not mess up things. The name might change or even point to a wrong place after a <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a>. So make sure to copy the memory before the name changes.</p>
<p><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName()</a> returns "" when there is no keyBaseName. The reason is </p>
<div class="fragment"><div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(k,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName</a>(k), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(k,<span class="stringliteral">&quot;user&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName</a>(k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> And there is also support for really empty basenames: </p>
<div class="fragment"><div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div>
<div class="line">succeed_if (<a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;&quot;</span>) &gt;= 0, <span class="stringliteral">&quot;could not add a base name&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k), <span class="stringliteral">&quot;system/valid/%&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName</a>(k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must never use the pointer returned by <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName()</a> method to change the name, but you should use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object to obtain the basename from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the basename </dd>
<dd>
"" when the key has no (base)name </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName()</a>, <a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">keyGetBaseNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> to get a pointer to the name </dd>
<dd>
<a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a> to get a pointer to the owner </dd></dl>

</div>
</div>
<a class="anchor" id="ga0992d26bcfca767cb8e77053a483eb64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetBaseName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the basename of a key name and put it in <code>returned</code> finalizing the string with NULL.</p>
<p>Some examples:</p>
<ul>
<li>basename of <code>system/some/keyname</code> is <code>keyname</code> </li>
<li>basename of <code>"user/tmp/some key"</code> is <code>"some key"</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to extract basename from </td></tr>
    <tr><td class="paramname">returned</td><td>a pre-allocated buffer to store the basename </td></tr>
    <tr><td class="paramname">maxSize</td><td>size of the <code>returned</code> buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes copied to <code>returned</code> </dd>
<dd>
1 on empty name </dd>
<dd>
-1 on NULL pointers </dd>
<dd>
-1 when maxSize is 0 or larger than SSIZE_MAX </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName()</a>, <a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a">keyGetBaseNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>, <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a0b76c5d9e5367c7e72211e6c63d43a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetBaseNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates number of bytes needed to store basename of <code>key</code>.</p>
<p>Key names that have only root names (e.g. <code>"system"</code> or <code>"user"</code> or <code>"user:domain"</code> ) does not have basenames, thus the function will return 1 bytes to store "".</p>
<p>Basenames are denoted as:</p>
<ul>
<li><code>system/some/thing/basename</code> -&gt; <code>basename</code> </li>
<li><code>user:domain/some/thing/base\/name</code> &gt; <code>base\/name</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes of <code>key's</code> basename including ending NULL </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName()</a>, <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64">keyGetBaseName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>, <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaba1494a5ffc976e0e56c43f4334a23c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetFullName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get key full name, including the user domain name.</p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written </dd>
<dd>
1 on empty name </dd>
<dd>
-1 on NULL pointers </dd>
<dd>
-1 if maxSize is 0 or larger than SSIZE_MAX </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object </td></tr>
    <tr><td class="paramname">returnedName</td><td>pre-allocated memory to write the key name </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that will fit in returnedName, including the final NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab65dc9d43d3ee08d5e936a20ebbddd23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetFullNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bytes needed to store the key name including user domain and ending NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed to store key name including user domain </dd>
<dd>
1 on empty name </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab29a850168d9b31c9529e90cf9ab68be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get abbreviated key name (without owner name).</p>
<p>When there is not enough space to write the name, nothing will be written and -1 will be returned.</p>
<p>maxSize is limited to SSIZE_MAX. When this value is exceeded -1 will be returned. The reason for that is that any value higher is just a negative return value passed by accident. Of course malloc is not as failure tolerant and will try to allocate.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *getBack = malloc (<a class="code" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a>(key));</div>
<div class="line"><a class="code" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName</a>(key, getBack, <a class="code" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize</a>(key));</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>number of bytes written to <code>returnedName</code> </dd>
<dd>
1 when only a null was written </dd>
<dd>
-1 when keyname is longer then maxSize or 0 or any NULL pointer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">returnedName</td><td>pre-allocated memory to write the key name </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that will fit in returnedName, including the final NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabdbcfa51ed8a387e47ead207affa2d2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetNameSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bytes needed to store the key name without owner.</p>
<p>For an empty key name you need one byte to store the ending NULL. For that reason 1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed, including ending NULL, to store key name without owner </dd>
<dd>
1 if there is is no key Name </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga35922a017bee8b4bcb493bbdfad9d6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetOwner </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>returnedOwner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the owner of the key.</p>
<ul>
<li>Given <code>user:someuser/</code>..... return <code>someuser</code> </li>
<li>Given <code>user:some.user/</code>.... return <code>some.user</code> </li>
<li>Given <code>user/</code>.... return the current user</li>
</ul>
<p>Only <code>user/</code>... keys have a owner. For <code>system/</code>... keys (that doesn't have a key owner) an empty string ("") is returned.</p>
<p>Although usually the same, the owner of a key is not related to its UID. Owner are related to WHERE the key is stored on disk, while UIDs are related to mode controls of a key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object to work with </td></tr>
    <tr><td class="paramname">returnedOwner</td><td>a pre-allocated space to store the owner </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that fit returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written to buffer </dd>
<dd>
1 if there is no owner </dd>
<dd>
-1 on NULL pointers </dd>
<dd>
-1 when maxSize is 0, larger than SSIZE_MAX or too small for ownername </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a>, <a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner()</a>, <a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a4561895741ba2ad10acf007c188593"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keyGetOwnerSize </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size of the owner of the Key with concluding 0.</p>
<p>The returned number can be used to allocate a string. 1 will returned on an empty owner to store the concluding 0 on using <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> * buffer;</div>
<div class="line">buffer = malloc (<a class="code" href="group__keyname.html#ga4a4561895741ba2ad10acf007c188593">keyGetOwnerSize</a> (key));</div>
<div class="line"><span class="comment">// use buffer and keyGetOwnerSize (key) for maxSize</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>that -1 might be returned on null pointer, so when you directly allocate afterwards its best to check if you will pass a null pointer before.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes </dd>
<dd>
1 if there is no owner </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e805c726a60da921d3736cda7813513"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyName </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the abbreviated real internal <code>key</code> name.</p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a> and can use it if you are responsible enough to not mess up things. You are not allowed to change anything in the returned array. The content of that string may change after <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> and similar functions. If you need a copy of the name, consider using <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>.</p>
<p>The name will be without owner, see <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a> if you need the name with its owner.</p>
<p><a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> returns "" when there is no keyName. The reason is </p>
<div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> method to set a new value. Use <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the keyname which must not be changed. </dd>
<dd>
"" when there is no (a empty) keyname </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e">keyGetNameSize()</a> for the string length </dd>
<dd>
<a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23">keyGetFullNameSize()</a> to get the full name </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a> as alternative to get a copy </dd>
<dd>
<a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a> to get a pointer to owner </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6485fb8599714b6bbd830cf915ffea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* keyOwner </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the real internal <code>key</code> owner.</p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a> and you should use it if you are responsible enough to not mess up things. You are not allowed to modify the returned string in any way. If you need a copy of the string, consider to use <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a> instead.</p>
<p><a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a> returns "" when there is no keyOwner. The reason is </p>
<div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
<div class="line"><a class="code" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner</a>(key,<span class="stringliteral">&quot;system&quot;</span>);</div>
<div class="line"><a class="code" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyname.html#gaf6485fb8599714b6bbd830cf915ffea5">keyOwner()</a> method to set a new value. Use <a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to internal owner </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no (a empty) owner </td></tr>
    <tr><td class="paramname">0</td><td>iff key is a NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#ga4a4561895741ba2ad10acf007c188593">keyGetOwnerSize()</a> for the size of the string with concluding 0 </dd>
<dd>
<a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a>, <a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> for name without owner </dd>
<dd>
<a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a> for name with owner </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e804bd453f98c28b0ff51430d1df407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetBaseName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>baseName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>baseName</code> as the new basename for <code>key</code>.</p>
<p>Only the baseName will be affected and no other part of the key.</p>
<p>All text after the last <code>'/'</code> in the <code>key</code> keyname is erased and <code>baseName</code> is appended.</p>
<p>So let us suppose <code>key</code> has name <code>"system/dir1/dir2/key1"</code>. If <code>baseName</code> is <code>"key2"</code>, the resulting key name will be <code>"system/dir1/dir2/key2"</code>. If <code>baseName</code> is empty or NULL, the resulting key name will be <code>"system/dir1/dir2"</code>.</p>
<p>This function does proper escaping on the supplied name argument.</p>
<p>You can use all names to set as basename (e.g. . (dot), .. (dot-dot), % and "" (empty)). They will be properly escaped.</p>
<p>A simple example is: </p>
<div class="fragment"><div class="line">Key * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/my/long/name&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a>(k, <span class="stringliteral">&quot;myname&quot;</span>);</div>
<div class="line">printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k)); <span class="comment">// will print user/my/long/myname</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(k);</div>
</div><!-- fragment --><p> If you do not want escaping, use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a> instead. E.g. if you want to add an inactive key, use: </p>
<div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a>(k, <span class="stringliteral">&quot;.hiddenkey&quot;</span>);</div>
<div class="line">        succeed_if_same_string(<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k), <span class="stringliteral">&quot;system/.hiddenkey&quot;</span>);</div>
<div class="line">        succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName</a>(k), <span class="stringliteral">&quot;.hiddenkey&quot;</span>);</div>
</div><!-- fragment --><p> or when you want to add an array item, use: </p>
<div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a>(k, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">        succeed_if_same_string(<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k), <span class="stringliteral">&quot;system/%&quot;</span>);</div>
<div class="line">        succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts.">keyBaseName</a>(k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html" title="Methods to do various operations on Key names.">Name Manipulation Methods</a> for more details on special names</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">baseName</td><td>the string used to overwrite the basename of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the new key name </dd>
<dd>
-1 on NULL pointers </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a> to set a new name </dd></dl>

</div>
</div>
<a class="anchor" id="ga7699091610e7f3f43d2949514a4b35d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetName </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a new name to a key.</p>
<p>A valid name is of the forms:</p>
<ul>
<li><code>system/something</code> </li>
<li><code>user/something</code> </li>
<li><code>user:username/something</code> </li>
</ul>
<p>The last form has explicitly set the owner, to let the library know in which user folder to save the key. A owner is a user name. If it is not defined (the second form) current user is used.</p>
<p>You should always follow the guidelines for key tree structure creation.</p>
<p>A private copy of the key name will be stored, and the <code>newName</code> parameter can be freed after this call.</p>
<p>.., . and / will be handled as in filesystem pathes. A valid name will be build out of the (valid) name what you pass, e.g. user///sw/../sw//././MyApp -&gt; user/sw/MyApp</p>
<p>On invalid names, NULL or "" the name will be "" afterwards.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">size</td><td>in bytes of this new key name including ending NULL </td></tr>
    <tr><td class="paramname">0</td><td>if newName is an empty string or a NULL pointer (name will be empty afterwards) </td></tr>
    <tr><td class="paramname">-1</td><td>if newName is invalid (name will be empty afterwards) </td></tr>
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">newName</td><td>the new key name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew()</a>, <a class="el" href="group__keyname.html#ga88d6ec200ba0707b7c1b4a88133d2be4">keySetOwner()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be">keyGetName()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a>, <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName()</a>, <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName()</a> to manipulate a name </dd></dl>

</div>
</div>
<a class="anchor" id="ga88d6ec200ba0707b7c1b4a88133d2be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetOwner </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newOwner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the owner of a key.</p>
<p>A owner is a name of a system user related to a UID. The owner decides on which location on the disc the key goes.</p>
<p>A private copy is stored, so the passed parameter can be freed after the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">newOwner</td><td>the string which describes the owner of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually saved including final NULL </dd>
<dd>
1 when owner is freed (by setting 0 or "") </dd>
<dd>
-1 on null pointer or memory problems </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName()</a>, <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c">keyGetFullName()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 4 2014 10:57:27 for Elektra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
