.TH "doc_tutorials_mount_md" 3elektra "Tue Feb 27 2018" "Version 0.8.22" "Elektra" \" -*- nroff -*-
.ad l
.nh
.SH NAME
doc_tutorials_mount_mdMounting 
 \- Elektra provides a global key database, that can integrate configuration in various formats\&.
.PP
Conversely configuration managed by Elektra can be integrated into applications\&. The best way of integrating Elektra into applications is to \fBelektrify\fP them\&.
.PP
A simpler form of integration is to let Elektra directly use configuration files as they are present on the system\&. Thus applications can read the configuration files and changes in the key database will be picked up by applications\&.
.PP
The heart of the approach is the so called \fImounting\fP of configuration files into the key database\&.
.PP
Let us start with a motivating example first:
.PP
.SS "Mount the Lookup Table for Hostnames"
.PP
We mount the lookup table with the following command:
.PP
.PP
.nf
sudo kdb mount --with-recommends /etc/hosts system/hosts hosts
.fi
.PP
.PP
.IP "1." 4
\fC/etc/hosts\fP is the configuration file we want to mount
.IP "2." 4
\fCsystem/hosts\fP is the path it should have in the key database, also known as \fBmountpoint\fP
.IP "3." 4
\fChosts\fP is the \fIstorage plugin\fP that can read and write this configuration format\&.
.PP
.PP
.RS 4
Consider using mount with the option \fC--with-recommends\fP, which loads all plugins recommended by the \fIhosts\fP plugin\&. You can see the recommended plugins of \fIhosts\fP if you look at the output of \fCkdb info hosts\fP\&. Hosts recommends the \fIglob\fP, \fInetwork\fP and \fIerror\fP plugins\&. Using \fC--with-recommends\fP, more validation is done when modifying keys in \fCsystem/hosts\fP\&. 
.RE
.PP
.PP
Now we use \fCkdb file\fP, to verify that all configuration below \fCsystem/hosts\fP is stored in \fC/etc/hosts\fP:
.PP
.PP
.nf
kdb file system/hosts
#> /etc/hosts
.fi
.PP
.PP
After mounting a file, we can modify keys below \fCsystem/hosts\fP\&. We need to be root, because we modify \fC/etc/hosts\fP\&.
.PP
.PP
.nf
sudo kdb set system/hosts/ipv4/mylocalhost 127\&.0\&.0\&.33
.fi
.PP
.PP
These changes are reflected in \fC/etc/hosts\fP instantly:
.PP
.PP
.nf
cat /etc/hosts | grep mylocalhost
#> 127\&.0\&.0\&.33   mylocalhost
.fi
.PP
.PP
Applications will now pick up these changes:
.PP
.PP
.nf
ping -c 1 mylocalhost
# RET:2
.fi
.PP
.PP
We are also safe against wrong changes:
.PP
.PP
.nf
sudo kdb set system/hosts/ipv4/mylocalhost ::1
# RET:5
# ERROR:51
sudo kdb set system/hosts/ipv4/mylocalhost 300\&.0\&.0\&.1
# RET:5
# ERROR:51
.fi
.PP
.PP
We can undo these changes with:
.PP
.PP
.nf
# remove the key \&.\&.\&.
sudo kdb rm system/hosts/ipv4/mylocalhost

# \&.\&.\&. and unmount
sudo kdb umount system/hosts
.fi
.PP
.PP
.RS 4
.SS "Why do you Need Superuser Privileges to Mount Files?"
.PP
.PP
Elektra manages its mountpoints in configuration below \fBsystem/elektra/mountpoints\fP\&. The file that holds this configuration is, in the same way as \fC/etc/hosts\fP before, only writable by administrators: 
.PP
.nf
$ kdb file system/elektra/mountpoints
/etc/kdb/elektra.ecf

.fi
.PP
.PP
Because of that only root can mount files\&. 
.RE
.PP
.PP
.SS "Resolver"
.PP
The configuration file path you supplied to \fCkdb mount\fP above is actually not an absolute or relative path in your file system, but gets resolved to one by Elektra\&. The plugin that is responsible for this is the \fB_Resolver_\fP\&.
.PP
When you mount a configuration file the resolver first looks at the namespace of your mountpoint\&. Based on that namespace and if the supplied path was relative or absolute the resolver then resolves the supplied path to a path in the file system\&. The resolving happens dynamically for every \fCkdb\fP invocation\&.
.PP
You can display the mounted configuration files with \fCkdb mount\fP\&. Also here you only see the unresolved paths\&.
.PP
If you supplied an absolute path (e\&.g\&. \fC/example\&.ini\fP) it gets resolved to this:
.PP
namespace resolved path  \fCspec\fP \fC/example\&.ini\fP \fCdir\fP \fC${PWD}/example\&.ini\fP \fCuser\fP \fC${HOME}/example\&.ini\fP \fCsystem\fP \fC/example\&.ini\fP If you supplied a relative path (e\&.g\&. \fCexample\&.ini\fP) it gets resolved to this:
.PP
namespace resolved path  \fCspec\fP \fC/usr/share/elektra/specification/example\&.ini\fP \fCdir\fP \fC${PWD}/\&.dir/example\&.ini\fP \fCuser\fP \fC${HOME}/\&.config/example\&.ini\fP \fCsystem\fP \fC/etc/kdb/example\&.ini\fP If this differs on your system, the resolver has a different configuration\&. Type \fCkdb info resolver\fP for more information about the resolvers\&.
.PP
There are different resolvers\&. For instance on non-POSIX systems paths must be resolved differently\&. In this case one might want to use the \fBwresolver\fP plugin\&. Another useful resolver is the \fBblockresolver\fP, which integrates only a block of a configuration file into Elektra\&.
.PP
But resolvers are not the only plugins Elektra uses:
.PP
.SS "Plugins"
.PP
Configuration files can have many different formats (\fCini\fP, \fCjson\fP, \fCyaml\fP, \fCxml\fP, \fCcsv\fP, \&.\&.\&. to name but a few)\&.
.PP
One of the goals of Elektra is to provide users with a unified interface to all those formats\&. Elektra accomplishes this task with \fIstorage plugins\fP\&.
.PP
.RS 4
In Elektra \fBPlugins\fP are the units that encapsulate functionality\&. There are not only plugins that handle storage of data, but also plugins that modify your values (\fBiconv\fP)\&. Furthermore there are plugins that validate your values (\fBvalidation\fP, \fBenum\fP, \fBboolean\fP, \fBmathcheck\fP, \&.\&.\&.), log changes in the key set (\fBlogchange\fP) or do things like executing commands on the shell (\fBshell\fP)\&. You can get a complete list of all available plugins with \fCkdb list\fP\&. Although an individual plugin does not provide much functionality, plugins are powerful because they are designed to be used together\&. 
.RE
.PP
.PP
When you mount a file you can tell Elektra which plugins it should use for reading and writing to configuration files\&.
.PP
Let us mount a projects git configuration into the dir namespace:
.PP
.PP
.nf
# create a directory for our demonstration
mkdir -p example && cd $_

# this creates the \&.git/config file
git init

# mount gitâ€™s configuration into Elektra
sudo kdb mount /\&.git/config dir/git ini multiline=0
.fi
.PP
.PP
As git uses the \fCini\fP format for its configuration we use the \fBini plugin\fP\&. You can pass parameters to plugins during the mount process\&. This is what we did with \fCmultiline=0\fP\&. Git intents the entries in its configuration files and the default behavior of the \fCini\fP plugin is to interpret these indented entries as values that span multiple lines\&. The passed parameter disables this behavior and makes the ini-plugin compatible with git configuration\&.
.PP
Now let us see how smoothly the ini plugin sets and gets the git configuration\&.
.PP
.PP
.nf
# set a user name \&.\&.\&.
git config user\&.name "Rob Banks"

# \&.\&.\&. and read it with kdb
kdb get dir/git/user/name
#> Rob Banks

# set a user email with kdb \&.\&.\&.
kdb set dir/git/user/email "rob\&.banks@dot\&.com"

# and read it with git
git config --get user\&.email
#> rob\&.banks@dot\&.com
.fi
.PP
.PP
.SS "Meta Data"
.PP
Elektra is able to store \fBmetadata\fP of keys, provided the format of the file that holds the configuration supports this feature\&. The ini plugin does support this feature, and so does the \fBni\fP and the \fBdump\fP plugin among others\&.
.PP
.RS 4
Actually the ini plugin creates some metadata on its own\&. This metadata contains information about the ordering of keys or comments, if a key has some\&. But unlike the ni and the dump plugin we can't store arbitrary metadata with the ini plugin\&. 
.RE
.PP
.PP
Meta data comes in handy if we use other plugins, than just the ones that store and retrieve data\&. I chose the \fCni\fP plugin for this demonstration, because it supports metadata and is human readable\&. So let us have a look at the \fBenum\fP and \fBmathcheck\fP plugins\&.
.PP
.PP
.nf
# mount the backend with the plugins \&.\&.\&.
kdb mount example\&.ni user/example ni enum

# \&.\&.\&. and set a value for the demonstration
kdb set user/example/enumtest/fruit apple
#> Create a new key user/example/enumtest/fruit with string "apple"
.fi
.PP
.PP
By entering \fCkdb info enum\fP in the commandline, we can find out how to use this plugin\&. It turns out that this plugin allows us to define a list of valid values for our keys via the metavalue \fCcheck/enum\fP\&.
.PP
.PP
.nf
kdb setmeta user/example/enumtest/fruit check/enum "'apple', 'banana', 'grape'"
kdb set user/example/enumtest/fruit tomato
# RET:5
# this fails because tomato is not in the list of valid values
.fi
.PP
.PP
You can have a look or even edit the configuration file with \fCkdb editor user/example ni\fP to see how the value and metadata is stored:
.PP
.PP
.nf
enumtest/fruit = apple

[enumtest/fruit]
check/enum = 'apple', 'banana', 'grape'
.fi
.PP
.PP
The example shows an important problem: the configuration file is now changed in ways that might not be acceptable for applications\&. We have at least two ways to avoid that:
.PP
.IP "1." 4
Encode metadata as comments
.IP "2." 4
Encode metadata in its own \fCspec\fP namespace, completely separate to the configuration files the application will see
.PP
.PP
If you want to find out more about validation I recommend reading \fBthis\fP tutorial next\&.
.PP
.SS "Backends"
.PP
The plugins together with the configuration file form a \fIbackend\fP\&. The backend determines how Elektra stores data below a mountpoint\&. You can examine every mountpoints backend by looking at the configuration below \fCsystem/elektra/mountpoints/<mountpoint>/\fP\&.
.PP
.SS "Limitations"
.PP
One drawback of this approach is, that an application can bypass Elektra and change configuration files directly\&. If for example Elektra is configured to \fBvalidate\fP new configuration values before updating them, this is something you do not want to happen\&.
.PP
Another drawback is that mounting is static\&. In a previous example we mounted the \fC/\&.git/config\fP file into \fCdir/git\fP\&. Now the \fCdir\fP namespace of every directory stores the configuration below \fCdir/git\fP in this directories \fC/\&.git/config\fP file\&. And this mountpoint is the same for all users and all directories\&. So you can't have different configuration files for the same mountpoints in other directories\&. Because of the same reason you cannot have different configuration file names or syntax for the same mountpoint in the \fCuser\fP namespace\&.
.PP
This is one of the reasons why Elektra promotes this \fBnaming convention\fP for keys:
.PP
.RS 4
Key names of software-applications should always start with: \fC/<type>/<org>/<name>/<version>/<profile>\fP 
.RE
.PP
.PP
.RS 4
.IP "\(bu" 2
\fBtype\fP can be \fCsw\fP (software), \fChw\fP (hardware) or \fCelektra\fP (for internal configuration)
.IP "\(bu" 2
\fBorg\fP is an URL/organization name\&. E\&.g\&. \fCkde\fP
.IP "\(bu" 2
\fBname\fP the name of the component that has this configuration
.IP "\(bu" 2
\fBversion\fP is the major version number\&. E\&.g\&. If you version is 6\&.3\&.8 than this would be \fC#6\fP
.IP "\(bu" 2
\fBprofile\fP is the name of the profile to be used\&. E\&.g\&.: \fCproduction\fP, \fCdevelopment\fP, \fCtesting\fP, \&.\&.\&. 
.PP
.RE
.PP
.PP
Furthermore, one cannot simply change the configuration file format, because it must be one the application understands\&. Thus one loses quite some flexibility (for instance if this file format doesn't support meta keys, as already mentioned)\&.
.PP
These limitations are the reasons why \fBelektrifing\fP applications provides even better integration\&. Go on reading \fBhow to elektrify your application\fP\&. 
