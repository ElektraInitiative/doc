<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: High-level API (with code-generation)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">High-level API (with code-generation) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_tutorials_highlevel"></a> Most applications don't need the flexibility of the low-level API (with <code>kdbGet</code>, <code>kdbSet</code>, etc.). In most cases an easy way and safe way to access the configuration values is preferred. This is why we created the high-level API.</p>
<p>There are two different ways of using the high-level API:</p>
<ol type="1">
<li>directly</li>
<li>via code-generation</li>
</ol>
<p>The recommended way is via code-generation (which will be explained below). If you want to use the high-level API directly take a look at <a class="el" href="src_libs_highlevel_README_md.html">its documentation</a>. Please note, however, that certain features are only available through code-generation.</p>
<h1><a class="anchor" id="autotoc_md3761"></a>
Overview</h1>
<p>The code-generation API builds on Elektra's specifications. Instead of just using specifications at runtime, the code-generator parses them when invoked (ideally right before compiling) and utilizes the specification when generating configuration accessor functions.</p>
<h1><a class="anchor" id="autotoc_md3762"></a>
Writing a specification</h1>
<p>The process of writing a full specification for your application is beyond the scope of this guide. We will just focus on the parts that are necessary for using the code-generation API.</p>
<p>We will use this specification in the format of the <code>ni</code> plugin:</p>
<div class="fragment"><div class="line">[]</div>
<div class="line">mountpoint = myapp.ini</div>
<div class="line"> </div>
<div class="line">[mydouble]</div>
<div class="line">type = double</div>
<div class="line">default = 0.0</div>
<div class="line"> </div>
<div class="line">[myfloatarray/#]</div>
<div class="line">type = float</div>
<div class="line">default = 1.1</div>
</div><!-- fragment --><p>In Elektra a specification is defined through the metadata of keys in the <code>spec</code> namespace. The specification above contains metadata for three keys:</p>
<ol type="1">
<li>the parent key (<code>@</code>)</li>
<li><code>@/mydouble</code></li>
<li><code>@/myfloatarray/#</code> (The <code>#</code> at the end of <code>myfloatarray/#</code> indicates that it is an array)</li>
</ol>
<p>The <code>mountpoint</code> metadata on the parent key sets the name of our application's config file (the location is defined by Elektra), it should be unique.</p>
<p>The <code>type</code> metadata specifies the type of a key. The available types can be found in the high-level API <a class="el" href="src_libs_highlevel_README_md.html">Readme</a> under "Data Types". It is important to set the <code>type</code>, because the code-generator will ignore all keys that don't have a <code>type</code>.</p>
<p>Because we want our getters to be unable to fail (makes error handling trivial), we need to provide a <code>default</code> value as well. Note that <code>default</code>s for array keys like <code>myfloatarray/#</code> only work via the <code>spec</code> plugin. If you didn't mount everything correctly, you will get an error.</p>
<p>That's it. The code-generator just requires that each key (that you want to access) has a <code>type</code> and a <code>default</code> value.</p>
<p><em>Note:</em> You can also mark keys with the <code>require</code> metadata, if there is no reasonable default value. This is only recommended as a last resort, but still preserves the guarantee that <code>elektraGet*</code> calls won't fail. If a <code>require</code>d key is missing, the initialization of the <code>Elektra</code> handle will fail.</p>
<h1><a class="anchor" id="autotoc_md3763"></a>
Invoking the code-generator</h1>
<p>The code-generator is a very powerful and flexible tool and has many options to tweak its output. If you want to know more about how to set up everything just the way you want to, take a look at the man-pages <a class="el" href="doc_help_kdb-gen_md.html">`kdb-gen(1)`</a> and <a class="el" href="doc_help_kdb-gen-highlevel_md.html">`kdb-gen-highlevel(1)`</a>.</p>
<p>To get started the basic invocation of the code-generator should be enough:</p>
<div class="fragment"><div class="line">kdb gen -F ni=spec.ini highlevel &quot;/sw/example/myapp/#0/current&quot; conf</div>
</div><!-- fragment --><p>This tells the code-generator that your application uses the parent key <code>/sw/example/myapp/#0/current</code> and that the output files should be called <code>conf.*</code>. The argument <code>highlevel</code> just specifies which template to use and the option <code>-F ni=spec.ini</code> indicates that the file <code>spec.ini</code> (in the <code>ni</code> plugin's format) contains the specification. While the code-generator can read a specification from the KDB, we recommend you use the <code>-F</code> option. It keeps the KDB clean and can avoid troubles later on, when installing your application.</p>
<h1><a class="anchor" id="autotoc_md3764"></a>
Using the generated code</h1>
<p>You can now take a look at <code>conf.h</code> and <code>conf.c</code> (the files generated by the compiler). Depending on the specification you used, these files may be very long. They might also be formatted strangely, because of limitations in the code-generator. Feel free to reformat them with your tool of choice, before inspecting them.</p>
<p>To explain how to use the generated code, lets take a look at some of <code>conf.h</code>. For brevity's sake some parts of the file have been replaced by placeholder comments.</p>
<div class="fragment"><div class="line"><span class="comment">/* file header ... */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef CONF_H</span></div>
<div class="line"><span class="preprocessor">#define CONF_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* includes ... */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* helper macros ... */</span></div>
</div><!-- fragment --><p>First there is some boilerplate, including the copyright header, include statements and some helper macros.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#define ELEKTRA_TAG_MYDOUBLE Mydouble</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define ELEKTRA_TAG_MYFLOATARRAY Myfloatarray</span></div>
</div><!-- fragment --><p>Next we see all the 'tag macros' used to refer to config values. These are essentially just aliases, but they allow for some flexibility in how we generate the names of the <code>static inline</code> functions further down. You should always refer to your config values via these macros, even if they are just aliases. This is because we might have to change the naming scheme for the functions, but we will try to keep the tag macros unchanged.</p>
<p>Additionally, the comments for these macros contain the documentation on what arguments are needed for accessing the tag in question. For example to access the elements of the array <code>myfloatarray/#</code>, we obviously need to provide an index.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define elektra_len19(x) ((x) &lt; 10000000000000000000ULL ? 19 : 20)</span></div>
<div class="line"><span class="comment">/* local macros ... */</span></div>
<div class="line"><span class="preprocessor">#define elektra_len(x) elektra_len00 (x)</span></div>
</div><!-- fragment --><p>Then we see some local helper macros only used in this file.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> kdb_double_t ELEKTRA_GET (Mydouble) (Elektra * elektra) { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ELEKTRA_SET (Mydouble) (Elektra * elektra, kdb_double_t value, ElektraError ** error) { <span class="comment">/* ... */</span> }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> kdb_float_t ELEKTRA_GET (Myfloatarray) (Elektra * elektra, kdb_long_long_t index1) {  <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> ELEKTRA_SET (Myfloatarray) (Elektra * elektra, kdb_float_t value, kdb_long_long_t index1, ElektraError ** error) { <span class="comment">/* ... */</span> }</div>
</div><!-- fragment --><p>This is the most important part of the header. It is what makes the API work.</p>
<p>For each config value we generate an <code>ELEKTRA_GET(*)</code> and an <code>ELEKTRA_SET(*)</code> accessor function. All these functions are <code>static inline</code>, because they just call other getter/setter functions with partially fixed arguments. In fact many of these functions will only be a single line.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#undef elektra_len19</span></div>
<div class="line"><span class="comment">/* local macros ... */</span></div>
<div class="line"><span class="preprocessor">#undef elektra_len</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> loadConfiguration (Elektra ** elektra, <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> * argv, <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> * envp, ElektraError ** error);</div>
<div class="line"><span class="keywordtype">void</span> printHelpMessage (Elektra * elektra, <span class="keyword">const</span> <span class="keywordtype">char</span> * usage, <span class="keyword">const</span> <span class="keywordtype">char</span> * prefix);</div>
<div class="line"><span class="keywordtype">void</span> exitForSpecload (<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> ** argv);</div>
</div><!-- fragment --><p>Then we undefine the local macros we defined before and declare the three initialization functions <code>loadConfiguration</code>, <code>printHelpMessage</code> and <code>exitForSpecload</code>.</p>
<div class="fragment"><div class="line"><span class="comment">/* elektra* macros ... */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef __cplusplus</span></div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// CONF_H</span></div>
</div><!-- fragment --><p>At the end of the file you will find the <code>elektra*</code> convenience macros. These macros can be used to make accessing config values look more like normal function calls and avoid the ugly double parentheses in e.g. <code>ELEKTRA_GET (...) (...)</code>.</p>
<h2><a class="anchor" id="autotoc_md3765"></a>
Obtaining an &lt;tt&gt;Elektra&lt;/tt&gt; handle</h2>
<p>We start at the bottom of our <code>conf.h</code> excerpt. <code>exitForSpecload</code> is used to initiate specload mode, if needed. This mode makes your application provide its specification to Elektra. How this works exactly is not so important (see <a class="el" href="md_src_plugins_specload_README.html#src_plugins_specload_README_md">specload plugin</a>). You only need to know, that <code>exitForSpecload</code> should be called immediately at the start of your <code>main</code> function and that it only returns, when your application is not in specload mode.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="testio__doc_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> * argv, <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> * envp) {</div>
<div class="line">    exitForSpecload (argc, argv);</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="atestio__doc_8c_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="testio__doc_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdoc">[kdbio testsuite main]</div><div class="ttdef"><b>Definition:</b> testio_doc.c:48</div></div>
</div><!-- fragment --><p>To access your configuration, you first need to call <code>loadConfiguration</code> to get an <code>Elektra</code> handle for your application. This is done via a snippet that is more or less the same for all applications:</p>
<div class="fragment"><div class="line">ElektraError * error = NULL;</div>
<div class="line">Elektra * elektra = NULL;</div>
<div class="line"><span class="keywordtype">int</span> rc = loadConfiguration (&amp;elektra, argc, argv, envp, &amp;error);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (rc == -1)</div>
<div class="line">{</div>
<div class="line">    fprintf (stderr, <span class="stringliteral">&quot;An error occurred while opening Elektra: %s&quot;</span>, <a class="code" href="group__highlevel.html#ga781cda83af3981a55321e7c613afbef0">elektraErrorDescription</a> (error));</div>
<div class="line">    <a class="code" href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693">elektraErrorReset</a> (&amp;error);</div>
<div class="line">    exit (EXIT_FAILURE);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (rc == 1)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// help mode - application was called with &#39;--help&#39;</span></div>
<div class="line">    <span class="comment">// for more information see &quot;Command line options&quot; below</span></div>
<div class="line">    printHelpMessage (elektra, NULL, NULL);</div>
<div class="line">    <a class="code" href="group__highlevel.html#ga9b688b7250e5f9d8ea6701cc2cc269af">elektraClose</a> (elektra);</div>
<div class="line">    exit (EXIT_SUCCESS);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__highlevel_html_ga591f7ed4b57a341928bf7bb3d7adb693"><div class="ttname"><a href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693">elektraErrorReset</a></div><div class="ttdeci">void elektraErrorReset(ElektraError **error)</div><div class="ttdoc">Frees the memory used by the error and sets the referenced error variable to NULL.</div><div class="ttdef"><b>Definition:</b> elektra_error.c:315</div></div>
<div class="ttc" id="agroup__highlevel_html_ga781cda83af3981a55321e7c613afbef0"><div class="ttname"><a href="group__highlevel.html#ga781cda83af3981a55321e7c613afbef0">elektraErrorDescription</a></div><div class="ttdeci">const char * elektraErrorDescription(const ElektraError *error)</div><div class="ttdef"><b>Definition:</b> elektra_error.c:306</div></div>
<div class="ttc" id="agroup__highlevel_html_ga9b688b7250e5f9d8ea6701cc2cc269af"><div class="ttname"><a href="group__highlevel.html#ga9b688b7250e5f9d8ea6701cc2cc269af">elektraClose</a></div><div class="ttdeci">void elektraClose(Elektra *elektra)</div><div class="ttdoc">Releases all resources used by the given elektra instance.</div><div class="ttdef"><b>Definition:</b> elektra.c:509</div></div>
</div><!-- fragment --><p>Next it is recommended, you change the default handler for fatal errors. By default, we just call <code>exit (EXIT_FAILURE)</code>, since we don't know how you log your errors and what cleanup may be needed.</p>
<div class="fragment"><div class="line"><a class="code" href="group__highlevel.html#ga496441e9e1dd80ed14a239dfc4c08c40">elektraFatalErrorHandler</a> (elektra, onFatalError);</div>
<div class="ttc" id="agroup__highlevel_html_ga496441e9e1dd80ed14a239dfc4c08c40"><div class="ttname"><a href="group__highlevel.html#ga496441e9e1dd80ed14a239dfc4c08c40">elektraFatalErrorHandler</a></div><div class="ttdeci">void elektraFatalErrorHandler(Elektra *elektra, ElektraErrorHandler fatalErrorHandler)</div><div class="ttdoc">Sets the fatal error handler that will be called, whenever a fatal error occurs.</div><div class="ttdef"><b>Definition:</b> elektra.c:500</div></div>
</div><!-- fragment --><p><code>onFatalError</code> will receive the fatal <code>ElektraError *</code>. It must at least call <code>elektraErrorReset</code> on the error and then call <code>exit()</code>.</p>
<p>If you want to try out the application immediately, skip down to the <a href="#compiling-your-application">section about compiling</a>. You may also have to follow the section on <a href="#running-your-application">running your application</a> to get everything up and running.</p>
<h2><a class="anchor" id="autotoc_md3766"></a>
Reading config values</h2>
<p>Once you have your <code>Elektra</code> instance, reading config values is easy. You just call one of the getter functions.</p>
<div class="fragment"><div class="line">kdb_double_t mydouble = elektraGet (elektra, ELEKTRA_TAG_MYDOUBLE);</div>
</div><!-- fragment --><p>Here we used the convenience macro <code>elektraGet</code>. You could also invoke the <code>static inline</code> accessor function directly:</p>
<div class="fragment"><div class="line">kdb_double_t mydouble = ELEKTRA_GET (ELEKTRA_TAG_MYDOUBLE) (elektra);</div>
</div><!-- fragment --><p>No error handling is required, because getter functions are designed to not fail. In a correct setup, either the initialization fails and getters are never called, or getter calls always succeed.</p>
<p>To access config values that don't have a static key name, like arrays, you have to supply additional arguments (and use <code>elektraGetV</code>):</p>
<div class="fragment"><div class="line">kdb_float_t myfloat0 = elektraGetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 0);</div>
<div class="line">kdb_float_t myfloat1 = elektraGetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 1);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">kdb_float_t myfloat0 = ELEKTRA_GET (ELEKTRA_TAG_MYFLOATARRAY) (elektra, 0);</div>
<div class="line"><span class="keywordtype">float</span> myfloat1 = ELEKTRA_GET (ELEKTRA_TAG_MYFLOATARRAY) (elektra, 1);</div>
</div><!-- fragment --><p>Of course we also need to know, how big the <code>myfloatarray/#</code> array actually is. To that end we can use <code>ELEKTRA_SIZE</code> or <code>elektraSize</code>:</p>
<div class="fragment"><div class="line">kdb_long_long_t myfloat_size = elektraSize (elektra, ELEKTRA_TAG_MYFLOATARRAY);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">kdb_long_long_t myfloat_size = ELEKTRA_SIZE (ELEKTRA_TAG_MYFLOATARRAY) (elektra);</div>
</div><!-- fragment --><p><code>ELEKTRA_SIZE</code> functions like their <code>ELEKTRA_GET</code> counterparts are designed to not fail.</p>
<p>Please note that, while it shouldn't happen, if you setup everything correctly, calling a getter on a non-existent, wrongly typed or otherwise inconvertible key is a fatal error. All fatal errors result in a call to the fatal error handler and therefore exit the application.</p>
<h2><a class="anchor" id="autotoc_md3767"></a>
Writing config values</h2>
<p>Writing config values is not quite as easy as reading, but it is still quite simple:</p>
<div class="fragment"><div class="line">ElektraError * error = NULL;</div>
<div class="line">ELEKTRA_SET (ELEKTRA_TAG_MYDOUBLE) (elektra, 3.141593, &amp;error);</div>
<div class="line"><span class="keywordflow">if</span> (error == NULL) {</div>
<div class="line">    <span class="comment">// handle error</span></div>
<div class="line">    <a class="code" href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693">elektraErrorReset</a> (&amp;error);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see the complexity stems from the necessary error handling. Because setting values involves IO and other uncontrollable factors, setter calls cannot be designed to not fail. This is why they accept an additional <code>ElektraError **</code> argument. It is important to call <code>elektraErrorReset</code>, if an error was set. Calling a setter with a non-null <code>ElektraError **</code> parameter is a fatal error.</p>
<p>Of course you can also use <code>elektraSet</code> (error handling omitted):</p>
<div class="fragment"><div class="line">elektraSet (elektra, ELEKTRA_TAG_MYDOUBLE, 3.141593, &amp;error);</div>
<div class="line">elektraSetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 2.718282f, &amp;error, 2);</div>
</div><!-- fragment --><p>Note that <code>elektraSetV</code> takes the <code>ElektraError</code> argument before the variable arguments, while in <code>ELEKTA_SET</code> the error is always the last argument. This is because of limitations in the C macro system.</p>
<p>There is no setter for array sizes. Since Elektra's low-level part supports discontinuous arrays, we simply change the array size whenever necessary, if an array element setter is called. However, the high-level API has no support for discontinuous arrays, so take care not to create holes in your arrays, if you want to iterate over them. Remember, accessing non-existent keys (and this includes array elements) is a fatal error.</p>
<h2><a class="anchor" id="autotoc_md3768"></a>
Command-line options</h2>
<p>The generated <code>loadConfiguration</code> function automatically mounts the <code>gopts</code> plugin. This means that command-line options (as described <a class="el" href="doc_tutorials_command-line-options_md.html">here</a>) are parsed and their values are set on the corresponding keys. You don't have to do anything, apart from setting the <code>opt</code> metadata. The only exception to that is the <em>help mode</em>.</p>
<p>When your application is called with <code>-h</code> or <code>--help</code>, we enter help mode. This is indicated by the return value <code>1</code> of <code>loadConfiguration</code>. As you can see in the example above, you should call <code>printHelpMessage</code> to print an appropriate help message to <code>stdout</code> and then close the allocated <code>Elektra</code> instance and <code>exit</code>. <b>Beware</b> an <code>Elektra</code> instance created in help mode may not be fully functional, which is why you should immediately close it once you called <code>printHelpMessage</code>.</p>
<h2><a class="anchor" id="autotoc_md3769"></a>
Advanced concepts</h2>
<p>The code-generator has some more advanced features that are supported out of the box. For example, you can read multiple config values at once by utilizing structs. The use of structs also allows for recursive configurations like menus (a menu can have submenus).</p>
<p>For more information take a look at the man-page <a class="el" href="doc_help_kdb-gen-highlevel_md.html">`kdb-gen-highlevel(1)`</a>.</p>
<h1><a class="anchor" id="autotoc_md3770"></a>
Compiling your application</h1>
<p>Once you've written your application, you will want to compile it. This requires linking some libraries and adding to your include path. The easiest way is to use CMake or pkg-config to find the needed compiler options. Examples on how set this up can be found in here and here.</p>
<p>The compiler invocation should look something like this:</p>
<div class="fragment"><div class="line">cc myapp.c conf.c `pkg-config --cflags --libs elektra-codegen` -I. -o myapp -Wl,-rpath `pkg-config --variable=libdir elektra-codegen`</div>
</div><!-- fragment --><p>Note: At least C99 is required, so if your compiler defaults to an older version you'll need to add <code>-std=c99</code>.</p>
<h1><a class="anchor" id="autotoc_md3771"></a>
Running your application</h1>
<p>Running your application is easy, just run the executable (e.g. <code>myapp</code>). While this might work out of the box, you will just get the default configuration. To change the configuration you need to use <code>kdb</code>, which doesn't know about your specification yet. This means you would need to set the <code>type</code> metadata and all the other stuff that your application expects by hand. For every single key. Obviously this is not the right solution.</p>
<h2><a class="anchor" id="autotoc_md3772"></a>
Mounting the specification</h2>
<p>A better solution is to inform Elektra (and <code>kdb</code>) about our specification. Then Elektra automatically copies metadata to where it should be.</p>
<p>First you need to mount your specification itself into the KDB. Mounting is basically the process of informing Elektra about a new part of the KDB, similar to how mounting an external hard drive informs the OS about a new part of the file system.</p>
<div class="fragment"><div class="line">sudo kdb mount -R noresolver /etc/myapp_spec.eqd &quot;spec:/sw/example/myapp/#0/current&quot; specload app=&quot;$PWD/myapp&quot;</div>
</div><!-- fragment --><p>The command above assumes that you also used the <code>kdb gen</code> command from <a href="#invoking-the-code-generator">above</a> and that the <code>myapp</code> executable is located in <code>$PWD</code>.</p>
<blockquote class="doxtable">
<p><b>Note:</b> Because of a limitation in <code>specload</code>, we have to use the <code>noresolver</code> resolver. This also means that the path to the config file (here <code>/etc/myapp_spec.eqd</code>) has to be absolute. Otherwise it will always be relative to the current working directory in which <code>kdb</code> or your application was executed. The file <em>should not</em> exist when calling <code>kdb mount</code>. <code>specload</code> works different to other plugins. The given config file is only used, if the user makes changes to the specification via <code>kdb set</code>. </p>
</blockquote>
<p>Now that Elektra knows about your specification, calling your application might work better, since metadata should now be copied, when you set a config value via <code>kdb set</code>. However, there won't be any type checking. For that we need to enable the <code>type</code> plugin. While this could be done manually, we can just let Elektra figure out which plugins we need and activate all of them.</p>
<p>This can be done with the <code>spec-mount</code> command:</p>
<div class="fragment"><div class="line">sudo kdb spec-mount &quot;/sw/example/myapp/#0/current&quot;</div>
</div><!-- fragment --><p>Now finally your application is all setup.</p>
<h2><a class="anchor" id="autotoc_md3773"></a>
Configuring your application</h2>
<p>To configure your application you can use <code>kdb</code>:</p>
<div class="fragment"><div class="line">kdb set &quot;/sw/example/myapp/#0/current/mydouble&quot; 15.4</div>
</div><!-- fragment --><p>If you want to set a value system-wide (not just for your user) you can use the system namespace:</p>
<div class="fragment"><div class="line">kdb set &quot;system:/sw/example/myapp/#0/current/mydouble&quot; 15.4</div>
</div><!-- fragment --><p>Always use the cascading version of <code>kdb set</code> (i.e. the keyname begins with a slash <code>/</code>), otherwise type checking and other plugins might not be called correctly. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
