.TH "kdb::Key" 3elektra "Tue Mar 14 2023" "Version 0.9.13" "Elektra" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kdb::Key \- \fBKey\fP is an essential class that encapsulates key \fBname \fP, \fBvalue \fP and \fBmetainfo \fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <key\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBKey\fP ()"
.br
.RI "Constructs a key with the name \fC/\fP\&. "
.ti -1c
.RI "\fBKey\fP (ckdb::Key *k)"
.br
.RI "Constructs a key out of a C key\&. "
.ti -1c
.RI "\fBKey\fP (\fBKey\fP &k)"
.br
.RI "Takes a reference of another key\&. "
.ti -1c
.RI "\fBKey\fP (\fBKey\fP const &k)"
.br
.RI "Takes a reference of another key\&. "
.ti -1c
.RI "\fBKey\fP (const char *\fBkeyName\fP,\&.\&.\&.)"
.br
.RI "A practical way to fully create a \fBKey\fP object in one step\&. "
.ti -1c
.RI "\fBKey\fP (const std::string \fBkeyName\fP,\&.\&.\&.)"
.br
.RI "A practical way to fully create a \fBKey\fP object in one step\&. "
.ti -1c
.RI "\fBKey\fP (const char *\fBkeyName\fP, va_list ap)"
.br
.RI "A practical way to fully create a \fBKey\fP object in one step\&. "
.ti -1c
.RI "void \fBoperator++\fP (int) const"
.br
.RI "Increment the reference counter of a \fBKey\fP object\&. "
.ti -1c
.RI "void \fBoperator++\fP () const"
.br
.RI "Increment the reference counter of a \fBKey\fP object\&. "
.ti -1c
.RI "void \fBoperator\-\-\fP (int) const"
.br
.RI "Decrement the reference counter of a \fBKey\fP object\&. "
.ti -1c
.RI "void \fBoperator\-\-\fP () const"
.br
.RI "Decrement the reference counter of a \fBKey\fP object\&. "
.ti -1c
.RI "uint16_t \fBgetReferenceCounter\fP () const"
.br
.RI "Return the current reference counter value of a \fBKey\fP object\&. "
.ti -1c
.RI "\fBKey\fP & \fBoperator=\fP (ckdb::Key *k)"
.br
.RI "Assign a C key\&. "
.ti -1c
.RI "\fBKey\fP & \fBoperator=\fP (const \fBKey\fP &k)"
.br
.RI "Assign a key\&. "
.ti -1c
.RI "void \fBcopy\fP (const \fBKey\fP &other, \fBelektraCopyFlags\fP flags=\fBKEY_CP_ALL\fP)"
.br
.RI "Copy or clear a key\&. "
.ti -1c
.RI "void \fBclear\fP ()"
.br
.RI "Clears/Invalidates a key\&. "
.ti -1c
.RI "\fBKey\fP * \fBoperator\->\fP ()"
.br
.ti -1c
.RI "ckdb::Key * \fBgetKey\fP () const"
.br
.RI "Passes out the raw key pointer\&. "
.ti -1c
.RI "ckdb::Key * \fBoperator*\fP () const"
.br
.RI "Is an abbreviation for getKey\&. "
.ti -1c
.RI "ckdb::Key * \fBrelease\fP ()"
.br
.RI "Passes out the raw key pointer and resets internal key handle\&. "
.ti -1c
.RI "ckdb::Key * \fBdup\fP (\fBelektraCopyFlags\fP flags=\fBKEY_CP_ALL\fP) const"
.br
.ti -1c
.RI "\fB~Key\fP ()"
.br
.RI "Destructs the key\&. "
.ti -1c
.RI "std::string \fBgetName\fP () const"
.br
.RI "Returns a pointer to the abbreviated real internal \fCkey\fP name\&. "
.ti -1c
.RI "ssize_t \fBgetNameSize\fP () const"
.br
.RI "Bytes needed to store the \fBKey\fP's name (excluding owner)\&. "
.ti -1c
.RI "std::string \fBgetBaseName\fP () const"
.br
.RI "Returns a pointer to the unescaped \fBKey\fP's name where the basename starts\&. "
.ti -1c
.RI "ssize_t \fBgetBaseNameSize\fP () const"
.br
.RI "Calculates number of bytes needed to store basename of \fCkey\fP (including NULL terminator)\&. "
.ti -1c
.RI "void \fBsetName\fP (const std::string &newName)"
.br
.RI "Set a new name to a \fBKey\fP\&. "
.ti -1c
.RI "void \fBsetBaseName\fP (const std::string &baseName)"
.br
.RI "Sets a base name for a key\&. "
.ti -1c
.RI "void \fBaddBaseName\fP (const std::string &baseName)"
.br
.RI "Adds a base name for a key\&. "
.ti -1c
.RI "void \fBdelBaseName\fP ()"
.br
.RI "Delete the baseName of a key\&. "
.ti -1c
.RI "bool \fBoperator==\fP (const \fBKey\fP &k) const"
.br
.RI "Compare the name of two Keys\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBKey\fP &k) const"
.br
.RI "Compare the name of two Keys\&. "
.ti -1c
.RI "bool \fBoperator<\fP (const \fBKey\fP &other) const"
.br
.RI "Compare the name of two Keys\&. "
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBKey\fP &other) const"
.br
.RI "Compare the name of two Keys\&. "
.ti -1c
.RI "bool \fBoperator>\fP (const \fBKey\fP &other) const"
.br
.RI "Compare the name of two Keys\&. "
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBKey\fP &other) const"
.br
.RI "Compare the name of two Keys\&. "
.ti -1c
.RI "bool \fBisNull\fP () const"
.br
.RI "Checks if C++ wrapper has an underlying key\&. "
.ti -1c
.RI "\fBoperator bool\fP () const"
.br
.RI "This is for loops and lookups only\&. "
.ti -1c
.RI "bool \fBneedSync\fP () const"
.br
.RI "Test if a key needs to be synced to backend storage\&. "
.ti -1c
.RI "template<class T > T \fBget\fP () const"
.br
.RI "Get a key value\&. "
.ti -1c
.RI "template<class T > void \fBset\fP (T x)"
.br
.RI "Set a key value\&. "
.ti -1c
.RI "std::string \fBgetString\fP () const"
.br
.ti -1c
.RI "void \fBsetString\fP (const char *newString)"
.br
.RI "Set the value for \fCkey\fP as \fCnewStringValue\fP\&. "
.ti -1c
.RI "ssize_t \fBgetStringSize\fP () const"
.br
.RI "Returns the number of bytes needed to store the key value, including the NULL terminator\&. "
.ti -1c
.RI "func_t \fBgetFunc\fP () const"
.br
.RI "Elektra can store function pointers as binary\&. "
.ti -1c
.RI "const void * \fBgetValue\fP () const"
.br
.RI "Return a pointer to the real internal \fCkey\fP value\&. "
.ti -1c
.RI "std::string \fBgetBinary\fP () const"
.br
.RI "Copy the binary value of a \fBKey\fP into \fCreturnedBinary\fP\&. "
.ti -1c
.RI "ssize_t \fBgetBinarySize\fP () const"
.br
.RI "Returns the number of bytes needed to store the key value, including the NULL terminator\&. "
.ti -1c
.RI "ssize_t \fBsetBinary\fP (const void *newBinary, size_t dataSize)"
.br
.RI "Set the value of a \fBKey\fP to the binary value \fCnewBinary\fP\&. "
.ti -1c
.RI "bool \fBhasMeta\fP (const std::string &metaName) const"
.br
.ti -1c
.RI "template<class T > T \fBgetMeta\fP (const std::string &metaName) const"
.br
.RI "Returns the \fBKey\fP for a metadata entry with name \fCmetaName\fP\&. "
.ti -1c
.RI "template<class T > void \fBsetMeta\fP (const std::string &metaName, T x)"
.br
.RI "Set metadata for key\&. "
.ti -1c
.RI "void \fBdelMeta\fP (const std::string &metaName)"
.br
.RI "Delete metadata for key\&. "
.ti -1c
.RI "void \fBcopyMeta\fP (const \fBKey\fP &other, const std::string &metaName)"
.br
.RI "Do a shallow copy of metadata with name \fCmetaName\fP from source to dest\&. "
.ti -1c
.RI "void \fBcopyAllMeta\fP (const \fBKey\fP &other)"
.br
.RI "Do a shallow copy of all metadata from source to dest\&. "
.ti -1c
.RI "bool \fBisValid\fP () const"
.br
.ti -1c
.RI "ElektraNamespace \fBgetNamespace\fP () const"
.br
.ti -1c
.RI "ssize_t \fBsetNamespace\fP (ElektraNamespace ns) const"
.br
.RI "Set the namespace of the key\&. "
.ti -1c
.RI "bool \fBisCascading\fP () const"
.br
.RI "Determines if the key is in cascading namespace\&. "
.ti -1c
.RI "bool \fBisSpec\fP () const"
.br
.RI "Determines if the key is in spec namespace\&. "
.ti -1c
.RI "bool \fBisProc\fP () const"
.br
.RI "Determines if the key is in proc namespace\&. "
.ti -1c
.RI "bool \fBisDir\fP () const"
.br
.RI "Determines if the key is in dir namespace\&. "
.ti -1c
.RI "bool \fBisUser\fP () const"
.br
.RI "Determines if the key is in user namespace\&. "
.ti -1c
.RI "bool \fBisSystem\fP () const"
.br
.RI "Determines if the key is in system namespace\&. "
.ti -1c
.RI "bool \fBisString\fP () const"
.br
.RI "Check if the value of \fCkey\fP is of string type\&. "
.ti -1c
.RI "bool \fBisBinary\fP () const"
.br
.RI "Check if the value of a \fCkey\fP is of binary type\&. "
.ti -1c
.RI "bool \fBisBelow\fP (const \fBKey\fP &k) const"
.br
.RI "Check if the \fBKey\fP \fCcheck\fP is below the \fBKey\fP \fCkey\fP or not\&. "
.ti -1c
.RI "bool \fBisBelowOrSame\fP (const \fBKey\fP &k) const"
.br
.RI "Check if a key is below or same\&. "
.ti -1c
.RI "bool \fBisDirectBelow\fP (const \fBKey\fP &k) const"
.br
.RI "Check whether the \fBKey\fP \fCcheck\fP is directly below the \fBKey\fP \fCkey\fP\&. "
.ti -1c
.RI "bool \fBisNameLocked\fP () const"
.br
.ti -1c
.RI "bool \fBisValueLocked\fP () const"
.br
.ti -1c
.RI "bool \fBisMetaLocked\fP () const"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBKey\fP is an essential class that encapsulates key \fBname \fP, \fBvalue \fP and \fBmetainfo \fP\&. 

To use it include: 
.PP
.nf
#include <kdb\&.h>

.fi
.PP
.PP
\fBKey\fP properties are:
.IP "\(bu" 2
\fBKey name \fP
.IP "\(bu" 2
\fBKey value \fP
.IP "\(bu" 2
\fBKey metadata \fP, including but not limited to:
.IP "  \(bu" 4
\fBKey comment \fP
.IP "  \(bu" 4
\fBKey owner \fP
.IP "  \(bu" 4
\fBUID, GID and filesystem-like mode permissions \fP
.IP "  \(bu" 4
\fBMode, change and modification times \fP
.PP

.PP
.PP
\fBABI\fP
.RS 4
Due to ABI compatibility, the \fC\fBKey\fP\fP structure is not defined in kdb\&.h, only declared\&. So you can only declare \fCpointers\fP to \fCKeys\fP in your program, and allocate and free memory for them with \fBkeyNew()\fP and \fBkeyDel()\fP respectively\&.
.RE
.PP
\fBReference Counting\fP
.RS 4
Every key has its reference counter (see \fBkeyGetRef()\fP for longer explanation) that will be initialized with 0, that means a subsequent call of \fBkeyDel()\fP will delete the key\&. If you append the key to a keyset the reference counter will be incremented by one (see \fBkeyIncRef()\fP) and the key can't be deleted by a \fBkeyDel()\fP\&.
.RE
.PP
\fB\fP
.RS 4
As you can imagine this refcounting allows you to put the \fBKey\fP in your own data structures\&. It can be a very powerful feature, e\&.g\&. if you need your own-defined ordering or different Models of your configuration\&.
.RE
.PP
\fBCopy-On-Write\fP
.RS 4
Keys employ copy-on-write techniques to minimize memory footprint\&. If keys are copied or duplicated, they will point at the same name and value as the source key\&. Only if this data is changed, additional memory is allocated\&.
.RE
.PP
This class is an wrapper for an optional, refcounted ckdb::Key\&. It is like an shared_ptr<ckdb::Key>, but the shared_ptr functionality is already within the \fBKey\fP and exposed with this wrapper\&.
.PP
\fBoptional\fP
.RS 4
A key can be constructed with an null pointer, by using \fBKey\fP (static_cast<ckdb::Key*>(0)); or made empty afterwards by using \fBrelease()\fP or assign a null key\&. To check if there is an associated managed object the user can use \fBisNull()\fP\&.
.RE
.PP
\fBreferences\fP
.RS 4
Copies of keys are cheap because they are only flat\&. If you really need a deep copy, you can use \fBcopy()\fP or \fBdup()\fP\&. If you \fBrelease()\fP an object, the reference counter will stay All other operations operate on references\&.
.RE
.PP
\fBdocumentation\fP
.RS 4
Note that the documentation is typically copied from the underlying function which is wrapped and sometimes extended with C++ specific details\&. So you might find C examples within the C++ documentation\&.
.RE
.PP
\fBInvariant\fP
.RS 4
\fBKey\fP either has a working underlying Elektra \fBKey\fP object or a null pointer\&. The \fBKey\fP, however, might be invalid (see \fBisValid()\fP) or null (see \fBisNull()\fP)\&.
.RE
.PP
\fBNote\fP
.RS 4
that the reference counting in the keys is mutable, so that const keys can be passed around by value\&. 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "kdb::Key::Key ()\fC [inline]\fP"

.PP
Constructs a key with the name \fC/\fP\&. 
.PP
\fBNote\fP
.RS 4
That this is not a null key, so the key will evaluate to true\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBisValid()\fP, \fBisNull()\fP 
.RE
.PP

.SS "kdb::Key::Key (ckdb::Key * k)\fC [inline]\fP"

.PP
Constructs a key out of a C key\&. 
.PP
\fBNote\fP
.RS 4
If you pass a null pointer here, the key will evaluate to false\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIk\fP the key to work with
.RE
.PP
\fBSee also\fP
.RS 4
\fBisValid()\fP, \fBisNull()\fP 
.RE
.PP

.SS "kdb::Key::Key (\fBKey\fP & k)\fC [inline]\fP"

.PP
Takes a reference of another key\&. The key will not be copied, but the reference counter will be increased\&.
.PP
\fBParameters\fP
.RS 4
\fIk\fP the key to work with 
.RE
.PP

.SS "kdb::Key::Key (\fBKey\fP const & k)\fC [inline]\fP"

.PP
Takes a reference of another key\&. The key will not be copied, but the reference counter will be increased\&.
.PP
\fBParameters\fP
.RS 4
\fIk\fP the key to work with 
.RE
.PP

.SS "kdb::Key::Key (const char * keyName,  \&.\&.\&.)\fC [inline]\fP, \fC [explicit]\fP"

.PP
A practical way to fully create a \fBKey\fP object in one step\&. To just get a key object, simple do:
.PP
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/some/example", KEY_END);
// work with it
keyDel (k);
.fi
.PP
 \fBkeyNew()\fP allocates memory for a key object and \fBkeyDel()\fP cleans everything up\&.
.PP
If you want the key object to contain a name, value, comment and other meta info read on\&.
.PP
\fBNote\fP
.RS 4
When you already have a key with similar properties its easier to keyDup() the key\&.
.RE
.PP
You can call \fBkeyNew()\fP in many different ways depending on the attribute tags you pass as parameters\&. Tags are represented as \fBelektraKeyFlags\fP values, and tell \fBkeyNew()\fP which \fBKey\fP attribute comes next\&. The \fBKey\fP attribute tags are the following:
.IP "\(bu" 2
\fBKEY_VALUE\fP 
.br
 Next parameter is a pointer to the value that will be used\&. If no \fBKEY_BINARY\fP was used before, a string is assumed\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex0",
        KEY_VALUE, "some data",    // set a string value
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_SIZE\fP 
.br
 Define a maximum length of the value\&. This is only used when setting a binary key\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex1",
        KEY_SIZE, 4,               // has no effect on strings
        KEY_VALUE, "some data",    // set a string value
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_META\fP 
.br
 Next two parameter is a metaname and a metavalue\&. See \fBkeySetMeta()\fP\&. 
.PP
.nf
Key *k=keyNew("user:/tmp/ex3",
        KEY_META, "comment/#0", "a comment",  // with a comment
        KEY_META, "owner", "root",         // and an owner
        KEY_META, "special", "yes",        // and any other metadata
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_END\fP 
.br
 Must be the last parameter passed to \fBkeyNew()\fP\&. It is always required, unless the \fCkeyName\fP is 0\&.
.IP "\(bu" 2
\fBKEY_FLAGS\fP 
.br
 Bitwise disjunction of flags, which don't require one or more values\&. recommended way to set multiple flags\&. overrides previously defined flags\&. 
.PP
.nf
Key *k=keyNew("user:/tmp/ex3",
        KEY_BINARY,                     // binary key
        KEY_SIZE, 7,                    // assume binary length 7
        KEY_VALUE, "some data",         // value that will be truncated in 7 bytes
        KEY_END);                       // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_BINARY\fP 
.br
 Allows one to change the key to a binary key\&. Make sure that you also pass \fBKEY_SIZE\fP before you set the value\&. Otherwise it will be cut off with first \\0 in the string\&. So this flag toggle from \fBkeySetString()\fP to \fBkeySetBinary()\fP\&. If no value (nor size) is given, it will be a NULL key\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex2",
        KEY_BINARY,
        KEY_SIZE, 4,               // now the size is important
        KEY_VALUE, "some data",    // sets the binary value ("some")
        KEY_END);                  // end of args

.fi
.PP
.PP
.PP
.nf
Key *k=keyNew("user:/tmp/ex4",
        KEY_BINARY,                     // key type
        KEY_SIZE, 7,                    // assume binary length 7
        KEY_VALUE, "some data",         // value that will be truncated in 7 bytes
        KEY_META, "comment/#0", "value is truncated",
        KEY_END);                       // end of args
.fi
.PP
 
.PP
\fBPrecondition\fP
.RS 4
\fCname\fP is a valid \fBKey\fP name 
.PP
Variable arguments are a valid combination 
.RE
.PP
\fBPostcondition\fP
.RS 4
returns a new, fully initialized \fBKey\fP object with the valid \fBKey\fP name and all data given by variable arguments
.RE
.PP
\fBParameters\fP
.RS 4
\fIname\fP a valid name to the key (see \fBkeySetName()\fP)
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to a new allocated and initialized \fBKey\fP object\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINULL\fP on allocation error or if an invalid \fCname\fP was passed (see \fBkeySetName()\fP)\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyDel()\fP for deallocating a created \fBKey\fP object 
.PP
\fBkeySetName()\fP for rules about which names are considered valid
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyInvalidName\fP if key could not be constructed
.RE
.PP
\fBParameters\fP
.RS 4
\fIkeyName\fP the name of the new key 
.RE
.PP

.PP

.SS "kdb::Key::Key (const std::string keyName,  \&.\&.\&.)\fC [inline]\fP, \fC [explicit]\fP"

.PP
A practical way to fully create a \fBKey\fP object in one step\&. To just get a key object, simple do:
.PP
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/some/example", KEY_END);
// work with it
keyDel (k);
.fi
.PP
 \fBkeyNew()\fP allocates memory for a key object and \fBkeyDel()\fP cleans everything up\&.
.PP
If you want the key object to contain a name, value, comment and other meta info read on\&.
.PP
\fBNote\fP
.RS 4
When you already have a key with similar properties its easier to keyDup() the key\&.
.RE
.PP
You can call \fBkeyNew()\fP in many different ways depending on the attribute tags you pass as parameters\&. Tags are represented as \fBelektraKeyFlags\fP values, and tell \fBkeyNew()\fP which \fBKey\fP attribute comes next\&. The \fBKey\fP attribute tags are the following:
.IP "\(bu" 2
\fBKEY_VALUE\fP 
.br
 Next parameter is a pointer to the value that will be used\&. If no \fBKEY_BINARY\fP was used before, a string is assumed\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex0",
        KEY_VALUE, "some data",    // set a string value
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_SIZE\fP 
.br
 Define a maximum length of the value\&. This is only used when setting a binary key\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex1",
        KEY_SIZE, 4,               // has no effect on strings
        KEY_VALUE, "some data",    // set a string value
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_META\fP 
.br
 Next two parameter is a metaname and a metavalue\&. See \fBkeySetMeta()\fP\&. 
.PP
.nf
Key *k=keyNew("user:/tmp/ex3",
        KEY_META, "comment/#0", "a comment",  // with a comment
        KEY_META, "owner", "root",         // and an owner
        KEY_META, "special", "yes",        // and any other metadata
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_END\fP 
.br
 Must be the last parameter passed to \fBkeyNew()\fP\&. It is always required, unless the \fCkeyName\fP is 0\&.
.IP "\(bu" 2
\fBKEY_FLAGS\fP 
.br
 Bitwise disjunction of flags, which don't require one or more values\&. recommended way to set multiple flags\&. overrides previously defined flags\&. 
.PP
.nf
Key *k=keyNew("user:/tmp/ex3",
        KEY_BINARY,                     // binary key
        KEY_SIZE, 7,                    // assume binary length 7
        KEY_VALUE, "some data",         // value that will be truncated in 7 bytes
        KEY_END);                       // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_BINARY\fP 
.br
 Allows one to change the key to a binary key\&. Make sure that you also pass \fBKEY_SIZE\fP before you set the value\&. Otherwise it will be cut off with first \\0 in the string\&. So this flag toggle from \fBkeySetString()\fP to \fBkeySetBinary()\fP\&. If no value (nor size) is given, it will be a NULL key\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex2",
        KEY_BINARY,
        KEY_SIZE, 4,               // now the size is important
        KEY_VALUE, "some data",    // sets the binary value ("some")
        KEY_END);                  // end of args

.fi
.PP
.PP
.PP
.nf
Key *k=keyNew("user:/tmp/ex4",
        KEY_BINARY,                     // key type
        KEY_SIZE, 7,                    // assume binary length 7
        KEY_VALUE, "some data",         // value that will be truncated in 7 bytes
        KEY_META, "comment/#0", "value is truncated",
        KEY_END);                       // end of args
.fi
.PP
 
.PP
\fBPrecondition\fP
.RS 4
\fCname\fP is a valid \fBKey\fP name 
.PP
Variable arguments are a valid combination 
.RE
.PP
\fBPostcondition\fP
.RS 4
returns a new, fully initialized \fBKey\fP object with the valid \fBKey\fP name and all data given by variable arguments
.RE
.PP
\fBParameters\fP
.RS 4
\fIname\fP a valid name to the key (see \fBkeySetName()\fP)
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to a new allocated and initialized \fBKey\fP object\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINULL\fP on allocation error or if an invalid \fCname\fP was passed (see \fBkeySetName()\fP)\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyDel()\fP for deallocating a created \fBKey\fP object 
.PP
\fBkeySetName()\fP for rules about which names are considered valid
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyInvalidName\fP if key could not be constructed
.RE
.PP
\fBWarning\fP
.RS 4
Not supported on some compilers, e\&.g\&. clang which requires you to only pass non-POD in varg lists\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIkeyName\fP the name of the new key 
.RE
.PP

.PP

.SS "kdb::Key::Key (const char * keyName, va_list ap)\fC [inline]\fP, \fC [explicit]\fP"

.PP
A practical way to fully create a \fBKey\fP object in one step\&. To just get a key object, simple do:
.PP
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/some/example", KEY_END);
// work with it
keyDel (k);
.fi
.PP
 \fBkeyNew()\fP allocates memory for a key object and \fBkeyDel()\fP cleans everything up\&.
.PP
If you want the key object to contain a name, value, comment and other meta info read on\&.
.PP
\fBNote\fP
.RS 4
When you already have a key with similar properties its easier to keyDup() the key\&.
.RE
.PP
You can call \fBkeyNew()\fP in many different ways depending on the attribute tags you pass as parameters\&. Tags are represented as \fBelektraKeyFlags\fP values, and tell \fBkeyNew()\fP which \fBKey\fP attribute comes next\&. The \fBKey\fP attribute tags are the following:
.IP "\(bu" 2
\fBKEY_VALUE\fP 
.br
 Next parameter is a pointer to the value that will be used\&. If no \fBKEY_BINARY\fP was used before, a string is assumed\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex0",
        KEY_VALUE, "some data",    // set a string value
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_SIZE\fP 
.br
 Define a maximum length of the value\&. This is only used when setting a binary key\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex1",
        KEY_SIZE, 4,               // has no effect on strings
        KEY_VALUE, "some data",    // set a string value
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_META\fP 
.br
 Next two parameter is a metaname and a metavalue\&. See \fBkeySetMeta()\fP\&. 
.PP
.nf
Key *k=keyNew("user:/tmp/ex3",
        KEY_META, "comment/#0", "a comment",  // with a comment
        KEY_META, "owner", "root",         // and an owner
        KEY_META, "special", "yes",        // and any other metadata
        KEY_END);                  // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_END\fP 
.br
 Must be the last parameter passed to \fBkeyNew()\fP\&. It is always required, unless the \fCkeyName\fP is 0\&.
.IP "\(bu" 2
\fBKEY_FLAGS\fP 
.br
 Bitwise disjunction of flags, which don't require one or more values\&. recommended way to set multiple flags\&. overrides previously defined flags\&. 
.PP
.nf
Key *k=keyNew("user:/tmp/ex3",
        KEY_BINARY,                     // binary key
        KEY_SIZE, 7,                    // assume binary length 7
        KEY_VALUE, "some data",         // value that will be truncated in 7 bytes
        KEY_END);                       // end of args

.fi
.PP

.IP "\(bu" 2
\fBKEY_BINARY\fP 
.br
 Allows one to change the key to a binary key\&. Make sure that you also pass \fBKEY_SIZE\fP before you set the value\&. Otherwise it will be cut off with first \\0 in the string\&. So this flag toggle from \fBkeySetString()\fP to \fBkeySetBinary()\fP\&. If no value (nor size) is given, it will be a NULL key\&. 
.PP
.nf
// Create and initialize a key with a name and nothing else
Key *k=keyNew("user:/tmp/ex2",
        KEY_BINARY,
        KEY_SIZE, 4,               // now the size is important
        KEY_VALUE, "some data",    // sets the binary value ("some")
        KEY_END);                  // end of args

.fi
.PP
.PP
.PP
.nf
Key *k=keyNew("user:/tmp/ex4",
        KEY_BINARY,                     // key type
        KEY_SIZE, 7,                    // assume binary length 7
        KEY_VALUE, "some data",         // value that will be truncated in 7 bytes
        KEY_META, "comment/#0", "value is truncated",
        KEY_END);                       // end of args
.fi
.PP
 
.PP
\fBPrecondition\fP
.RS 4
\fCname\fP is a valid \fBKey\fP name 
.PP
Variable arguments are a valid combination 
.RE
.PP
\fBPostcondition\fP
.RS 4
returns a new, fully initialized \fBKey\fP object with the valid \fBKey\fP name and all data given by variable arguments
.RE
.PP
\fBParameters\fP
.RS 4
\fIname\fP a valid name to the key (see \fBkeySetName()\fP)
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to a new allocated and initialized \fBKey\fP object\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINULL\fP on allocation error or if an invalid \fCname\fP was passed (see \fBkeySetName()\fP)\&.
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyDel()\fP for deallocating a created \fBKey\fP object 
.PP
\fBkeySetName()\fP for rules about which names are considered valid
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyInvalidName\fP if key could not be constructed
.RE
.PP
\fBParameters\fP
.RS 4
\fIkeyName\fP the name of the new key 
.br
\fIap\fP the variable argument list pointer 
.RE
.PP

.PP

.SS "kdb::Key::~Key ()\fC [inline]\fP"

.PP
Destructs the key\&. 
.PP
\fBSee also\fP
.RS 4
del() 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void kdb::Key::addBaseName (const std::string & baseName)\fC [inline]\fP"

.PP
Adds a base name for a key\&. Adds \fCbaseName\fP to the name of \fCkey\fP\&. \fCbaseName\fP will be escaped before adding it to the name of \fCkey\fP\&. No other part of the \fBKey\fP's name will be affected\&.
.PP
Assumes that \fCkey\fP is a directory and will append \fCbaseName\fP to it\&. The function adds the path separator for concatenating\&.
.PP
If \fCkey\fP has the name \fC'system:/dir1/dir2'\fP and this method is called with \fCbaseName\fP \fC'mykey'\fP, the resulting key will have the name \fC'system:/dir1/dir2/mykey'\fP\&.
.PP
When \fCbaseName\fP is 0, nothing will happen and the size of the name is returned\&.
.PP
The escaping rules apply as in \fBabove \fP\&.
.PP
A simple example is: 
.PP
.nf
Key * k = keyNew ("user:/my/long", KEY_END);
keyAddBaseName (k, "myname");
printf ("%s\n", keyName (k)); // will print user:/my/long/myname
keyDel (k);

.fi
.PP
 E\&.g\&. if you add \&. it will be escaped: 
.PP
.nf
        keySetName (k, "system:/valid");
        succeed_if (keyAddBaseName (k, "\&.") >= 0, "could not add a base name");
        succeed_if_same_string (keyName (k), "system:/valid/\\\&.");
        succeed_if_same_string (keyBaseName (k), "\&.");

.fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP to add the basename to 
.br
\fIbaseName\fP the string to append to the \fBKey\fP's name
.RE
.PP
\fBReturns\fP
.RS 4
the size in bytes of the \fBKey\fP's new name including the NULL terminator 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP if the \fBKey\fP has no name 
.br
\fI-1\fP on NULL pointers 
.br
\fI-1\fP if \fBKey\fP was inserted into \fBKeySet\fP before 
.br
\fI-1\fP if the \fBKey\fP was read-only 
.br
\fI-1\fP on memory allocation errors
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeySetBaseName()\fP for setting the basename of a \fBKey\fP 
.PP
\fBkeySetName()\fP for setting the name of a \fBKey\fP
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyInvalidName\fP if the name is not valid 
.RE
.PP

.SS "void kdb::Key::clear ()\fC [inline]\fP"

.PP
Clears/Invalidates a key\&. Afterwards the object is empty again\&.
.PP
\fBNote\fP
.RS 4
This is not a null key, so it will evaluate to true\&. \fBisValid()\fP will, however, be false\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBrelease()\fP 
.PP
\fBisValid()\fP, \fBisNull()\fP
.RE
.PP
Will clear all internal data of a \fBKey\fP\&. After this call you will receive a fresh \fBKey\fP - with no value, metadata or name\&.
.PP
The reference counter will stay unmodified\&.
.PP
\fBNote\fP
.RS 4
that you might also \fBclear()\fP all aliases with this operation\&.
.RE
.PP
.PP
.nf
int f (Key *k)
{
        keyClear (k);
        // you have a fresh Key k here
        keySetString (k, "value");
        // the caller will get an empty Key k with an value
}
.fi
.PP
.PP
\fBPostcondition\fP
.RS 4
\fCkey's\fP name is '/' 
.PP
\fCkey's\fP metadata is empty
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP that should be cleared
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP on success 
.br
\fI-1\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyDel()\fP for completely deleting a \fBKey\fP 
.RE
.PP

.SS "void kdb::Key::copy (const \fBKey\fP & other, \fBelektraCopyFlags\fP flags = \fC\fBKEY_CP_ALL\fP\fP)\fC [inline]\fP"

.PP
Copy or clear a key\&. Depending on the chosen \fCflags\fP \fBkeyCopy()\fP only copies certain parts of \fCsource\fP into \fCdest\fP\&.
.PP
.IP "\(bu" 2
If \fBKEY_CP_NAME\fP is set, the key name will be copied from \fCsource\fP to \fCdest\fP\&.
.IP "\(bu" 2
If \fBKEY_CP_META\fP is set, the meta keys will be copied from \fCsource\fP to \fCdest\fP\&.
.IP "\(bu" 2
If \fBKEY_CP_VALUE\fP is set, the key value will be copied from \fCsource\fP to \fCdest\fP\&. Additionally, if \fCsource\fP is a binary key (\fBkeyIsBinary()\fP), \fCdest\fP will also be marked as binary\&. This means that even if \fBKEY_CP_META\fP is not set, the \fCbinary\fP meta key will be copied with \fBKEY_CP_VALUE\fP\&.
.IP "\(bu" 2
If \fBKEY_CP_STRING\fP is set, the key value will be copied from \fCsource\fP to \fCdest\fP, but only, if \fCsource\fP is \fInot\fP a binary key (\fBkeyIsBinary()\fP)\&. If \fCsource\fP is binary, \fBkeyCopy()\fP fails\&. If \fCdest\fP is binary, it will still be marked as binary after the copy\&. This cannot be used together with \fBKEY_CP_VALUE\fP\&. The main purpose of \fBKEY_CP_STRING\fP is for copying \fIinto\fP known string keys\&. It ensure that you don't accidentally convert string keys into binary keys\&.
.PP
.PP
There is also the shorthand \fBKEY_CP_ALL\fP\&. It is equivalent to \fCKEY_CP_NAME | KEY_CP_VALUE | KEY_CP_META\fP, i\&.e\&. all key data supported by \fBkeyCopy()\fP will be copied from \fCsource\fP to \fCdest\fP\&.
.PP
Use this function when you need to copy into an existing key, e\&.g\&. because it was passed by a pointer in a function you can do so:
.PP
.PP
.nf
keyCopy (copy, orig, KEY_CP_ALL);
.fi
.PP
 Most often you will want to duplicate an existing key\&. For this purpose the alias keyDup() exists\&. Calling
.PP
.PP
.nf
copy = keyDup (orig, KEY_CP_ALL);
.fi
.PP
 is equivalent to
.PP
.PP
.nf
copy = keyCopy (keyNew ("/", KEY_END), orig, KEY_CP_ALL);
.fi
.PP
 The reference counter will not be changed for both keys\&. Affiliation to keysets are also not affected\&.
.PP
Since metadata uses copy-on-write semantics there is only a constant memory cost to copying metadata\&.
.PP
When you pass a NULL-pointer as \fCsource\fP the pieces of \fCdest\fP specified by \fCflags\fP will be cleared\&.
.PP
Calling \fCkeyCopy (dest, NULL, KEY_CP_ALL)\fP is different from calling \fBkeyClear()\fP\&. The key will not be fully reset, the reference counter and internal flags will remain unchanged\&. Additionally, \fBkeyCopy()\fP respects \fBkeyLock()\fP state, while \fBkeyClear()\fP always works\&.
.PP
.PP
.nf
keyCopy (k, NULL, KEY_CP_ALL);
// name, value and metadata of k have now been clear
// lock flags, reference count, etc\&. remain unchanged
.fi
.PP
 
.PP
\fBPrecondition\fP
.RS 4
\fCdest\fP must be a valid \fBKey\fP (created with keyNew) 
.PP
\fCdest\fP must not have read-only flags set 
.PP
\fCsource\fP must be a valid \fBKey\fP or NULL 
.RE
.PP
\fBInvariant\fP
.RS 4
\fBKey\fP name stays valid until delete 
.RE
.PP
\fBPostcondition\fP
.RS 4
Value from \fBKey\fP source is written to \fBKey\fP dest
.RE
.PP
\fBParameters\fP
.RS 4
\fIdest\fP the key which will be written to 
.br
\fIsource\fP the key which should be copied or NULL to clear the data of \fCdest\fP 
.br
\fIflags\fP specifies which parts of the key should be copied
.RE
.PP
\fBReturns\fP
.RS 4
\fCdest\fP 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINULL\fP on memory allocation problems 
.br
\fINULL\fP when a part of \fCdest\fP that should be modified (e\&.g\&. name, value) was marked read-only, e\&.g\&. the name of \fCdest\fP will be read-only if \fCdest\fP is part of a \fBKeySet\fP 
.br
\fINULL\fP when \fCdest\fP is NULL 
.br
\fINULL\fP when both \fBKEY_CP_VALUE\fP and \fBKEY_CP_STRING\fP are set in \fCflags\fP 
.br
\fINULL\fP when both \fBKEY_CP_STRING\fP is set in \fCflags\fP and \fCsource\fP is a binary key (\fBkeyIsBinary()\fP)
.RE
.PP
\fBSince\fP
.RS 4
0\&.9\&.5
.RE
.PP
\fBSee also\fP
.RS 4
keyDup() for duplicating an existing \fBKey\fP 
.RE
.PP

.SS "void kdb::Key::copyAllMeta (const \fBKey\fP & other)\fC [inline]\fP"

.PP
Do a shallow copy of all metadata from source to dest\&. The key dest will additionally have all metadata the source had\&. Metadata not present in source will not be changed\&. Metadata which was present in source and dest will be overwritten\&. If the \fCdest\fP \fBKey\fP is read-only it will not be changed\&.
.PP
For example the metadata type is copied into the \fBKey\fP k:
.PP
.PP
.nf
void l (Key * k)
{
        // receive copy
        keyCopyAllMeta (k, copy);
        // the caller will see the changed key k
        // with all the metadata from copy
}
.fi
.PP
 The main purpose of this function is for plugins or applications which want to add the same metadata to n keys\&. When you do that with \fBkeySetMeta()\fP it will take n times the memory for the key\&. This can be considerable amount of memory for many keys with some metadata for each\&.
.PP
To avoid that problem you can use \fBkeyCopyAllMeta()\fP or \fBkeyCopyMeta()\fP:
.PP
.PP
.nf
void o (KeySet * ks)
{
        Key * current;
        Key * shared = keyNew ("/", KEY_END);
        keySetMeta (shared, "shared1", "this metadata should be shared among many keys");
        keySetMeta (shared, "shared2", "this metadata should be shared among many keys also");
        keySetMeta (shared, "shared3", "this metadata should be shared among many keys too");

        for (elektraCursor it = 0; it < ksGetSize (ks); ++it)
        {
                current = ksAtCursor (ks, it);
                if (needsSharedData (current)) keyCopyAllMeta (current, shared);
        }

        keyDel (shared);
}
.fi
.PP
 
.PP
\fBPrecondition\fP
.RS 4
\fCdest's\fP metadata is not read-only 
.RE
.PP
\fBPostcondition\fP
.RS 4
for every metaName present in source: keyGetMeta(source, metaName) == keyGetMeta(dest, metaName)
.RE
.PP
\fBParameters\fP
.RS 4
\fIdest\fP the destination where the metadata should be copied too 
.br
\fIsource\fP the key where the metadata should be copied from
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if metadata was successfully copied 
.br
\fI0\fP if source did not have any metadata 
.br
\fI-1\fP on null pointer of dest or source 
.br
\fI-1\fP on memory problems
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyCopyMeta()\fP for copying one metadata \fBKey\fP from \fCdest\fP to \fCsource\fP 
.PP
\fBgetMeta()\fP, \fBsetMeta()\fP, \fBcopyMeta()\fP 
.RE
.PP

.SS "void kdb::Key::copyMeta (const \fBKey\fP & other, const std::string & metaName)\fC [inline]\fP"

.PP
Do a shallow copy of metadata with name \fCmetaName\fP from source to dest\&. Afterwards \fCsource\fP and \fCdest\fP will have the same metadata referred with \fCmetaName\fP\&. If the \fBKey\fP with name \fCmetaName\fP doesn't exist in \fCsource\fP - it gets deleted in \fCdest\fP\&.
.PP
For example the metadata type is copied into the \fBKey\fP k\&.
.PP
.PP
.nf
void l(Key *k)
{
        // receive c
        keyCopyMeta(k, c, "type");
        // the caller will see the changed key k
        // with the metadata "type" from c
}
.fi
.PP
.PP
The main purpose of this function is for plugins or applications, which want to add the same metadata to n keys\&. When you do that \fBkeySetMeta()\fP will take n times the memory for the key\&. This can be a considerable amount of memory for many keys with some metadata for each\&.
.PP
To avoid that problem you can use \fBkeyCopyAllMeta()\fP or \fBkeyCopyMeta()\fP\&.
.PP
.PP
.nf
void o(KeySet *ks)
{
        Key *shared = keyNew ("/", KEY_END);
        keySetMeta(shared, "shared", "this metadata should be shared among many keys");

        for (elektraCursor it = 0; it < ksGetSize (ks); ++it)
        {
                Key * current = ksAtCursor (ks, it);
                if (needs_shared_data(current)) keyCopyMeta(current, shared, "shared");
        }
}
.fi
.PP
.PP
\fBPrecondition\fP
.RS 4
\fCdest's\fP metadata is not read-only 
.RE
.PP
\fBPostcondition\fP
.RS 4
keyGetMeta(source, metaName) == keyGetMeta(dest, metaName)
.RE
.PP
\fBParameters\fP
.RS 4
\fIdest\fP the destination where the metadata should be copied to 
.br
\fIsource\fP the key where the metadata should be copied from 
.br
\fImetaName\fP the name of the metadata \fBKey\fP which should be copied
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if was successfully copied 
.br
\fI0\fP if the metadata in dest was removed too 
.br
\fI-1\fP on null pointers (source or dest) 
.br
\fI-1\fP on memory problems 
.br
\fI-1\fP if metadata is read-only
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyCopyAllMeta()\fP copies all metadata from \fCdest\fP to \fCsrc\fP 
.PP
\fBgetMeta()\fP, \fBsetMeta()\fP, \fBcopyAllMeta()\fP 
.RE
.PP

.SS "void kdb::Key::delBaseName ()\fC [inline]\fP"

.PP
Delete the baseName of a key\&. 
.PP
\fBExceptions\fP
.RS 4
\fIKeyInvalidName\fP if the name is not valid 
.RE
.PP

.SS "void kdb::Key::delMeta (const std::string & metaName)\fC [inline]\fP"

.PP
Delete metadata for key\&. 
.PP
\fBSee also\fP
.RS 4
\fBsetMeta()\fP, \fBgetMeta()\fP, \fBcopyMeta()\fP, \fBcopyAllMeta()\fP 
.RE
.PP

.SS "ckdb::Key * kdb::Key::dup (\fBelektraCopyFlags\fP flags = \fC\fBKEY_CP_ALL\fP\fP) const\fC [inline]\fP"

.PP

.SS "template<class T > T kdb::Key::get\fC [inline]\fP"

.PP
Get a key value\&. You can write your own template specialication, e\&.g\&.: 
.PP
.nf
template <>
inline QColor Key::get() const
{
        if (getStringSize() < 1)
        {
                throw KeyTypeConversion();
        }

        std::string str = getString();
        QColor c(str\&.c_str());
        return c;
}

.fi
.PP
.PP
\fBReturns\fP
.RS 4
the string directly from the key\&.
.RE
.PP
It should be the same as \fBget()\fP\&. 
.PP
\fBReturns\fP
.RS 4
empty string on null pointers
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyException\fP on null key or not a valid size 
.br
\fIKeyTypeMismatch\fP if key holds binary data and not a string
.RE
.PP
\fBNote\fP
.RS 4
unlike in the C version, it is safe to change the returned string\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBisString()\fP, \fBgetBinary()\fP
.RE
.PP
This method tries to serialise the string to the given type\&. 
.SS "std::string kdb::Key::getBaseName () const\fC [inline]\fP"

.PP
Returns a pointer to the unescaped \fBKey\fP's name where the basename starts\&. This is a much more efficient version of \fBkeyGetBaseName()\fP and you should use it if you are responsible enough to not mess up things\&. The name might change or even point to a wrong place after a \fBkeySetName()\fP\&. So make sure to copy the memory before the name changes\&.
.PP
\fBkeyBaseName()\fP returns '' when the \fBKey\fP has no basename\&. The reason is 
.PP
.nf
      keySetName (k, "");
        succeed_if_same_string (keyBaseName (k), "");
        keySetName (k, "user:/");
        succeed_if_same_string (keyBaseName (k), "");

.fi
.PP
 There is also support for really empty basenames: 
.PP
.nf
        keySetName (k, "system:/valid");
        succeed_if (keyAddBaseName (k, "") >= 0, "could not add a base name");
        succeed_if_same_string (keyName (k), "system:/valid/%");
        succeed_if_same_string (keyBaseName (k), "");

.fi
.PP
 
.PP
\fBNote\fP
.RS 4
You must never use the pointer returned by \fBkeyBaseName()\fP method to change the name\&. You should use \fBkeySetBaseName()\fP instead\&.
.PP
Do not assume that \fBkeyBaseName()\fP points to the same region as \fBkeyName()\fP does\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP to obtain the basename from
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the \fBKey\fP's basename 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI''\fP when the \fBKey\fP has no (base)name 
.br
\fI0\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetBaseName()\fP for getting a \fBcopy\fP of the \fBKey\fP's basename 
.PP
\fBkeyGetBaseNameSize()\fP for getting the size of the \fBKey\fP's basename 
.PP
\fBkeyName()\fP for getting a pointer to the \fBKey\fP's name 
.RE
.PP

.SS "ssize_t kdb::Key::getBaseNameSize () const\fC [inline]\fP"

.PP
Calculates number of bytes needed to store basename of \fCkey\fP (including NULL terminator)\&. \fBKey\fP names consisting of only root names (e\&.g\&. \fC'system:/'\fP or \fC'user:/'\fP or \fC'user:domain'\fP ) do not have basenames\&. In this case the function will return 1, because only a NULL terminator is needed for storage\&.
.PP
Basenames are denoted as:
.IP "\(bu" 2
\fCsystem:/some/thing/basename\fP -> \fCbasename\fP 
.IP "\(bu" 2
\fCuser:domain/some/thing/base\\/name\fP > \fCbase\\/name\fP 
.PP
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP to get the size of the basename from
.RE
.PP
\fBReturns\fP
.RS 4
size in bytes of the \fBKey\fP's basename including NULL terminator 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP if the \fBKey\fP or the \fBKey\fP's basename is NULL
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyBaseName()\fP for getting a pointer to a \fBKey\fP's basename 
.PP
\fBkeyGetBaseName()\fP for getting a \fBcopy\fP of a \fBKey\fP's basename 
.PP
\fBkeyName()\fP, \fBkeyGetName()\fP for getting a pointer / \fBcopy\fP of the whole name 
.PP
\fBkeySetName()\fP for setting a \fBKey\fP's name 
.RE
.PP

.SS "std::string kdb::Key::getBinary () const\fC [inline]\fP"

.PP
Copy the binary value of a \fBKey\fP into \fCreturnedBinary\fP\&. 
.PP
\fBReturns\fP
.RS 4
the binary Value of the key\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fI''\fP on null pointers (size == 0) and on data only containing \\0
.RE
.PP
\fBNote\fP
.RS 4
if you need to distinguish between null pointers and data containing \\0 you can use \fBgetValue()\fP\&.
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyException\fP on invalid binary size 
.br
\fIKeyTypeMismatch\fP if key is string and not a binary
.RE
.PP
If the type is not binary -1 will be returned\&.
.PP
When the binary data is empty (this is not the same as ''!) 0 will be returned and \fCreturnedBinary\fP will not be changed\&.
.PP
For string values see \fBkeyGetString()\fP and \fBkeyIsString()\fP\&.
.PP
When \fCreturnedBinary\fP is too small to hold the data (maximum size is given by maxSize), the returnedBinary will not be changed and -1 is returned\&.
.PP
\fBExample:\fP
.RS 4

.PP
.nf
Key *key = keyNew ("user:/keyname", KEY_BINARY, KEY_END);
char buffer[300];

if (keyGetBinary(key,buffer,sizeof(buffer)) == -1)
{
        // handle error
}

.fi
.PP
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object to get the binary value from 
.br
\fIreturnedBinary\fP pre-allocated memory to store a copy of the \fBKey\fP's value 
.br
\fImaxSize\fP number of bytes of pre-allocated memory in \fCreturnedBinary\fP 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes copied to \fCreturnedBinary\fP 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP if the binary is empty 
.br
\fI-1\fP on NULL pointers 
.br
\fI-1\fP if maxSize is 0, too small for the value or larger than SSIZE_MAX 
.br
\fI-1\fP if the \fBKey\fP's value is a string
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyValue()\fP for getting a raw pointer to the \fBKey\fP's value 
.PP
\fBkeyGetValueSize()\fP for getting the size of the \fBKey\fP's value 
.PP
\fBkeySetBinary()\fP for setting the binary value of a \fBKey\fP 
.PP
\fBkeyIsBinary()\fP for checking whether a \fBKey\fP's value is binary 
.PP
\fBkeyGetString()\fP, \fBkeySetString()\fP for working with string values
.PP
\fBisBinary()\fP, \fBgetString()\fP, \fBgetValue()\fP 
.RE
.PP

.SS "ssize_t kdb::Key::getBinarySize () const\fC [inline]\fP"

.PP
Returns the number of bytes needed to store the key value, including the NULL terminator\&. It returns the correct size, independent of the \fBKey\fP Type\&. If the value is binary there might be '\\0' values in it\&.
.PP
For an empty string you need one byte to store the ending NULL\&. For that reason 1 is returned\&. This is not true for binary data, so 0 will be returned\&.
.PP
A binary key has no '\\0' termination\&. String types are null-terminated, and the terminator will be considered for the length\&.
.PP
This method can be used with \fBelektraMalloc()\fP before \fBkeyGetString()\fP or \fBkeyGetBinary()\fP is called\&.
.PP
.PP
.nf
char *buffer;
buffer = elektraMalloc (keyGetValueSize (key));
// use this buffer to store the value (binary or string)
// pass keyGetValueSize (key) for maxSize
.fi
.PP
.PP
\fBPostcondition\fP
.RS 4
returns the exact amount of bytes needed to store \fCkey's\fP value (including NULL terminators)
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object to get the size of the value from
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes needed to store the \fBKey\fP's value 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP when there is no data and type is a string 
.br
\fI0\fP when there is no data and type is binary 
.br
\fI-1\fP on null pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetString()\fP for getting the \fBKey\fP's value as a string 
.PP
\fBkeyGetBinary()\fP for getting the \fBKey\fP's value as a binary 
.PP
\fBkeyValue()\fP for getting a pointer to the \fBKey\fP's value 
.RE
.PP

.SS "Key::func_t kdb::Key::getFunc () const\fC [inline]\fP"

.PP
Elektra can store function pointers as binary\&. This function returns such a function pointer\&.
.PP
\fBExceptions\fP
.RS 4
\fIKeyTypeMismatch\fP if no binary data found, or binary data has not correct length
.RE
.PP
\fBReturns\fP
.RS 4
a function pointer stored with \fBsetBinary()\fP 
.RE
.PP

.SS "ckdb::Key * kdb::Key::getKey () const\fC [inline]\fP"

.PP
Passes out the raw key pointer\&. This pointer can be used to directly change the underlying key object\&.
.PP
\fBNote\fP
.RS 4
that the ownership remains in the object 
.RE
.PP

.SS "template<class T > T kdb::Key::getMeta (const std::string & metaName) const\fC [inline]\fP"

.PP
Returns the \fBKey\fP for a metadata entry with name \fCmetaName\fP\&. You are not allowed to modify the resulting key\&.
.PP
If \fCmetaName\fP does not start with 'meta:/', it will be prefixed with 'meta:/'\&.
.PP
.PP
.nf
Key metaData = keyGetMeta(k, "type")
// keyType == "boolean"
char keyType[] = keyValue(metaData)
.fi
.PP
.PP
\fBNote\fP
.RS 4
You must not delete or change the returned key, use \fBkeySetMeta()\fP if you want to delete or change it\&.
.RE
.PP
\fBPrecondition\fP
.RS 4
\fCkey\fP contains metadata 
.PP
\fCmetaName\fP is prefixed with 'meta:/'
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP from which to get metadata 
.br
\fImetaName\fP the name of the meta information you want the \fBKey\fP from\&.
.RE
.PP
\fBReturns\fP
.RS 4
value of meta-information if meta-information is found 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP if key or metaName is NULL 
.br
\fI0\fP if no such metaName is found
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeySetMeta()\fP for setting metadata 
.PP
\fBkeyMeta()\fP for getting the \fBKeySet\fP containing metadata
.RE
.PP
You can specify your own template specialisation: 
.PP
.nf
template<>
inline yourtype Key::getMeta(const std::string &name) const
{
        yourtype x;
        std::string str;
        str = std::string(
                static_cast<const char*>(
                        ckdb::keyValue(
                                ckdb::keyGetMeta(key, name\&.c_str())
                                )
                        )
                );
        return yourconversion(str);
}

.fi
.PP
.PP
\fBExceptions\fP
.RS 4
\fIKeyTypeConversion\fP if metadata could not be parsed
.RE
.PP
\fBNote\fP
.RS 4
No exception will be thrown if a const \fBKey\fP or char* is requested, but don't forget the const: getMeta<const Key>, otherwise you will get an compiler error\&.
.RE
.PP
If no meta is available:
.IP "\(bu" 2
char* is null (evaluates to 0)
.IP "\(bu" 2
const \fBKey\fP is null (evaluate to false)
.IP "\(bu" 2
otherwise the default constructed type will be returned 
.PP
\fBSee also\fP
.RS 4
\fBhasMeta\fP
.PP
\fBdelMeta()\fP, \fBsetMeta()\fP, \fBcopyMeta()\fP, \fBcopyAllMeta()\fP 
.RE
.PP

.PP

.SS "std::string kdb::Key::getName () const\fC [inline]\fP"

.PP
Returns a pointer to the abbreviated real internal \fCkey\fP name\&. This is a much more efficient version of \fBkeyGetName()\fP and can use it if you are responsible enough to not mess up things\&. You are not allowed to change anything in the returned array\&. The content of that string may change after \fBkeySetName()\fP and similar functions\&. If you need a copy of the name, consider using \fBkeyGetName()\fP\&.
.PP
\fBReturn values\fP
.RS 4
\fI''\fP when there is no keyName\&. The reason is 
.PP
.nf
key=keyNew(0);
keySetName(key,"");
keyName(key); // you would expect "" here
keyDel(key);

.fi
.PP
.RE
.PP
Valid key names are:
.PP
.IP "\(bu" 2
\fCspec:/something\fP for specification of other keys\&.
.IP "\(bu" 2
\fCproc:/something\fP for in-memory keys, e\&.g\&. commandline\&.
.IP "\(bu" 2
\fCdir:/something\fP for dir keys in current working directory
.IP "\(bu" 2
\fCsystem:/something\fP for system keys in /etc or /
.IP "\(bu" 2
\fCuser:/something\fP for user keys in home directory
.IP "\(bu" 2
\fCuser:username/something\fP for other users (deprecated: \fBkdbGet()\fP + \fBkdbSet()\fP currently unsupported)
.IP "\(bu" 2
\fC/something\fP for cascading keys (actually refers to one of the above, see also \fBksLookup()\fP)
.PP
\fBNote\fP
.RS 4
Note that the \fBKey\fP structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by \fBkeyName()\fP method to set a new value\&. Use \fBkeySetName()\fP instead\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP you want to get the name from
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the \fBKey\fP's name which must not be changed\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI''\fP when \fBKey\fP's name is empty 
.br
\fI0\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetNameSize()\fP for the string length 
.PP
\fBkeyGetName()\fP as alternative to \fBget\fP a \fBcopy\fP 
.PP
\fBkeyUnescapedName\fP to \fBget\fP an unescaped \fBKey\fP name
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyException\fP if key is null
.RE
.PP
\fBNote\fP
.RS 4
unlike in the C version, it is safe to change the returned string\&. 
.RE
.PP

.PP

.SS "ssize_t kdb::Key::getNameSize () const\fC [inline]\fP"

.PP
Bytes needed to store the \fBKey\fP's name (excluding owner)\&. For an empty \fBKey\fP name you need one byte to store the ending NULL\&. For that reason, 1 is returned when the name is empty\&.
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP to get the name size from
.RE
.PP
\fBReturns\fP
.RS 4
number of bytes needed, including NULL terminator, to store \fBKey\fP's name (excluding owner) 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if \fBKey\fP has no name 
.br
\fI-1\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetName()\fP for getting the \fBKey\fP's name 
.PP
\fBkeyGetUnescapedNameSize()\fP for getting the size of the unescaped name 
.RE
.PP

.SS "ElektraNamespace kdb::Key::getNamespace () const\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
namespace of the key
.RE
.PP
\fBSee also\fP
.RS 4
ElektraNamespace, \fBkeyGetNamespace\fP 
.RE
.PP

.SS "uint16_t kdb::Key::getReferenceCounter () const\fC [inline]\fP"

.PP
Return the current reference counter value of a \fBKey\fP object\&. 
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP whose reference counter to retrieve
.RE
.PP
\fBReturns\fP
.RS 4
the value of the \fCkey's\fP reference counter 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyIncRef()\fP for increasing the reference counter and for a more complete explanation of the reference counting system 
.PP
\fBkeyDecRef()\fP for decreasing the reference counter 
.RE
.PP

.SS "std::string kdb::Key::getString () const\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
the string directly from the key\&.
.RE
.PP
It should be the same as \fBget()\fP\&. 
.PP
\fBReturns\fP
.RS 4
empty string on null pointers
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyException\fP on null key or not a valid size 
.br
\fIKeyTypeMismatch\fP if key holds binary data and not a string
.RE
.PP
\fBNote\fP
.RS 4
unlike in the C version, it is safe to change the returned string\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBisString()\fP, \fBgetBinary()\fP 
.RE
.PP

.SS "ssize_t kdb::Key::getStringSize () const\fC [inline]\fP"

.PP
Returns the number of bytes needed to store the key value, including the NULL terminator\&. It returns the correct size, independent of the \fBKey\fP Type\&. If the value is binary there might be '\\0' values in it\&.
.PP
For an empty string you need one byte to store the ending NULL\&. For that reason 1 is returned\&. This is not true for binary data, so 0 will be returned\&.
.PP
A binary key has no '\\0' termination\&. String types are null-terminated, and the terminator will be considered for the length\&.
.PP
This method can be used with \fBelektraMalloc()\fP before \fBkeyGetString()\fP or \fBkeyGetBinary()\fP is called\&.
.PP
.PP
.nf
char *buffer;
buffer = elektraMalloc (keyGetValueSize (key));
// use this buffer to store the value (binary or string)
// pass keyGetValueSize (key) for maxSize
.fi
.PP
.PP
\fBPostcondition\fP
.RS 4
returns the exact amount of bytes needed to store \fCkey's\fP value (including NULL terminators)
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object to get the size of the value from
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes needed to store the \fBKey\fP's value 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP when there is no data and type is a string 
.br
\fI0\fP when there is no data and type is binary 
.br
\fI-1\fP on null pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetString()\fP for getting the \fBKey\fP's value as a string 
.PP
\fBkeyGetBinary()\fP for getting the \fBKey\fP's value as a binary 
.PP
\fBkeyValue()\fP for getting a pointer to the \fBKey\fP's value 
.RE
.PP

.SS "const void * kdb::Key::getValue () const\fC [inline]\fP"

.PP
Return a pointer to the real internal \fCkey\fP value\&. This is a much more efficient version of \fBkeyGetString()\fP \fBkeyGetBinary()\fP\&. You should use it if you are responsible enough to not mess up things\&. You are not allowed to modify anything in the returned string\&. If you need a copy of the Value, consider to use \fBkeyGetString()\fP or \fBkeyGetBinary()\fP instead\&.
.SH "String Handling"
.PP
If \fCkey\fP is string (\fBkeyIsString()\fP), you may cast the returned as a \fC'char *'\fP because you'll get a NULL terminated regular string\&.
.PP
\fBkeyValue()\fP returns '' in string mode when there is no value\&. The reason is 
.PP
.nf
key=keyNew(0);
keySetString(key,"");
keyValue(key); // you would expect "" here
keyDel(key);

.fi
.PP
.SH "Binary Data Handling"
.PP
If the data is binary, the size of the value must be determined by \fBkeyGetValueSize()\fP, any strlen() operations are not suitable to determine the size\&.
.PP
\fBkeyValue()\fP returns 0 in binary mode when there is no value\&. The reason is 
.PP
.nf
key=keyNew(0);
keySetBinary(key, 0, 0);
keyValue(key); // you would expect 0 here

keySetBinary(key,"", 1);
keyValue(key); // you would expect "" (a pointer to '\0') here

int i=23;
keySetBinary(key, (void*)&i, 4);
(int*)keyValue(key); // you would expect a pointer to (int)23 here
keyDel(key);

.fi
.PP
.PP
\fBNote\fP
.RS 4
Note that the \fBKey\fP structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by \fBkeyValue()\fP method to set a new value\&. Use \fBkeySetString()\fP or \fBkeySetBinary()\fP instead\&.
.RE
.PP
\fBWarning\fP
.RS 4
Binary keys will return a NULL pointer when there is no data in contrast to \fBkeyName()\fP, \fBkeyBaseName()\fP and \fBkeyComment()\fP\&. For string value the behaviour is the same\&.
.RE
.PP
\fBExample:\fP
.RS 4

.PP
.nf
KDB *handle = kdbOpen();
KeySet *ks=ksNew(0, KS_END);
kdbGetByName(handle,ks,"system:/sw/my",KDB_O_SORT|KDB_O_RECURSIVE);

 for (elektraCursor it = 0; it < ksGetSize (ks); ++it)
 {
        Key * current = ksAtCursor (ks, it);
        size_t size=0;

        if (keyIsBinary(current)) {
                size=keyGetValueSize(current);
                printf("Key %s has a value of size %d bytes\&. Value: <BINARY>\nComment: %s",
                        keyName(current),
                        size,
                        keyComment(current));
        } else {
                size=elektraStrLen((char *)keyValue(current));
                printf("Key %s has a value of size %d bytes\&. Value: %s\nComment: %s",
                        keyName(current),
                        size,
                        (char *)keyValue(current),
                        keyComment(current));
        }
}

ksDel (ks);
kdbClose (handle);

.fi
.PP
.RE
.PP
\fBPrecondition\fP
.RS 4
\fCkey\fP is not NULL and has stored data 
.RE
.PP
\fBPostcondition\fP
.RS 4
returned pointer points to the stored internal value 
.PP
if the value is a string, the value is NULL terminated
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP from which to get the value
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the \fBKey\fP's internal value 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI''\fP when there is no value and \fBKey\fP is not binary 
.br
\fI0\fP where there is no value and \fBKey\fP is binary 
.br
\fI0\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetValueSize()\fP to \fBget\fP the size of the \fBKey\fP's value 
.PP
\fBkeyGetString()\fP for getting the \fBKey\fP's value as string 
.PP
\fBkeyGetBinary()\fP for getting the \fBKey\fP's value as binary
.RE
.PP
\fBReturns\fP
.RS 4
the value of the key 
.RE
.PP
\fBSee also\fP
.RS 4
\fBgetBinary()\fP 
.RE
.PP

.SS "bool kdb::Key::hasMeta (const std::string & metaName) const\fC [inline]\fP"

.PP
\fBReturn values\fP
.RS 4
\fItrue\fP if there is a metadata with given name 
.br
\fIfalse\fP if no such metadata exists
.RE
.PP
\fBSee also\fP
.RS 4
\fBgetMeta()\fP 
.RE
.PP

.SS "bool kdb::Key::isBelow (const \fBKey\fP & k) const\fC [inline]\fP"

.PP
Check if the \fBKey\fP \fCcheck\fP is below the \fBKey\fP \fCkey\fP or not\&. 
.PP
\fBParameters\fP
.RS 4
\fIk\fP the other key 
.RE
.PP
\fBReturns\fP
.RS 4
true if our key is below k
.RE
.PP
Example: 
.PP
.nf
key user:/sw/app
check user:/sw/app/key

.fi
.PP
.PP
returns true because \fCcheck\fP is below \fCkey\fP 
.PP
Example: 
.PP
.nf
key user:/sw/app
check user:/sw/app/folder/key

.fi
.PP
.PP
returns also true because \fCcheck\fP is indirectly below \fCkey\fP 
.PP
Obviously, there is no \fBKey\fP above a namespace (e\&.g\&. user, system, /):
.PP
.PP
.nf
key *
check user
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object to check against 
.br
\fIcheck\fP the \fBKey\fP object for which it should be checked whether it is below \fCkey\fP 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if \fCcheck\fP is below \fCkey\fP 
.br
\fI0\fP if it is not below or if it is the same key 
.br
\fI-1\fP if key or check is null
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyIsDirectlyBelow()\fP for checking whether a \fBKey\fP is directly below another 
.PP
\fBkeyGetName()\fP, \fBkeySetName()\fP for getting / setting the \fBKey\fP's name 
.RE
.PP

.SS "bool kdb::Key::isBelowOrSame (const \fBKey\fP & k) const\fC [inline]\fP"

.PP
Check if a key is below or same\&. 
.PP
\fBParameters\fP
.RS 4
\fIk\fP the other key 
.RE
.PP
\fBReturns\fP
.RS 4
true if our key is below k or the same as k
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the key object to work with 
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyIsBelow()\fP 
.RE
.PP

.SS "bool kdb::Key::isBinary () const\fC [inline]\fP"

.PP
Check if the value of a \fCkey\fP is of binary type\&. The function checks if the value of \fCkey\fP is binary\&. Contrary to string values binary values can have '\\0' inside the value and may not be terminated by a null character\&. Their disadvantage is that you need to pass their size\&.
.PP
Make sure to use this function and don't test the binary type another way to ensure compatibility and to write less error prone programs\&.
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP to check
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if the value of \fCkey\fP is binary 
.br
\fI0\fP if the value of \fCkey\fP is not binary 
.br
\fI-1\fP on NULL pointer
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetBinary()\fP, \fBkeySetBinary()\fP for getting / setting a \fBKey\fP's value as binary 
.RE
.PP

.SS "bool kdb::Key::isCascading () const\fC [inline]\fP"

.PP
Determines if the key is in cascading namespace\&. 
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP if it is a cascading key 
.br
\fIfalse\fP otherwise 
.RE
.PP

.SS "bool kdb::Key::isDir () const\fC [inline]\fP"

.PP
Determines if the key is in dir namespace\&. 
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP if it is a dir key 
.br
\fIfalse\fP otherwise 
.RE
.PP

.SS "bool kdb::Key::isDirectBelow (const \fBKey\fP & k) const\fC [inline]\fP"

.PP
Check whether the \fBKey\fP \fCcheck\fP is directly below the \fBKey\fP \fCkey\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIk\fP the other key 
.RE
.PP
\fBReturns\fP
.RS 4
true if our key is direct below k
.RE
.PP
.PP
.nf
Example:
key user:/sw/app
check user:/sw/app/key.fi
.PP
.PP
returns true because check is directly below key
.PP
.PP
.nf
Example:
key user:/sw/app
check user:/sw/app/folder/key.fi
.PP
.PP
does not return true, because it is only indirectly below
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object to check against 
.br
\fIcheck\fP the \fBKey\fP object for which it should be checked whether it is directly below \fCkey\fP 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if \fCcheck\fP is directly below \fCkey\fP 
.br
\fI0\fP if \fCcheck\fP is not directly below \fCkey\fP or if it is the same 
.br
\fI-1\fP on null pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyIsBelow()\fP for checking whether a \fBKey\fP is below another 
.PP
\fBkeyGetName()\fP, \fBkeySetName()\fP for getting / setting the \fBKey\fP's name 
.RE
.PP

.SS "bool kdb::Key::isMetaLocked () const\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
true if the metadata of our key has been locked 
.RE
.PP

.SS "bool kdb::Key::isNameLocked () const\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
true if the name of our key has been locked 
.RE
.PP

.SS "bool kdb::Key::isNull () const\fC [inline]\fP"

.PP
Checks if C++ wrapper has an underlying key\&. 
.PP
\fBSee also\fP
.RS 4
operator bool(), \fBisValid()\fP 
.RE
.PP
\fBReturns\fP
.RS 4
true if no underlying key exists 
.RE
.PP

.SS "bool kdb::Key::isProc () const\fC [inline]\fP"

.PP
Determines if the key is in proc namespace\&. 
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP if it is a proc key 
.br
\fIfalse\fP otherwise 
.RE
.PP

.SS "bool kdb::Key::isSpec () const\fC [inline]\fP"

.PP
Determines if the key is in spec namespace\&. 
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP if it is a spec key 
.br
\fIfalse\fP otherwise 
.RE
.PP

.SS "bool kdb::Key::isString () const\fC [inline]\fP"

.PP
Check if the value of \fCkey\fP is of string type\&. String values are null terminated and are not allowed to have any '\\0' characters inside the string\&.
.PP
Make sure to use this function and don't test the string type another way to ensure compatibility and to write less error prone programs\&.
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP to check
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if the value of \fCkey\fP is string 
.br
\fI0\fP if the value of \fCkey\fP is not string 
.br
\fI-1\fP on NULL pointer
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetString()\fP, \fBkeySetString()\fP for getting / setting a \fBKey\fP's value as string 
.RE
.PP

.SS "bool kdb::Key::isSystem () const\fC [inline]\fP"

.PP
Determines if the key is in system namespace\&. 
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP if it is a system key 
.br
\fIfalse\fP otherwise 
.RE
.PP

.SS "bool kdb::Key::isUser () const\fC [inline]\fP"

.PP
Determines if the key is in user namespace\&. 
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP if it is a user key 
.br
\fIfalse\fP otherwise 
.RE
.PP

.SS "bool kdb::Key::isValid () const\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
if the key is valid
.RE
.PP
An invalid key has no name\&. The name of valid keys either start with user or system\&.
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP if the key has a valid name 
.br
\fIfalse\fP if the key has an invalid name
.RE
.PP
\fBSee also\fP
.RS 4
\fBgetName()\fP, \fBisUser()\fP, \fBisSystem()\fP, \fBgetNamespace()\fP 
.RE
.PP

.SS "bool kdb::Key::isValueLocked () const\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
true if the value of our key has been locked 
.RE
.PP

.SS "bool kdb::Key::needSync () const\fC [inline]\fP"

.PP
Test if a key needs to be synced to backend storage\&. If any \fBKey\fP modification took place the \fBKey\fP will be flagged so that \fBkdbSet()\fP knows which keys were modified and which not\&.
.PP
After \fBkeyNew()\fP the flag will normally be set, but after \fBkdbGet()\fP and \fBkdbSet()\fP the flag will be removed\&. When you modify the key the flag will be set again\&.
.PP
In your application you can make use of that flag to know if you changed something in a key after a \fBkdbGet()\fP or \fBkdbSet()\fP\&.
.PP
\fBNote\fP
.RS 4
Note that the sync status will be updated on any change, including metadata\&.
.RE
.PP
\fBDeprecated\fP
.RS 4
The handling of synchronization is done internally and does not need to be checked by neither application nor plugins\&.
.RE
.PP
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP which should be checked
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if \fCkey\fP was changed in memory 
.br
\fI0\fP if \fCkey\fP wasn't changed 
.br
\fI-1\fP on NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyNew()\fP, keyDup() Keys need to be synced after calling those functions 
.RE
.PP

.SS "kdb::Key::operator bool () const\fC [inline]\fP"

.PP
This is for loops and lookups only\&. Opposite of \fBisNull()\fP
.PP
For loops it checks if there are still more keys\&. For lookups it checks if a key could be found\&.
.PP
\fBWarning\fP
.RS 4
you should not construct or use null keys
.RE
.PP
\fBSee also\fP
.RS 4
\fBisNull()\fP, \fBisValid()\fP 
.RE
.PP
\fBReturns\fP
.RS 4
false on null keys 
.PP
true otherwise 
.RE
.PP

.SS "bool kdb::Key::operator!= (const \fBKey\fP & k) const\fC [inline]\fP"

.PP
Compare the name of two Keys\&. The comparison is based on a memcmp of the \fBKey\fP's names\&. If the names match, the Keys are found to be exactly the same and 0 is returned\&. These two keys can't be used in the same \fBKeySet\fP\&.
.PP
\fBkeyCmp()\fP defines the sorting order for a \fBKeySet\fP\&.
.PP
The following 3 points are the rules for NULL values:
.PP
.IP "\(bu" 2
A NULL pointer will be found to be smaller than every other \fBKey\fP\&. If both are NULL pointers, 0 is returned\&.
.IP "\(bu" 2
A NULL name will be found to be smaller than every other name\&. If both are NULL names, 0 is returned\&.
.PP
.PP
If the name is equal then:
.PP
.IP "\(bu" 2
No owner will be found to be smaller than every other owner\&. If both don't have an owner, 0 is returned\&.
.PP
.PP
\fBNote\fP
.RS 4
the owner will only be used if the names are equal\&.
.RE
.PP
Given any Keys k1 and k2 constructed with \fBkeyNew()\fP, following equation hold true:
.PP
.PP
.nf
  succeed_if (keyCmp (0, 0) == 0, "all null pointers same");
        succeed_if (keyCmp (k1, 0) == 1, "null pointer is smaller");
        succeed_if (keyCmp (0, k2) == -1, "null pointer is smaller");
.fi
.PP
 Here are some more examples: 
.PP
.nf
Key *k1 = keyNew("user:/a", KEY_END);
Key *k2 = keyNew("user:/b", KEY_END);

// keyCmp(k1,k2) < 0
// keyCmp(k2,k1) > 0

.fi
.PP
.PP
Do not strcmp the \fBkeyName()\fP yourself, because the result differs from simple ascii comparison\&.
.PP
\fBPrecondition\fP
.RS 4
The Keys \fCk1\fP and \fCk2\fP have been properly initialized via \fBkeyNew()\fP or are NULL 
.RE
.PP
\fBInvariant\fP
.RS 4
All parts of the Keys remain unchanged 
.RE
.PP
\fBPostcondition\fP
.RS 4
If the result is 0, \fCk1\fP and \fCk2\fP cannot be used in the same \fBKeySet\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIk1\fP the first \fBKey\fP to be compared 
.br
\fIk2\fP the second \fBKey\fP to be compared
.RE
.PP
\fBReturn values\fP
.RS 4
\fI<0\fP if k1 < k2 
.br
\fI0\fP if k1 == k2 
.br
\fI>0\fP if k1 > k2
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBksAppendKey()\fP, \fBksAppend()\fP will compare Keys via \fBkeyCmp()\fP when appending 
.PP
\fBksLookup()\fP will compare Keys via \fBkeyCmp()\fP during searching
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP != 0 
.RE
.PP

.SS "ckdb::Key * kdb::Key::operator* () const\fC [inline]\fP"

.PP
Is an abbreviation for getKey\&. Passes out the raw key pointer\&. This pointer can be used to directly change the underlying key object\&.
.PP
\fBNote\fP
.RS 4
that the ownership remains in the object
.RE
.PP
\fBSee also\fP
.RS 4
\fBgetKey()\fP 
.RE
.PP

.SS "void kdb::Key::operator++ () const\fC [inline]\fP"

.PP
Increment the reference counter of a \fBKey\fP object\&. As long as the reference counter is non-zero, \fC\fBkeyDel()\fP\fP operations on \fCkey\fP will be a no-op and return an error code\&.
.PP
Elektra's system for reference counting is not based on a concept of shared ownership\&. It is more similar to a shared lock, where the counter is used to keep track of how many clients hold the lock\&.
.PP
Initially, the reference counter will be 0\&. This is can be interpreted as the lock being unlocked\&. When you increment the reference counter, the lock becomes locked and \fC\fBkeyDel()\fP\fP is blocked and fails\&. Only when the reference counter is fully decremented back down to 0 again, will \fC\fBkeyDel()\fP\fP work again\&.
.PP
\fBNote\fP
.RS 4
The reference counter can never exceed \fCUINT16_MAX - 1\fP\&. \fCUINT16_MAX\fP is reserved as an error code\&.
.RE
.PP
\fBPostcondition\fP
.RS 4
\fCkey's\fP reference counter is > 0 
.PP
\fCkey's\fP reference counter is <= UINT16_MAX - 1
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object whose reference counter should be increased
.RE
.PP
\fBReturns\fP
.RS 4
the updated value of the reference counter 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIUINT16_MAX\fP on NULL pointer 
.br
\fIUINT16_MAX\fP when the reference counter already was the maximum value \fCUINT16_MAX - 1\fP, the reference counter will not be modified in this case
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetRef()\fP to retrieve the current reference count 
.PP
\fBkeyDecRef()\fP for decreasing the reference counter 
.PP
\fBkeyDel()\fP for deleting a \fBKey\fP 
.RE
.PP

.SS "void kdb::Key::operator++ (int) const\fC [inline]\fP"

.PP
Increment the reference counter of a \fBKey\fP object\&. As long as the reference counter is non-zero, \fC\fBkeyDel()\fP\fP operations on \fCkey\fP will be a no-op and return an error code\&.
.PP
Elektra's system for reference counting is not based on a concept of shared ownership\&. It is more similar to a shared lock, where the counter is used to keep track of how many clients hold the lock\&.
.PP
Initially, the reference counter will be 0\&. This is can be interpreted as the lock being unlocked\&. When you increment the reference counter, the lock becomes locked and \fC\fBkeyDel()\fP\fP is blocked and fails\&. Only when the reference counter is fully decremented back down to 0 again, will \fC\fBkeyDel()\fP\fP work again\&.
.PP
\fBNote\fP
.RS 4
The reference counter can never exceed \fCUINT16_MAX - 1\fP\&. \fCUINT16_MAX\fP is reserved as an error code\&.
.RE
.PP
\fBPostcondition\fP
.RS 4
\fCkey's\fP reference counter is > 0 
.PP
\fCkey's\fP reference counter is <= UINT16_MAX - 1
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object whose reference counter should be increased
.RE
.PP
\fBReturns\fP
.RS 4
the updated value of the reference counter 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIUINT16_MAX\fP on NULL pointer 
.br
\fIUINT16_MAX\fP when the reference counter already was the maximum value \fCUINT16_MAX - 1\fP, the reference counter will not be modified in this case
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetRef()\fP to retrieve the current reference count 
.PP
\fBkeyDecRef()\fP for decreasing the reference counter 
.PP
\fBkeyDel()\fP for deleting a \fBKey\fP 
.RE
.PP

.SS "void kdb::Key::operator\-\- () const\fC [inline]\fP"

.PP
Decrement the reference counter of a \fBKey\fP object\&. As long as the reference counter is non-zero, \fC\fBkeyDel()\fP\fP operations on \fCkey\fP will be a no-op and return an error code\&.
.PP
\fBPostcondition\fP
.RS 4
\fCkey's\fP reference counter is >= 0 
.PP
\fCkey's\fP reference counter is < SSIZE_MAX
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object whose reference counter should get decreased
.RE
.PP
\fBReturns\fP
.RS 4
the updated value of the reference counter 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIUINT16_MAX\fP on NULL pointer 
.br
\fI0\fP when the reference counter already was the minimum value 0, the reference counter will not be modified in this case
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetRef()\fP to retrieve the current reference count 
.PP
\fBkeyIncRef()\fP for increasing the reference counter and for a more complete explanation of the reference counting system 
.PP
\fBkeyDel()\fP for deleting a \fBKey\fP 
.RE
.PP

.SS "void kdb::Key::operator\-\- (int) const\fC [inline]\fP"

.PP
Decrement the reference counter of a \fBKey\fP object\&. As long as the reference counter is non-zero, \fC\fBkeyDel()\fP\fP operations on \fCkey\fP will be a no-op and return an error code\&.
.PP
\fBPostcondition\fP
.RS 4
\fCkey's\fP reference counter is >= 0 
.PP
\fCkey's\fP reference counter is < SSIZE_MAX
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object whose reference counter should get decreased
.RE
.PP
\fBReturns\fP
.RS 4
the updated value of the reference counter 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIUINT16_MAX\fP on NULL pointer 
.br
\fI0\fP when the reference counter already was the minimum value 0, the reference counter will not be modified in this case
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetRef()\fP to retrieve the current reference count 
.PP
\fBkeyIncRef()\fP for increasing the reference counter and for a more complete explanation of the reference counting system 
.PP
\fBkeyDel()\fP for deleting a \fBKey\fP 
.RE
.PP

.SS "\fBKey\fP * kdb::Key::operator\-> ()\fC [inline]\fP"

.PP
\fBReturns\fP
.RS 4
a pointer to this object
.RE
.PP
Needed for \fBKeySet\fP iterators\&. 
.PP
\fBSee also\fP
.RS 4
\fBKeySetIterator\fP 
.RE
.PP

.SS "bool kdb::Key::operator< (const \fBKey\fP & other) const\fC [inline]\fP"

.PP
Compare the name of two Keys\&. The comparison is based on a memcmp of the \fBKey\fP's names\&. If the names match, the Keys are found to be exactly the same and 0 is returned\&. These two keys can't be used in the same \fBKeySet\fP\&.
.PP
\fBkeyCmp()\fP defines the sorting order for a \fBKeySet\fP\&.
.PP
The following 3 points are the rules for NULL values:
.PP
.IP "\(bu" 2
A NULL pointer will be found to be smaller than every other \fBKey\fP\&. If both are NULL pointers, 0 is returned\&.
.IP "\(bu" 2
A NULL name will be found to be smaller than every other name\&. If both are NULL names, 0 is returned\&.
.PP
.PP
If the name is equal then:
.PP
.IP "\(bu" 2
No owner will be found to be smaller than every other owner\&. If both don't have an owner, 0 is returned\&.
.PP
.PP
\fBNote\fP
.RS 4
the owner will only be used if the names are equal\&.
.RE
.PP
Given any Keys k1 and k2 constructed with \fBkeyNew()\fP, following equation hold true:
.PP
.PP
.nf
        succeed_if (keyCmp (0, 0) == 0, "all null pointers same");
        succeed_if (keyCmp (k1, 0) == 1, "null pointer is smaller");
        succeed_if (keyCmp (0, k2) == -1, "null pointer is smaller");
.fi
.PP
 Here are some more examples: 
.PP
.nf
Key *k1 = keyNew("user:/a", KEY_END);
Key *k2 = keyNew("user:/b", KEY_END);

// keyCmp(k1,k2) < 0
// keyCmp(k2,k1) > 0

.fi
.PP
.PP
Do not strcmp the \fBkeyName()\fP yourself, because the result differs from simple ascii comparison\&.
.PP
\fBPrecondition\fP
.RS 4
The Keys \fCk1\fP and \fCk2\fP have been properly initialized via \fBkeyNew()\fP or are NULL 
.RE
.PP
\fBInvariant\fP
.RS 4
All parts of the Keys remain unchanged 
.RE
.PP
\fBPostcondition\fP
.RS 4
If the result is 0, \fCk1\fP and \fCk2\fP cannot be used in the same \fBKeySet\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIk1\fP the first \fBKey\fP to be compared 
.br
\fIk2\fP the second \fBKey\fP to be compared
.RE
.PP
\fBReturn values\fP
.RS 4
\fI<0\fP if k1 < k2 
.br
\fI0\fP if k1 == k2 
.br
\fI>0\fP if k1 > k2
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBksAppendKey()\fP, \fBksAppend()\fP will compare Keys via \fBkeyCmp()\fP when appending 
.PP
\fBksLookup()\fP will compare Keys via \fBkeyCmp()\fP during searching
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP < 0 
.RE
.PP

.SS "bool kdb::Key::operator<= (const \fBKey\fP & other) const\fC [inline]\fP"

.PP
Compare the name of two Keys\&. The comparison is based on a memcmp of the \fBKey\fP's names\&. If the names match, the Keys are found to be exactly the same and 0 is returned\&. These two keys can't be used in the same \fBKeySet\fP\&.
.PP
\fBkeyCmp()\fP defines the sorting order for a \fBKeySet\fP\&.
.PP
The following 3 points are the rules for NULL values:
.PP
.IP "\(bu" 2
A NULL pointer will be found to be smaller than every other \fBKey\fP\&. If both are NULL pointers, 0 is returned\&.
.IP "\(bu" 2
A NULL name will be found to be smaller than every other name\&. If both are NULL names, 0 is returned\&.
.PP
.PP
If the name is equal then:
.PP
.IP "\(bu" 2
No owner will be found to be smaller than every other owner\&. If both don't have an owner, 0 is returned\&.
.PP
.PP
\fBNote\fP
.RS 4
the owner will only be used if the names are equal\&.
.RE
.PP
Given any Keys k1 and k2 constructed with \fBkeyNew()\fP, following equation hold true:
.PP
.PP
.nf
     succeed_if (keyCmp (0, 0) == 0, "all null pointers same");
        succeed_if (keyCmp (k1, 0) == 1, "null pointer is smaller");
        succeed_if (keyCmp (0, k2) == -1, "null pointer is smaller");
.fi
.PP
 Here are some more examples: 
.PP
.nf
Key *k1 = keyNew("user:/a", KEY_END);
Key *k2 = keyNew("user:/b", KEY_END);

// keyCmp(k1,k2) < 0
// keyCmp(k2,k1) > 0

.fi
.PP
.PP
Do not strcmp the \fBkeyName()\fP yourself, because the result differs from simple ascii comparison\&.
.PP
\fBPrecondition\fP
.RS 4
The Keys \fCk1\fP and \fCk2\fP have been properly initialized via \fBkeyNew()\fP or are NULL 
.RE
.PP
\fBInvariant\fP
.RS 4
All parts of the Keys remain unchanged 
.RE
.PP
\fBPostcondition\fP
.RS 4
If the result is 0, \fCk1\fP and \fCk2\fP cannot be used in the same \fBKeySet\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIk1\fP the first \fBKey\fP to be compared 
.br
\fIk2\fP the second \fBKey\fP to be compared
.RE
.PP
\fBReturn values\fP
.RS 4
\fI<0\fP if k1 < k2 
.br
\fI0\fP if k1 == k2 
.br
\fI>0\fP if k1 > k2
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBksAppendKey()\fP, \fBksAppend()\fP will compare Keys via \fBkeyCmp()\fP when appending 
.PP
\fBksLookup()\fP will compare Keys via \fBkeyCmp()\fP during searching
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP <= 0 
.RE
.PP

.SS "\fBKey\fP & kdb::Key::operator= (ckdb::Key * k)\fC [inline]\fP"

.PP
Assign a C key\&. Will call del() on the old key\&. 
.SS "\fBKey\fP & kdb::Key::operator= (const \fBKey\fP & k)\fC [inline]\fP"

.PP
Assign a key\&. Will call del() on the old key\&. 
.SS "bool kdb::Key::operator== (const \fBKey\fP & k) const\fC [inline]\fP"

.PP
Compare the name of two Keys\&. The comparison is based on a memcmp of the \fBKey\fP's names\&. If the names match, the Keys are found to be exactly the same and 0 is returned\&. These two keys can't be used in the same \fBKeySet\fP\&.
.PP
\fBkeyCmp()\fP defines the sorting order for a \fBKeySet\fP\&.
.PP
The following 3 points are the rules for NULL values:
.PP
.IP "\(bu" 2
A NULL pointer will be found to be smaller than every other \fBKey\fP\&. If both are NULL pointers, 0 is returned\&.
.IP "\(bu" 2
A NULL name will be found to be smaller than every other name\&. If both are NULL names, 0 is returned\&.
.PP
.PP
If the name is equal then:
.PP
.IP "\(bu" 2
No owner will be found to be smaller than every other owner\&. If both don't have an owner, 0 is returned\&.
.PP
.PP
\fBNote\fP
.RS 4
the owner will only be used if the names are equal\&.
.RE
.PP
Given any Keys k1 and k2 constructed with \fBkeyNew()\fP, following equation hold true:
.PP
.PP
.nf
       succeed_if (keyCmp (0, 0) == 0, "all null pointers same");
        succeed_if (keyCmp (k1, 0) == 1, "null pointer is smaller");
        succeed_if (keyCmp (0, k2) == -1, "null pointer is smaller");
.fi
.PP
 Here are some more examples: 
.PP
.nf
Key *k1 = keyNew("user:/a", KEY_END);
Key *k2 = keyNew("user:/b", KEY_END);

// keyCmp(k1,k2) < 0
// keyCmp(k2,k1) > 0

.fi
.PP
.PP
Do not strcmp the \fBkeyName()\fP yourself, because the result differs from simple ascii comparison\&.
.PP
\fBPrecondition\fP
.RS 4
The Keys \fCk1\fP and \fCk2\fP have been properly initialized via \fBkeyNew()\fP or are NULL 
.RE
.PP
\fBInvariant\fP
.RS 4
All parts of the Keys remain unchanged 
.RE
.PP
\fBPostcondition\fP
.RS 4
If the result is 0, \fCk1\fP and \fCk2\fP cannot be used in the same \fBKeySet\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIk1\fP the first \fBKey\fP to be compared 
.br
\fIk2\fP the second \fBKey\fP to be compared
.RE
.PP
\fBReturn values\fP
.RS 4
\fI<0\fP if k1 < k2 
.br
\fI0\fP if k1 == k2 
.br
\fI>0\fP if k1 > k2
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBksAppendKey()\fP, \fBksAppend()\fP will compare Keys via \fBkeyCmp()\fP when appending 
.PP
\fBksLookup()\fP will compare Keys via \fBkeyCmp()\fP during searching
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP == 0 
.RE
.PP

.SS "bool kdb::Key::operator> (const \fBKey\fP & other) const\fC [inline]\fP"

.PP
Compare the name of two Keys\&. The comparison is based on a memcmp of the \fBKey\fP's names\&. If the names match, the Keys are found to be exactly the same and 0 is returned\&. These two keys can't be used in the same \fBKeySet\fP\&.
.PP
\fBkeyCmp()\fP defines the sorting order for a \fBKeySet\fP\&.
.PP
The following 3 points are the rules for NULL values:
.PP
.IP "\(bu" 2
A NULL pointer will be found to be smaller than every other \fBKey\fP\&. If both are NULL pointers, 0 is returned\&.
.IP "\(bu" 2
A NULL name will be found to be smaller than every other name\&. If both are NULL names, 0 is returned\&.
.PP
.PP
If the name is equal then:
.PP
.IP "\(bu" 2
No owner will be found to be smaller than every other owner\&. If both don't have an owner, 0 is returned\&.
.PP
.PP
\fBNote\fP
.RS 4
the owner will only be used if the names are equal\&.
.RE
.PP
Given any Keys k1 and k2 constructed with \fBkeyNew()\fP, following equation hold true:
.PP
.PP
.nf
      succeed_if (keyCmp (0, 0) == 0, "all null pointers same");
        succeed_if (keyCmp (k1, 0) == 1, "null pointer is smaller");
        succeed_if (keyCmp (0, k2) == -1, "null pointer is smaller");
.fi
.PP
 Here are some more examples: 
.PP
.nf
Key *k1 = keyNew("user:/a", KEY_END);
Key *k2 = keyNew("user:/b", KEY_END);

// keyCmp(k1,k2) < 0
// keyCmp(k2,k1) > 0

.fi
.PP
.PP
Do not strcmp the \fBkeyName()\fP yourself, because the result differs from simple ascii comparison\&.
.PP
\fBPrecondition\fP
.RS 4
The Keys \fCk1\fP and \fCk2\fP have been properly initialized via \fBkeyNew()\fP or are NULL 
.RE
.PP
\fBInvariant\fP
.RS 4
All parts of the Keys remain unchanged 
.RE
.PP
\fBPostcondition\fP
.RS 4
If the result is 0, \fCk1\fP and \fCk2\fP cannot be used in the same \fBKeySet\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIk1\fP the first \fBKey\fP to be compared 
.br
\fIk2\fP the second \fBKey\fP to be compared
.RE
.PP
\fBReturn values\fP
.RS 4
\fI<0\fP if k1 < k2 
.br
\fI0\fP if k1 == k2 
.br
\fI>0\fP if k1 > k2
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBksAppendKey()\fP, \fBksAppend()\fP will compare Keys via \fBkeyCmp()\fP when appending 
.PP
\fBksLookup()\fP will compare Keys via \fBkeyCmp()\fP during searching
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP > 0 
.RE
.PP

.SS "bool kdb::Key::operator>= (const \fBKey\fP & other) const\fC [inline]\fP"

.PP
Compare the name of two Keys\&. The comparison is based on a memcmp of the \fBKey\fP's names\&. If the names match, the Keys are found to be exactly the same and 0 is returned\&. These two keys can't be used in the same \fBKeySet\fP\&.
.PP
\fBkeyCmp()\fP defines the sorting order for a \fBKeySet\fP\&.
.PP
The following 3 points are the rules for NULL values:
.PP
.IP "\(bu" 2
A NULL pointer will be found to be smaller than every other \fBKey\fP\&. If both are NULL pointers, 0 is returned\&.
.IP "\(bu" 2
A NULL name will be found to be smaller than every other name\&. If both are NULL names, 0 is returned\&.
.PP
.PP
If the name is equal then:
.PP
.IP "\(bu" 2
No owner will be found to be smaller than every other owner\&. If both don't have an owner, 0 is returned\&.
.PP
.PP
\fBNote\fP
.RS 4
the owner will only be used if the names are equal\&.
.RE
.PP
Given any Keys k1 and k2 constructed with \fBkeyNew()\fP, following equation hold true:
.PP
.PP
.nf
     succeed_if (keyCmp (0, 0) == 0, "all null pointers same");
        succeed_if (keyCmp (k1, 0) == 1, "null pointer is smaller");
        succeed_if (keyCmp (0, k2) == -1, "null pointer is smaller");
.fi
.PP
 Here are some more examples: 
.PP
.nf
Key *k1 = keyNew("user:/a", KEY_END);
Key *k2 = keyNew("user:/b", KEY_END);

// keyCmp(k1,k2) < 0
// keyCmp(k2,k1) > 0

.fi
.PP
.PP
Do not strcmp the \fBkeyName()\fP yourself, because the result differs from simple ascii comparison\&.
.PP
\fBPrecondition\fP
.RS 4
The Keys \fCk1\fP and \fCk2\fP have been properly initialized via \fBkeyNew()\fP or are NULL 
.RE
.PP
\fBInvariant\fP
.RS 4
All parts of the Keys remain unchanged 
.RE
.PP
\fBPostcondition\fP
.RS 4
If the result is 0, \fCk1\fP and \fCk2\fP cannot be used in the same \fBKeySet\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIk1\fP the first \fBKey\fP to be compared 
.br
\fIk2\fP the second \fBKey\fP to be compared
.RE
.PP
\fBReturn values\fP
.RS 4
\fI<0\fP if k1 < k2 
.br
\fI0\fP if k1 == k2 
.br
\fI>0\fP if k1 > k2
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBksAppendKey()\fP, \fBksAppend()\fP will compare Keys via \fBkeyCmp()\fP when appending 
.PP
\fBksLookup()\fP will compare Keys via \fBkeyCmp()\fP during searching
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP >= 0 
.RE
.PP

.SS "ckdb::Key * kdb::Key::release ()\fC [inline]\fP"

.PP
Passes out the raw key pointer and resets internal key handle\&. 
.PP
\fBNote\fP
.RS 4
that the ownership is moved outside\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP if no key is held (null pointer), no action is done then\&. 
.RE
.PP

.SS "template<class T > void kdb::Key::set (T x)\fC [inline]\fP"

.PP
Set a key value\&. Set the value for \fCkey\fP as \fCnewStringValue\fP\&. The function will allocate and save a private copy of \fCnewStringValue\fP, so the parameter can be freed after the call\&.
.PP
String values will be saved in backend storage in UTF-8 universal encoding, regardless of the program's current encoding (if the iconv plugin is available)\&.
.PP
\fBPrecondition\fP
.RS 4
\fCnewStringValue\fP is a NULL terminated string 
.RE
.PP
\fBPostcondition\fP
.RS 4
Value of the \fBKey\fP is set to the UTF-8 encoded value of \fCnewStringValue\fP 
.PP
Metakey \fCmeta:/binary\fP is cleared
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP for which to set the string value 
.br
\fInewStringValue\fP NULL-terminated string to be set as \fCkey's\fP value
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes actually saved in private struct including final NULL 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if \fCnewStringValue\fP is a NULL pointer, this will make the string empty (string only containing null termination) 
.br
\fI-1\fP if \fCkey\fP is a NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyString()\fP for getting a pointer to the \fBKey\fP's value 
.PP
\fBkeyGetString()\fP for getting a \fBcopy\fP of the \fBKey\fP's value 
.PP
\fBkeySetBinary()\fP for setting binary data
.RE
.PP
This method tries to deserialise the string to the given type\&. 
.SS "void kdb::Key::setBaseName (const std::string & baseName)\fC [inline]\fP"

.PP
Sets a base name for a key\&. Sets \fCbaseName\fP as the new basename for \fCkey\fP\&. Only the basename of the \fBKey\fP will be affected\&.
.PP
A simple example is: 
.PP
.nf
Key * k = keyNew ("user:/my/long/name", KEY_END);
keySetBaseName (k, "myname");
printf ("%s\n", keyName (k)); // will print user:/my/long/myname
keyDel (k);

.fi
.PP
 All text after the last \fC'/'\fP in the \fBKey\fP's name is erased and \fCbaseName\fP is appended\&. If \fCbaseName\fP is 0 (NULL), then the last part of the \fBKey\fP's name is removed without replacement\&. The root name of the \fBKey\fP will not be removed though\&.
.PP
Let us suppose \fCkey\fP has name \fC'system:/dir1/dir2/key1'\fP\&. If \fCbaseName\fP is \fC'key2'\fP, the resulting key name will be \fC'system:/dir1/dir2/key2'\fP\&. If \fCbaseName\fP is 0 (NULL), the resulting key name will be \fC'system:/dir1/dir2'\fP\&. If \fCbaseName\fP is empty, the resulting key name will be \fC'system:/dir1/dir2/%'\fP, where \fC'%'\fP denotes an empty base name, as also shown in the following code:
.PP
.PP
.nf
        keySetName (k, "system:/valid");
        keySetBaseName (k, "");
        succeed_if_same_string (keyName (k), "system:/%");
        succeed_if_same_string (keyBaseName (k), "");
.fi
.PP
 \fBkeySetBaseName()\fP does proper escaping on the supplied name argument\&.
.PP
You can use character sequences as \fCbaseName\fP (e\&.g\&. \fC'\&.'\fP (dot), \fC'\&.\&.'\fP (dot-dot), \fC'%'\fP (empty basename))\&. They will be properly escaped and will not have their usual meaning\&.
.PP
If you want to add to the basename instead of changing it, use \fBkeyAddBaseName()\fP\&. If you do not want any escaping, use \fBkeyAddName()\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP whose basename to set 
.br
\fIbaseName\fP the new basename for the \fBKey\fP
.RE
.PP
\fBReturns\fP
.RS 4
the size in bytes of the new key name 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP if \fBKey\fP is NULL 
.br
\fI-1\fP if \fBKey\fP was inserted into \fBKeySet\fP before 
.br
\fI-1\fP if \fBKey\fP is read-only 
.br
\fI-1\fP on allocation errors
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyAddBaseName()\fP for adding a basename instead of changing it 
.PP
\fBkeyAddName()\fP for adding a name without escaping 
.PP
\fBkeySetName()\fP for setting a completely new name 
.PP
\fBName Manipulation Methods\fP for more details on special names
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyInvalidName\fP if the name is not valid 
.RE
.PP

.SS "ssize_t kdb::Key::setBinary (const void * newBinary, size_t dataSize)\fC [inline]\fP"

.PP
Set the value of a \fBKey\fP to the binary value \fCnewBinary\fP\&. A private copy of \fCnewBinary\fP will be allocated and saved inside \fCkey\fP, so the parameter can be deallocated after the call\&.
.PP
Binary values might be encoded in another way than string values depending on the plugin\&. Typically character encodings should not take place on binary data\&. Consider using a string \fBKey\fP instead, if encoding should occur\&.
.PP
When \fCnewBinary\fP is a NULL pointer the value will be freed and 0 will be returned\&.
.PP
Read-only keys will stay unchanged after calling this function\&.
.PP
\fBNote\fP
.RS 4
The metadata 'binary' will be set to mark that the key is binary from now on\&. When the \fBKey\fP is already binary the metadata won't be changed\&. This will only happen in the successful case, but not when -1 is returned\&.
.RE
.PP
\fBPrecondition\fP
.RS 4
\fCdataSize\fP matches the length of \fCnewBinary\fP 
.PP
\fCnewBinary\fP is not NULL and \fCdataSize\fP > 0 
.PP
\fCkey\fP is not read-only 
.RE
.PP
\fBPostcondition\fP
.RS 4
\fCkey's\fP value set exactly to the data in \fCnewBinary\fP 
.PP
'binary' key set in \fCkey's\fP metadata
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP object where the value should be set 
.br
\fInewBinary\fP a pointer to any binary data or NULL (to clear the stored value) 
.br
\fIdataSize\fP number of bytes to copy from \fCnewBinary\fP 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes actually copied to internal struct storage 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP when the internal binary was freed and is now a null pointer 
.br
\fI-1\fP if \fCkey\fP is NULL 
.br
\fI-1\fP when \fCdataSize\fP is 0 (and newBinary not NULL) or larger than SSIZE_MAX 
.br
\fI-1\fP if \fCkey\fP is read-only
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetBinary()\fP for getting a \fBKey\fP's value as binary 
.PP
\fBkeyIsBinary()\fP to check if the \fBKey\fP's value is binary 
.PP
\fBkeyGetString()\fP and \fBkeySetString()\fP for working with string values 
.RE
.PP

.SS "template<class T > void kdb::Key::setMeta (const std::string & metaName, T x)\fC [inline]\fP"

.PP
Set metadata for key\&. Set a new metadata \fBKey\fP\&. Will set a new metadata pair with name \fCmetaName\fP and value \fCnewMetaString\fP\&.
.PP
Will add a new metadata \fBKey\fP, if \fCmetaName\fP was unused until now\&.
.PP
It will modify an existing Pair of metadata if \fCmetaName\fP was already present\&.
.PP
It will remove a metadata \fBKey\fP if \fCnewMetaString\fP is 0\&.
.PP
If \fCmetaName\fP does not start with 'meta:/', it will be prefixed with 'meta:/'\&.
.PP
\fBPrecondition\fP
.RS 4
\fCmetaName\fP is prefixed with 'meta:/' 
.PP
\fCkey's\fP metadata is not read-only 
.RE
.PP
\fBPostcondition\fP
.RS 4
The value in \fCkey's\fP metadata Keyset for \fCmetaName\fP is \fCnewMetaString\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP \fBKey\fP whose metadata should be set 
.br
\fImetaName\fP name of the metadata \fBKey\fP that should be set 
.br
\fInewMetaString\fP new value for the metadata \fBKey\fP
.RE
.PP
\fBReturns\fP
.RS 4
size (>0) of \fCnewMetaString\fP if metadata has been successfully added 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI0\fP if the meta-information for metaName was removed 
.br
\fI-1\fP if key or metaName is 0 
.br
\fI-1\fP if system is out of memory 
.br
\fI-1\fP if \fCmetaName\fP is not a valid metadata name
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetMeta()\fP for getting the value of a metadata \fBKey\fP 
.PP
\fBkeyMeta()\fP for getting the \fBKeySet\fP containing metadata
.RE
.PP
\fBWarning\fP
.RS 4
unlike the C Interface, it is not possible to remove metadata with this method\&. k\&.setMeta('something', NULL) will lead to set the number 0 or to something different (may depend on compiler definition of NULL)\&. See discussion in Issue https://github.com/ElektraInitiative/libelektra/issues/8
.RE
.PP
Use \fBdelMeta()\fP to avoid these issues\&.
.PP
\fBSee also\fP
.RS 4
\fBdelMeta()\fP, \fBgetMeta()\fP, \fBcopyMeta()\fP, \fBcopyAllMeta()\fP 
.RE
.PP

.SS "void kdb::Key::setName (const std::string & newName)\fC [inline]\fP"

.PP
Set a new name to a \fBKey\fP\&. A valid name is one of the forms:
.IP "\(bu" 2
\fCspec:/something\fP for specification of other keys\&.
.IP "\(bu" 2
\fCproc:/something\fP for in-memory keys, e\&.g\&. commandline\&.
.IP "\(bu" 2
\fCdir:/something\fP for dir keys in current working directory
.IP "\(bu" 2
\fCsystem:/something\fP for system keys in /etc or /
.IP "\(bu" 2
\fCuser:/something\fP for user keys in home directory
.IP "\(bu" 2
\fCuser:username/something\fP for other users (deprecated: \fBkdbGet()\fP + \fBkdbSet()\fP currently unsupported)
.IP "\(bu" 2
\fC/something\fP for cascading keys (actually refers to one of the above, see also \fBksLookup()\fP)
.PP
.PP
An invalid name either has an invalid namespace or a wrongly escaped \\ at the end of the name\&.
.PP
See \fBkey names \fP for the exact rules\&.
.PP
The last form has explicitly set the owner, to let the library know in which user folder to save the \fBKey\fP\&. A owner is a user name\&. If it is not defined (the second form), current user is used\&.
.PP
You should always follow the guidelines for \fBKey\fP tree structure creation\&.
.PP
A private copy of the \fBKey\fP name will be stored, and the \fCnewName\fP parameter can be freed after this call\&.
.PP
\&.\&., \&. and / will be handled as in filesystem paths\&. A valid name will be build out of the (valid) name what you pass, e\&.g\&. user:///sw/\&.\&./sw//\&./\&./MyApp -> user:/sw/MyApp
.PP
Trailing slashes will be stripped\&.
.PP
On invalid names, the name stays unchanged\&.
.PP
\fBReturns\fP
.RS 4
size of the new \fBKey\fP name in bytes, including NULL terminator 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI-1\fP if \fCkey\fP or \fCkeyName\fP is NULL or \fCkeyName\fP is empty or invalid 
.br
\fI-1\fP if \fBKey\fP was inserted to a \fBKeySet\fP before 
.br
\fI-1\fP if \fBKey\fP name is read-only
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP whose name to set 
.br
\fInewName\fP the new name for the \fBKey\fP
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyGetName()\fP for getting a \fBcopy\fP of the \fBKey\fP's name 
.PP
\fBkeyName()\fP for getting a pointer to the \fBKey\fP's name 
.PP
\fBkeySetBaseName()\fP, \fBkeyAddBaseName()\fP for manipulating the base name
.RE
.PP
\fBExceptions\fP
.RS 4
\fIKeyInvalidName\fP if the name is not valid 
.RE
.PP

.SS "ssize_t kdb::Key::setNamespace (ElektraNamespace ns) const\fC [inline]\fP"

.PP
Set the namespace of the key\&. 
.PP
\fBSee also\fP
.RS 4
ElektraNamespace, \fBkeySetNamespace\fP 
.RE
.PP

.SS "void kdb::Key::setString (const char * newString)\fC [inline]\fP"

.PP
Set the value for \fCkey\fP as \fCnewStringValue\fP\&. The function will allocate and save a private copy of \fCnewStringValue\fP, so the parameter can be freed after the call\&.
.PP
String values will be saved in backend storage in UTF-8 universal encoding, regardless of the program's current encoding (if the iconv plugin is available)\&.
.PP
\fBPrecondition\fP
.RS 4
\fCnewStringValue\fP is a NULL terminated string 
.RE
.PP
\fBPostcondition\fP
.RS 4
Value of the \fBKey\fP is set to the UTF-8 encoded value of \fCnewStringValue\fP 
.PP
Metakey \fCmeta:/binary\fP is cleared
.RE
.PP
\fBParameters\fP
.RS 4
\fIkey\fP the \fBKey\fP for which to set the string value 
.br
\fInewStringValue\fP NULL-terminated string to be set as \fCkey's\fP value
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes actually saved in private struct including final NULL 
.RE
.PP
\fBReturn values\fP
.RS 4
\fI1\fP if \fCnewStringValue\fP is a NULL pointer, this will make the string empty (string only containing null termination) 
.br
\fI-1\fP if \fCkey\fP is a NULL pointer
.RE
.PP
\fBSince\fP
.RS 4
1\&.0\&.0
.RE
.PP
\fBSee also\fP
.RS 4
\fBkeyString()\fP for getting a pointer to the \fBKey\fP's value 
.PP
\fBkeyGetString()\fP for getting a \fBcopy\fP of the \fBKey\fP's value 
.PP
\fBkeySetBinary()\fP for setting binary data 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Elektra from the source code\&.
