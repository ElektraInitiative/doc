<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Elektra: Meta Info Manipulation Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Meta Info Manipulation Methods</div>  </div>
<div class="ingroups"><a class="el" href="group__key.html">Key</a></div></div><!--header-->
<div class="contents">

<p>Methods to do various operations on Key metainfo.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Meta Info Manipulation Methods:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__keymeta.png" border="0" alt="" usemap="#group____keymeta"/>
<map name="group____keymeta" id="group____keymeta">
<area shape="rect" id="node1" href="group__key.html" title="A Key is the essential class that encapsulates key name , value &#160;and metainfo ." alt="" coords="7,13,49,41"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5dbb669802eea27e106ee3a5e39717a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">keyRewindMeta</a> (Key *key)</td></tr>
<tr class="separator:ga5dbb669802eea27e106ee3a5e39717a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c88342f580a4291455a801af71ce048"><td class="memItemLeft" align="right" valign="top">const Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (Key *key)</td></tr>
<tr class="separator:ga4c88342f580a4291455a801af71ce048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a273f529030f4947df52e14fdd2869"><td class="memItemLeft" align="right" valign="top">const Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869">keyCurrentMeta</a> (const Key *key)</td></tr>
<tr class="separator:ga74a273f529030f4947df52e14fdd2869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a22b992478e613c8788bd460b4a1f0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a> (Key *dest, const Key *source, const char *metaName)</td></tr>
<tr class="separator:ga9a22b992478e613c8788bd460b4a1f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e63720a65610a29597494d0671f9401"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a> (Key *dest, const Key *source)</td></tr>
<tr class="separator:ga8e63720a65610a29597494d0671f9401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed3875495ddb3d8a8d29158a60a147c"><td class="memItemLeft" align="right" valign="top">const Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta</a> (const Key *key, const char *metaName)</td></tr>
<tr class="separator:ga9ed3875495ddb3d8a8d29158a60a147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f15546b234ffb6007d8a31178652b9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a> (Key *key, const char *metaName, const char *newMetaString)</td></tr>
<tr class="separator:gae1f15546b234ffb6007d8a31178652b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa5060e67b03f50ae49a3620c54bc46"><td class="memItemLeft" align="right" valign="top">uid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#gacaa5060e67b03f50ae49a3620c54bc46">keyGetUID</a> (const Key *key)</td></tr>
<tr class="separator:gacaa5060e67b03f50ae49a3620c54bc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f284f5ecd261e0a290095f50ba1af7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#gab5f284f5ecd261e0a290095f50ba1af7">keySetUID</a> (Key *key, uid_t uid)</td></tr>
<tr class="separator:gab5f284f5ecd261e0a290095f50ba1af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a95e81d7d7f4e3eb59e60e5f3738c0"><td class="memItemLeft" align="right" valign="top">gid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga46a95e81d7d7f4e3eb59e60e5f3738c0">keyGetGID</a> (const Key *key)</td></tr>
<tr class="separator:ga46a95e81d7d7f4e3eb59e60e5f3738c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e3d0fb3f7ba906e067727b9155d22e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga9e3d0fb3f7ba906e067727b9155d22e3">keySetGID</a> (Key *key, gid_t gid)</td></tr>
<tr class="separator:ga9e3d0fb3f7ba906e067727b9155d22e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae575bd86a628a15ee45baa860522e75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#gaae575bd86a628a15ee45baa860522e75">keySetDir</a> (Key *key)</td></tr>
<tr class="separator:gaae575bd86a628a15ee45baa860522e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0cec592ce3b77e9bc33dbc8e8f6bdc"><td class="memItemLeft" align="right" valign="top">mode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#gabc0cec592ce3b77e9bc33dbc8e8f6bdc">keyGetMode</a> (const Key *key)</td></tr>
<tr class="separator:gabc0cec592ce3b77e9bc33dbc8e8f6bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8803037e35b9da1ce492323a88ff6bc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga8803037e35b9da1ce492323a88ff6bc3">keySetMode</a> (Key *key, mode_t mode)</td></tr>
<tr class="separator:ga8803037e35b9da1ce492323a88ff6bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b05da399c3c78904969ef39f191b0eb"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga6b05da399c3c78904969ef39f191b0eb">keyGetATime</a> (const Key *key)</td></tr>
<tr class="separator:ga6b05da399c3c78904969ef39f191b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995d8b84731673c88c7c01f3fed538b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga995d8b84731673c88c7c01f3fed538b9">keySetATime</a> (Key *key, time_t atime)</td></tr>
<tr class="separator:ga995d8b84731673c88c7c01f3fed538b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57689eb5691679071463b777ae786ae9"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga57689eb5691679071463b777ae786ae9">keyGetMTime</a> (const Key *key)</td></tr>
<tr class="separator:ga57689eb5691679071463b777ae786ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481d8997187992fe4bbf288bc8ef4db7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga481d8997187992fe4bbf288bc8ef4db7">keySetMTime</a> (Key *key, time_t mtime)</td></tr>
<tr class="separator:ga481d8997187992fe4bbf288bc8ef4db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c213c120cbe02201278ef7fb8cd94be"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga2c213c120cbe02201278ef7fb8cd94be">keyGetCTime</a> (const Key *key)</td></tr>
<tr class="separator:ga2c213c120cbe02201278ef7fb8cd94be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f502ecab8ab43f0b17220fcc95f3fa5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keymeta.html#ga9f502ecab8ab43f0b17220fcc95f3fa5">keySetCTime</a> (Key *key, time_t ctime)</td></tr>
<tr class="separator:ga9f502ecab8ab43f0b17220fcc95f3fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Methods to do various operations on Key metainfo. </p>
<p>To use them: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kdb.h&gt;</span></div>
</div><!-- fragment --><p>Next to <a class="el" href="group__keyname.html">Name (key and owner) </a> and <a class="el" href="group__keyvalue.html">Value (data and comment) </a> there is the so called meta information inside every key.</p>
<p>Key meta information are an unlimited number of key/value pairs strongly related to a key. It main purpose is to give keys special semantics, so that plugins can treat them differently.</p>
<p>File system information (see stat(2) for more information):</p>
<ul>
<li>uid: the user id (positive number)</li>
<li>gid: the group id (positive number)</li>
<li>mode: filesystem-like mode permissions (positive octal number)</li>
<li>atime: When was the key accessed the last time.</li>
<li>mtime: When was the key modified the last time.</li>
<li>ctime: When the uid, gid or mode of a key changes. (times are represented through a positive number as unix timestamp)</li>
</ul>
<p>The comment can contain userdata which directly belong to that key. The name of the meta information is "comment" for a general purpose comment about the key. Multi-Language comments are also supported by appending [LANG] to the name.</p>
<p>Validators are regular expressions which are tested against the key value. The metakey "validator" can hold a regular expression which will be matched against.</p>
<p>Types can be expressed with the meta information "type".</p>
<p>The relevance of the key can be tagged with a value from -20 to 20. Negative numbers are the more important and must be present in order to start the program.</p>
<p>A version of a key may be stored with "version". Its format is full.major.minor where all of these are integers.</p>
<p>The order inside a persistent storage can be described with the tag "order" which contains a positive number.</p>
<p>The meta key "app" describes to which application a key belongs. It can be used to remove keys from an application no longer installed.</p>
<p>The meta key "path" describes where the key is physically stored.</p>
<p>The "owner" is the user that owns the key. It only works for the user/ hierarchy. It rather says where the key is stored and says nothing about the filesystem properties. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8e63720a65610a29597494d0671f9401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keyCopyAllMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a shallow copy of all meta data from source to dest.</p>
<p>The key dest will additionally have all meta data source had. Meta data not present in source will not be changed. Meta data which was present in source and dest will be overwritten.</p>
<p>For example the meta data type is copied into the Key k.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> l(Key *k)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// receive c</span></div>
<div class="line">        <a class="code" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a>(k, c);</div>
<div class="line">        <span class="comment">// the caller will see the changed key k</span></div>
<div class="line">        <span class="comment">// with all the metadata from c</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The main purpose of this function is for plugins or applications which want to add the same meta data to n keys. When you do that with <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta()</a> it will take n times the memory for the key. This can be considerable amount of memory for many keys with some meta data for each.</p>
<p>To avoid that problem you can use <a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta()</a> or <a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> o(KeySet *ks)</div>
<div class="line">{</div>
<div class="line">        Key *current;</div>
<div class="line">        Key *shared = <a class="code" href="group__key.html#gaf6893c038b3ebee90c73a9ea8356bebf">keyNew</a> (0);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared1&quot;</span>, <span class="stringliteral">&quot;this meta data should be shared among many keys&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared2&quot;</span>, <span class="stringliteral">&quot;this meta data should be shared among many keys also&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared3&quot;</span>, <span class="stringliteral">&quot;this meta data should be shared among many keys too&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a>(ks);</div>
<div class="line">        <span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a>(ks)) != 0)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (needs_shared_data(current)) <a class="code" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a>(current, shared);</div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section post"><dt>Postcondition</dt><dd>for every metaName present in source: keyGetMeta(source, metaName) == keyGetMeta(dest, metaName)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if was successfully copied </dd>
<dd>
0 if source did not have any meta data </dd>
<dd>
-1 on null pointers (source or dest) </dd>
<dd>
-1 on memory problems </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination where the meta data should be copied too </td></tr>
    <tr><td class="paramname">source</td><td>the key where the meta data should be copied from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9a22b992478e613c8788bd460b4a1f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keyCopyMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a shallow copy of meta data from source to dest.</p>
<p>The key dest will have the same meta data referred with metaName afterwards then source.</p>
<p>For example the meta data type is copied into the Key k.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> l(Key *k)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// receive c</span></div>
<div class="line">        <a class="code" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a>(k, c, <span class="stringliteral">&quot;type&quot;</span>);</div>
<div class="line">        <span class="comment">// the caller will see the changed key k</span></div>
<div class="line">        <span class="comment">// with the metadata &quot;type&quot; from c</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The main purpose of this function is for plugins or applications which want to add the same meta data to n keys. When you do that with <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta()</a> it will take n times the memory for the key. This can be considerable amount of memory for many keys with some meta data for each.</p>
<p>To avoid that problem you can use <a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta()</a> or <a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> o(KeySet *ks)</div>
<div class="line">{</div>
<div class="line">        Key *current;</div>
<div class="line">        Key *shared = <a class="code" href="group__key.html#gaf6893c038b3ebee90c73a9ea8356bebf">keyNew</a> (0);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared&quot;</span>, <span class="stringliteral">&quot;this meta data should be shared among many keys&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a>(ks);</div>
<div class="line">        <span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a>(ks)) != 0)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (needs_shared_data(current)) <a class="code" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a>(current, shared, <span class="stringliteral">&quot;shared&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section post"><dt>Postcondition</dt><dd>keyGetMeta(source, metaName) == keyGetMeta(dest, metaName)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1 if was successfully copied </dd>
<dd>
0 if the meta data in dest was removed too </dd>
<dd>
-1 on null pointers (source or dest) </dd>
<dd>
-1 on memory problems </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination where the meta data should be copied too </td></tr>
    <tr><td class="paramname">source</td><td>the key where the meta data should be copied from </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the meta data which should be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga74a273f529030f4947df52e14fdd2869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Key* keyCurrentMeta </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Value of a Meta-Information which is current.</p>
<p>The pointer is NULL if you reached the end or after <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer to the value pointed by <code>key's</code> cursor </dd>
<dd>
0 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a>, <a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">keyRewindMeta()</a></dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent()</a> for pedant in iterator interface of KeySet </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b05da399c3c78904969ef39f191b0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t keyGetATime </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get last time the key data was read from disk.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>Every <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a> might update the access time of a key. You get information when the key was read the last time from the database.</p>
<p>You will get 0 when the key was not read already.</p>
<p>Beware that multiple copies of keys with <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3">keyDup()</a> might have different atimes because you <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a> one, but not the other. You can use this information to decide which key is the latest.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to get information from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time you got the key with <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a> </dd>
<dd>
0 on key that was never <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a> </dd>
<dd>
(time_t)-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga995d8b84731673c88c7c01f3fed538b9">keySetATime()</a> </dd>
<dd>
<a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c213c120cbe02201278ef7fb8cd94be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t keyGetCTime </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get last time the key metadata was changed from disk.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>You will get 0 when the key was not read already.</p>
<p>Any changed field in metadata will influence the ctime of a key.</p>
<p>This time is not updated if only value or comment are changed.</p>
<p>Not changed keys will not update this time, even after <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a>.</p>
<p>It is possible that other keys written to disc influence this time if the backend is not grained enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to get information from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga9f502ecab8ab43f0b17220fcc95f3fa5">keySetCTime()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>(time_t)-1 on NULL pointer </dd>
<dd>
the metadata change time </dd></dl>

</div>
</div>
<a class="anchor" id="ga46a95e81d7d7f4e3eb59e60e5f3738c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gid_t keyGetGID </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the group ID of a key.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<h1><a class="anchor" id="GID"></a>
GID</h1>
<p>The group ID is a unique identification for every group present on a system. Keys will belong to root (0) as long as you did not get their real GID with <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a>.</p>
<p>Unlike UID users might change their group. This makes it possible to share configuration between some users.</p>
<p>A fresh key will have (gid_t)-1 also known as the group nogroup. It means that the key is not related to a group ID at the moment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the system's GID of the key </dd>
<dd>
(gid_t)-1 on NULL key or currently unknown ID </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga9e3d0fb3f7ba906e067727b9155d22e3">keySetGID()</a>, <a class="el" href="group__keymeta.html#gacaa5060e67b03f50ae49a3620c54bc46">keyGetUID()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ed3875495ddb3d8a8d29158a60a147c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Key* keyGetMeta </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Value of a Meta-Information given by name.</p>
<p>This is a much more efficient version of <a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta()</a>. But unlike with keyGetMeta you are not allowed to modify the resulting string.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f(Key *k)</div>
<div class="line">{</div>
<div class="line">        <span class="keywordflow">if</span> (!strcmp(<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(<a class="code" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta</a>(k, <span class="stringliteral">&quot;type&quot;</span>)), <span class="stringliteral">&quot;boolean&quot;</span>))</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// the type of the key is boolean</span></div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the meta information you want the value from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the key or metaName is 0 </dd>
<dd>
0 if no such metaName is found </dd>
<dd>
value of Meta-Information if Meta-Information is found </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta()</a>, <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabc0cec592ce3b77e9bc33dbc8e8f6bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mode_t keyGetMode </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the key mode permissions.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>Default is 0664 (octal) for keys and 0775 for directory keys which used <a class="el" href="group__keymeta.html#gaae575bd86a628a15ee45baa860522e75">keySetDir()</a>.</p>
<p>The defaults are defined with the macros KDB_FILE_MODE and KDB_DIR_MODE.</p>
<p>For more information about the mode permissions see <a class="el" href="group__keymeta.html#mode">Modes</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mode permissions of the key </dd>
<dd>
KDB_FILE_MODE as defaults </dd>
<dd>
(mode_t)-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga8803037e35b9da1ce492323a88ff6bc3">keySetMode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga57689eb5691679071463b777ae786ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t keyGetMTime </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get last modification time of the key on disk.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>You will get 0 when the key was not read already.</p>
<p>Everytime you change value or comment and <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> the key the mtime will be updated. When you <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a> the key, the atime is set appropriate.</p>
<p>Not changed keys may not even passed to kdbSet_backend() so it will not update this time, even after <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a>.</p>
<p>It is possible that other keys written to disc influence this time if the backend is not grained enough.</p>
<p>If you add or remove a key the key thereunder in the hierarchy will update the mtime if written with <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> to disc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to get information from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga481d8997187992fe4bbf288bc8ef4db7">keySetMTime()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the last modification time </dd>
<dd>
(time_t)-1 on NULL pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gacaa5060e67b03f50ae49a3620c54bc46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uid_t keyGetUID </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the user ID of a key.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<h1><a class="anchor" id="UID"></a>
UID</h1>
<p>The user ID is a unique identification for every user present on a system. Keys will belong to root (0) as long as you did not get their real UID with <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a>.</p>
<p>Although usually the same, the UID of a key is not related to its owner.</p>
<p>A fresh key will have no UID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the system's UID of the key </dd>
<dd>
(uid_t)-1 on NULL key </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga46a95e81d7d7f4e3eb59e60e5f3738c0">keyGetGID()</a>, <a class="el" href="group__keymeta.html#gab5f284f5ecd261e0a290095f50ba1af7">keySetUID()</a>, <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c88342f580a4291455a801af71ce048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Key* keyNextMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate to the next meta information.</p>
<p>Keys have an internal cursor that can be reset with <a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">keyRewindMeta()</a>. Every time <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a> is called the cursor is incremented and the new current Name of Meta Information is returned.</p>
<p>You'll get a NULL pointer if the meta information after the end of the Key was reached. On subsequent calls of <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a> it will still return the NULL pointer.</p>
<p>The <code>key</code> internal cursor will be changed, so it is not const.</p>
<dl class="section note"><dt>Note</dt><dd>That the resulting key is guaranteed to have a value, because meta information has no binary or null pointer semantics.</dd>
<dd>
You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a key representing meta information </dd>
<dd>
0 when the end is reached </dd>
<dd>
0 on NULL pointer</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext()</a> for pedant in iterator interface of KeySet </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dbb669802eea27e106ee3a5e39717a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keyRewindMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rewind the internal iterator to first meta data.</p>
<p>Use it to set the cursor to the beginning of the Key Meta Infos. <a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869">keyCurrentMeta()</a> will then always return NULL afterwards. So you want to <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a> first.</p>
<div class="fragment"><div class="line">Key *key;</div>
<div class="line"><span class="keyword">const</span> Key *meta;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">keyRewindMeta</a> (key);</div>
<div class="line"><span class="keywordflow">while</span> ((meta = <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (key))!=0)</div>
<div class="line">{</div>
<div class="line">        printf (<span class="stringliteral">&quot;name: %s, value: %s&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(meta), (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(meta));</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
0 if there is no meta information for that key (<a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a> will always return 0 in that case) </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta()</a>, <a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869">keyCurrentMeta()</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind()</a> for pedant in iterator interface of KeySet </dd></dl>

</div>
</div>
<a class="anchor" id="ga995d8b84731673c88c7c01f3fed538b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetATime </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>atime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the atime information for a key.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>When you do manual sync of keys you might also update the atime to make them indistinguishable.</p>
<p>It can also be useful if you work with keys not using a keydatabase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key object to work with </td></tr>
    <tr><td class="paramname">atime</td><td>The new access time for the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga6b05da399c3c78904969ef39f191b0eb">keyGetATime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f502ecab8ab43f0b17220fcc95f3fa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetCTime </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>ctime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the ctime information for a key.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key object to work with </td></tr>
    <tr><td class="paramname">ctime</td><td>The new change metadata time for the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga2c213c120cbe02201278ef7fb8cd94be">keyGetCTime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaae575bd86a628a15ee45baa860522e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetDir </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set mode so that key will be recognized as directory.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>The function will add all executable bits.</p>
<ul>
<li>Mode 0200 will be translated to 0311</li>
<li>Mode 0400 will be translated to 0711</li>
<li>Mode 0664 will be translated to 0775</li>
</ul>
<p>The macro KDB_DIR_MODE (defined to 0111) will be used for that.</p>
<p>The executable bits show that child keys are allowed and listable. There is no way to have child keys which are not listable for anyone, but it is possible to restrict listing the keys to the owner only.</p>
<ul>
<li>Mode 0000 means that it is a key not read or writable to anyone.</li>
<li>Mode 0111 means that it is a directory not read or writable to anyone. But it is recognized as directory to anyone.</li>
</ul>
<p>For more about mode see <a class="el" href="group__keymeta.html#ga8803037e35b9da1ce492323a88ff6bc3">keySetMode()</a>.</p>
<p>It is not possible to access keys below a not executable key. If a key is not writeable and executable <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> will fail to access the keys below. If a key is not readable and executable <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a> will fail to access the keys below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to set permissions to be recognized as directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL pointer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga8803037e35b9da1ce492323a88ff6bc3">keySetMode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e3d0fb3f7ba906e067727b9155d22e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetGID </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the group ID of a key.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>See <a class="el" href="group__keymeta.html#GID">GID</a> for more information about group IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">gid</td><td>is the group ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL key </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga46a95e81d7d7f4e3eb59e60e5f3738c0">keyGetGID()</a>, <a class="el" href="group__keymeta.html#gab5f284f5ecd261e0a290095f50ba1af7">keySetUID()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae1f15546b234ffb6007d8a31178652b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t keySetMeta </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>metaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newMetaString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a new Meta-Information.</p>
<p>Will set a new Meta-Information pair consisting of metaName and newMetaString.</p>
<p>Will add a new Pair for Meta-Information if metaName was not added up to now.</p>
<p>It will modify a existing Pair of Meta-Information if the the metaName was inserted already.</p>
<p>It will remove a meta information if newMetaString is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the meta information where you want to change the value </td></tr>
    <tr><td class="paramname">newMetaString</td><td>the new value for the meta information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error if key or metaName is 0, out of memory or names are not valid </dd>
<dd>
0 if the Meta-Information for metaName was removed </dd>
<dd>
size (&gt;0) of newMetaString if Meta-Information was successfully added </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8803037e35b9da1ce492323a88ff6bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetMode </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the key mode permissions.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>This API is obsolete. It is only a mapping to keySetMeta(key, "mode", str) which should be prefered.</dd></dl>
<p>The mode consists of 9 individual bits for mode permissions. In the following explanation the octal notation with leading zero will be used.</p>
<p>Default is 0664 (octal) for keys and 0775 for directory keys which used <a class="el" href="group__keymeta.html#gaae575bd86a628a15ee45baa860522e75">keySetDir()</a>.</p>
<p>The defaults are defined with the macros KDB_FILE_MODE and KDB_DIR_MODE.</p>
<dl class="section note"><dt>Note</dt><dd>libelektra 0.7.0 only allows 0775 (directory keys) and 0664 (other keys). More will be added later in a sense of the description below.</dd></dl>
<h1><a class="anchor" id="mode"></a>
Modes</h1>
<p>0000 is the most restrictive mode. No user might read, write or execute the key.</p>
<p>Reading the key means to get the value by <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way, all other kdbGet() Functions rely on that one...">kdbGet()</a>.</p>
<p>Writing the key means to set the value by <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a>.</p>
<p>Execute the key means to make a step deeper in the hierarchy. But you must be able to read the key to be able to list the keys below. See also <a class="el" href="group__keymeta.html#gaae575bd86a628a15ee45baa860522e75">keySetDir()</a> in that context. But you must be able to write the key to be able to add or remove keys below.</p>
<p>0777 is the most relaxing mode. Every user is allowed to read, write and execute the key, if he is allowed to execute and read all keys below.</p>
<p>0700 allows every action for the current user, identified by the uid. See <a class="el" href="group__keymeta.html#gacaa5060e67b03f50ae49a3620c54bc46">keyGetUID()</a> and <a class="el" href="group__keymeta.html#gab5f284f5ecd261e0a290095f50ba1af7">keySetUID()</a>.</p>
<p>To be more specific for the user the single bits can elect the mode for read, write and execute. 0100 only allows executing which gives the information that it is a directory for that user, but not accessable. 0200 only allows reading. This information may be combined to 0300, which allows execute and reading of the directory. Last 0400 decides about the writing permissions.</p>
<p>The same as above is also valid for the 2 other octal digits. 0070 decides about the group permissions, in that case full access. Groups are identified by the gid. See <a class="el" href="group__keymeta.html#ga46a95e81d7d7f4e3eb59e60e5f3738c0">keyGetGID()</a> and <a class="el" href="group__keymeta.html#ga9e3d0fb3f7ba906e067727b9155d22e3">keySetGID()</a>. In that example everyone with a different uid, but the gid of the the key, has full access.</p>
<p>0007 decides about the world permissions. This is taken into account when neighter the uid nor the gid matches. So that example would allow everyone with a different uid and gid of that key gains full access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to set mode permissions </td></tr>
    <tr><td class="paramname">mode</td><td>the mode permissions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL key </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#gabc0cec592ce3b77e9bc33dbc8e8f6bdc">keyGetMode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga481d8997187992fe4bbf288bc8ef4db7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetMTime </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>mtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the mtime information for a key.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key object to work with </td></tr>
    <tr><td class="paramname">mtime</td><td>The new modification time for the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga57689eb5691679071463b777ae786ae9">keyGetMTime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab5f284f5ecd261e0a290095f50ba1af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int keySetUID </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>uid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user ID of a key.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This API is obsolete.</dd></dl>
<p>See <a class="el" href="group__keymeta.html#UID">UID</a> for more information about user IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">uid</td><td>the user ID to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-1 on NULL key or conversion error </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__keymeta.html#ga9e3d0fb3f7ba906e067727b9155d22e3">keySetGID()</a>, <a class="el" href="group__keymeta.html#gacaa5060e67b03f50ae49a3620c54bc46">keyGetUID()</a>, <a class="el" href="group__keyname.html#ga35922a017bee8b4bcb493bbdfad9d6f5">keyGetOwner()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 21 2013 18:23:46 for Elektra by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
