<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Elektra: kdb::Key Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.14</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacekdb.html">kdb</a></li><li class="navelem"><a class="el" href="classkdb_1_1Key.html">Key</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">kdb::Key Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> is an essential class that encapsulates key <a class="el" href="group__keyname.html">name </a>, <a class="el" href="group__keyvalue.html">value </a> and <a class="el" href="group__keymeta.html">metainfo </a>.  
 <a href="classkdb_1_1Key.html#details">More...</a></p>

<p><code>#include &lt;key.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5679f5cae63caddd64a60388b9cc77fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> ()</td></tr>
<tr class="memdesc:a5679f5cae63caddd64a60388b9cc77fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty, invalid key.  <a href="#a5679f5cae63caddd64a60388b9cc77fa">More...</a><br /></td></tr>
<tr class="separator:a5679f5cae63caddd64a60388b9cc77fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ada34fa45a270e63444267621b59c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a41ada34fa45a270e63444267621b59c9">Key</a> (ckdb::Key *k)</td></tr>
<tr class="memdesc:a41ada34fa45a270e63444267621b59c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a key out of a C key.  <a href="#a41ada34fa45a270e63444267621b59c9">More...</a><br /></td></tr>
<tr class="separator:a41ada34fa45a270e63444267621b59c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f63e153a7d832a54e02c0cba569feb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a33f63e153a7d832a54e02c0cba569feb">Key</a> (<a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k)</td></tr>
<tr class="memdesc:a33f63e153a7d832a54e02c0cba569feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a reference of another key.  <a href="#a33f63e153a7d832a54e02c0cba569feb">More...</a><br /></td></tr>
<tr class="separator:a33f63e153a7d832a54e02c0cba569feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68da8be743b2f635ff8e28dfaeaaea6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ab68da8be743b2f635ff8e28dfaeaaea6">Key</a> (<a class="el" href="classkdb_1_1Key.html">Key</a> const &amp;k)</td></tr>
<tr class="memdesc:ab68da8be743b2f635ff8e28dfaeaaea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a reference of another key.  <a href="#ab68da8be743b2f635ff8e28dfaeaaea6">More...</a><br /></td></tr>
<tr class="separator:ab68da8be743b2f635ff8e28dfaeaaea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b2e9e1cc323cde05b0d1d3805656e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a15b2e9e1cc323cde05b0d1d3805656e0">Key</a> (const char *<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>,...)</td></tr>
<tr class="memdesc:a15b2e9e1cc323cde05b0d1d3805656e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A practical way to fully create a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object in one step.  <a href="#a15b2e9e1cc323cde05b0d1d3805656e0">More...</a><br /></td></tr>
<tr class="separator:a15b2e9e1cc323cde05b0d1d3805656e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf7642258d46da2c4427f4104cf01ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#acbf7642258d46da2c4427f4104cf01ee">Key</a> (const std::string <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>,...)</td></tr>
<tr class="memdesc:acbf7642258d46da2c4427f4104cf01ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A practical way to fully create a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object in one step.  <a href="#acbf7642258d46da2c4427f4104cf01ee">More...</a><br /></td></tr>
<tr class="separator:acbf7642258d46da2c4427f4104cf01ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dc94c7e676a0d280e5817e4c6238d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aa0dc94c7e676a0d280e5817e4c6238d3">Key</a> (const char *<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>, va_list ap)</td></tr>
<tr class="memdesc:aa0dc94c7e676a0d280e5817e4c6238d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A practical way to fully create a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object in one step.  <a href="#aa0dc94c7e676a0d280e5817e4c6238d3">More...</a><br /></td></tr>
<tr class="separator:aa0dc94c7e676a0d280e5817e4c6238d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f7139c5378b3fde4dfab4955208d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a31f7139c5378b3fde4dfab4955208d23">operator++</a> (int) const </td></tr>
<tr class="memdesc:a31f7139c5378b3fde4dfab4955208d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the viability of a key object.  <a href="#a31f7139c5378b3fde4dfab4955208d23">More...</a><br /></td></tr>
<tr class="separator:a31f7139c5378b3fde4dfab4955208d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab017ed5e104e441d86725f61439d1f24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ab017ed5e104e441d86725f61439d1f24">operator++</a> () const </td></tr>
<tr class="memdesc:ab017ed5e104e441d86725f61439d1f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the viability of a key object.  <a href="#ab017ed5e104e441d86725f61439d1f24">More...</a><br /></td></tr>
<tr class="separator:ab017ed5e104e441d86725f61439d1f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb63da4ab49c66c851228511c000ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#acbb63da4ab49c66c851228511c000ec7">operator--</a> (int) const </td></tr>
<tr class="memdesc:acbb63da4ab49c66c851228511c000ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the viability of a key object.  <a href="#acbb63da4ab49c66c851228511c000ec7">More...</a><br /></td></tr>
<tr class="separator:acbb63da4ab49c66c851228511c000ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa095fe7021b7ca01e6224b976449b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#afa095fe7021b7ca01e6224b976449b3f">operator--</a> () const </td></tr>
<tr class="memdesc:afa095fe7021b7ca01e6224b976449b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the viability of a key object.  <a href="#afa095fe7021b7ca01e6224b976449b3f">More...</a><br /></td></tr>
<tr class="separator:afa095fe7021b7ca01e6224b976449b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213fb46e13b669cc862fce06ac361b79"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a213fb46e13b669cc862fce06ac361b79">getReferenceCounter</a> () const </td></tr>
<tr class="memdesc:a213fb46e13b669cc862fce06ac361b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return how many references the key has.  <a href="#a213fb46e13b669cc862fce06ac361b79">More...</a><br /></td></tr>
<tr class="separator:a213fb46e13b669cc862fce06ac361b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628f3ee543a1d71d4488233018eddd86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a628f3ee543a1d71d4488233018eddd86">operator=</a> (ckdb::Key *k)</td></tr>
<tr class="memdesc:a628f3ee543a1d71d4488233018eddd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a C key.  <a href="#a628f3ee543a1d71d4488233018eddd86">More...</a><br /></td></tr>
<tr class="separator:a628f3ee543a1d71d4488233018eddd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a006c140cfd2a633c6fdf3f9eb9d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a63a006c140cfd2a633c6fdf3f9eb9d1a">operator=</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k)</td></tr>
<tr class="memdesc:a63a006c140cfd2a633c6fdf3f9eb9d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a key.  <a href="#a63a006c140cfd2a633c6fdf3f9eb9d1a">More...</a><br /></td></tr>
<tr class="separator:a63a006c140cfd2a633c6fdf3f9eb9d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bc93e22f4cf40b9d2b1fc32cc260be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ab5bc93e22f4cf40b9d2b1fc32cc260be">copy</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;other)</td></tr>
<tr class="memdesc:ab5bc93e22f4cf40b9d2b1fc32cc260be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy or Clear a key.  <a href="#ab5bc93e22f4cf40b9d2b1fc32cc260be">More...</a><br /></td></tr>
<tr class="separator:ab5bc93e22f4cf40b9d2b1fc32cc260be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a112681b0b2e94e6d369c0f89e361b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a33a112681b0b2e94e6d369c0f89e361b">clear</a> ()</td></tr>
<tr class="memdesc:a33a112681b0b2e94e6d369c0f89e361b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears/Invalidates a key.  <a href="#a33a112681b0b2e94e6d369c0f89e361b">More...</a><br /></td></tr>
<tr class="separator:a33a112681b0b2e94e6d369c0f89e361b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64ec9d578e083dad3e43322535cf108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkdb_1_1Key.html">Key</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ab64ec9d578e083dad3e43322535cf108">operator-&gt;</a> ()</td></tr>
<tr class="separator:ab64ec9d578e083dad3e43322535cf108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81381365a7c159f070e74a7b7bd8688"><td class="memItemLeft" align="right" valign="top">ckdb::Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ae81381365a7c159f070e74a7b7bd8688">getKey</a> () const </td></tr>
<tr class="memdesc:ae81381365a7c159f070e74a7b7bd8688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes out the raw key pointer.  <a href="#ae81381365a7c159f070e74a7b7bd8688">More...</a><br /></td></tr>
<tr class="separator:ae81381365a7c159f070e74a7b7bd8688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0dd36c31cc7c46ee1cda0decc6e884"><td class="memItemLeft" align="right" valign="top">ckdb::Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a6e0dd36c31cc7c46ee1cda0decc6e884">operator*</a> () const </td></tr>
<tr class="memdesc:a6e0dd36c31cc7c46ee1cda0decc6e884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a abbreviation for getKey.  <a href="#a6e0dd36c31cc7c46ee1cda0decc6e884">More...</a><br /></td></tr>
<tr class="separator:a6e0dd36c31cc7c46ee1cda0decc6e884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae719043e6e99f5f3d6fb85837306f8"><td class="memItemLeft" align="right" valign="top">ckdb::Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a9ae719043e6e99f5f3d6fb85837306f8">release</a> ()</td></tr>
<tr class="memdesc:a9ae719043e6e99f5f3d6fb85837306f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes out the raw key pointer and resets internal key handle.  <a href="#a9ae719043e6e99f5f3d6fb85837306f8">More...</a><br /></td></tr>
<tr class="separator:a9ae719043e6e99f5f3d6fb85837306f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a1f28d7a0d40f0ded8473d480931ff"><td class="memItemLeft" align="right" valign="top">ckdb::Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a43a1f28d7a0d40f0ded8473d480931ff">dup</a> () const </td></tr>
<tr class="memdesc:a43a1f28d7a0d40f0ded8473d480931ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a duplicate of a key.  <a href="#a43a1f28d7a0d40f0ded8473d480931ff">More...</a><br /></td></tr>
<tr class="separator:a43a1f28d7a0d40f0ded8473d480931ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dd6ae58d125a298e30aed13b15c1f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a35dd6ae58d125a298e30aed13b15c1f4">~Key</a> ()</td></tr>
<tr class="memdesc:a35dd6ae58d125a298e30aed13b15c1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the key.  <a href="#a35dd6ae58d125a298e30aed13b15c1f4">More...</a><br /></td></tr>
<tr class="separator:a35dd6ae58d125a298e30aed13b15c1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3903afe9a4b7aebf427a74612a803cd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aa3903afe9a4b7aebf427a74612a803cd">getName</a> () const </td></tr>
<tr class="memdesc:aa3903afe9a4b7aebf427a74612a803cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the abbreviated real internal <code>key</code> name.  <a href="#aa3903afe9a4b7aebf427a74612a803cd">More...</a><br /></td></tr>
<tr class="separator:aa3903afe9a4b7aebf427a74612a803cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1d42f22eda4d84d78ab72cd60cc005"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aee1d42f22eda4d84d78ab72cd60cc005">getNameSize</a> () const </td></tr>
<tr class="memdesc:aee1d42f22eda4d84d78ab72cd60cc005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes needed to store the key name without owner.  <a href="#aee1d42f22eda4d84d78ab72cd60cc005">More...</a><br /></td></tr>
<tr class="separator:aee1d42f22eda4d84d78ab72cd60cc005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d3efd13e01624c520346a19984750b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a43d3efd13e01624c520346a19984750b">getBaseName</a> () const </td></tr>
<tr class="memdesc:a43d3efd13e01624c520346a19984750b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the internal unescaped key name where the <code>basename</code> starts.  <a href="#a43d3efd13e01624c520346a19984750b">More...</a><br /></td></tr>
<tr class="separator:a43d3efd13e01624c520346a19984750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fde543f3fbfaa0f8af80dad12a9fe7"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a92fde543f3fbfaa0f8af80dad12a9fe7">getBaseNameSize</a> () const </td></tr>
<tr class="memdesc:a92fde543f3fbfaa0f8af80dad12a9fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates number of bytes needed to store basename of <code>key</code>.  <a href="#a92fde543f3fbfaa0f8af80dad12a9fe7">More...</a><br /></td></tr>
<tr class="separator:a92fde543f3fbfaa0f8af80dad12a9fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3b5d3a854d02187484bfbdbdf975af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aac3b5d3a854d02187484bfbdbdf975af">setName</a> (const std::string &amp;newName)</td></tr>
<tr class="memdesc:aac3b5d3a854d02187484bfbdbdf975af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new name to a key.  <a href="#aac3b5d3a854d02187484bfbdbdf975af">More...</a><br /></td></tr>
<tr class="separator:aac3b5d3a854d02187484bfbdbdf975af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8c7cef03d6482d89973be72fb3c8b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a0c8c7cef03d6482d89973be72fb3c8b8">setBaseName</a> (const std::string &amp;baseName)</td></tr>
<tr class="memdesc:a0c8c7cef03d6482d89973be72fb3c8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a base name for a key.  <a href="#a0c8c7cef03d6482d89973be72fb3c8b8">More...</a><br /></td></tr>
<tr class="separator:a0c8c7cef03d6482d89973be72fb3c8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f72ce0985413ce588dc33a575ea306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ad2f72ce0985413ce588dc33a575ea306">addBaseName</a> (const std::string &amp;baseName)</td></tr>
<tr class="memdesc:ad2f72ce0985413ce588dc33a575ea306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a base name for a key.  <a href="#ad2f72ce0985413ce588dc33a575ea306">More...</a><br /></td></tr>
<tr class="separator:ad2f72ce0985413ce588dc33a575ea306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5c13b86402dffa0845a6044cd57b39"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a4b5c13b86402dffa0845a6044cd57b39">getFullNameSize</a> () const </td></tr>
<tr class="memdesc:a4b5c13b86402dffa0845a6044cd57b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes needed to store the key name including user domain and ending NULL.  <a href="#a4b5c13b86402dffa0845a6044cd57b39">More...</a><br /></td></tr>
<tr class="separator:a4b5c13b86402dffa0845a6044cd57b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94686ea0b459e5a383942ec322d9c6e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ab94686ea0b459e5a383942ec322d9c6e">getFullName</a> () const </td></tr>
<tr class="memdesc:ab94686ea0b459e5a383942ec322d9c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get key full name, including the user domain name.  <a href="#ab94686ea0b459e5a383942ec322d9c6e">More...</a><br /></td></tr>
<tr class="separator:ab94686ea0b459e5a383942ec322d9c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaff8356eb91a6d3aed2b6d282269da2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#abaff8356eb91a6d3aed2b6d282269da2">operator==</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k) const </td></tr>
<tr class="memdesc:abaff8356eb91a6d3aed2b6d282269da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the name of two keys.  <a href="#abaff8356eb91a6d3aed2b6d282269da2">More...</a><br /></td></tr>
<tr class="separator:abaff8356eb91a6d3aed2b6d282269da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313a84b686a72769ecf4c368a79d492c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a313a84b686a72769ecf4c368a79d492c">operator!=</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k) const </td></tr>
<tr class="memdesc:a313a84b686a72769ecf4c368a79d492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the name of two keys.  <a href="#a313a84b686a72769ecf4c368a79d492c">More...</a><br /></td></tr>
<tr class="separator:a313a84b686a72769ecf4c368a79d492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace409efd393ae21f08d333f45da2769"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aace409efd393ae21f08d333f45da2769">operator&lt;</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;other) const </td></tr>
<tr class="memdesc:aace409efd393ae21f08d333f45da2769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the name of two keys.  <a href="#aace409efd393ae21f08d333f45da2769">More...</a><br /></td></tr>
<tr class="separator:aace409efd393ae21f08d333f45da2769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b466f59870b989aa9ec41558bba4d19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a3b466f59870b989aa9ec41558bba4d19">operator&lt;=</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;other) const </td></tr>
<tr class="memdesc:a3b466f59870b989aa9ec41558bba4d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the name of two keys.  <a href="#a3b466f59870b989aa9ec41558bba4d19">More...</a><br /></td></tr>
<tr class="separator:a3b466f59870b989aa9ec41558bba4d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd2b165eeade6a71401b9b122864bad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a1bd2b165eeade6a71401b9b122864bad">operator&gt;</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;other) const </td></tr>
<tr class="memdesc:a1bd2b165eeade6a71401b9b122864bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the name of two keys.  <a href="#a1bd2b165eeade6a71401b9b122864bad">More...</a><br /></td></tr>
<tr class="separator:a1bd2b165eeade6a71401b9b122864bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1258657e3dbddf4aed3716dd63d2a3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aa1258657e3dbddf4aed3716dd63d2a3c">operator&gt;=</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;other) const </td></tr>
<tr class="memdesc:aa1258657e3dbddf4aed3716dd63d2a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the name of two keys.  <a href="#aa1258657e3dbddf4aed3716dd63d2a3c">More...</a><br /></td></tr>
<tr class="separator:aa1258657e3dbddf4aed3716dd63d2a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ac7f1f28842e6edc03b2f97ae14bdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a46ac7f1f28842e6edc03b2f97ae14bdc">isNull</a> () const </td></tr>
<tr class="memdesc:a46ac7f1f28842e6edc03b2f97ae14bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if C++ wrapper has an underlying key.  <a href="#a46ac7f1f28842e6edc03b2f97ae14bdc">More...</a><br /></td></tr>
<tr class="separator:a46ac7f1f28842e6edc03b2f97ae14bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac203d41896988df49dd149c2a6ad91d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ac203d41896988df49dd149c2a6ad91d8">operator bool</a> () const </td></tr>
<tr class="memdesc:ac203d41896988df49dd149c2a6ad91d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is for loops and lookups only.  <a href="#ac203d41896988df49dd149c2a6ad91d8">More...</a><br /></td></tr>
<tr class="separator:ac203d41896988df49dd149c2a6ad91d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab727b6254fec01a129d3e6ac681a5fe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ab727b6254fec01a129d3e6ac681a5fe5">needSync</a> () const </td></tr>
<tr class="memdesc:ab727b6254fec01a129d3e6ac681a5fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a key needs to be synced to backend storage.  <a href="#ab727b6254fec01a129d3e6ac681a5fe5">More...</a><br /></td></tr>
<tr class="separator:ab727b6254fec01a129d3e6ac681a5fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0916e2e6be60b5c591bae56e250ed693"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0916e2e6be60b5c591bae56e250ed693"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693">get</a> () const </td></tr>
<tr class="memdesc:a0916e2e6be60b5c591bae56e250ed693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a key value.  <a href="#a0916e2e6be60b5c591bae56e250ed693">More...</a><br /></td></tr>
<tr class="separator:a0916e2e6be60b5c591bae56e250ed693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615124f0a2b291e03975b49c233654d7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a615124f0a2b291e03975b49c233654d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a615124f0a2b291e03975b49c233654d7">set</a> (T x)</td></tr>
<tr class="memdesc:a615124f0a2b291e03975b49c233654d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a key value.  <a href="#a615124f0a2b291e03975b49c233654d7">More...</a><br /></td></tr>
<tr class="separator:a615124f0a2b291e03975b49c233654d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbad98e920ffb6d65d5d690be73ae6d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#afbad98e920ffb6d65d5d690be73ae6d9">getString</a> () const </td></tr>
<tr class="separator:afbad98e920ffb6d65d5d690be73ae6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97ef37aa235f0ae04dc6e6c21109d1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ab97ef37aa235f0ae04dc6e6c21109d1a">setString</a> (std::string newString)</td></tr>
<tr class="memdesc:ab97ef37aa235f0ae04dc6e6c21109d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value for <code>key</code> as <code>newStringValue</code>.  <a href="#ab97ef37aa235f0ae04dc6e6c21109d1a">More...</a><br /></td></tr>
<tr class="separator:ab97ef37aa235f0ae04dc6e6c21109d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3032a91f0fbf111b6b5e42dd35865db"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#af3032a91f0fbf111b6b5e42dd35865db">getStringSize</a> () const </td></tr>
<tr class="memdesc:af3032a91f0fbf111b6b5e42dd35865db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes needed to store the key value, including the NULL terminator.  <a href="#af3032a91f0fbf111b6b5e42dd35865db">More...</a><br /></td></tr>
<tr class="separator:af3032a91f0fbf111b6b5e42dd35865db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4f81dae7370976dad75030e8c0d084"><td class="memItemLeft" align="right" valign="top">func_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a9e4f81dae7370976dad75030e8c0d084">getFunc</a> () const </td></tr>
<tr class="memdesc:a9e4f81dae7370976dad75030e8c0d084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elektra can store function pointers as binary.  <a href="#a9e4f81dae7370976dad75030e8c0d084">More...</a><br /></td></tr>
<tr class="separator:a9e4f81dae7370976dad75030e8c0d084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0bbc6b746b89db7abb73a4cc2fff39"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a3e0bbc6b746b89db7abb73a4cc2fff39">getValue</a> () const </td></tr>
<tr class="memdesc:a3e0bbc6b746b89db7abb73a4cc2fff39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the real internal <code>key</code> value.  <a href="#a3e0bbc6b746b89db7abb73a4cc2fff39">More...</a><br /></td></tr>
<tr class="separator:a3e0bbc6b746b89db7abb73a4cc2fff39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b64fd6db0a743e2e4ab08daf6fba73"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a16b64fd6db0a743e2e4ab08daf6fba73">getBinary</a> () const </td></tr>
<tr class="memdesc:a16b64fd6db0a743e2e4ab08daf6fba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a key as a binary.  <a href="#a16b64fd6db0a743e2e4ab08daf6fba73">More...</a><br /></td></tr>
<tr class="separator:a16b64fd6db0a743e2e4ab08daf6fba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af173c1c4ab4104c5bc48a98cf011ca8d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#af173c1c4ab4104c5bc48a98cf011ca8d">getBinarySize</a> () const </td></tr>
<tr class="memdesc:af173c1c4ab4104c5bc48a98cf011ca8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes needed to store the key value, including the NULL terminator.  <a href="#af173c1c4ab4104c5bc48a98cf011ca8d">More...</a><br /></td></tr>
<tr class="separator:af173c1c4ab4104c5bc48a98cf011ca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7211129a4b95f4d1e335dcd06e9bf0a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#af7211129a4b95f4d1e335dcd06e9bf0a">setBinary</a> (const void *newBinary, size_t dataSize)</td></tr>
<tr class="memdesc:af7211129a4b95f4d1e335dcd06e9bf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a key as a binary.  <a href="#af7211129a4b95f4d1e335dcd06e9bf0a">More...</a><br /></td></tr>
<tr class="separator:af7211129a4b95f4d1e335dcd06e9bf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2c472e514ecef5fedb63ecae7c0f54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#abb2c472e514ecef5fedb63ecae7c0f54">hasMeta</a> (const std::string &amp;metaName) const </td></tr>
<tr class="separator:abb2c472e514ecef5fedb63ecae7c0f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e21abc1a5b8c3a8d3ee39f8f8b91fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a36e21abc1a5b8c3a8d3ee39f8f8b91fa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a36e21abc1a5b8c3a8d3ee39f8f8b91fa">getMeta</a> (const std::string &amp;metaName) const </td></tr>
<tr class="memdesc:a36e21abc1a5b8c3a8d3ee39f8f8b91fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Value of a Meta-Information given by name.  <a href="#a36e21abc1a5b8c3a8d3ee39f8f8b91fa">More...</a><br /></td></tr>
<tr class="separator:a36e21abc1a5b8c3a8d3ee39f8f8b91fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a3d463127ade0b766c4298002daa3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4c5a3d463127ade0b766c4298002daa3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a4c5a3d463127ade0b766c4298002daa3">setMeta</a> (const std::string &amp;metaName, T x)</td></tr>
<tr class="memdesc:a4c5a3d463127ade0b766c4298002daa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set metadata for key.  <a href="#a4c5a3d463127ade0b766c4298002daa3">More...</a><br /></td></tr>
<tr class="separator:a4c5a3d463127ade0b766c4298002daa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2305da805095605aca38d53f2733fb57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a2305da805095605aca38d53f2733fb57">delMeta</a> (const std::string &amp;metaName)</td></tr>
<tr class="memdesc:a2305da805095605aca38d53f2733fb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete metadata for key.  <a href="#a2305da805095605aca38d53f2733fb57">More...</a><br /></td></tr>
<tr class="separator:a2305da805095605aca38d53f2733fb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f6d2196a7f17c4bdc544207bdc5f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a53f6d2196a7f17c4bdc544207bdc5f4c">copyMeta</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;other, const std::string &amp;metaName)</td></tr>
<tr class="memdesc:a53f6d2196a7f17c4bdc544207bdc5f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a shallow copy of meta data from source to dest.  <a href="#a53f6d2196a7f17c4bdc544207bdc5f4c">More...</a><br /></td></tr>
<tr class="separator:a53f6d2196a7f17c4bdc544207bdc5f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0910bf293db33deac6a3f81359cb48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aec0910bf293db33deac6a3f81359cb48">copyAllMeta</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;other)</td></tr>
<tr class="memdesc:aec0910bf293db33deac6a3f81359cb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a shallow copy of all meta data from source to dest.  <a href="#aec0910bf293db33deac6a3f81359cb48">More...</a><br /></td></tr>
<tr class="separator:aec0910bf293db33deac6a3f81359cb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6171b76e01c2b84c6050d43673dd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#adf6171b76e01c2b84c6050d43673dd97">rewindMeta</a> () const </td></tr>
<tr class="memdesc:adf6171b76e01c2b84c6050d43673dd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind the internal iterator to first meta data.  <a href="#adf6171b76e01c2b84c6050d43673dd97">More...</a><br /></td></tr>
<tr class="separator:adf6171b76e01c2b84c6050d43673dd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855f37fef58a4ea4006d9e281f66cfe1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a855f37fef58a4ea4006d9e281f66cfe1">nextMeta</a> ()</td></tr>
<tr class="memdesc:a855f37fef58a4ea4006d9e281f66cfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate to the next meta information.  <a href="#a855f37fef58a4ea4006d9e281f66cfe1">More...</a><br /></td></tr>
<tr class="separator:a855f37fef58a4ea4006d9e281f66cfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be586ccd64cd280561ba5cd23f6ff1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classkdb_1_1Key.html">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a2be586ccd64cd280561ba5cd23f6ff1e">currentMeta</a> () const </td></tr>
<tr class="memdesc:a2be586ccd64cd280561ba5cd23f6ff1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Value of a Meta-Information which is current.  <a href="#a2be586ccd64cd280561ba5cd23f6ff1e">More...</a><br /></td></tr>
<tr class="separator:a2be586ccd64cd280561ba5cd23f6ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb13cfcabb4548177e86eec1ac16d87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#acbb13cfcabb4548177e86eec1ac16d87">isValid</a> () const </td></tr>
<tr class="separator:acbb13cfcabb4548177e86eec1ac16d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf2b97f404d5808f46a9a5c4b8b93e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a2cf2b97f404d5808f46a9a5c4b8b93e1">getNamespace</a> () const </td></tr>
<tr class="separator:a2cf2b97f404d5808f46a9a5c4b8b93e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f21b82a3d851eb3dfae53ddcfdbe48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ac0f21b82a3d851eb3dfae53ddcfdbe48">isSystem</a> () const </td></tr>
<tr class="memdesc:ac0f21b82a3d851eb3dfae53ddcfdbe48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name starts with "system".  <a href="#ac0f21b82a3d851eb3dfae53ddcfdbe48">More...</a><br /></td></tr>
<tr class="separator:ac0f21b82a3d851eb3dfae53ddcfdbe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6103772c702b400eaefbc4665f5c0cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#ab6103772c702b400eaefbc4665f5c0cf">isUser</a> () const </td></tr>
<tr class="memdesc:ab6103772c702b400eaefbc4665f5c0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name starts with "user".  <a href="#ab6103772c702b400eaefbc4665f5c0cf">More...</a><br /></td></tr>
<tr class="separator:ab6103772c702b400eaefbc4665f5c0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60e37609593de715c342740c76040cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aa60e37609593de715c342740c76040cc">isString</a> () const </td></tr>
<tr class="memdesc:aa60e37609593de715c342740c76040cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a key is string type.  <a href="#aa60e37609593de715c342740c76040cc">More...</a><br /></td></tr>
<tr class="separator:aa60e37609593de715c342740c76040cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad92210fe2389ad950a47a4eca428574"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#aad92210fe2389ad950a47a4eca428574">isBinary</a> () const </td></tr>
<tr class="memdesc:aad92210fe2389ad950a47a4eca428574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a key is binary type.  <a href="#aad92210fe2389ad950a47a4eca428574">More...</a><br /></td></tr>
<tr class="separator:aad92210fe2389ad950a47a4eca428574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd75cc13e9d766eaac72beb7d748bdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#adcd75cc13e9d766eaac72beb7d748bdb">isInactive</a> () const </td></tr>
<tr class="memdesc:adcd75cc13e9d766eaac72beb7d748bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a key is inactive.  <a href="#adcd75cc13e9d766eaac72beb7d748bdb">More...</a><br /></td></tr>
<tr class="separator:adcd75cc13e9d766eaac72beb7d748bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493893308d5b4c54d646cc0df5a076ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a493893308d5b4c54d646cc0df5a076ae">isBelow</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k) const </td></tr>
<tr class="memdesc:a493893308d5b4c54d646cc0df5a076ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the key check is below the key key or not.  <a href="#a493893308d5b4c54d646cc0df5a076ae">More...</a><br /></td></tr>
<tr class="separator:a493893308d5b4c54d646cc0df5a076ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4d2d50f9e3624ade560b0f74267d86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a0d4d2d50f9e3624ade560b0f74267d86">isBelowOrSame</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k) const </td></tr>
<tr class="separator:a0d4d2d50f9e3624ade560b0f74267d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc66b309bd42e67d7bc0e4234aa76a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdb_1_1Key.html#a3cc66b309bd42e67d7bc0e4234aa76a1">isDirectBelow</a> (const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;k) const </td></tr>
<tr class="memdesc:a3cc66b309bd42e67d7bc0e4234aa76a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the key check is direct below the key key or not.  <a href="#a3cc66b309bd42e67d7bc0e4234aa76a1">More...</a><br /></td></tr>
<tr class="separator:a3cc66b309bd42e67d7bc0e4234aa76a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> is an essential class that encapsulates key <a class="el" href="group__keyname.html">name </a>, <a class="el" href="group__keyvalue.html">value </a> and <a class="el" href="group__keymeta.html">metainfo </a>. </p>
<p>To use it include: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kdb.h&gt;</span></div>
</div><!-- fragment --><p><a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> properties are:</p><ul>
<li><a class="el" href="group__keyname.html">Key name </a></li>
<li><a class="el" href="group__keyvalue.html">Key value </a></li>
<li><a class="el" href="group__keymeta.html">Key meta data </a>, including but not limited to:<ul>
<li><a class="el" href="group__meta.html#gafb89735689929ff717cc9f2d0d0b46a2">Key comment </a></li>
<li><a class="el" href="group__meta.html#ga35922a017bee8b4bcb493bbdfad9d6f5">Key owner </a></li>
<li><a class="el" href="group__keymeta.html">UID, GID and filesystem-like mode permissions </a></li>
<li><a class="el" href="group__keymeta.html">Mode, change and modification times </a></li>
</ul>
</li>
</ul>
<dl class="section user"><dt>ABI</dt><dd>Due to ABI compatibility, the <code><a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a></code> structure is not defined in kdb.h, only declared. So you can only declare <code>pointers</code> to <code>Keys</code> in your program, and allocate and free memory for them with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> and <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> respectively.</dd></dl>
<dl class="section user"><dt>Reference Counting</dt><dd>Every key has its reference counter (see <a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae" title="Return how many references the key has. ">keyGetRef()</a> for longer explanation) that will be initialized with 0, that means a subsequent call of <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> will delete the key. If you append the key to a keyset the reference counter will be incremented by one (see <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a>) and the key can't be be deleted by a <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>As you can imagine this refcounting allows you to put the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> in your own datastructures. It can be a very powerful feature, e.g. if you need your own-defined ordering or different Models of your configuration.</dd></dl>
<p>This class is an wrapper for an optional, refcounted ckdb::Key. It is like an shared_ptr&lt;ckdb::Key&gt;, but the shared_ptr functionality is already within the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> and exposed with this wrapper.</p>
<dl class="section user"><dt>optional</dt><dd>A key can be constructed with an null pointer, by using <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> (static_cast&lt;ckdb::Key*&gt;(0)); or made empty afterwards by using <a class="el" href="classkdb_1_1Key.html#a9ae719043e6e99f5f3d6fb85837306f8" title="Passes out the raw key pointer and resets internal key handle. ">release()</a> or assign a null key. To check if there is an associated managed object the user can use <a class="el" href="classkdb_1_1Key.html#a46ac7f1f28842e6edc03b2f97ae14bdc" title="Checks if C++ wrapper has an underlying key. ">isNull()</a>.</dd></dl>
<dl class="section user"><dt>references</dt><dd>Copies of keys are cheap because they are only flat. If you really need a deep copy, you can use <a class="el" href="classkdb_1_1Key.html#ab5bc93e22f4cf40b9d2b1fc32cc260be" title="Copy or Clear a key. ">copy()</a> or <a class="el" href="classkdb_1_1Key.html#a43a1f28d7a0d40f0ded8473d480931ff" title="Return a duplicate of a key. ">dup()</a>. If you <a class="el" href="classkdb_1_1Key.html#a9ae719043e6e99f5f3d6fb85837306f8" title="Passes out the raw key pointer and resets internal key handle. ">release()</a> an object, the reference counter will stay All other operations operate on references.</dd></dl>
<dl class="section user"><dt>documentation</dt><dd>Note that the documentation is typically copied from the underlying function which is wrapped and sometimes extended with C++ specific details. So you might find C examples within the C++ documentation.</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> either has a working underlying Elektra <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object or a null pointer. The <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a>, however, might be invalid (see <a class="el" href="classkdb_1_1Key.html#acbb13cfcabb4548177e86eec1ac16d87">isValid()</a>) or null (see <a class="el" href="classkdb_1_1Key.html#a46ac7f1f28842e6edc03b2f97ae14bdc" title="Checks if C++ wrapper has an underlying key. ">isNull()</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>that the reference counting in the keys is mutable, so that const keys can be passed around by value. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5679f5cae63caddd64a60388b9cc77fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::Key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty, invalid key. </p>
<dl class="section note"><dt>Note</dt><dd>That this is not a null key, so the key will evaluate to true.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#acbb13cfcabb4548177e86eec1ac16d87">isValid()</a>, <a class="el" href="classkdb_1_1Key.html#a46ac7f1f28842e6edc03b2f97ae14bdc" title="Checks if C++ wrapper has an underlying key. ">isNull()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a41ada34fa45a270e63444267621b59c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::Key </td>
          <td>(</td>
          <td class="paramtype">ckdb::Key *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a key out of a C key. </p>
<dl class="section note"><dt>Note</dt><dd>If you pass a null pointer here, the key will evaluate to false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the key to work with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#acbb13cfcabb4548177e86eec1ac16d87">isValid()</a>, <a class="el" href="classkdb_1_1Key.html#a46ac7f1f28842e6edc03b2f97ae14bdc" title="Checks if C++ wrapper has an underlying key. ">isNull()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a33f63e153a7d832a54e02c0cba569feb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::Key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a reference of another key. </p>
<p>The key will not be copied, but the reference counter will be increased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the key to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab68da8be743b2f635ff8e28dfaeaaea6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::Key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkdb_1_1Key.html">Key</a> const &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a reference of another key. </p>
<p>The key will not be copied, but the reference counter will be increased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the key to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15b2e9e1cc323cde05b0d1d3805656e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::Key </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A practical way to fully create a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object in one step. </p>
<p>To just get a key object, simple do:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> If you want the key object to contain a name, value, comment and other meta info read on.</p>
<dl class="section note"><dt>Note</dt><dd>When you already have a key with similar properties its easier to <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> the key.</dd></dl>
<p>You can call it in many different ways depending on the attribute tags you pass as parameters. Tags are represented as the <a class="el" href="group__key.html#ga91fb3178848bd682000958089abbaf40" title="Allows keyNew() to determine which information comes next. ">keyswitch_t</a> values, and tell <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> which <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> attribute comes next.</p>
<p>We can also give an empty key name and a KEY_END tag with the same effect as before:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k =<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>); <span class="comment">// Has the same effect as above</span></div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> But we can also give the key a proper name right from the start:</p>
<div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/some/example&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> So, <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> allocates memory for a key object and <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> cleans everything up.</p>
<p><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> processes the given argument list even further. The <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> attribute tags are the following:</p><ul>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a> <br />
 Next parameter is a pointer to the value that will be used. If no <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> was used before, a string is assumed. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex0&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// set a string value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a> <br />
 Define a maximum length of the value. This is only used when setting a binary key. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex1&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 4,               <span class="comment">// has no effect on strings</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// set a string value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a> <br />
 Next two parameter is a meta name and a meta value. See <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;comment&quot;</span>, <span class="stringliteral">&quot;a comment&quot;</span>,  <span class="comment">// with a commet</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;owner&quot;</span>, <span class="stringliteral">&quot;root&quot;</span>,         <span class="comment">// and an owner</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;special&quot;</span>, <span class="stringliteral">&quot;yes&quot;</span>,        <span class="comment">// and any other meta data</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a> <br />
 Must be the last parameter passed to <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>. It is always required, unless the <code>keyName</code> is 0.</li>
<li>::KEY_FLAGS <br />
 Bitwise disjunction of flags, which don't require one or more values. recommended way to set multiple flags. overrides previously defined flags. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        KEY_FLAGS, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> | KEY_CASCADING_NAME, <span class="comment">// flags</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 7,                    <span class="comment">// assume binary length 7</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,         <span class="comment">// value that will be truncated in 7 bytes</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                       <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> <br />
 Allows one to change the key to a binary key. Make sure that you also pass <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a> before you set the value. Otherwise it will be cut off with first \0 in the string. So this flag toggle from <a class="el" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2" title="Set the value for key as newStringValue. ">keySetString()</a> to <a class="el" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7" title="Set the value of a key as a binary. ">keySetBinary()</a>. If no value (nor size) is given, it will be a NULL key. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex2&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 4,               <span class="comment">// now the size is important</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// sets the binary value (&quot;some&quot;)</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li>::KEY_CASCADING_NAME allow the name to start with / useful for <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> and <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> parent/lookup keys</li>
<li>::KEY_META_NAME allow the name to start with arbitrary namespaces useful to compare with meta keys</li>
</ul>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>These other flags deprecated and <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a> should be preferred. They remain some time, however, for compatibility:<ul>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a9e43e47c8a21478538e2d20e049981d5">KEY_DIR</a> <br />
 Define that the key is a directory rather than a ordinary key. This means its executable bits in its mode are set. But even without this option the key can have subkeys. See <a class="el" href="group__meta.html#gaae575bd86a628a15ee45baa860522e75" title="Set mode so that key will be recognized as directory. ">keySetDir()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a> <br />
 Next parameter is the owner. See <a class="el" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key. ">keySetOwner()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e">KEY_UID</a>, <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac0628bbaba7c837ca73323681393d15f">KEY_GID</a> <br />
 Next parameter is taken as the UID (uid_t) or GID (gid_t) that will be defined on the key. See <a class="el" href="group__meta.html#gab5f284f5ecd261e0a290095f50ba1af7" title="Set the user ID of a key. ">keySetUID()</a> and <a class="el" href="group__meta.html#ga9e3d0fb3f7ba906e067727b9155d22e3" title="Set the group ID of a key. ">keySetGID()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518">KEY_MODE</a> <br />
 Next parameter is taken as mode permissions (int) to the key. See <a class="el" href="group__meta.html#ga8803037e35b9da1ce492323a88ff6bc3" title="Set the key mode permissions. ">keySetMode()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// with a simple value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518">KEY_MODE</a>, 0777,            <span class="comment">// permissions</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3">KEY_COMMENT</a> <br />
 Next parameter is a comment. See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key. ">keySetComment()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex4&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a>,                     <span class="comment">// key type</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 7,                    <span class="comment">// assume binary length 7</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,         <span class="comment">// value that will be truncated in 7 bytes</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3">KEY_COMMENT</a>, <span class="stringliteral">&quot;value is truncated&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;root&quot;</span>,              <span class="comment">// owner (not uid) is root</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e">KEY_UID</a>, 0,                     <span class="comment">// root uid</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                       <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a valid name to the key, or NULL to get a simple initialized, but really empty, object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new allocated and initialized <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on malloc error or if an invalid <code>name</code> was passed (see <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">bad_alloc</td><td>if key could not be constructed (allocation problems)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyName</td><td>the name of the new key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbf7642258d46da2c4427f4104cf01ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::Key </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A practical way to fully create a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object in one step. </p>
<p>To just get a key object, simple do:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> If you want the key object to contain a name, value, comment and other meta info read on.</p>
<dl class="section note"><dt>Note</dt><dd>When you already have a key with similar properties its easier to <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> the key.</dd></dl>
<p>You can call it in many different ways depending on the attribute tags you pass as parameters. Tags are represented as the <a class="el" href="group__key.html#ga91fb3178848bd682000958089abbaf40" title="Allows keyNew() to determine which information comes next. ">keyswitch_t</a> values, and tell <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> which <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> attribute comes next.</p>
<p>We can also give an empty key name and a KEY_END tag with the same effect as before:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k =<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>); <span class="comment">// Has the same effect as above</span></div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> But we can also give the key a proper name right from the start:</p>
<div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/some/example&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> So, <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> allocates memory for a key object and <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> cleans everything up.</p>
<p><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> processes the given argument list even further. The <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> attribute tags are the following:</p><ul>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a> <br />
 Next parameter is a pointer to the value that will be used. If no <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> was used before, a string is assumed. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex0&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// set a string value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a> <br />
 Define a maximum length of the value. This is only used when setting a binary key. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex1&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 4,               <span class="comment">// has no effect on strings</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// set a string value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a> <br />
 Next two parameter is a meta name and a meta value. See <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;comment&quot;</span>, <span class="stringliteral">&quot;a comment&quot;</span>,  <span class="comment">// with a commet</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;owner&quot;</span>, <span class="stringliteral">&quot;root&quot;</span>,         <span class="comment">// and an owner</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;special&quot;</span>, <span class="stringliteral">&quot;yes&quot;</span>,        <span class="comment">// and any other meta data</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a> <br />
 Must be the last parameter passed to <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>. It is always required, unless the <code>keyName</code> is 0.</li>
<li>::KEY_FLAGS <br />
 Bitwise disjunction of flags, which don't require one or more values. recommended way to set multiple flags. overrides previously defined flags. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        KEY_FLAGS, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> | KEY_CASCADING_NAME, <span class="comment">// flags</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 7,                    <span class="comment">// assume binary length 7</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,         <span class="comment">// value that will be truncated in 7 bytes</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                       <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> <br />
 Allows one to change the key to a binary key. Make sure that you also pass <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a> before you set the value. Otherwise it will be cut off with first \0 in the string. So this flag toggle from <a class="el" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2" title="Set the value for key as newStringValue. ">keySetString()</a> to <a class="el" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7" title="Set the value of a key as a binary. ">keySetBinary()</a>. If no value (nor size) is given, it will be a NULL key. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex2&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 4,               <span class="comment">// now the size is important</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// sets the binary value (&quot;some&quot;)</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li>::KEY_CASCADING_NAME allow the name to start with / useful for <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> and <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> parent/lookup keys</li>
<li>::KEY_META_NAME allow the name to start with arbitrary namespaces useful to compare with meta keys</li>
</ul>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>These other flags deprecated and <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a> should be preferred. They remain some time, however, for compatibility:<ul>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a9e43e47c8a21478538e2d20e049981d5">KEY_DIR</a> <br />
 Define that the key is a directory rather than a ordinary key. This means its executable bits in its mode are set. But even without this option the key can have subkeys. See <a class="el" href="group__meta.html#gaae575bd86a628a15ee45baa860522e75" title="Set mode so that key will be recognized as directory. ">keySetDir()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a> <br />
 Next parameter is the owner. See <a class="el" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key. ">keySetOwner()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e">KEY_UID</a>, <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac0628bbaba7c837ca73323681393d15f">KEY_GID</a> <br />
 Next parameter is taken as the UID (uid_t) or GID (gid_t) that will be defined on the key. See <a class="el" href="group__meta.html#gab5f284f5ecd261e0a290095f50ba1af7" title="Set the user ID of a key. ">keySetUID()</a> and <a class="el" href="group__meta.html#ga9e3d0fb3f7ba906e067727b9155d22e3" title="Set the group ID of a key. ">keySetGID()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518">KEY_MODE</a> <br />
 Next parameter is taken as mode permissions (int) to the key. See <a class="el" href="group__meta.html#ga8803037e35b9da1ce492323a88ff6bc3" title="Set the key mode permissions. ">keySetMode()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// with a simple value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518">KEY_MODE</a>, 0777,            <span class="comment">// permissions</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3">KEY_COMMENT</a> <br />
 Next parameter is a comment. See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key. ">keySetComment()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex4&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a>,                     <span class="comment">// key type</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 7,                    <span class="comment">// assume binary length 7</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,         <span class="comment">// value that will be truncated in 7 bytes</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3">KEY_COMMENT</a>, <span class="stringliteral">&quot;value is truncated&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;root&quot;</span>,              <span class="comment">// owner (not uid) is root</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e">KEY_UID</a>, 0,                     <span class="comment">// root uid</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                       <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a valid name to the key, or NULL to get a simple initialized, but really empty, object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new allocated and initialized <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on malloc error or if an invalid <code>name</code> was passed (see <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">bad_alloc</td><td>if key could not be constructed (allocation problems)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Not supported on some compilers, e.g. clang which require you to only pass non-POD in varg lists.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyName</td><td>the name of the new key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0dc94c7e676a0d280e5817e4c6238d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::Key </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A practical way to fully create a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object in one step. </p>
<p>To just get a key object, simple do:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> If you want the key object to contain a name, value, comment and other meta info read on.</p>
<dl class="section note"><dt>Note</dt><dd>When you already have a key with similar properties its easier to <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> the key.</dd></dl>
<p>You can call it in many different ways depending on the attribute tags you pass as parameters. Tags are represented as the <a class="el" href="group__key.html#ga91fb3178848bd682000958089abbaf40" title="Allows keyNew() to determine which information comes next. ">keyswitch_t</a> values, and tell <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> which <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> attribute comes next.</p>
<p>We can also give an empty key name and a KEY_END tag with the same effect as before:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k =<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>); <span class="comment">// Has the same effect as above</span></div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> But we can also give the key a proper name right from the start:</p>
<div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/some/example&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><span class="comment">// work with it</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);</div>
</div><!-- fragment --><p> So, <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> allocates memory for a key object and <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> cleans everything up.</p>
<p><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> processes the given argument list even further. The <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> attribute tags are the following:</p><ul>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a> <br />
 Next parameter is a pointer to the value that will be used. If no <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> was used before, a string is assumed. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex0&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// set a string value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a> <br />
 Define a maximum length of the value. This is only used when setting a binary key. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex1&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 4,               <span class="comment">// has no effect on strings</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// set a string value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a> <br />
 Next two parameter is a meta name and a meta value. See <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;comment&quot;</span>, <span class="stringliteral">&quot;a comment&quot;</span>,  <span class="comment">// with a commet</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;owner&quot;</span>, <span class="stringliteral">&quot;root&quot;</span>,         <span class="comment">// and an owner</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a>, <span class="stringliteral">&quot;special&quot;</span>, <span class="stringliteral">&quot;yes&quot;</span>,        <span class="comment">// and any other meta data</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a> <br />
 Must be the last parameter passed to <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>. It is always required, unless the <code>keyName</code> is 0.</li>
<li>::KEY_FLAGS <br />
 Bitwise disjunction of flags, which don't require one or more values. recommended way to set multiple flags. overrides previously defined flags. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        KEY_FLAGS, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> | KEY_CASCADING_NAME, <span class="comment">// flags</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 7,                    <span class="comment">// assume binary length 7</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,         <span class="comment">// value that will be truncated in 7 bytes</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                       <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a> <br />
 Allows one to change the key to a binary key. Make sure that you also pass <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a> before you set the value. Otherwise it will be cut off with first \0 in the string. So this flag toggle from <a class="el" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2" title="Set the value for key as newStringValue. ">keySetString()</a> to <a class="el" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7" title="Set the value of a key as a binary. ">keySetBinary()</a>. If no value (nor size) is given, it will be a NULL key. <div class="fragment"><div class="line"><span class="comment">// Create and initialize a key with a name and nothing else</span></div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex2&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 4,               <span class="comment">// now the size is important</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// sets the binary value (&quot;some&quot;)</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li>::KEY_CASCADING_NAME allow the name to start with / useful for <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> and <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> parent/lookup keys</li>
<li>::KEY_META_NAME allow the name to start with arbitrary namespaces useful to compare with meta keys</li>
</ul>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>These other flags deprecated and <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a040582834bb2d90049947d7ef74e87e2">KEY_META</a> should be preferred. They remain some time, however, for compatibility:<ul>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a9e43e47c8a21478538e2d20e049981d5">KEY_DIR</a> <br />
 Define that the key is a directory rather than a ordinary key. This means its executable bits in its mode are set. But even without this option the key can have subkeys. See <a class="el" href="group__meta.html#gaae575bd86a628a15ee45baa860522e75" title="Set mode so that key will be recognized as directory. ">keySetDir()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a> <br />
 Next parameter is the owner. See <a class="el" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key. ">keySetOwner()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e">KEY_UID</a>, <a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac0628bbaba7c837ca73323681393d15f">KEY_GID</a> <br />
 Next parameter is taken as the UID (uid_t) or GID (gid_t) that will be defined on the key. See <a class="el" href="group__meta.html#gab5f284f5ecd261e0a290095f50ba1af7" title="Set the user ID of a key. ">keySetUID()</a> and <a class="el" href="group__meta.html#ga9e3d0fb3f7ba906e067727b9155d22e3" title="Set the group ID of a key. ">keySetGID()</a>.</li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518">KEY_MODE</a> <br />
 Next parameter is taken as mode permissions (int) to the key. See <a class="el" href="group__meta.html#ga8803037e35b9da1ce492323a88ff6bc3" title="Set the key mode permissions. ">keySetMode()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex3&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,    <span class="comment">// with a simple value</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1b0a91ff3a855d6993930ebf0abaa518">KEY_MODE</a>, 0777,            <span class="comment">// permissions</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                  <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
<li><a class="el" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3">KEY_COMMENT</a> <br />
 Next parameter is a comment. See <a class="el" href="group__meta.html#ga8863a877a84fa46e6017fe72e49b89c1" title="Set a comment for a key. ">keySetComment()</a>. <div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/tmp/ex4&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a1ca18d4e094ae7487d35ecedda2235ff">KEY_BINARY</a>,                     <span class="comment">// key type</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a6d531b5c41445d19d0452eebdccbfa01">KEY_SIZE</a>, 7,                    <span class="comment">// assume binary length 7</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;some data&quot;</span>,         <span class="comment">// value that will be truncated in 7 bytes</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40ac29427bb47cc31689d02912e36161ee3">KEY_COMMENT</a>, <span class="stringliteral">&quot;value is truncated&quot;</span>,</div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;root&quot;</span>,              <span class="comment">// owner (not uid) is root</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a28f01a87d65f065172f734c9c9446c0e">KEY_UID</a>, 0,                     <span class="comment">// root uid</span></div>
<div class="line">        <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);                       <span class="comment">// end of args</span></div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a valid name to the key, or NULL to get a simple initialized, but really empty, object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new allocated and initialized <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> object. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on malloc error or if an invalid <code>name</code> was passed (see <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">bad_alloc</td><td>if key could not be constructed (allocation problems)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyName</td><td>the name of the new key </td></tr>
    <tr><td class="paramname">ap</td><td>the variable argument list pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35dd6ae58d125a298e30aed13b15c1f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::~Key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructs the key. </p>
<dl class="section see"><dt>See also</dt><dd>del() </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad2f72ce0985413ce588dc33a575ea306"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::addBaseName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a base name for a key. </p>
<p>Adds <code>baseName</code> (that will be escaped) to the current key name. A new baseName will be added, no other part of the key name will be affected.</p>
<p>Assumes that <code>key</code> is a directory and will append <code>baseName</code> to it. The function adds the path separator for concatenating.</p>
<p>So if <code>key</code> has name <code>"system/dir1/dir2"</code> and this method is called with <code>baseName</code> <code>"mykey"</code>, the resulting key will have the name <code>"system/dir1/dir2/mykey"</code>.</p>
<p>When <code>baseName</code> is 0 nothing will happen and the size of the name is returned.</p>
<p>The escaping rules apply as in <a class="el" href="group__keyname.html">above </a>.</p>
<p>A simple example is: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/my/long&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a>(k, <span class="stringliteral">&quot;myname&quot;</span>);</div>
<div class="line">printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k)); <span class="comment">// will print user/my/long/myname</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(k);</div>
</div><!-- fragment --><p> E.g. if you add . it will be escaped: </p><div class="fragment"><div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div>
<div class="line">succeed_if (<a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;.&quot;</span>) &gt;= 0, <span class="stringliteral">&quot;could not add a base name&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k), <span class="stringliteral">&quot;system/valid/\\.&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a>(k), <span class="stringliteral">&quot;.&quot;</span>);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a> to <a class="el" href="classkdb_1_1Key.html#a615124f0a2b291e03975b49c233654d7" title="Set a key value. ">set</a> a base name </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> to <a class="el" href="classkdb_1_1Key.html#a615124f0a2b291e03975b49c233654d7" title="Set a key value. ">set</a> a new name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">baseName</td><td>the string to append to the name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the new key name including the ending NULL </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the key had no name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyInvalidName</td><td>if the name is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33a112681b0b2e94e6d369c0f89e361b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears/Invalidates a key. </p>
<p>Afterwards the object is empty again.</p>
<dl class="section note"><dt>Note</dt><dd>This is not a null key, so it will evaluate to true. <a class="el" href="classkdb_1_1Key.html#acbb13cfcabb4548177e86eec1ac16d87">isValid()</a> will, however, be false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#a9ae719043e6e99f5f3d6fb85837306f8" title="Passes out the raw key pointer and resets internal key handle. ">release()</a> </dd>
<dd>
<a class="el" href="classkdb_1_1Key.html#acbb13cfcabb4548177e86eec1ac16d87">isValid()</a>, <a class="el" href="classkdb_1_1Key.html#a46ac7f1f28842e6edc03b2f97ae14bdc" title="Checks if C++ wrapper has an underlying key. ">isNull()</a></dd></dl>
<p><a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> Object Cleaner. Will reset all internal data.</p>
<p>After this call you will receive a fresh key.</p>
<p>The reference counter will stay unmodified.</p>
<dl class="section note"><dt>Note</dt><dd>that you might also <a class="el" href="classkdb_1_1Key.html#a33a112681b0b2e94e6d369c0f89e361b" title="Clears/Invalidates a key. ">clear()</a> all aliases with this operation.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f (<a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="group__key.html#gab2242311a36bbc0520e0d36895107ec1">keyClear</a> (k);</div>
<div class="line">        <span class="comment">// you have a fresh key k here</span></div>
<div class="line">        <a class="code" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2">keySetString</a> (k, <span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line">        <span class="comment">// the caller will get an empty key k with an value</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">returns</td><td>0 on success </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5bc93e22f4cf40b9d2b1fc32cc260be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy or Clear a key. </p>
<p>Most often you may prefer <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> which allocates a new key and returns a duplication of another key.</p>
<p>But when you need to copy into an existing key, e.g. because it was passed by a pointer in a function you can do so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> h (<a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// receive key c</span></div>
<div class="line">        <a class="code" href="group__key.html#ga6a12cbbe656a1ad9f41b8c681d7a2f92">keyCopy</a> (k, c);</div>
<div class="line">        <span class="comment">// the caller will see the changed key k</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> The reference counter will not be changed for both keys. Affiliation to keysets are also not affected.</p>
<p>The meta data will be duplicated for the destination key. So it will not take much additional space, even with lots of metadata.</p>
<p>When you pass a NULL-pointer as source the data of dest will be cleaned completely (except reference counter, see <a class="el" href="group__key.html#gab2242311a36bbc0520e0d36895107ec1" title="Key Object Cleaner. ">keyClear()</a>) and you get a fresh dest key:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> g (<a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="group__key.html#ga6a12cbbe656a1ad9f41b8c681d7a2f92">keyCopy</a> (k, 0);</div>
<div class="line">        <span class="comment">// k is now an empty and fresh key</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> If you want to copy everything, except e.g. the value you can use <a class="el" href="group__key.html#ga6a12cbbe656a1ad9f41b8c681d7a2f92" title="Copy or Clear a key. ">keyCopy()</a> too:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> j (<a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k)</div>
<div class="line">{</div>
<div class="line">        <span class="keywordtype">size_t</span> size = <a class="code" href="group__keyvalue.html#gae326672fffb7474abfe9baf53b73217e">keyGetValueSize</a> (k);</div>
<div class="line">        <span class="keywordtype">char</span> *value = malloc (size);</div>
<div class="line">        <span class="keywordtype">int</span> bstring = <a class="code" href="group__keytest.html#gaea7670778abd07fee0fe8ac12a149190">keyIsString</a> (k);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// receive key c</span></div>
<div class="line">        memcpy (value, <a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(k), size);</div>
<div class="line">        <a class="code" href="group__key.html#ga6a12cbbe656a1ad9f41b8c681d7a2f92">keyCopy</a> (k, c);</div>
<div class="line">        <span class="keywordflow">if</span> (bstring) <a class="code" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2">keySetString</a> (k, value);</div>
<div class="line">        <span class="keywordflow">else</span> <a class="code" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7">keySetBinary</a> (k, value, size);</div>
<div class="line">        free (value);</div>
<div class="line">        <span class="comment">// the caller will see the changed key k</span></div>
<div class="line">        <span class="comment">// with the name and metadata from c (except</span></div>
<div class="line">        <span class="comment">// metadata &quot;binary&quot;, which stayed the same)</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Restrain from coping everything yourself, because it will lead to wrong metadata and is not able to copy empty or cascading names:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> i (<a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(k, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(c));</div>
<div class="line">        <a class="code" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2">keySetString</a>(k, <a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(c));</div>
<div class="line">        <a class="code" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a>(k, c);</div>
<div class="line">        <span class="comment">// k is not a copy of c even if everything was successfully,</span></div>
<div class="line">        <span class="comment">// because it still contains meta data from k</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the key which will be written to </td></tr>
    <tr><td class="paramname">source</td><td>the key which should be copied or NULL to clean the destination key</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on failure when a NULL pointer was passed for dest or a dynamic property could not be written. The content will be unmodified then. </td></tr>
    <tr><td class="paramname">0</td><td>when dest was cleaned </td></tr>
    <tr><td class="paramname">1</td><td>when source was successfully copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> to <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get</a> a duplication of a <a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aec0910bf293db33deac6a3f81359cb48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::copyAllMeta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a shallow copy of all meta data from source to dest. </p>
<p>The key dest will additionally have all meta data the source had. Meta data not present in source will not be changed. Meta data which was present in source and dest will be overwritten.</p>
<p>For example the meta data type is copied into the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> k:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> l(<a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// receive c</span></div>
<div class="line">        <a class="code" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a>(k, c);</div>
<div class="line">        <span class="comment">// the caller will see the changed key k</span></div>
<div class="line">        <span class="comment">// with all the metadata from c</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> The main purpose of this function is for plugins or applications which want to add the same meta data to n keys. When you do that with <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a> it will take n times the memory for the key. This can be considerable amount of memory for many keys with some meta data for each.</p>
<p>To avoid that problem you can use <a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401" title="Do a shallow copy of all meta data from source to dest. ">keyCopyAllMeta()</a> or <a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c" title="Do a shallow copy of meta data from source to dest. ">keyCopyMeta()</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> o(KeySet *ks)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *current;</div>
<div class="line">        <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *shared = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (0);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared1&quot;</span>, <span class="stringliteral">&quot;this meta data should be shared among many keys&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared2&quot;</span>, <span class="stringliteral">&quot;this meta data should be shared among many keys also&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared3&quot;</span>, <span class="stringliteral">&quot;this meta data should be shared among many keys too&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a>(ks);</div>
<div class="line">        <span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a>(ks)) != 0)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (needsSharedData(current)) <a class="code" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401">keyCopyAllMeta</a>(current, shared);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(shared);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section post"><dt>Postcondition</dt><dd>for every metaName present in source: keyGetMeta(source, metaName) == keyGetMeta(dest, metaName)</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if was successfully copied </td></tr>
    <tr><td class="paramname">0</td><td>if source did not have any meta data </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointer of dest or source </td></tr>
    <tr><td class="paramname">-1</td><td>on memory problems </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination where the meta data should be copied too </td></tr>
    <tr><td class="paramname">source</td><td>the key where the meta data should be copied from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#a36e21abc1a5b8c3a8d3ee39f8f8b91fa" title="Returns the Value of a Meta-Information given by name. ">getMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a4c5a3d463127ade0b766c4298002daa3" title="Set metadata for key. ">setMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a53f6d2196a7f17c4bdc544207bdc5f4c" title="Do a shallow copy of meta data from source to dest. ">copyMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53f6d2196a7f17c4bdc544207bdc5f4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::copyMeta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do a shallow copy of meta data from source to dest. </p>
<p>The key dest will have the same meta data referred with metaName afterwards then source.</p>
<p>For example the meta data type is copied into the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> k.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> l(<a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// receive c</span></div>
<div class="line">        <a class="code" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a>(k, c, <span class="stringliteral">&quot;type&quot;</span>);</div>
<div class="line">        <span class="comment">// the caller will see the changed key k</span></div>
<div class="line">        <span class="comment">// with the metadata &quot;type&quot; from c</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The main purpose of this function is for plugins or applications which want to add the same meta data to n keys. When you do that with <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a> it will take n times the memory for the key. This can be considerable amount of memory for many keys with some meta data for each.</p>
<p>To avoid that problem you can use <a class="el" href="group__keymeta.html#ga8e63720a65610a29597494d0671f9401" title="Do a shallow copy of all meta data from source to dest. ">keyCopyAllMeta()</a> or <a class="el" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c" title="Do a shallow copy of meta data from source to dest. ">keyCopyMeta()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> o(KeySet *ks)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *current;</div>
<div class="line">        <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *shared = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (0);</div>
<div class="line">        <a class="code" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9">keySetMeta</a>(shared, <span class="stringliteral">&quot;shared&quot;</span>, <span class="stringliteral">&quot;this meta data should be shared among many keys&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a>(ks);</div>
<div class="line">        <span class="keywordflow">while</span> ((current = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a>(ks)) != 0)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">if</span> (needs_shared_data(current)) <a class="code" href="group__keymeta.html#ga9a22b992478e613c8788bd460b4a1f0c">keyCopyMeta</a>(current, shared, <span class="stringliteral">&quot;shared&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section post"><dt>Postcondition</dt><dd>keyGetMeta(source, metaName) == keyGetMeta(dest, metaName)</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if was successfully copied </td></tr>
    <tr><td class="paramname">0</td><td>if the meta data in dest was removed too </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointers (source or dest) </td></tr>
    <tr><td class="paramname">-1</td><td>on memory problems </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the destination where the meta data should be copied too </td></tr>
    <tr><td class="paramname">source</td><td>the key where the meta data should be copied from </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the meta data which should be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#a36e21abc1a5b8c3a8d3ee39f8f8b91fa" title="Returns the Value of a Meta-Information given by name. ">getMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a4c5a3d463127ade0b766c4298002daa3" title="Set metadata for key. ">setMeta()</a>, <a class="el" href="classkdb_1_1Key.html#aec0910bf293db33deac6a3f81359cb48" title="Do a shallow copy of all meta data from source to dest. ">copyAllMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2be586ccd64cd280561ba5cd23f6ff1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classkdb_1_1Key.html">Key</a> kdb::Key::currentMeta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Value of a Meta-Information which is current. </p>
<p>The pointer is NULL if you reached the end or after <a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer to the value pointed by <code>key's</code> cursor </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a>, <a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9" title="Rewind the internal iterator to first meta data. ">keyRewindMeta()</a></dd>
<dd>
<a class="el" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094" title="Return the current Key. ">ksCurrent()</a> for pedant in iterator interface of <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>that the key will be null if last meta data is found.</dd></dl>
<div class="fragment"><div class="line">k.rewindMeta();</div>
<div class="line"><span class="keywordflow">while</span> (meta = k.nextMeta())</div>
<div class="line">{</div>
<div class="line">        cout &lt;&lt; meta.getName() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; meta.getString() &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#adf6171b76e01c2b84c6050d43673dd97" title="Rewind the internal iterator to first meta data. ">rewindMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a855f37fef58a4ea4006d9e281f66cfe1" title="Iterate to the next meta information. ">nextMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2305da805095605aca38d53f2733fb57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::delMeta </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete metadata for key. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#a4c5a3d463127ade0b766c4298002daa3" title="Set metadata for key. ">setMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a36e21abc1a5b8c3a8d3ee39f8f8b91fa" title="Returns the Value of a Meta-Information given by name. ">getMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a53f6d2196a7f17c4bdc544207bdc5f4c" title="Do a shallow copy of meta data from source to dest. ">copyMeta()</a>, <a class="el" href="classkdb_1_1Key.html#aec0910bf293db33deac6a3f81359cb48" title="Do a shallow copy of all meta data from source to dest. ">copyAllMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43a1f28d7a0d40f0ded8473d480931ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::Key * kdb::Key::dup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a duplicate of a key. </p>
<p>Memory will be allocated as needed for dynamic properties.</p>
<p>The new key will not be member of any <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> and will start with a new reference counter at 0. A subsequent <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> will delete the key.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f (<span class="keyword">const</span> <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> * source)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> * <a class="code" href="classkdb_1_1Key.html#a43a1f28d7a0d40f0ded8473d480931ff">dup</a> = <a class="code" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3">keyDup</a> (source);</div>
<div class="line">        <span class="comment">// work with duplicate</span></div>
<div class="line">        <a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (dup);</div>
<div class="line">        <span class="comment">// everything related to dup is freed</span></div>
<div class="line">        <span class="comment">// and source is unchanged</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Like for a new key after <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> a subsequent <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a> makes a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> to take care of the lifecycle of the key.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> g (<span class="keyword">const</span> <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> * source, KeySet * ks)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> * <a class="code" href="classkdb_1_1Key.html#a43a1f28d7a0d40f0ded8473d480931ff">dup</a> = <a class="code" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3">keyDup</a> (source);</div>
<div class="line">        <span class="comment">// work with duplicate</span></div>
<div class="line">        <a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (ks, dup);</div>
<div class="line">        <span class="comment">// ksDel(ks) will also free the duplicate</span></div>
<div class="line">        <span class="comment">// source remains unchanged.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Duplication of keys should be preferred to <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, because data like owner can be filled with a copy of the key instead of asking the environment. It can also be optimized in the checks, because the keyname is known to be valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>has to be an initialized source <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>failure or on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fully copy of source on success </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a>, <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a>, <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0916e2e6be60b5c591bae56e250ed693"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T kdb::Key::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a key value. </p>
<p>You can write your own template specialication, e.g.: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> QColor <a class="code" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693">Key::get</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="classkdb_1_1Key.html#af3032a91f0fbf111b6b5e42dd35865db">getStringSize</a>() &lt; 1)</div>
<div class="line">        {</div>
<div class="line">                <span class="keywordflow">throw</span> KeyTypeConversion();</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        std::string str = <a class="code" href="classkdb_1_1Key.html#afbad98e920ffb6d65d5d690be73ae6d9">getString</a>();</div>
<div class="line">        QColor c(str.c_str());</div>
<div class="line">        <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the string directly from the key.</dd></dl>
<p>It should be the same as <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get()</a>. </p><dl class="section return"><dt>Returns</dt><dd>empty string on null pointers</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyException</td><td>on null key or not a valid size </td></tr>
    <tr><td class="paramname">KeyTypeMismatch</td><td>if key holds binary data and not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>unlike in the C version, it is safe to change the returned string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#aa60e37609593de715c342740c76040cc" title="Check if a key is string type. ">isString()</a>, <a class="el" href="classkdb_1_1Key.html#a16b64fd6db0a743e2e4ab08daf6fba73" title="Get the value of a key as a binary. ">getBinary()</a></dd></dl>
<p>This method tries to serialise the string to the given type. </p>

</div>
</div>
<a class="anchor" id="a43d3efd13e01624c520346a19984750b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string kdb::Key::getBaseName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the internal unescaped key name where the <code>basename</code> starts. </p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Calculate the basename of a key name and put it in returned finalizing the string with NULL...">keyGetBaseName()</a> and you should use it if you are responsible enough to not mess up things. The name might change or even point to a wrong place after a <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a>. So make sure to copy the memory before the name changes.</p>
<p><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a> returns "" when there is no keyBaseName. The reason is </p><div class="fragment"><div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(k,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a>(k), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(k,<span class="stringliteral">&quot;user&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a>(k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> And there is also support for really empty basenames: </p><div class="fragment"><div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div>
<div class="line">succeed_if (<a class="code" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524">keyAddBaseName</a> (k, <span class="stringliteral">&quot;&quot;</span>) &gt;= 0, <span class="stringliteral">&quot;could not add a base name&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k), <span class="stringliteral">&quot;system/valid/%&quot;</span>);</div>
<div class="line">succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a>(k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must never use the pointer returned by <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a> method to change the name, but you should use <a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a> instead.</dd>
<dd>
Do not assume that <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a> points to the same region as <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> does.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object to obtain the basename from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the basename </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when the key has no (base)name </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Calculate the basename of a key name and put it in returned finalizing the string with NULL...">keyGetBaseName()</a>, <a class="el" href="group__keyname.html#ga1a0b76c5d9e5367c7e72211e6c63d43a" title="Calculates number of bytes needed to store basename of key. ">keyGetBaseNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> to <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get</a> a pointer to the name </dd>
<dd>
<a class="el" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner. ">keyOwner()</a> to <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get</a> a pointer to the owner </dd></dl>

</div>
</div>
<a class="anchor" id="a92fde543f3fbfaa0f8af80dad12a9fe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::Key::getBaseNameSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates number of bytes needed to store basename of <code>key</code>. </p>
<p><a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> names that have only root names (e.g. <code>"system"</code> or <code>"user"</code> or <code>"user:domain"</code> ) does not have basenames, thus the function will return 1 bytes to store "".</p>
<p>Basenames are denoted as:</p><ul>
<li><code>system/some/thing/basename</code> -&gt; <code>basename</code> </li>
<li><code>user:domain/some/thing/base\/name</code> &gt; <code>base\/name</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size in bytes of <code>key's</code> basename including ending NULL </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a>, <a class="el" href="group__keyname.html#ga0992d26bcfca767cb8e77053a483eb64" title="Calculate the basename of a key name and put it in returned finalizing the string with NULL...">keyGetBaseName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>, <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a16b64fd6db0a743e2e4ab08daf6fba73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string kdb::Key::getBinary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of a key as a binary. </p>
<dl class="section return"><dt>Returns</dt><dd>the binary Value of the key.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>on null pointers (size == 0) and on data only containing \0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if you need to distinguish between null pointers and data containing \0 you can use <a class="el" href="classkdb_1_1Key.html#a3e0bbc6b746b89db7abb73a4cc2fff39" title="Return a pointer to the real internal key value. ">getValue()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyException</td><td>on invalid binary size </td></tr>
    <tr><td class="paramname">KeyTypeMismatch</td><td>if key is string and not a binary</td></tr>
  </table>
  </dd>
</dl>
<p>If the type is not binary -1 will be returned.</p>
<p>When the binary data is empty (this is not the same as ""!) 0 will be returned and the returnedBinary will not be changed.</p>
<p>For string values see <a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a> and <a class="el" href="group__keytest.html#gaea7670778abd07fee0fe8ac12a149190" title="Check if a key is string type. ">keyIsString()</a>.</p>
<p>When the returnedBinary is to small to hold the data (its maximum size is given by maxSize), the returnedBinary will not be changed and -1 is returned.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *key = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;user/keyname&quot;</span>, KEY_TYPE, KEY_TYPE_BINARY, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><span class="keywordtype">char</span> buffer[300];</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84">keyGetBinary</a>(key,buffer,<span class="keyword">sizeof</span>(buffer)) == -1)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// handle error</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object to gather the value from </td></tr>
    <tr><td class="paramname">returnedBinary</td><td>pre-allocated memory to store a copy of the key value </td></tr>
    <tr><td class="paramname">maxSize</td><td>number of bytes of pre-allocated memory in <code>returnedBinary</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually copied to <code>returnedBinary</code> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the binary is empty </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if maxSize is 0 </td></tr>
    <tr><td class="paramname">-1</td><td>if maxSize is too small for string </td></tr>
    <tr><td class="paramname">-1</td><td>if maxSize is larger than SSIZE_MAX </td></tr>
    <tr><td class="paramname">-1</td><td>on type mismatch: binary expected, but found string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af" title="Return a pointer to the real internal key value. ">keyValue()</a>, <a class="el" href="group__keyvalue.html#gae326672fffb7474abfe9baf53b73217e" title="Returns the number of bytes needed to store the key value, including the NULL terminator. ">keyGetValueSize()</a>, <a class="el" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7" title="Set the value of a key as a binary. ">keySetBinary()</a> </dd>
<dd>
<a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a> and <a class="el" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2" title="Set the value for key as newStringValue. ">keySetString()</a> as preferred alternative to binary </dd>
<dd>
<a class="el" href="group__keytest.html#ga9526b371087564e43e3dff8ad0dac949" title="Check if a key is binary type. ">keyIsBinary()</a> to see how to check for binary type</dd>
<dd>
<a class="el" href="classkdb_1_1Key.html#aad92210fe2389ad950a47a4eca428574" title="Check if a key is binary type. ">isBinary()</a>, <a class="el" href="classkdb_1_1Key.html#afbad98e920ffb6d65d5d690be73ae6d9">getString()</a>, <a class="el" href="classkdb_1_1Key.html#a3e0bbc6b746b89db7abb73a4cc2fff39" title="Return a pointer to the real internal key value. ">getValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af173c1c4ab4104c5bc48a98cf011ca8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::Key::getBinarySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes needed to store the key value, including the NULL terminator. </p>
<p>It returns the correct size, independent of the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> Type. If it is a binary there might be '\0' values in it.</p>
<p>For an empty string you need one byte to store the ending NULL. For that reason 1 is returned. This is not true for binary data, so there might be returned 0 too.</p>
<p>A binary key has no '\0' termination. String types have it, so to there length will be added 1 to have enough space to store it.</p>
<p>This method can be used with malloc() before <a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a> or <a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a> is called.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *buffer;</div>
<div class="line">buffer = malloc (<a class="code" href="group__keyvalue.html#gae326672fffb7474abfe9baf53b73217e">keyGetValueSize</a> (key));</div>
<div class="line"><span class="comment">// use this buffer to store the value (binary or string)</span></div>
<div class="line"><span class="comment">// pass keyGetValueSize (key) for maxSize</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes needed to store the key value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>when there is no data and type is not binary </td></tr>
    <tr><td class="paramname">0</td><td>when there is no data and type is binary </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a>, <a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a>, <a class="el" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af" title="Return a pointer to the real internal key value. ">keyValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab94686ea0b459e5a383942ec322d9c6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string kdb::Key::getFullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get key full name, including the user domain name. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on empty name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if maxSize is 0 or larger than SSIZE_MAX </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object </td></tr>
    <tr><td class="paramname">returnedName</td><td>pre-allocated memory to write the key name </td></tr>
    <tr><td class="paramname">maxSize</td><td>maximum number of bytes that will fit in returnedName, including the final NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyException</td><td>if key is null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b5c13b86402dffa0845a6044cd57b39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::Key::getFullNameSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bytes needed to store the key name including user domain and ending NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed to store key name including user domain </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on empty name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the key name without owner. ">keyGetNameSize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e4f81dae7370976dad75030e8c0d084"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Key::func_t kdb::Key::getFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elektra can store function pointers as binary. </p>
<p>This function returns such a function pointer.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyTypeMismatch</td><td>if no binary data found, or binary data has not correct length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a function pointer stored with <a class="el" href="classkdb_1_1Key.html#af7211129a4b95f4d1e335dcd06e9bf0a" title="Set the value of a key as a binary. ">setBinary()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae81381365a7c159f070e74a7b7bd8688"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::Key * kdb::Key::getKey </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Passes out the raw key pointer. </p>
<p>This pointer can be used to directly change the underlying key object.</p>
<dl class="section note"><dt>Note</dt><dd>that the ownership remains in the object </dd></dl>

</div>
</div>
<a class="anchor" id="a36e21abc1a5b8c3a8d3ee39f8f8b91fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T kdb::Key::getMeta </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Value of a Meta-Information given by name. </p>
<p>This is a much more efficient version of <a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c" title="Returns the Value of a Meta-Information given by name. ">keyGetMeta()</a>. But unlike with keyGetMeta you are not allowed to modify the resulting string.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f(<a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k)</div>
<div class="line">{</div>
<div class="line">        <span class="keywordflow">if</span> (!strcmp(<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(<a class="code" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">keyGetMeta</a>(k, <span class="stringliteral">&quot;type&quot;</span>)), <span class="stringliteral">&quot;boolean&quot;</span>))</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// the type of the key is boolean</span></div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the meta information you want the value from </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the key or metaName is 0 </td></tr>
    <tr><td class="paramname">0</td><td>if no such metaName is found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of Meta-Information if Meta-Information is found </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c" title="Returns the Value of a Meta-Information given by name. ">keyGetMeta()</a>, <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a></dd></dl>
<p>You can specify your own template specialisation: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> yourtype <a class="code" href="classkdb_1_1Key.html#a36e21abc1a5b8c3a8d3ee39f8f8b91fa">Key::getMeta</a>(<span class="keyword">const</span> std::string &amp;name)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">        yourtype x;</div>
<div class="line">        std::string str;</div>
<div class="line">        str = std::string(</div>
<div class="line">                static_cast&lt;const char*&gt;(</div>
<div class="line">                        <a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">ckdb::keyValue</a>(</div>
<div class="line">                                <a class="code" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c">ckdb::keyGetMeta</a>(key, name.c_str())</div>
<div class="line">                                )</div>
<div class="line">                        )</div>
<div class="line">                );</div>
<div class="line">        <span class="keywordflow">return</span> yourconversion(str);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyTypeConversion</td><td>if meta data could not be parsed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No exception will be thrown if a const <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> or char* is requested, but don't forget the const: getMeta&lt;const Key&gt;, otherwise you will get an compiler error.</dd></dl>
<p>If no meta is available:</p><ul>
<li>char* is null (evaluates to 0)</li>
<li>const <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> is null (evaluate to false)</li>
<li>otherwise the default constructed type will be returned <dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#abb2c472e514ecef5fedb63ecae7c0f54">hasMeta</a></dd>
<dd>
<a class="el" href="classkdb_1_1Key.html#a2305da805095605aca38d53f2733fb57" title="Delete metadata for key. ">delMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a4c5a3d463127ade0b766c4298002daa3" title="Set metadata for key. ">setMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a53f6d2196a7f17c4bdc544207bdc5f4c" title="Do a shallow copy of meta data from source to dest. ">copyMeta()</a>, <a class="el" href="classkdb_1_1Key.html#aec0910bf293db33deac6a3f81359cb48" title="Do a shallow copy of all meta data from source to dest. ">copyAllMeta()</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="aa3903afe9a4b7aebf427a74612a803cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string kdb::Key::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the abbreviated real internal <code>key</code> name. </p>
<p>This is a much more efficient version of <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a> and can use it if you are responsible enough to not mess up things. You are not allowed to change anything in the returned array. The content of that string may change after <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> and similar functions. If you need a copy of the name, consider using <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>.</p>
<p>The name will be without owner, see <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a> if you need the name with its owner.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no keyName. The reason is <div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);</div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p>Valid key names are:</p>
<ul>
<li><code>spec/something</code> for specification of other keys.</li>
<li><code>proc/something</code> for in-memory keys, e.g. commandline.</li>
<li><code>dir/something</code> for dir keys in current working directory</li>
<li><code>system/something</code> for system keys in /etc or /</li>
<li><code>user/something</code> for user keys in home directory</li>
<li><code>user:username/something</code> for other users (deprecated: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> + <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> currently unsupported)</li>
<li><p class="startli"><code>/something</code> for cascading keys (actually refers to one of the above, see also <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a>)</p>
<dl class="section note"><dt>Note</dt><dd>Note that the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> method to set a new value. Use <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the keyname which must not be changed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no (a empty) keyname </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gabdbcfa51ed8a387e47ead207affa2d2e" title="Bytes needed to store the key name without owner. ">keyGetNameSize()</a> for the string length </dd>
<dd>
<a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23" title="Bytes needed to store the key name including user domain and ending NULL. ">keyGetFullNameSize()</a> to <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get</a> the full name </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a> as alternative to <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get</a> a <a class="el" href="classkdb_1_1Key.html#ab5bc93e22f4cf40b9d2b1fc32cc260be" title="Copy or Clear a key. ">copy</a> </dd>
<dd>
<a class="el" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner. ">keyOwner()</a> to <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get</a> a pointer to owner </dd>
<dd>
<a class="el" href="group__keyname.html#ga6fe6af4c27b35d911a533f4ae4d698bb" title="Returns a keyname which is null separated and does not use backslash for escaping. ">keyUnescapedName</a> to <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get</a> an unescaped <a class="el" href="group__key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyException</td><td>if key is null</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>unlike in the C version, it is safe to change the returned string. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="aee1d42f22eda4d84d78ab72cd60cc005"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::Key::getNameSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bytes needed to store the key name without owner. </p>
<p>For an empty key name you need one byte to store the ending NULL. For that reason 1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes needed, including ending NULL, to store key name without owner </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if there is is no key Name </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>, <a class="el" href="group__keyname.html#gab65dc9d43d3ee08d5e936a20ebbddd23" title="Bytes needed to store the key name including user domain and ending NULL. ">keyGetFullNameSize()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga5e7eff0c77678420199d0d2e8729152b" title="return size of unescaped name with embedded and terminating null characters ">keyGetUnescapedNameSize</a> to <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get</a> size of unescaped name </dd></dl>

</div>
</div>
<a class="anchor" id="a2cf2b97f404d5808f46a9a5c4b8b93e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string kdb::Key::getNamespace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>namespace as string</dd></dl>
<p>Will return slash for cascading names.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#aa3903afe9a4b7aebf427a74612a803cd" title="Returns a pointer to the abbreviated real internal key name. ">getName()</a>, <a class="el" href="classkdb_1_1Key.html#ab6103772c702b400eaefbc4665f5c0cf" title="Name starts with &quot;user&quot;. ">isUser()</a>, <a class="el" href="classkdb_1_1Key.html#ac0f21b82a3d851eb3dfae53ddcfdbe48" title="Name starts with &quot;system&quot;. ">isSystem()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a213fb46e13b669cc862fce06ac361b79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::Key::getReferenceCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return how many references the key has. </p>
<p>The reference counting is the essential property of keys to make sure that they can be put safely into data structures. E.g. if you put a <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> into a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/proper_name&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>); <span class="comment">// ref counter = 0</span></div>
<div class="line">KeySet *ks = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a> (1, k, KS_END);</div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(k); <span class="comment">// key will not be deleted, because its in the keyset</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a>(ks); <span class="comment">// now the key will be deleted</span></div>
</div><!-- fragment --><p> You can even add the key to more KeySets:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/proper_name&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>); <span class="comment">// ref counter 0</span></div>
<div class="line">KeySet *ks1 = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(1, k, KS_END); <span class="comment">// ref counter of k 1</span></div>
<div class="line">KeySet *ks2 = <a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(1, k, KS_END); <span class="comment">// ref counter of k 2</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a>(ks1); <span class="comment">// ref counter of k 1</span></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a>(ks2); <span class="comment">// k is now deleted</span></div>
</div><!-- fragment --><p> If you increment only by one with <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a> the same as said above is valid:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0); <span class="comment">// ref counter = 0</span></div>
<div class="line"><a class="code" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1">keyIncRef</a>(k); <span class="comment">// ref counter = 1</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(k); <span class="comment">// key will not be deleted</span></div>
<div class="line"><a class="code" href="group__key.html#ga2c6433ca22109e4e141946057eccb283">keyDecRef</a>(k);</div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(k);</div>
</div><!-- fragment --><p> or use <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a> more than once:</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0); <span class="comment">// ref counter 0</span></div>
<div class="line"><a class="code" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1">keyIncRef</a>(k); <span class="comment">// ref counter of key 1</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);   <span class="comment">// has no effect</span></div>
<div class="line"><a class="code" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1">keyIncRef</a>(k); <span class="comment">// ref counter of key 2</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);   <span class="comment">// has no effect</span></div>
<div class="line"><a class="code" href="group__key.html#ga2c6433ca22109e4e141946057eccb283">keyDecRef</a>(k); <span class="comment">// ref counter of key 1</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k);   <span class="comment">// has no effect</span></div>
<div class="line"><a class="code" href="group__key.html#ga2c6433ca22109e4e141946057eccb283">keyDecRef</a>(k); <span class="comment">// ref counter is now 0</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (k); <span class="comment">// k is now deleted</span></div>
</div><!-- fragment --><p> The key won't be deleted by a <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> as long refcounter is not 0.</p>
<p>The references will be incremented on successful calls to <a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a> or <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> will reset the references for dupped key.</dd></dl>
<p>For your own applications you can use <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a> and <a class="el" href="group__key.html#ga2c6433ca22109e4e141946057eccb283" title="Decrement the viability of a key object. ">keyDecRef()</a> for reference counting, too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of references </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a> and <a class="el" href="group__key.html#ga2c6433ca22109e4e141946057eccb283" title="Decrement the viability of a key object. ">keyDecRef()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbad98e920ffb6d65d5d690be73ae6d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string kdb::Key::getString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the string directly from the key.</dd></dl>
<p>It should be the same as <a class="el" href="classkdb_1_1Key.html#a0916e2e6be60b5c591bae56e250ed693" title="Get a key value. ">get()</a>. </p><dl class="section return"><dt>Returns</dt><dd>empty string on null pointers</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyException</td><td>on null key or not a valid size </td></tr>
    <tr><td class="paramname">KeyTypeMismatch</td><td>if key holds binary data and not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>unlike in the C version, it is safe to change the returned string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#aa60e37609593de715c342740c76040cc" title="Check if a key is string type. ">isString()</a>, <a class="el" href="classkdb_1_1Key.html#a16b64fd6db0a743e2e4ab08daf6fba73" title="Get the value of a key as a binary. ">getBinary()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af3032a91f0fbf111b6b5e42dd35865db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::Key::getStringSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes needed to store the key value, including the NULL terminator. </p>
<p>It returns the correct size, independent of the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> Type. If it is a binary there might be '\0' values in it.</p>
<p>For an empty string you need one byte to store the ending NULL. For that reason 1 is returned. This is not true for binary data, so there might be returned 0 too.</p>
<p>A binary key has no '\0' termination. String types have it, so to there length will be added 1 to have enough space to store it.</p>
<p>This method can be used with malloc() before <a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a> or <a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a> is called.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *buffer;</div>
<div class="line">buffer = malloc (<a class="code" href="group__keyvalue.html#gae326672fffb7474abfe9baf53b73217e">keyGetValueSize</a> (key));</div>
<div class="line"><span class="comment">// use this buffer to store the value (binary or string)</span></div>
<div class="line"><span class="comment">// pass keyGetValueSize (key) for maxSize</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes needed to store the key value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>when there is no data and type is not binary </td></tr>
    <tr><td class="paramname">0</td><td>when there is no data and type is binary </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a>, <a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a>, <a class="el" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af" title="Return a pointer to the real internal key value. ">keyValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3e0bbc6b746b89db7abb73a4cc2fff39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * kdb::Key::getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the real internal <code>key</code> value. </p>
<p>This is a much more efficient version of <a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a> <a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a>, and you should use it if you are responsible enough to not mess up things. You are not allowed to modify anything in the returned string. If you need a copy of the Value, consider to use <a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a> or <a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a> instead.</p>
<h1><a class="anchor" id="string"></a>
String Handling</h1>
<p>If <code>key</code> is string (<a class="el" href="group__keytest.html#gaea7670778abd07fee0fe8ac12a149190" title="Check if a key is string type. ">keyIsString()</a>), you may cast the returned as a <code>"char *"</code> because you'll get a NULL terminated regular string.</p>
<p><a class="el" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af" title="Return a pointer to the real internal key value. ">keyValue()</a> returns "" in string mode when there is no value. The reason is </p><div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2">keySetString</a>(key,<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(key); <span class="comment">// you would expect &quot;&quot; here</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);</div>
</div><!-- fragment --><h1><a class="anchor" id="binary"></a>
Binary Data Handling</h1>
<p>If the data is binary, the size of the value must be determined by <a class="el" href="group__keyvalue.html#gae326672fffb7474abfe9baf53b73217e" title="Returns the number of bytes needed to store the key value, including the NULL terminator. ">keyGetValueSize()</a>, any strlen() operations are not suitable to determine the size.</p>
<p><a class="el" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af" title="Return a pointer to the real internal key value. ">keyValue()</a> returns 0 in binary mode when there is no value. The reason is </p><div class="fragment"><div class="line">key=<a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(0);</div>
<div class="line"><a class="code" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7">keySetBinary</a>(key, 0, 0);</div>
<div class="line"><a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(key); <span class="comment">// you would expect 0 here</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7">keySetBinary</a>(key,<span class="stringliteral">&quot;&quot;</span>, 1);</div>
<div class="line"><a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(key); <span class="comment">// you would expect &quot;&quot; (a pointer to &#39;\0&#39;) here</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> i=23;</div>
<div class="line"><a class="code" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7">keySetBinary</a>(key, (<span class="keywordtype">void</span>*)&amp;i, 4);</div>
<div class="line">(<span class="keywordtype">int</span>*)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(key); <span class="comment">// you would expect a pointer to (int)23 here</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(key);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Note that the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by <a class="el" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af" title="Return a pointer to the real internal key value. ">keyValue()</a> method to set a new value. Use <a class="el" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2" title="Set the value for key as newStringValue. ">keySetString()</a> or <a class="el" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7" title="Set the value of a key as a binary. ">keySetBinary()</a> instead.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Binary keys will return a NULL pointer when there is no data in contrast to <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a>, <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a>, <a class="el" href="group__meta.html#gaf6485fb8599714b6bbd830cf915ffea5" title="Return a pointer to the real internal key owner. ">keyOwner()</a> and <a class="el" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a" title="Return a pointer to the real internal key comment. ">keyComment()</a>. For string value the behaviour is the same.</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">KDB *handle = <a class="code" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca">kdbOpen</a>();</div>
<div class="line">KeySet *ks=<a class="code" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew</a>(0, KS_END);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *current=0;</div>
<div class="line"></div>
<div class="line">kdbGetByName(handle,ks,<span class="stringliteral">&quot;system/sw/my&quot;</span>,<a class="code" href="group__keyset.html#gga98a3d6a4016c9dad9cbd1a99a9c2a45aad9d03b36ee88ca5a774cc01b190c99b8">KDB_O_SORT</a>|KDB_O_RECURSIVE);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a>(ks);</div>
<div class="line"><span class="keywordflow">while</span>(current=<a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a>(ks)) {</div>
<div class="line">        <span class="keywordtype">size_t</span> size=0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (keyIsBin(current)) {</div>
<div class="line">                size=<a class="code" href="group__keyvalue.html#gae326672fffb7474abfe9baf53b73217e">keyGetValueSize</a>(current);</div>
<div class="line">                printf(<span class="stringliteral">&quot;Key %s has a value of size %d bytes. Value: &lt;BINARY&gt;\nComment: %s&quot;</span>,</div>
<div class="line">                        <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(current),</div>
<div class="line">                        size,</div>
<div class="line">                        <a class="code" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a">keyComment</a>(current));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">                size=elektraStrLen((<span class="keywordtype">char</span> *)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(current));</div>
<div class="line">                printf(<span class="stringliteral">&quot;Key %s has a value of size %d bytes. Value: %s\nComment: %s&quot;</span>,</div>
<div class="line">                        <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(current),</div>
<div class="line">                        size,</div>
<div class="line">                        (<span class="keywordtype">char</span> *)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(current),</div>
<div class="line">                        <a class="code" href="group__meta.html#gac89fd319783b3457db45b4c09e55274a">keyComment</a>(current));</div>
<div class="line">        }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__keyset.html#ga27e5c16473b02a422238c8d970db7ac8">ksDel</a> (ks);</div>
<div class="line"><a class="code" href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f">kdbClose</a> (handle);</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to internal value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">""</td><td>when there is no data and key is not binary </td></tr>
    <tr><td class="paramname">0</td><td>where there is no data and key is binary </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#gae326672fffb7474abfe9baf53b73217e" title="Returns the number of bytes needed to store the key value, including the NULL terminator. ">keyGetValueSize()</a>, <a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a>, <a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the key </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#a16b64fd6db0a743e2e4ab08daf6fba73" title="Get the value of a key as a binary. ">getBinary()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb2c472e514ecef5fedb63ecae7c0f54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::hasMeta </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there is a metadata with given name </td></tr>
    <tr><td class="paramname">false</td><td>if no such metadata exists</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#a36e21abc1a5b8c3a8d3ee39f8f8b91fa" title="Returns the Value of a Meta-Information given by name. ">getMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a493893308d5b4c54d646cc0df5a076ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isBelow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the key check is below the key key or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the other key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if our key is below k</dd></dl>
<p>Example: </p><pre class="fragment">key user/sw/app
check user/sw/app/key
</pre><p>returns true because check is below key</p>
<p>Example: </p><pre class="fragment">key user/sw/app
check user/sw/app/folder/key
</pre><p>returns also true because check is indirect below key</p>
<p>Obviously, there is no key above a namespace (e.g. user, system, /):</p>
<pre class="fragment">key *
check user
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">check</td><td>the key to find the relative position of </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if check is below key </td></tr>
    <tr><td class="paramname">0</td><td>if it is not below or if it is the same key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>, <a class="el" href="group__keytest.html#ga4f175aafd98948ce6c774f3bd92b72ca" title="Check if the key check is direct below the key key or not. ">keyIsDirectBelow()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d4d2d50f9e3624ade560b0f74267d86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isBelowOrSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the other key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if our key is below k or the same as k</dd></dl>

</div>
</div>
<a class="anchor" id="aad92210fe2389ad950a47a4eca428574"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isBinary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a key is binary type. </p>
<p>The function checks if the key is a binary. Opposed to string values binary values can have '\0' inside the value and may not be terminated by a null character. Their disadvantage is that you need to pass their size.</p>
<p>Make sure to use this function and don't test the binary type another way to ensure compatibility and to write less error prone programs.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if it is binary </td></tr>
    <tr><td class="paramname">0</td><td>if it is not </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a>, <a class="el" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7" title="Set the value of a key as a binary. ">keySetBinary()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3cc66b309bd42e67d7bc0e4234aa76a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isDirectBelow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the key check is direct below the key key or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the other key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if our key is direct below k</dd></dl>
<pre class="fragment">Example:
key user/sw/app
check user/sw/app/key

returns true because check is below key

Example:
key user/sw/app
check user/sw/app/folder/key

does not return true, because there is only a indirect relation
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">check</td><td>the key to find the relative position of </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if check is below key </td></tr>
    <tr><td class="paramname">0</td><td>if it is not below or if it is the same key </td></tr>
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keytest.html#ga03332b5d97c76a4fd2640aca4762b8df" title="Check if the key check is below the key key or not. ">keyIsBelow()</a>, <a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a>, <a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adcd75cc13e9d766eaac72beb7d748bdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isInactive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a key is inactive. </p>
<p>In Elektra terminology a hierarchy of keys is inactive if the rootkey's basename starts with '.'. So a key is also inactive if it is below an inactive key. For example, user/key/.hidden is inactive and so is user/.hidden/below.</p>
<p>Inactive keys should not have any meaning to applications, they are only a convention reserved for users and administrators. To automatically remove all inactive keys for an application, consider to use the hidden plugin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if the key is inactive </td></tr>
    <tr><td class="paramname">0</td><td>if the key is active </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer or when key has no name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46ac7f1f28842e6edc03b2f97ae14bdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if C++ wrapper has an underlying key. </p>
<dl class="section see"><dt>See also</dt><dd>operator bool(), <a class="el" href="classkdb_1_1Key.html#acbb13cfcabb4548177e86eec1ac16d87">isValid()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if no underlying key exists </dd></dl>

</div>
</div>
<a class="anchor" id="aa60e37609593de715c342740c76040cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a key is string type. </p>
<p>String values are null terminated and are not allowed to have any '\0' characters inside the string.</p>
<p>Make sure to use this function and don't test the string type another way to ensure compatibility and to write less error prone programs.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if it is string </td></tr>
    <tr><td class="paramname">0</td><td>if it is not </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a>, <a class="el" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2" title="Set the value for key as newStringValue. ">keySetString()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0f21b82a3d851eb3dfae53ddcfdbe48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name starts with "system". </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if it is a system key </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6103772c702b400eaefbc4665f5c0cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isUser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name starts with "user". </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if it is a user key </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbb13cfcabb4548177e86eec1ac16d87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if the key is valid</dd></dl>
<p>An invalid key has no name. The name of valid keys either start with user or system.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the key has a valid name </td></tr>
    <tr><td class="paramname">false</td><td>if the key has an invalid name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#aa3903afe9a4b7aebf427a74612a803cd" title="Returns a pointer to the abbreviated real internal key name. ">getName()</a>, <a class="el" href="classkdb_1_1Key.html#ab6103772c702b400eaefbc4665f5c0cf" title="Name starts with &quot;user&quot;. ">isUser()</a>, <a class="el" href="classkdb_1_1Key.html#ac0f21b82a3d851eb3dfae53ddcfdbe48" title="Name starts with &quot;system&quot;. ">isSystem()</a>, <a class="el" href="classkdb_1_1Key.html#a2cf2b97f404d5808f46a9a5c4b8b93e1">getNamespace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab727b6254fec01a129d3e6ac681a5fe5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::needSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a key needs to be synced to backend storage. </p>
<p>If any key modification took place the key will be flagged so that <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> knows which keys were modified and which not.</p>
<p>After <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a> the flag will normally be set, but after <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> and <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> the flag will be removed. When you modify the key the flag will be set again.</p>
<p>In your application you can make use of that flag to know if you changed something in a key after a <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> or <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Note that the sync status will be updated on any change, including meta data.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>The handling of synchronization is done internally and does not need to be checked by neither application nor plugins.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>after <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, <a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> keys need sync</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if <code>key</code> was changed in memory, 0 otherwise </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a855f37fef58a4ea4006d9e281f66cfe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classkdb_1_1Key.html">Key</a> kdb::Key::nextMeta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate to the next meta information. </p>
<p>Keys have an internal cursor that can be reset with <a class="el" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9" title="Rewind the internal iterator to first meta data. ">keyRewindMeta()</a>. Every time <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a> is called the cursor is incremented and the new current Name of Meta Information is returned.</p>
<p>You'll get a NULL pointer if the meta information after the end of the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> was reached. On subsequent calls of <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a> it will still return the NULL pointer.</p>
<p>The <code>key</code> internal cursor will be changed, so it is not const.</p>
<dl class="section note"><dt>Note</dt><dd>That the resulting key is guaranteed to have a value, because meta information has no binary or null pointer semantics.</dd>
<dd>
You must not delete or change the returned key, use <a class="el" href="group__keymeta.html#gae1f15546b234ffb6007d8a31178652b9" title="Set a new Meta-Information. ">keySetMeta()</a> if you want to delete or change it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a key representing meta information </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the end is reached </td></tr>
    <tr><td class="paramname">0</td><td>on NULL pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9" title="Returns the next Key in a KeySet. ">ksNext()</a> for pedant in iterator interface of <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a></dd>
<dd>
<a class="el" href="classkdb_1_1Key.html#adf6171b76e01c2b84c6050d43673dd97" title="Rewind the internal iterator to first meta data. ">rewindMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a2be586ccd64cd280561ba5cd23f6ff1e" title="Returns the Value of a Meta-Information which is current. ">currentMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac203d41896988df49dd149c2a6ad91d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kdb::Key::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is for loops and lookups only. </p>
<p>Opposite of <a class="el" href="classkdb_1_1Key.html#a46ac7f1f28842e6edc03b2f97ae14bdc" title="Checks if C++ wrapper has an underlying key. ">isNull()</a></p>
<p>For loops it checks if there are still more keys. For lookups it checks if a key could be found.</p>
<dl class="section warning"><dt>Warning</dt><dd>you should not construct or use null keys</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#a46ac7f1f28842e6edc03b2f97ae14bdc" title="Checks if C++ wrapper has an underlying key. ">isNull()</a>, <a class="el" href="classkdb_1_1Key.html#acbb13cfcabb4548177e86eec1ac16d87">isValid()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false on null keys </dd>
<dd>
true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a313a84b686a72769ecf4c368a79d492c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the name of two keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.</dd></dl>
<p>The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p><a class="el" href="group__keytest.html#gaf6e66e12fe04d535a5d1c8218ced803e" title="Compare the name of two keys. ">keyCmp()</a> defines the sorting order for a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p>The following 3 points are the rules for null values:</p>
<ul>
<li>A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.</li>
<li>A null name will be found to be smaller than every other name. If both are null names, 0 is returned.</li>
</ul>
<p>If the name is equal then:</p>
<ul>
<li>No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>the owner will only be used if the names are equal.</dd></dl>
<p>Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see <a class="el" href="group__keytest.html#ga6bb0f95ac34ce9c42d61bb35a76139d0" title="Information about the relation in the hierarchy between two keys. ">keyRel()</a>.</p>
<p>Given any Keys k1 and k2 constructed with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, following equation hold true:</p>
<div class="fragment"></div><!-- fragment --><p> Here are some more examples: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/b&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>And even more: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;markus&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;max&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>Do not strcmp the <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> yourself because the result differs from simple ascii comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k1</td><td>the first key object to compare with </td></tr>
    <tr><td class="paramname">k2</td><td>the second key object to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>, <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a> will compare keys when appending </dd>
<dd>
<a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> will compare keys during searching</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>!= 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e0dd36c31cc7c46ee1cda0decc6e884"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::Key * kdb::Key::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a abbreviation for getKey. </p>
<p>Passes out the raw key pointer. This pointer can be used to directly change the underlying key object.</p>
<dl class="section note"><dt>Note</dt><dd>that the ownership remains in the object</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#ae81381365a7c159f070e74a7b7bd8688" title="Passes out the raw key pointer. ">getKey()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a31f7139c5378b3fde4dfab4955208d23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the viability of a key object. </p>
<p>This function is intended for applications using their own reference counter for key objects. With it you can increment the reference and thus avoid destruction of the object in a subsequent <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a>.</p>
<p>The reference counter can't be incremented once it reached SSIZE_MAX. In that situation nothing will happen and SSIZE_MAX will be returned.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> will reset the references for dupped key.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the new reference counter </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
    <tr><td class="paramname">SSIZE_MAX</td><td>when maximum exceeded </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae" title="Return how many references the key has. ">keyGetRef()</a> for longer explanation, <a class="el" href="group__key.html#ga2c6433ca22109e4e141946057eccb283" title="Decrement the viability of a key object. ">keyDecRef()</a>, <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab017ed5e104e441d86725f61439d1f24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the viability of a key object. </p>
<p>This function is intended for applications using their own reference counter for key objects. With it you can increment the reference and thus avoid destruction of the object in a subsequent <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a>.</p>
<p>The reference counter can't be incremented once it reached SSIZE_MAX. In that situation nothing will happen and SSIZE_MAX will be returned.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> will reset the references for dupped key.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the new reference counter </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
    <tr><td class="paramname">SSIZE_MAX</td><td>when maximum exceeded </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae" title="Return how many references the key has. ">keyGetRef()</a> for longer explanation, <a class="el" href="group__key.html#ga2c6433ca22109e4e141946057eccb283" title="Decrement the viability of a key object. ">keyDecRef()</a>, <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acbb63da4ab49c66c851228511c000ec7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the viability of a key object. </p>
<p>The references will be decremented for <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a> or successful calls of <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> with the option KDB_O_POP. It will also be decremented with an following <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> in the case that an old key is replaced with another key with the same name.</p>
<p>The reference counter can't be decremented once it reached 0. In that situation nothing will happen and 0 will be returned.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> will reset the references for dupped key.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the new reference counter </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
    <tr><td class="paramname">0</td><td>when the key is ready to be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae" title="Return how many references the key has. ">keyGetRef()</a> for longer explanation, <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a>, <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa095fe7021b7ca01e6224b976449b3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement the viability of a key object. </p>
<p>The references will be decremented for <a class="el" href="group__keyset.html#gae42530b04defb772059de0600159cf69" title="Remove and return the last key of ks. ">ksPop()</a> or successful calls of <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> with the option KDB_O_POP. It will also be decremented with an following <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a> in the case that an old key is replaced with another key with the same name.</p>
<p>The reference counter can't be decremented once it reached 0. In that situation nothing will happen and 0 will be returned.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__key.html#gae6ec6a60cc4b8c1463fa08623d056ce3" title="Return a duplicate of a key. ">keyDup()</a> will reset the references for dupped key.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the new reference counter </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointer </td></tr>
    <tr><td class="paramname">0</td><td>when the key is ready to be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#ga4aabc4272506dd63161db2bbb42de8ae" title="Return how many references the key has. ">keyGetRef()</a> for longer explanation, <a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects. ">keyDel()</a>, <a class="el" href="group__key.html#ga6970a6f254d67af7e39f8e469bb162f1" title="Increment the viability of a key object. ">keyIncRef()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab64ec9d578e083dad3e43322535cf108"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> * kdb::Key::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to this object</dd></dl>
<p>Needed for <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a> iterators. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1KeySetIterator.html" title="For C++ forward Iteration over KeySets. ">KeySetIterator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aace409efd393ae21f08d333f45da2769"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the name of two keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.</dd></dl>
<p>The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p><a class="el" href="group__keytest.html#gaf6e66e12fe04d535a5d1c8218ced803e" title="Compare the name of two keys. ">keyCmp()</a> defines the sorting order for a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p>The following 3 points are the rules for null values:</p>
<ul>
<li>A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.</li>
<li>A null name will be found to be smaller than every other name. If both are null names, 0 is returned.</li>
</ul>
<p>If the name is equal then:</p>
<ul>
<li>No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>the owner will only be used if the names are equal.</dd></dl>
<p>Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see <a class="el" href="group__keytest.html#ga6bb0f95ac34ce9c42d61bb35a76139d0" title="Information about the relation in the hierarchy between two keys. ">keyRel()</a>.</p>
<p>Given any Keys k1 and k2 constructed with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, following equation hold true:</p>
<div class="fragment"></div><!-- fragment --><p> Here are some more examples: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/b&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>And even more: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;markus&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;max&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>Do not strcmp the <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> yourself because the result differs from simple ascii comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k1</td><td>the first key object to compare with </td></tr>
    <tr><td class="paramname">k2</td><td>the second key object to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>, <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a> will compare keys when appending </dd>
<dd>
<a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> will compare keys during searching</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>&lt; 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b466f59870b989aa9ec41558bba4d19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the name of two keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.</dd></dl>
<p>The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p><a class="el" href="group__keytest.html#gaf6e66e12fe04d535a5d1c8218ced803e" title="Compare the name of two keys. ">keyCmp()</a> defines the sorting order for a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p>The following 3 points are the rules for null values:</p>
<ul>
<li>A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.</li>
<li>A null name will be found to be smaller than every other name. If both are null names, 0 is returned.</li>
</ul>
<p>If the name is equal then:</p>
<ul>
<li>No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>the owner will only be used if the names are equal.</dd></dl>
<p>Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see <a class="el" href="group__keytest.html#ga6bb0f95ac34ce9c42d61bb35a76139d0" title="Information about the relation in the hierarchy between two keys. ">keyRel()</a>.</p>
<p>Given any Keys k1 and k2 constructed with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, following equation hold true:</p>
<div class="fragment"></div><!-- fragment --><p> Here are some more examples: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/b&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>And even more: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;markus&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;max&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>Do not strcmp the <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> yourself because the result differs from simple ascii comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k1</td><td>the first key object to compare with </td></tr>
    <tr><td class="paramname">k2</td><td>the second key object to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>, <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a> will compare keys when appending </dd>
<dd>
<a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> will compare keys during searching</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>&lt;= 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a628f3ee543a1d71d4488233018eddd86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> &amp; kdb::Key::operator= </td>
          <td>(</td>
          <td class="paramtype">ckdb::Key *&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a C key. </p>
<p>Will call del() on the old key. </p>

</div>
</div>
<a class="anchor" id="a63a006c140cfd2a633c6fdf3f9eb9d1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkdb_1_1Key.html">Key</a> &amp; kdb::Key::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a key. </p>
<p>Will call del() on the old key. </p>

</div>
</div>
<a class="anchor" id="abaff8356eb91a6d3aed2b6d282269da2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the name of two keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.</dd></dl>
<p>The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p><a class="el" href="group__keytest.html#gaf6e66e12fe04d535a5d1c8218ced803e" title="Compare the name of two keys. ">keyCmp()</a> defines the sorting order for a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p>The following 3 points are the rules for null values:</p>
<ul>
<li>A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.</li>
<li>A null name will be found to be smaller than every other name. If both are null names, 0 is returned.</li>
</ul>
<p>If the name is equal then:</p>
<ul>
<li>No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>the owner will only be used if the names are equal.</dd></dl>
<p>Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see <a class="el" href="group__keytest.html#ga6bb0f95ac34ce9c42d61bb35a76139d0" title="Information about the relation in the hierarchy between two keys. ">keyRel()</a>.</p>
<p>Given any Keys k1 and k2 constructed with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, following equation hold true:</p>
<div class="fragment"></div><!-- fragment --><p> Here are some more examples: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/b&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>And even more: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;markus&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;max&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>Do not strcmp the <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> yourself because the result differs from simple ascii comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k1</td><td>the first key object to compare with </td></tr>
    <tr><td class="paramname">k2</td><td>the second key object to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>, <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a> will compare keys when appending </dd>
<dd>
<a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> will compare keys during searching</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>== 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bd2b165eeade6a71401b9b122864bad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the name of two keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.</dd></dl>
<p>The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p><a class="el" href="group__keytest.html#gaf6e66e12fe04d535a5d1c8218ced803e" title="Compare the name of two keys. ">keyCmp()</a> defines the sorting order for a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p>The following 3 points are the rules for null values:</p>
<ul>
<li>A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.</li>
<li>A null name will be found to be smaller than every other name. If both are null names, 0 is returned.</li>
</ul>
<p>If the name is equal then:</p>
<ul>
<li>No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>the owner will only be used if the names are equal.</dd></dl>
<p>Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see <a class="el" href="group__keytest.html#ga6bb0f95ac34ce9c42d61bb35a76139d0" title="Information about the relation in the hierarchy between two keys. ">keyRel()</a>.</p>
<p>Given any Keys k1 and k2 constructed with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, following equation hold true:</p>
<div class="fragment"></div><!-- fragment --><p> Here are some more examples: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/b&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>And even more: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;markus&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;max&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>Do not strcmp the <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> yourself because the result differs from simple ascii comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k1</td><td>the first key object to compare with </td></tr>
    <tr><td class="paramname">k2</td><td>the second key object to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>, <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a> will compare keys when appending </dd>
<dd>
<a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> will compare keys during searching</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>&gt; 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1258657e3dbddf4aed3716dd63d2a3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool kdb::Key::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkdb_1_1Key.html">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare the name of two keys. </p>
<dl class="section return"><dt>Returns</dt><dd>a number less than, equal to or greater than zero if k1 is found, respectively, to be less than, to match, or be greater than k2.</dd></dl>
<p>The comparison is based on a strcmp of the keynames, and iff they match a strcmp of the owner will be used to distuingish. If even this matches the keys are found to be exactly the same and 0 is returned. These two keys can't be used in the same <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p><a class="el" href="group__keytest.html#gaf6e66e12fe04d535a5d1c8218ced803e" title="Compare the name of two keys. ">keyCmp()</a> defines the sorting order for a <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a>.</p>
<p>The following 3 points are the rules for null values:</p>
<ul>
<li>A null pointer will be found to be smaller than every other key. If both are null pointers, 0 is returned.</li>
<li>A null name will be found to be smaller than every other name. If both are null names, 0 is returned.</li>
</ul>
<p>If the name is equal then:</p>
<ul>
<li>No owner will be found to be smaller then every other owner. If both don't have a owner, 0 is returned.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>the owner will only be used if the names are equal.</dd></dl>
<p>Often is enough to know if the other key is less then or greater then the other one. But Sometimes you need more precise information, see <a class="el" href="group__keytest.html#ga6bb0f95ac34ce9c42d61bb35a76139d0" title="Information about the relation in the hierarchy between two keys. ">keyRel()</a>.</p>
<p>Given any Keys k1 and k2 constructed with <a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, following equation hold true:</p>
<div class="fragment"></div><!-- fragment --><p> Here are some more examples: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/b&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>And even more: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k1 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;markus&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *k2 = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/a&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40a77ca60362fa8daca8d5347db4385068b">KEY_OWNER</a>, <span class="stringliteral">&quot;max&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// keyCmp(k1,k2) &lt; 0</span></div>
<div class="line"><span class="comment">// keyCmp(k2,k1) &gt; 0</span></div>
</div><!-- fragment --><p>Do not strcmp the <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> yourself because the result differs from simple ascii comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k1</td><td>the first key object to compare with </td></tr>
    <tr><td class="paramname">k2</td><td>the second key object to compare with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45" title="Appends a Key to the end of ks. ">ksAppendKey()</a>, <a class="el" href="group__keyset.html#ga21eb9c3a14a604ee3a8bdc779232e7b7" title="Append all toAppend contained keys to the end of the ks. ">ksAppend()</a> will compare keys when appending </dd>
<dd>
<a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a> will compare keys during searching</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>&gt;= 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ae719043e6e99f5f3d6fb85837306f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ckdb::Key * kdb::Key::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Passes out the raw key pointer and resets internal key handle. </p>
<dl class="section note"><dt>Note</dt><dd>that the ownership is moved outside.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no key is held (null pointer), no action is done then. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf6171b76e01c2b84c6050d43673dd97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::rewindMeta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewind the internal iterator to first meta data. </p>
<p>Use it to set the cursor to the beginning of the <a class="el" href="classkdb_1_1Key.html" title="Key is an essential class that encapsulates key name , value  and metainfo . ">Key</a> Meta Infos. <a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869" title="Returns the Value of a Meta-Information which is current. ">keyCurrentMeta()</a> will then always return NULL afterwards. So you want to <a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a> first.</p>
<div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *key;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> *meta;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__keymeta.html#ga5dbb669802eea27e106ee3a5e39717a9">keyRewindMeta</a> (key);</div>
<div class="line"><span class="keywordflow">while</span> ((meta = <a class="code" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048">keyNextMeta</a> (key))!=0)</div>
<div class="line">{</div>
<div class="line">        printf (<span class="stringliteral">&quot;name: %s, value: %s&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(meta), (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(meta));</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">0</td><td>if there is no meta information for that key (<a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a> will always return 0 in that case) </td></tr>
    <tr><td class="paramname">-1</td><td>on NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga4c88342f580a4291455a801af71ce048" title="Iterate to the next meta information. ">keyNextMeta()</a>, <a class="el" href="group__keymeta.html#ga74a273f529030f4947df52e14fdd2869" title="Returns the Value of a Meta-Information which is current. ">keyCurrentMeta()</a> </dd>
<dd>
<a class="el" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70" title="Rewinds the KeySet internal cursor. ">ksRewind()</a> for pedant in iterator interface of <a class="el" href="classkdb_1_1KeySet.html" title="A keyset holds together a set of keys. ">KeySet</a></dd>
<dd>
<a class="el" href="classkdb_1_1Key.html#a855f37fef58a4ea4006d9e281f66cfe1" title="Iterate to the next meta information. ">nextMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a2be586ccd64cd280561ba5cd23f6ff1e" title="Returns the Value of a Meta-Information which is current. ">currentMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a615124f0a2b291e03975b49c233654d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::set </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a key value. </p>
<p>Set the value for <code>key</code> as <code>newStringValue</code>. The function will allocate and save a private copy of <code>newStringValue</code>, so the parameter can be freed after the call.</p>
<p>String values will be saved in backend storage, when kdbSetKey() will be called, in UTF-8 universal encoding, regardless of the program's current encoding, when iconv plugin is present.</p>
<dl class="section note"><dt>Note</dt><dd>The type will be set to KEY_TYPE_STRING. When the type of the key is already a string type it won't be changed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to set the string value </td></tr>
    <tr><td class="paramname">newStringValue</td><td>NULL-terminated text string to be set as <code>key's</code> value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually saved in private struct including final NULL </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if newStringValue is a NULL pointer, this will make the string empty (string only containing null termination) </td></tr>
    <tr><td class="paramname">-1</td><td>if key is a NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a>, <a class="el" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af" title="Return a pointer to the real internal key value. ">keyValue()</a>, <a class="el" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05" title="Get the c-string representing the value. ">keyString()</a></dd></dl>
<p>This method tries to deserialise the string to the given type. </p>

</div>
</div>
<a class="anchor" id="a0c8c7cef03d6482d89973be72fb3c8b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::setBaseName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a base name for a key. </p>
<p>Sets <code>baseName</code> as the new basename for <code>key</code>. Only the baseName will be affected and no other part of the key.</p>
<p>All text after the last <code>'/'</code> in the <code>key</code> keyname is erased and <code>baseName</code> is appended.</p>
<p>So let us suppose <code>key</code> has name <code>"system/dir1/dir2/key1"</code>. If <code>baseName</code> is <code>"key2"</code>, the resulting key name will be <code>"system/dir1/dir2/key2"</code>. If <code>baseName</code> is empty or NULL, the resulting key name will be <code>"system/dir1/dir2"</code>.</p>
<p>This function does proper escaping on the supplied name argument.</p>
<p>You can use all names to set as basename (e.g. . (dot), .. (dot-dot), % and "" (empty)). They will be properly escaped.</p>
<p>A simple example is: </p><div class="fragment"><div class="line"><a class="code" href="classkdb_1_1Key.html#a5679f5cae63caddd64a60388b9cc77fa">Key</a> * k = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a>(<span class="stringliteral">&quot;user/my/long/name&quot;</span>, <a class="code" href="group__key.html#gga91fb3178848bd682000958089abbaf40aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a>(k, <span class="stringliteral">&quot;myname&quot;</span>);</div>
<div class="line">printf (<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k)); <span class="comment">// will print user/my/long/myname</span></div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(k);</div>
</div><!-- fragment --><p> If you want to add and not change the basename, use <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a> instead. If you do not want escaping, use <a class="el" href="group__keyname.html#gaa70593a2c772c4b7bc33423b9b10a270" title="Add a already escaped name to the keyname. ">keyAddName()</a> instead.</p>
<p>To add an inactive key name, use: </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a>(k, <span class="stringliteral">&quot;.hiddenkey&quot;</span>);</div>
<div class="line">        succeed_if_same_string(<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k), <span class="stringliteral">&quot;system/.hiddenkey&quot;</span>);</div>
<div class="line">        succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a>(k), <span class="stringliteral">&quot;.hiddenkey&quot;</span>);</div>
</div><!-- fragment --><p> When you want to add an array item, use: </p><div class="fragment"><div class="line">        <a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (k, <span class="stringliteral">&quot;system/valid&quot;</span>);</div>
<div class="line">        <a class="code" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407">keySetBaseName</a>(k, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">        succeed_if_same_string(<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(k), <span class="stringliteral">&quot;system/%&quot;</span>);</div>
<div class="line">        succeed_if_same_string(<a class="code" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5">keyBaseName</a>(k), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html" title="Methods to do various operations on Key names. ">Name Manipulation Methods</a> for more details on special names</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">baseName</td><td>the string used to overwrite the basename of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the new key name </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on NULL pointers </td></tr>
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9" title="Set a new name to a key. ">keySetName()</a> to <a class="el" href="classkdb_1_1Key.html#a615124f0a2b291e03975b49c233654d7" title="Set a key value. ">set</a> a new name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyInvalidName</td><td>if the name is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7211129a4b95f4d1e335dcd06e9bf0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t kdb::Key::setBinary </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>newBinary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of a key as a binary. </p>
<p>A private copy of <code>newBinary</code> will allocated and saved inside <code>key</code>, so the parameter can be deallocated after the call.</p>
<p>Binary values might be encoded in another way then string values depending on the plugin. Typically character encodings should not take place on binary data. Consider using a string key instead.</p>
<p>When newBinary is a NULL pointer the binary will be freed and 0 will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>The meta data "binary" will be set to mark that the key is binary from now on. When the key is already binary the meta data won't be changed. This will only happen in the successful case, but not when -1 is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the object on which to set the value </td></tr>
    <tr><td class="paramname">newBinary</td><td>is a pointer to any binary data or NULL to free the previous set data </td></tr>
    <tr><td class="paramname">dataSize</td><td>number of bytes to copy from <code>newBinary</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually copied to internal struct storage </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>when the internal binary was freed and is now a null pointer </td></tr>
    <tr><td class="paramname">-1</td><td>if key is a NULL pointer </td></tr>
    <tr><td class="paramname">-1</td><td>when dataSize is 0 (but newBinary not NULL) or larger than SSIZE_MAX </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#ga4c0d8a4a11174197699c231e0b5c3c84" title="Get the value of a key as a binary. ">keyGetBinary()</a> </dd>
<dd>
<a class="el" href="group__keytest.html#ga9526b371087564e43e3dff8ad0dac949" title="Check if a key is binary type. ">keyIsBinary()</a> to check if the type is binary </dd>
<dd>
<a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a> and <a class="el" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2" title="Set the value for key as newStringValue. ">keySetString()</a> as preferred alternative to binary </dd></dl>

</div>
</div>
<a class="anchor" id="a4c5a3d463127ade0b766c4298002daa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::setMeta </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set metadata for key. </p>
<p>Set a new Meta-Information. Will set a new Meta-Information pair consisting of metaName and newMetaString.</p>
<p>Will add a new Pair for Meta-Information if metaName was not added up to now.</p>
<p>It will modify a existing Pair of Meta-Information if the the metaName was inserted already.</p>
<p>It will remove a meta information if newMetaString is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">metaName</td><td>the name of the meta information where you want to change the value </td></tr>
    <tr><td class="paramname">newMetaString</td><td>the new value for the meta information </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error if key or metaName is 0, out of memory or names are not valid </td></tr>
    <tr><td class="paramname">0</td><td>if the Meta-Information for metaName was removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size (&gt;0) of newMetaString if Meta-Information was successfully added </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keymeta.html#ga9ed3875495ddb3d8a8d29158a60a147c" title="Returns the Value of a Meta-Information given by name. ">keyGetMeta()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>unlike the C Interface, it is not possible to remove metadata with this method. k.setMeta("something", NULL) will lead to set the number 0 or to something different (may depend on compiler definition of NULL). See discussion in Issue <a href="https://github.com/ElektraInitiative/libelektra/issues/8">https://github.com/ElektraInitiative/libelektra/issues/8</a></dd></dl>
<p>Use <a class="el" href="classkdb_1_1Key.html#a2305da805095605aca38d53f2733fb57" title="Delete metadata for key. ">delMeta()</a> to avoid these issues.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classkdb_1_1Key.html#a2305da805095605aca38d53f2733fb57" title="Delete metadata for key. ">delMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a36e21abc1a5b8c3a8d3ee39f8f8b91fa" title="Returns the Value of a Meta-Information given by name. ">getMeta()</a>, <a class="el" href="classkdb_1_1Key.html#a53f6d2196a7f17c4bdc544207bdc5f4c" title="Do a shallow copy of meta data from source to dest. ">copyMeta()</a>, <a class="el" href="classkdb_1_1Key.html#aec0910bf293db33deac6a3f81359cb48" title="Do a shallow copy of all meta data from source to dest. ">copyAllMeta()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aac3b5d3a854d02187484bfbdbdf975af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new name to a key. </p>
<p>A valid name is one of the forms:</p><ul>
<li><code>spec/something</code> for specification of other keys.</li>
<li><code>proc/something</code> for in-memory keys, e.g. commandline.</li>
<li><code>dir/something</code> for dir keys in current working directory</li>
<li><code>system/something</code> for system keys in /etc or /</li>
<li><code>user/something</code> for user keys in home directory</li>
<li><code>user:username/something</code> for other users (deprecated: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> + <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> currently unsupported)</li>
<li><code>/something</code> for cascading keys (actually refers to one of the above, see also <a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a>)</li>
</ul>
<p>An invalid name either has an invalid namespace or a wrongly escaped \ at the end of the name.</p>
<p>See <a class="el" href="group__keyname.html">key names </a> for the exact rules.</p>
<p>The last form has explicitly set the owner, to let the library know in which user folder to save the key. A owner is a user name. If it is not defined (the second form) current user is used.</p>
<p>You should always follow the guidelines for key tree structure creation.</p>
<p>A private copy of the key name will be stored, and the <code>newName</code> parameter can be freed after this call.</p>
<p>.., . and / will be handled as in filesystem pathes. A valid name will be build out of the (valid) name what you pass, e.g. user///sw/../sw//././MyApp -&gt; user/sw/MyApp</p>
<p>On invalid names, NULL or "" the name will be "" afterwards.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">size</td><td>in bytes of this new key name including ending NULL </td></tr>
    <tr><td class="paramname">0</td><td>if newName is an empty string or a NULL pointer (name will be empty afterwards) </td></tr>
    <tr><td class="paramname">-1</td><td>if newName is invalid (name will be empty afterwards) </td></tr>
    <tr><td class="paramname">-1</td><td>if key was inserted to a keyset before </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key object to work with </td></tr>
    <tr><td class="paramname">newName</td><td>the new key name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89" title="A practical way to fully create a Key object in one step. ">keyNew()</a>, <a class="el" href="group__meta.html#ga88d6ec200ba0707b7c1b4a88133d2be4" title="Set the owner of a key. ">keySetOwner()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#gab29a850168d9b31c9529e90cf9ab68be" title="Get abbreviated key name (without owner name). ">keyGetName()</a>, <a class="el" href="group__keyname.html#gaaba1494a5ffc976e0e56c43f4334a23c" title="Get key full name, including the user domain name. ">keyGetFullName()</a>, <a class="el" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513" title="Returns a pointer to the abbreviated real internal key name. ">keyName()</a> </dd>
<dd>
<a class="el" href="group__keyname.html#ga6e804bd453f98c28b0ff51430d1df407" title="Sets baseName as the new basename for key. ">keySetBaseName()</a>, <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a> to manipulate a name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KeyInvalidName</td><td>if the name is not valid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab97ef37aa235f0ae04dc6e6c21109d1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void kdb::Key::setString </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value for <code>key</code> as <code>newStringValue</code>. </p>
<p>The function will allocate and save a private copy of <code>newStringValue</code>, so the parameter can be freed after the call.</p>
<p>String values will be saved in backend storage, when kdbSetKey() will be called, in UTF-8 universal encoding, regardless of the program's current encoding, when iconv plugin is present.</p>
<dl class="section note"><dt>Note</dt><dd>The type will be set to KEY_TYPE_STRING. When the type of the key is already a string type it won't be changed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key to set the string value </td></tr>
    <tr><td class="paramname">newStringValue</td><td>NULL-terminated text string to be set as <code>key's</code> value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes actually saved in private struct including final NULL </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if newStringValue is a NULL pointer, this will make the string empty (string only containing null termination) </td></tr>
    <tr><td class="paramname">-1</td><td>if key is a NULL pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__keyvalue.html#ga41b9fac5ccddafe407fc0ae1e2eb8778" title="Get the value of a key as a string. ">keyGetString()</a>, <a class="el" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af" title="Return a pointer to the real internal key value. ">keyValue()</a>, <a class="el" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05" title="Get the c-string representing the value. ">keyString()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>key.hpp</li>
<li>kdbvalue.hpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
