\hypertarget{group__meta}{}\doxysection{Meta Data proposal+compatibility}
\label{group__meta}\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}


Meta data proposal+compatibility methods.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \mbox{\hyperlink{group__meta_gac89fd319783b3457db45b4c09e55274a}{key\+Comment}} (const Key $\ast$key)
\begin{DoxyCompactList}\small\item\em Return a pointer to the real internal {\ttfamily key} comment. \end{DoxyCompactList}\item 
ssize\+\_\+t \mbox{\hyperlink{group__meta_ga0dd737fadc16d4cf16720d17f066a9d3}{key\+Get\+Comment\+Size}} (const Key $\ast$key)
\begin{DoxyCompactList}\small\item\em Calculates number of bytes needed to store a key comment, including final NULL. \end{DoxyCompactList}\item 
ssize\+\_\+t \mbox{\hyperlink{group__meta_gafb89735689929ff717cc9f2d0d0b46a2}{key\+Get\+Comment}} (const Key $\ast$key, char $\ast$returned\+Comment, size\+\_\+t max\+Size)
\begin{DoxyCompactList}\small\item\em Get the key comment. \end{DoxyCompactList}\item 
ssize\+\_\+t \mbox{\hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment}} (Key $\ast$key, const char $\ast$new\+Comment)
\begin{DoxyCompactList}\small\item\em Set a comment for a key. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__meta_gab8b30dfabb0867bd6899e60e7bd193a2}{elektra\+Key\+Cmp\+Order}} (const Key $\ast$ka, const Key $\ast$kb)
\begin{DoxyCompactList}\small\item\em Compare the order metadata of two keys. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__meta_ga166c65c4eb2d758ced57b0bd74fb9a57}{elektra\+Meta\+Array\+Add}} (Key $\ast$key, const char $\ast$meta\+Name, const char $\ast$value)
\begin{DoxyCompactList}\small\item\em creates an metadata array or appends another element to an existing metadata array e.\+g. \end{DoxyCompactList}\item 
Key\+Set $\ast$ \mbox{\hyperlink{group__meta_gacee3e2d9285dd2bde975a09fdbe50502}{elektra\+Meta\+Array\+To\+KS}} (Key $\ast$key, const char $\ast$meta\+Name)
\begin{DoxyCompactList}\small\item\em Create a {\ttfamily Key\+Set} from a metakey array. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{group__meta_gaadfae80314be2415a7654fe8a0d2ee82}{elektra\+Sort\+Topology}} (Key\+Set $\ast$ks, Key $\ast$$\ast$array)
\begin{DoxyCompactList}\small\item\em topological sorting \end{DoxyCompactList}\item 
char $\ast$ \mbox{\hyperlink{group__meta_ga40469799e2c6e9937eaf013bfc05d014}{elektra\+Meta\+Array\+To\+String}} (const Key $\ast$key, const char $\ast$meta\+Name, const char $\ast$delim)
\begin{DoxyCompactList}\small\item\em returns the metakey array as a string separated by delim \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Meta data proposal+compatibility methods. 

In versions before Elektra 0.\+8 only limited metadata was available. Now any metadata can be added. These API methods are implementations of the 0.\+7 API using 0.\+8 metadata.

Additionally, new suggestions can be made here.

It is planned that these methods will be generated from doc/\+METADATA.\+ini and moved to a separate library. Currently, you should better avoid the methods and directly use \mbox{\hyperlink{group__keymeta}{metainfo }} instead. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__meta_gab8b30dfabb0867bd6899e60e7bd193a2}\label{group__meta_gab8b30dfabb0867bd6899e60e7bd193a2}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!elektraKeyCmpOrder@{elektraKeyCmpOrder}}
\index{elektraKeyCmpOrder@{elektraKeyCmpOrder}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{elektraKeyCmpOrder()}{elektraKeyCmpOrder()}}
{\footnotesize\ttfamily int elektra\+Key\+Cmp\+Order (\begin{DoxyParamCaption}\item[{const Key $\ast$}]{ka,  }\item[{const Key $\ast$}]{kb }\end{DoxyParamCaption})}



Compare the order metadata of two keys. 

\begin{DoxyReturn}{Returns}
a number less than, equal to or greater than zero if the order of k1 is found, respectively, to be less than, to match, or be greater than the order of k2. If one key is NULL, but the other isn\textquotesingle{}t, the key which is not NULL is considered to be greater. If both keys are NULL, they are considered to be equal. If one key does have an order metadata but the other has not, the key with the metadata is considered greater. If no key has metadata, they are considered to be equal.
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em ka} & key to compare with \\
\hline
{\em kb} & other key to compare with \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__meta_ga166c65c4eb2d758ced57b0bd74fb9a57}\label{group__meta_ga166c65c4eb2d758ced57b0bd74fb9a57}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!elektraMetaArrayAdd@{elektraMetaArrayAdd}}
\index{elektraMetaArrayAdd@{elektraMetaArrayAdd}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{elektraMetaArrayAdd()}{elektraMetaArrayAdd()}}
{\footnotesize\ttfamily void elektra\+Meta\+Array\+Add (\begin{DoxyParamCaption}\item[{Key $\ast$}]{key,  }\item[{const char $\ast$}]{meta\+Name,  }\item[{const char $\ast$}]{value }\end{DoxyParamCaption})}



creates an metadata array or appends another element to an existing metadata array e.\+g. 


\begin{DoxyCode}{0}
\DoxyCodeLine{Key *key = \mbox{\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}}(\textcolor{stringliteral}{"{}user:/test"{}}, \mbox{\hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}});}
\DoxyCodeLine{\mbox{\hyperlink{group__meta_ga166c65c4eb2d758ced57b0bd74fb9a57}{elektraMetaArrayAdd}}(key, \textcolor{stringliteral}{"{}test"{}}, \textcolor{stringliteral}{"{}val0"{}});}
\DoxyCodeLine{\textcolor{comment}{// key now has "{}test/\#0"{} with value "{}val0"{} as metadata}}
\DoxyCodeLine{\mbox{\hyperlink{group__meta_ga166c65c4eb2d758ced57b0bd74fb9a57}{elektraMetaArrayAdd}}(key, \textcolor{stringliteral}{"{}test"{}}, \textcolor{stringliteral}{"{}val1"{}});}
\DoxyCodeLine{\textcolor{comment}{// appends "{}test/\#1"{} with value "{}val1"{} to key}}

\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em key} & the key the metadata should be added to \\
\hline
{\em meta\+Name} & the name of the metakey array parent \\
\hline
{\em value} & the value of the newly appended metakey \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__meta_gacee3e2d9285dd2bde975a09fdbe50502}\label{group__meta_gacee3e2d9285dd2bde975a09fdbe50502}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!elektraMetaArrayToKS@{elektraMetaArrayToKS}}
\index{elektraMetaArrayToKS@{elektraMetaArrayToKS}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{elektraMetaArrayToKS()}{elektraMetaArrayToKS()}}
{\footnotesize\ttfamily Key\+Set$\ast$ elektra\+Meta\+Array\+To\+KS (\begin{DoxyParamCaption}\item[{Key $\ast$}]{key,  }\item[{const char $\ast$}]{meta\+Name }\end{DoxyParamCaption})}



Create a {\ttfamily Key\+Set} from a metakey array. 

For example, the following function call


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__meta_gacee3e2d9285dd2bde975a09fdbe50502}{elektraMetaArrayToKS}}(}
\DoxyCodeLine{        \mbox{\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}} (\textcolor{stringliteral}{"{}/a"{}}, \mbox{\hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e}{KEY\_VALUE}}, \textcolor{stringliteral}{"{}b, c"{}},}
\DoxyCodeLine{                \mbox{\hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2}{KEY\_META}}, \textcolor{stringliteral}{"{}dep"{}},    \textcolor{stringliteral}{"{}\#1"{}},}
\DoxyCodeLine{                \mbox{\hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2}{KEY\_META}}, \textcolor{stringliteral}{"{}dep/\#0"{}}, \textcolor{stringliteral}{"{}/b"{}},}
\DoxyCodeLine{                \mbox{\hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8a040582834bb2d90049947d7ef74e87e2}{KEY\_META}}, \textcolor{stringliteral}{"{}dep/\#1"{}}, \textcolor{stringliteral}{"{}/c"{}}, \mbox{\hyperlink{group__key_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403}{KEY\_END}}),}
\DoxyCodeLine{        \textcolor{stringliteral}{"{}dep"{}});}

\end{DoxyCode}


returns a {\ttfamily Key\+Set} containing the keys {\ttfamily dep} with value {\ttfamily \#1}, {\ttfamily \char`\"{}dep/\#0\char`\"{}} with value {\ttfamily \char`\"{}/b\char`\"{}} and {\ttfamily \char`\"{}dep/\#1\char`\"{}} with value {\ttfamily \char`\"{}/c\char`\"{}}.

If no metakey array is found, null is returned. The returned {\ttfamily Key\+Set} must be freed with {\ttfamily ks\+Del}

\begin{DoxyReturn}{Returns}
a keyset containing all the metakeys of the metakey array or null if no metakey array is found 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em key} & the key containing the metakey array \\
\hline
{\em meta\+Name} & the name of the metakey array parent \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__meta_ga40469799e2c6e9937eaf013bfc05d014}\label{group__meta_ga40469799e2c6e9937eaf013bfc05d014}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!elektraMetaArrayToString@{elektraMetaArrayToString}}
\index{elektraMetaArrayToString@{elektraMetaArrayToString}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{elektraMetaArrayToString()}{elektraMetaArrayToString()}}
{\footnotesize\ttfamily char$\ast$ elektra\+Meta\+Array\+To\+String (\begin{DoxyParamCaption}\item[{const Key $\ast$}]{key,  }\item[{const char $\ast$}]{meta\+Name,  }\item[{const char $\ast$}]{delim }\end{DoxyParamCaption})}



returns the metakey array as a string separated by delim 


\begin{DoxyParams}{Parameters}
{\em key} & the key containing the metakey array \\
\hline
{\em meta\+Name} & the name of the metakey array parent \\
\hline
{\em delim} & delimiter for the records in the returned string\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a string containing all metakey values separated by \char`\"{}delim\char`\"{} 
\end{DoxyReturn}
\mbox{\Hypertarget{group__meta_gaadfae80314be2415a7654fe8a0d2ee82}\label{group__meta_gaadfae80314be2415a7654fe8a0d2ee82}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!elektraSortTopology@{elektraSortTopology}}
\index{elektraSortTopology@{elektraSortTopology}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{elektraSortTopology()}{elektraSortTopology()}}
{\footnotesize\ttfamily int elektra\+Sort\+Topology (\begin{DoxyParamCaption}\item[{Key\+Set $\ast$}]{ks,  }\item[{Key $\ast$$\ast$}]{array }\end{DoxyParamCaption})}



topological sorting 


\begin{DoxyParams}{Parameters}
{\em array} & the array where the sorted keys will be stored in topological order. Nothing will be written into an array if \\
\hline
{\em ks} & is the keyset that should be sorted. Dependencies and order is defined by metakeys.\\
\hline
\end{DoxyParams}

\begin{DoxyItemize}
\item the \char`\"{}dep/\#\char`\"{} metakeys e.\+g. the Key $\ast$k = key\+New (\char`\"{}/a\char`\"{}, KEY\+\_\+\+VALUE, \char`\"{}b, c\char`\"{}, KEY\+\_\+\+META, \char`\"{}dep\char`\"{}, \char`\"{}\#1\char`\"{}, KEY\+\_\+\+META, \char`\"{}dep/\#0\char`\"{}, \char`\"{}/b\char`\"{}, KEY\+\_\+\+META, \char`\"{}dep/\#1\char`\"{}, \char`\"{}/c\char`\"{}, KEY\+\_\+\+END), \char`\"{}dep\char`\"{}); depends on Key \char`\"{}/b\char`\"{} and Key \char`\"{}/c\char`\"{}.
\item if \char`\"{}order\char`\"{} metakeys are defined for the keys the algorithm tries to resolves them by that order using lexical comparison. You should prefer {\ttfamily \#0} array syntax.
\end{DoxyItemize}

Duplicated and reflexive dep entries are ignored.

The algorithm used is a mixture of Kahn and BFS. Furthermore the algorithm does not use recursion.

First a BFS with the keys sorted by \char`\"{}order\char`\"{} is used. Then all dependencies (recursively) of every key is collected.


\begin{DoxyRetVals}{Return values}
{\em 1} & on success \\
\hline
{\em 0} & for cycles \\
\hline
{\em -\/1} & for invalid dependencies \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__meta_gac89fd319783b3457db45b4c09e55274a}\label{group__meta_gac89fd319783b3457db45b4c09e55274a}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!keyComment@{keyComment}}
\index{keyComment@{keyComment}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{keyComment()}{keyComment()}}
{\footnotesize\ttfamily const char$\ast$ key\+Comment (\begin{DoxyParamCaption}\item[{const Key $\ast$}]{key }\end{DoxyParamCaption})}



Return a pointer to the real internal {\ttfamily key} comment. 

This is a much more efficient version of \mbox{\hyperlink{group__meta_gafb89735689929ff717cc9f2d0d0b46a2}{key\+Get\+Comment()}} and you should use it if you are responsible enough to not mess up things. You are not allowed to change anything in the memory region the returned pointer points to.

\mbox{\hyperlink{group__meta_gac89fd319783b3457db45b4c09e55274a}{key\+Comment()}} returns \char`\"{}\char`\"{} when there is no key\+Comment. The reason is 
\begin{DoxyCode}{0}
\DoxyCodeLine{key=\mbox{\hyperlink{group__key_gad23c65b44bf48d773759e1f9a4d43b89}{keyNew}}(0);}
\DoxyCodeLine{\mbox{\hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{keySetComment}}(key,\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{\mbox{\hyperlink{group__meta_gac89fd319783b3457db45b4c09e55274a}{keyComment}}(key); \textcolor{comment}{// you would expect "{}"{} here}}
\DoxyCodeLine{\mbox{\hyperlink{group__key_ga3df95bbc2494e3e6703ece5639be5bb1}{keyDel}}(key);}

\end{DoxyCode}


See \mbox{\hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}} for more information on comments.

\begin{DoxyNote}{Note}
Note that the Key structure keeps its own size field that is calculated by library internal calls, so to avoid inconsistencies, you must never use the pointer returned by \mbox{\hyperlink{group__meta_gac89fd319783b3457db45b4c09e55274a}{key\+Comment()}} method to set a new value. Use \mbox{\hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}} instead.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to the internal managed comment 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em \char`\"{}\char`\"{}} & when there is no comment \\
\hline
{\em 0} & on NULL pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__meta_ga0dd737fadc16d4cf16720d17f066a9d3}{key\+Get\+Comment\+Size()}} for size and \mbox{\hyperlink{group__meta_gafb89735689929ff717cc9f2d0d0b46a2}{key\+Get\+Comment()}} as alternative 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__meta_gafb89735689929ff717cc9f2d0d0b46a2}\label{group__meta_gafb89735689929ff717cc9f2d0d0b46a2}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!keyGetComment@{keyGetComment}}
\index{keyGetComment@{keyGetComment}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{keyGetComment()}{keyGetComment()}}
{\footnotesize\ttfamily ssize\+\_\+t key\+Get\+Comment (\begin{DoxyParamCaption}\item[{const Key $\ast$}]{key,  }\item[{char $\ast$}]{returned\+Comment,  }\item[{size\+\_\+t}]{max\+Size }\end{DoxyParamCaption})}



Get the key comment. 

\hypertarget{group__meta_comment}{}\doxysubsection{Comments}\label{group__meta_comment}
A Key comment is description for humans what this key is for. It may be a textual explanation of valid values, when and why a user or administrator changed the key or any other text that helps the user or administrator related to that key.

Don\textquotesingle{}t depend on a comment in your program. A user is always allowed to remove or change it in any way they want to. But you are allowed or even encouraged to always show the content of the comment to the user and allow him to change it.


\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em returned\+Comment} & pre-\/allocated memory to copy the comments to \\
\hline
{\em max\+Size} & number of bytes that will fit returned\+Comment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes actually copied to {\ttfamily returned\+String}, including final NULL 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & if the string is empty \\
\hline
{\em -\/1} & on NULL pointer \\
\hline
{\em -\/1} & if max\+Size is 0, not enough to store the comment or when larger then SSIZE\+\_\+\+MAX \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__meta_ga0dd737fadc16d4cf16720d17f066a9d3}{key\+Get\+Comment\+Size()}}, \mbox{\hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__meta_ga0dd737fadc16d4cf16720d17f066a9d3}\label{group__meta_ga0dd737fadc16d4cf16720d17f066a9d3}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!keyGetCommentSize@{keyGetCommentSize}}
\index{keyGetCommentSize@{keyGetCommentSize}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{keyGetCommentSize()}{keyGetCommentSize()}}
{\footnotesize\ttfamily ssize\+\_\+t key\+Get\+Comment\+Size (\begin{DoxyParamCaption}\item[{const Key $\ast$}]{key }\end{DoxyParamCaption})}



Calculates number of bytes needed to store a key comment, including final NULL. 

Use this method to know to size for allocated memory to retrieve a key comment.

See \mbox{\hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}} for more information on comments.

For an empty key name you need one byte to store the ending NULL. For that reason 1 is returned.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \textcolor{keywordtype}{char} *buffer;}
\DoxyCodeLine{ buffer = \mbox{\hyperlink{internal_8c_a35cdc2e5caed3454cb73b4fc7f37858c}{elektraMalloc}} (\mbox{\hyperlink{group__meta_ga0dd737fadc16d4cf16720d17f066a9d3}{keyGetCommentSize}} (key));}
\DoxyCodeLine{\textcolor{comment}{// use this buffer to store the comment}}
\DoxyCodeLine{\textcolor{comment}{// pass keyGetCommentSize (key) for maxSize}}

\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes needed 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 1} & if there is no comment \\
\hline
{\em -\/1} & on NULL pointer \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__meta_gafb89735689929ff717cc9f2d0d0b46a2}{key\+Get\+Comment()}}, \mbox{\hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}\label{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}} 
\index{Meta Data proposal+compatibility@{Meta Data proposal+compatibility}!keySetComment@{keySetComment}}
\index{keySetComment@{keySetComment}!Meta Data proposal+compatibility@{Meta Data proposal+compatibility}}
\doxysubsubsection{\texorpdfstring{keySetComment()}{keySetComment()}}
{\footnotesize\ttfamily ssize\+\_\+t key\+Set\+Comment (\begin{DoxyParamCaption}\item[{Key $\ast$}]{key,  }\item[{const char $\ast$}]{new\+Comment }\end{DoxyParamCaption})}



Set a comment for a key. 

A key comment is like a configuration file comment. See \mbox{\hyperlink{group__meta_ga8863a877a84fa46e6017fe72e49b89c1}{key\+Set\+Comment()}} for more information.


\begin{DoxyParams}{Parameters}
{\em key} & the key object to work with \\
\hline
{\em new\+Comment} & the comment, that can be freed after this call. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes actually saved including final NULL 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & when the comment was freed (new\+Comment NULL or empty string) \\
\hline
{\em -\/1} & on NULL pointer or memory problems \\
\hline
\end{DoxyRetVals}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__meta_gafb89735689929ff717cc9f2d0d0b46a2}{key\+Get\+Comment()}} 
\end{DoxySeeAlso}
