<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Copy On Write</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
$darkmode
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Add mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_color_doxygen.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Elektra<span id="projectnumber">&#160;0.10.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Copy On Write </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_decisions_6_implemented_copy_on_write"></a> </p>
<h1><a class="anchor" id="autotoc_md2264"></a>
Problem</h1>
<p>One of Elektra's core goals is low memory usage. Currently, there are many places within Elektra where keys and keysets are duplicated and copied around. Most of those copied keys are never modified, but are required to be detached from the lifetime of the original instance. We want to introduce an in-memory copy-on-write mechanism to lower our memory usage.</p>
<p>In the near future, Elektra will also gain facilities for <a class="el" href="doc_decisions_3_in_review_change_tracking_md.html">change tracking</a> and session recording, both of which will potentially again duplicate keys. There are also aspirations to create a new, simple <a class="el" href="doc_decisions_4_decided_internal_cache_md.html">internal cache</a> that would also benefit from a copy-on-write mechanism.</p>
<h1><a class="anchor" id="autotoc_md2265"></a>
Constraints</h1>
<ol type="1">
<li>The lifetime of a <code>Key</code> and a <code>KeySet</code> must be unaffected by copy-on-write.</li>
</ol>
<h1><a class="anchor" id="autotoc_md2266"></a>
Assumptions</h1>
<h1><a class="anchor" id="autotoc_md2267"></a>
Considered Alternatives</h1>
<h2><a class="anchor" id="autotoc_md2268"></a>
&lt;tt&gt;mmapstorage&lt;/tt&gt;-like copy-on-write implementation</h2>
<p>There is already some kind of copy-on-write semantics within <code>libelektra-core</code> to support the <code>mmapstorage</code> plugin. We can build on this and add a more generic copy-on-write to it.</p>
<div class="fragment"><div class="line">Key * key = <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;dir:/something&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;my value&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>);</div>
<div class="line"><a class="code" href="group__key.html#ga505575ebef060066984fe0f590081e37">keyCopy</a> (key_dup, key, ELEKTRA_CP_COW);</div>
<div class="line">assert (<a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(key) == <a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(key_dup));</div>
<div class="line"><a class="code" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2">keySetString</a> (key_dup, <span class="stringliteral">&quot;other value&quot;</span>); <span class="comment">// COW done here</span></div>
<div class="line">assert (<a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(key) != <a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(key_dup));</div>
<div class="line">assert (<a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a> (key_dup, <span class="stringliteral">&quot;dir:/valid&quot;</span>) == -1); <span class="comment">// must fail, as we have a COW key</span></div>
<div class="line">assert (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key) == <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(key_dup)); <span class="comment">// stays always valid</span></div>
<div class="ttc" id="agroup__key_html_ga505575ebef060066984fe0f590081e37"><div class="ttname"><a href="group__key.html#ga505575ebef060066984fe0f590081e37">keyCopy</a></div><div class="ttdeci">Key * keyCopy(Key *dest, const Key *source, elektraCopyFlags flags)</div><div class="ttdoc">Copy or clear a key.</div><div class="ttdef"><b>Definition:</b> key.c:319</div></div>
<div class="ttc" id="agroup__key_html_gad23c65b44bf48d773759e1f9a4d43b89"><div class="ttname"><a href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a></div><div class="ttdeci">Key * keyNew(const char *name,...)</div><div class="ttdoc">A practical way to fully create a Key object in one step.</div><div class="ttdef"><b>Definition:</b> key.c:144</div></div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a></div><div class="ttdeci">@ KEY_END</div><div class="ttdef"><b>Definition:</b> kdbenum.c:95</div></div>
<div class="ttc" id="agroup__key_html_gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e"><div class="ttname"><a href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a></div><div class="ttdeci">@ KEY_VALUE</div><div class="ttdef"><b>Definition:</b> kdbenum.c:88</div></div>
<div class="ttc" id="agroup__keyname_html_ga7699091610e7f3f43d2949514a4b35d9"><div class="ttname"><a href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a></div><div class="ttdeci">ssize_t keySetName(Key *key, const char *newName)</div><div class="ttdoc">Set a new name to a Key.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:681</div></div>
<div class="ttc" id="agroup__keyname_html_ga8e805c726a60da921d3736cda7813513"><div class="ttname"><a href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a></div><div class="ttdeci">const char * keyName(const Key *key)</div><div class="ttdoc">Returns a pointer to the abbreviated real internal key name.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:432</div></div>
<div class="ttc" id="agroup__keyvalue_html_ga622bde1eb0e0c4994728331326340ef2"><div class="ttname"><a href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2">keySetString</a></div><div class="ttdeci">ssize_t keySetString(Key *key, const char *newStringValue)</div><div class="ttdoc">Set the value for key as newStringValue.</div><div class="ttdef"><b>Definition:</b> keyvalue.c:381</div></div>
<div class="ttc" id="agroup__keyvalue_html_ga880936f2481d28e6e2acbe7486a21d05"><div class="ttname"><a href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a></div><div class="ttdeci">const char * keyString(const Key *key)</div><div class="ttdoc">Get a pointer to the c-string representing the value.</div><div class="ttdef"><b>Definition:</b> keyvalue.c:208</div></div>
</div><!-- fragment --><p>This is already implemented for the MMAP cache, so the implementation should be straightforward: Do the same COW duplications as done for MMAP but with a different flag.</p>
<p>For the metadata, however, also COW KeySets might be needed (at least with the current API). Example:</p>
<div class="fragment"><div class="line"><a class="code" href="group__key.html#ga505575ebef060066984fe0f590081e37">keyCopy</a> (cow, key, ELEKTRA_CP_COW);</div>
<div class="line">KeySet * cowMeta = <a class="code" href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29">keyMeta</a> (cow);</div>
<div class="line"><a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (cowMeta, <a class="code" href="group__key.html#gad23c65b44bf48d773759e1f9a4d43b89">keyNew</a> (<span class="stringliteral">&quot;meta:/whatever&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8ac66e4a49d09212b79f5754ca6db5bd2e">KEY_VALUE</a>, <span class="stringliteral">&quot;abc&quot;</span>, <a class="code" href="group__key.html#gga9b703ca49f48b482def322b77d3e6bc8aa8adb6fcb92dec58fb19410eacfdd403">KEY_END</a>));</div>
<div class="line">ksRemoveByName (cowMeta, <span class="stringliteral">&quot;meta:/type&quot;</span>);</div>
<div class="ttc" id="agroup__keymeta_html_ga11706f1753e67933f7cffc5c0345cd29"><div class="ttname"><a href="group__keymeta.html#ga11706f1753e67933f7cffc5c0345cd29">keyMeta</a></div><div class="ttdeci">KeySet * keyMeta(Key *key)</div><div class="ttdoc">Returns the KeySet holding the given Key's metadata.</div><div class="ttdef"><b>Definition:</b> keymeta.c:547</div></div>
<div class="ttc" id="agroup__keyset_html_gaa5a1d467a4d71041edce68ea7748ce45"><div class="ttname"><a href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a></div><div class="ttdeci">ssize_t ksAppendKey(KeySet *ks, Key *toAppend)</div><div class="ttdoc">Appends a Key to the end of ks.</div><div class="ttdef"><b>Definition:</b> keyset.c:968</div></div>
</div><!-- fragment --><p><b>Pros:</b></p>
<ul>
<li>Elektra doesn't require MMAP</li>
</ul>
<p><b>Cons:</b></p>
<ul>
<li><p class="startli">Lifetime of a copied COW key MUST be less than the key it was copied from. We can not track how many keys point to the same data and name this way, so we can only free data and name if the key does not have the COW flag. If the original key gets deleted, using a COW key that points to the same data and name will lead to corrupt data. The same is true for updating values of the original key.</p>
<p class="startli">This is only problematic if we want to use COW for keys outside of <code>KDB</code>. If it is only for use within <code>KDB</code>, especially for usage as internal cache and in change tracking, we could always guarantee that the original keys are going to last as long as the <code>KDB</code> instance. However, we need to document for the users of Elektra that keys returned from <code>kdbGet</code> are only valid until <code>kdbClose</code>. If they want to continue using them afterwards, they'd have to deep copy them.</p>
<p class="startli">Triggering the delete problem:</p>
</li>
</ul>
<div class="fragment"><div class="line">Key * originalKey;</div>
<div class="line">Key * copiedKey;</div>
<div class="line"><a class="code" href="group__key.html#ga505575ebef060066984fe0f590081e37">keyCopy</a> (copiedKey, originalKey, ELEKTRA_CP_COW);</div>
<div class="line"> </div>
<div class="line">assert (<a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a> (copiedKey) == <a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a> (originalKey));</div>
<div class="line">assert (<a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (copiedKey) == <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (originalKey));</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (originalKey);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a> (copiedKey); <span class="comment">// Error! Original value has been deleted. Pointer to data in copiedKey points to freed memory</span></div>
<div class="line"><a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a> (copiedKey);   <span class="comment">// Error! Original name has been deleted.</span></div>
<div class="ttc" id="agroup__key_html_ga3df95bbc2494e3e6703ece5639be5bb1"><div class="ttname"><a href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a></div><div class="ttdeci">int keyDel(Key *key)</div><div class="ttdoc">A destructor for Key objects.</div><div class="ttdef"><b>Definition:</b> key.c:459</div></div>
</div><!-- fragment --><p>Triggering the update problem:</p>
<div class="fragment"><div class="line">Key * originalKey;</div>
<div class="line">Key * copiedKey;</div>
<div class="line"><a class="code" href="group__key.html#ga505575ebef060066984fe0f590081e37">keyCopy</a> (copiedKey, originalKey, ELEKTRA_CP_COW);</div>
<div class="line"> </div>
<div class="line">assert (<a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(copiedKey) == <a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(originalKey));</div>
<div class="line"><a class="code" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2">keySetString</a> (originalKey, <span class="stringliteral">&quot;new value!&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__keyvalue.html#ga880936f2481d28e6e2acbe7486a21d05">keyString</a>(copiedKey); <span class="comment">// Error! Original value has been deleted. Pointer to data in copiedKey points to potentially freed memory</span></div>
</div><!-- fragment --><p>The same problems in principle exist for <code>mmapstorage</code> where <code>kdbSet</code> frees (<code>munmap</code>) the keyset. We can still let users access the flag <code>ELEKTRA_CP_COW</code>, we just need to clearly document what is forbidden. Maybe set the <code>KEY_FLAG_RO_VALUE</code> on the original key, so that the API itself detects the error. There is, however, no flag for <code>keyDel</code> that we could set.</p>
<h3><a class="anchor" id="autotoc_md2269"></a>
Changes to &lt;tt&gt;libelektra-core&lt;/tt&gt;</h3>
<p>The <code>struct _Key</code> will be extended with two more pointers, if we want to eliminate the lifetime problem:</p>
<ul>
<li><code>struct _Key * origData</code>: points to the key containing the referenced data</li>
<li><code>struct _Key * origName</code>: points to the key containing the referenced name</li>
</ul>
<p>Those two pointers are needed for memory management. Each referenced key will also have its reference counter increased. This way, an original key can be <code><a class="el" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1" title="A destructor for Key objects.">keyDel()</a></code>d without impacting the copied keys.</p>
<p>Three new key flags will be added:</p>
<ul>
<li><code>KEY_FLAG_COW_VALUE</code>: the value points to a value of another key</li>
<li><code>KEY_FLAG_COW_NAME</code>: the name points to the name of another key</li>
<li><code>KEY_FLAG_COW_META</code>: metakeys are copy-on-write</li>
</ul>
<p>A new copy flag will be added:</p>
<ul>
<li><code>KEY_CP_COW</code>: instructs <code>keyCopy</code> to copy whatever it should copy as copy-on-write. This will NOT be part of <code>KEY_CP_ALL</code>. We don't want developers outside of Elektra to accidentally use this.</li>
</ul>
<p>If <code><a class="el" href="group__key.html#ga505575ebef060066984fe0f590081e37" title="Copy or clear a key.">keyCopy()</a></code> is instructed to do a copy-on-write copy:</p>
<ul>
<li><code>dest-&gt;data.v</code> and <code>dest-&gt;data.c</code> point to the exact same location as in the source. <code>dest-&gt;dataSize</code> is set to the same value as <code>source-&gt;dataSize</code>. <code>KEY_FLAG_COW_VALUE</code> is set on <code>dest-&gt;flags</code>. <code>KEY_FLAG_RO_VALUE</code> is set on <code>source-&gt;flags</code>. <code>dest-&gt;originalData</code> is set to <code>source</code>. <code>source-&gt;refs</code> is incremented.</li>
<li><code>dest-&gt;key</code> points to <code>source-&gt;key</code>. <code>dest-&gt;keySize</code> is set to the same value as <code>source-&gt;keySize</code>. <code>dest-&gt;ukey</code> points to <code>source-&gt;ukey</code>. <code>dest-&gt;keyUSize</code> is set to the same value as <code>source-&gt;keyUSize</code>. <code>KEY_FLAG_COW_NAME</code> is set on <code>dest-&gt;flags</code>. <code>KEY_FLAG_RO_NAME</code> is set on <code>source-&gt;flags</code>. <code>dest-&gt;originalName</code> is set to <code>source</code>. <code>source-&gt;refs</code> is incremented.</li>
<li><code>dest-&gt;meta</code> points to a <b>new</b> keyset. The keys in <code>dest-&gt;meta</code> are also copied with <code>KEY_CP_COW</code>, i.e. they are also copy-on-write keys. <code>KEY_FLAG_COW_META</code> is set on <code>dest-&gt;flags</code>. <code>KEY_FLAG_RO_META</code> is set on <code>source-&gt;flags</code>.</li>
</ul>
<p>The source key will remain as a read-only key. This constraint is needed, because the source key is the only key we can free the resources on. If the data or the name would change in the source key, all COW-copied keys would suddenly have another value. For the same reason, the source key will need to live longer than all COW-copied keys from it.</p>
<p>A <code><a class="el" href="group__key.html#ga505575ebef060066984fe0f590081e37" title="Copy or clear a key.">keyCopy()</a></code> without <code>KEY_CP_COW</code> from an COW key will create a deep copy of the key. These keys are "normal" non-COW keys and can live on their own.</p>
<p>Every <code>key*()</code> method that modifies data on a COW-copied key will need to allocate new memory for this data and remove the <code>KEY_FLAG_COW_DATA</code> flag. Every <code>key*()</code> method that modifies the name of a COW-copied key will need to allocate new memory for this name and remove the <code>KEY_FLAG_COW_NAME</code> flag. Every <code>key*()</code> method that modifies metadata needs to make sure that the same happens for metakeys.</p>
<p>Keysets are not copy-on-write. A <code>ksDeepDup()</code> of a keyset with COW keys will create a keyset with deep-copied non-COW keys. Internally we may need a <code>ksCowDup()</code> function to create a keyset with copy-on-write keys from another keyset. Whether this function will be part of the public API is a point for discussion.</p>
<h2><a class="anchor" id="autotoc_md2270"></a>
Full-blown copy-on-write implementation</h2>
<p>Make Elektra's <code>Key</code> and <code>KeySet</code> data structures copy-on-write. This requires some major refactoring of code within <code>libelektra-core</code>. Code that does only interact with the data structures via the public <code>libelektra-core</code> API should not notice any differences. The <code>mmapstorage</code> plugin needs to be updated.</p>
<p>Unlike "mmapstorage-like COW implementation" keyDup, keyCopy, ksCopy and ksDup will always use COW. <code>ksCopy</code> and <code>ksDup</code> is needed for (de)duplication of metadata. Furthermore, the API has better usability if Key and KeySet behave the same, especially for bindings where duplication might happen implicitly.</p>
<h3><a class="anchor" id="autotoc_md2271"></a>
Changes to &lt;tt&gt;Key&lt;/tt&gt;</h3>
<p>For the <code>Key</code>, we need to extract everything for the data and name into their own structs. This is done for memory-management reasons, as we need to track how many keys point to the same data and/or name.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>_KeyData {</div>
<div class="line">    <span class="keyword">union </span>{</div>
<div class="line">        <span class="keywordtype">char</span> * c;</div>
<div class="line">        <span class="keywordtype">void</span> * v;</div>
<div class="line">    } data;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> dataSize;</div>
<div class="line"> </div>
<div class="line">    uint16_t refs;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>_KeyName {</div>
<div class="line">    <span class="keywordtype">char</span> * key;</div>
<div class="line">    <span class="keywordtype">size_t</span> keySize;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span> * ukey;</div>
<div class="line">    <span class="keywordtype">size_t</span> keyUSize;</div>
<div class="line"> </div>
<div class="line">    uint16_t refs;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>_Key {</div>
<div class="line">    <span class="keyword">struct </span>_KeyData * keyData;</div>
<div class="line">    <span class="keyword">struct </span>_KeyName * <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>;</div>
<div class="line">    KeySet * meta;</div>
<div class="line">    keyflag_t flags;</div>
<div class="line"> </div>
<div class="line">    uint16_t refs;</div>
<div class="line">};</div>
</div><!-- fragment --><p>@mpranj's thoughts regarding moving name and data to separate structures:</p>
<blockquote class="doxtable">
<p>1. If they [key name and data] are a separate entity, <code>mmapstorage</code> will need a flag once again for each of those. This is used to mark whether the data is in an mmap region or not. (or we find some bit somewhere that we can steal for this purpose)</p>
<ol type="1">
<li>Adding more indirections is probably not going to help performance. (I understand that we save memory here) </li>
</ol>
</blockquote>
<h3><a class="anchor" id="autotoc_md2272"></a>
Changes to &lt;tt&gt;KeySet&lt;/tt&gt;</h3>
<p>For <code>KeySet</code>, we need to split out everything to do with the stored keys into a separate datastructure. This includes the array itself, the sizes and the hashmap.</p>
<p>Why don't we just add the number of references to the original <code>KeySet</code>?</p>
<ul>
<li>If we delete a copied KeySet, we don't know which KeySet is the original, so we couldn't decrement the counter. This could be dealt with storing a pointer to the original KeySet.</li>
<li>If the original KeySet is deleted, we don't know which other KeySets point at the data, so updating their count would not work</li>
<li>In similar fashion, if you update the original KeySet, the copied KeySets will also contain the new data (if the memory address does not change). This is unexpected behavior.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">struct </span>_KeySetData {</div>
<div class="line">    <span class="keyword">struct </span>_Key ** array;</div>
<div class="line">    <span class="keywordtype">size_t</span> size;  </div>
<div class="line">    <span class="keywordtype">size_t</span> alloc; </div>
<div class="line">    <a class="code" href="structOpmphm.html">Opmphm</a> * opmphm;</div>
<div class="line">    OpmphmPredictor * <a class="code" href="opmphmpredictor_8c.html#a6dab3e7c921f8adc655bd893cfbfb4cb">opmphmPredictor</a>;</div>
<div class="line"> </div>
<div class="line">    uint16_t refs; </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>_KeySet {</div>
<div class="line">    <span class="keyword">struct </span>_KeySetData * data;</div>
<div class="line"> </div>
<div class="line">    ksflag_t flags;</div>
<div class="line"> </div>
<div class="line">    uint16_t refs; </div>
<div class="line">};</div>
<div class="ttc" id="aopmphmpredictor_8c_html_a6dab3e7c921f8adc655bd893cfbfb4cb"><div class="ttname"><a href="opmphmpredictor_8c.html#a6dab3e7c921f8adc655bd893cfbfb4cb">opmphmPredictor</a></div><div class="ttdeci">int opmphmPredictor(OpmphmPredictor *op, size_t n)</div><div class="ttdoc">Predictcs at the first ksLookup (...) after a KeySet changed if it will be worth using the OPMPHM.</div><div class="ttdef"><b>Definition:</b> opmphmpredictor.c:100</div></div>
<div class="ttc" id="astructOpmphm_html"><div class="ttname"><a href="structOpmphm.html">Opmphm</a></div><div class="ttdoc">The opmphm.</div><div class="ttdef"><b>Definition:</b> kdbopmphm.h:90</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2273"></a>
Reference Counting</h3>
<p>We need reference counting for the internal COW datastructures. We do it the same way reference counting currently works for <code>Key</code> and <code>KeySet</code>. One tweak though is that the refcount should never be 0, as this does not make sense for internal datastructures.</p>
<p>This means we always increment the refcount after creation and always decrement before deletion, so that the refcount is never zero. An example implementation is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> keySetValue(Key * key, <span class="keywordtype">void</span> * value, <span class="keywordtype">size_t</span> size) {</div>
<div class="line">  <span class="comment">// [...] removal of current value from key</span></div>
<div class="line">  <span class="keyword">struct </span>_KeyData data = keyDataNew (value, size);</div>
<div class="line">  keyDataIncRef (data);</div>
<div class="line">  key-&gt;data = data;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a>(Key * key) {</div>
<div class="line">  keyDataDecRef (key-&gt;data);</div>
<div class="line">  keyDataDel (key-&gt;data);</div>
<div class="line">  <span class="comment">// [...] other cleanup</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2274"></a>
Variation 1 - RcBuffer</h3>
<p>Instead of using different structs for <code>_KeyData</code>, and <code>_KeyName</code> use a more generic struct for reference counting. This would avoid some duplication on the reference counting code for the key. Keysets will still have their own data struct, as it contains more than just a pointer and a size.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">        <span class="keywordtype">void</span> * data;</div>
<div class="line">        <span class="keywordtype">size_t</span> size;</div>
<div class="line">        uint16_t refs;</div>
<div class="line">} RcBuffer;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>_Key {</div>
<div class="line">        RcBuffer * uname;</div>
<div class="line">        RcBuffer * ename; <span class="comment">// will be removed soon</span></div>
<div class="line">        RcBuffer * value;</div>
<div class="line"> </div>
<div class="line">        KeySet * meta;</div>
<div class="line">        keyflag_t flags;</div>
<div class="line">        uint16_t refs;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2275"></a>
Possible Edge Cases</h3>
<p>In general, it should be possible to always do copy-on-write. From a users perspective, copy-on-write copies of a key (and a keyset) should behave the same. There is, however, one edge case: the user modifying the value of a key directly. This is shown in the following example:</p>
<div class="fragment"><div class="line">Key * key;</div>
<div class="line"><span class="keyword">struct </span>foo myFoo = {</div>
<div class="line">  .x = 0</div>
<div class="line">};</div>
<div class="line"><a class="code" href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7">keySetBinary</a> (key, &amp;myFoo, <span class="keyword">sizeof</span>(myFoo));</div>
<div class="line"> </div>
<div class="line">Key * dup = keyDup (key);</div>
<div class="line"> </div>
<div class="line">((<span class="keyword">struct </span>foo *)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a> (key))-&gt;x = 1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// with COW</span></div>
<div class="line">assert (((<span class="keyword">struct</span> foo *)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a> (dup))-&gt;x == 1);</div>
<div class="line"><span class="comment">// without COW</span></div>
<div class="line">assert (((<span class="keyword">struct</span> foo *)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a> (dup))-&gt;x == 0);</div>
<div class="ttc" id="agroup__keyvalue_html_ga6f29609c5da53c6dc26a98678d5752af"><div class="ttname"><a href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a></div><div class="ttdeci">const void * keyValue(const Key *key)</div><div class="ttdoc">Return a pointer to the real internal key value.</div><div class="ttdef"><b>Definition:</b> keyvalue.c:163</div></div>
<div class="ttc" id="agroup__keyvalue_html_gaa50a5358fd328d373a45f395fa1b99e7"><div class="ttname"><a href="group__keyvalue.html#gaa50a5358fd328d373a45f395fa1b99e7">keySetBinary</a></div><div class="ttdeci">ssize_t keySetBinary(Key *key, const void *newBinary, size_t dataSize)</div><div class="ttdoc">Set the value of a Key to the binary value newBinary.</div><div class="ttdef"><b>Definition:</b> keyvalue.c:514</div></div>
</div><!-- fragment --><p>This edge case can be accounted for by providing a private function <code>keyDetach</code>, that forces that the key has its very own copy of the data.</p>
<div class="fragment"><div class="line">((<span class="keyword">struct </span>foo *)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a> (keyDetach(key)))-&gt;x = 1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// with COW</span></div>
<div class="line">assert (((<span class="keyword">struct</span> foo *)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a> (dup))-&gt;x == 0);</div>
<div class="line"><span class="comment">// without COW</span></div>
<div class="line">assert (((<span class="keyword">struct</span> foo *)<a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a> (dup))-&gt;x == 0);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2276"></a>
Compatibility with &lt;tt&gt;mmapstorage&lt;/tt&gt; plugin</h3>
<p>If we do change the internal data structures it makes much more sense to fix the cache and mmapstorage afterwards (or in tandem). The most important constraint for mmap is that any structure (or bytes) that is an allocation unit (e.g. we malloc() the bytes needed for KeySet struct, so this is an unit) needs to have a flag to determine whether those bytes are actually malloc()ed or they are mmap()ed. Thus all the newly added structures as proposed will need some kind of an mmap flag.</p>
<p><code>mmapstorage</code> only calls <code>munmap</code> in some error cases, so basically <code>munmap</code> is almost never done and the keyset is never invalidated.</p>
<p>During <code>kdbSet</code> the storage plugins always write to a temp file, due to how the resolver works. We also don't need to mmap the temp file here: when doing <code>kdbSet</code> we already have the <code>KeySet</code> at hand, mmap-ing it is not needed at all, because we have the data. We just want to update the cache file. The <code>mmap</code>/<code>munmap</code> in kdbSet are just so we can write the KeySet to a file in our format. (<code>mmap()</code> is just simpler, but we could also <code>malloc()</code> a region and then <code>fwrite()</code> the stuff)</p>
<p>Therefore the only case where we return a <code>mmap()</code>ed KeySet should be in <code>kdbGet</code>.</p>
<p>When the <code>mmapstorage</code> was designed/implemented, not all structures had refcounters, so there was no way to know when a <code>munmap</code> is safe. This was simply out of scope at that point in time.</p>
<p>If refcounting is now implemented for all structures, we might be able to properly <code>munmap</code> in future.</p>
<p>Two ideas to deal with this in conjunction with our reference counting implementation:</p>
<p>If we have <code>free</code> function-pointer along side the refcount, <code>mmapstorage</code> (and also other plugins with different allocators) could set it to their own implementation. To mimic the current behavior of <code>mmapstorage</code> this would point to a no-op function. However, we could also improve things and keep track of when all data has been freed and only then call <code>munmap</code>.</p>
<p>Another simpler way to avoid the flag, which doesn't really allow for further improvements, would be using the refcount. <code>mmapstorage</code> could set the refcount to a value that is otherwise illegal. This would allow us to detect the keys. Depending on the refcount implementation good values would probably be 0 or UINT16_MAX. The special value would have to ignored by all refcounting functions (inc, dec, del) and turn the functions into no-ops.</p>
<h3><a class="anchor" id="autotoc_md2277"></a>
Possible Optimizations</h3>
<ul>
<li>This approach requires more allocations than previously. We have not fully benchmarked whether this is a big issue. One optimization could be an expanding "pool" of <code>_KeySetData</code>, <code>_KeyData</code> and <code>_KeyName</code>. We could then allocate multiple of them at the same time, and borrow and give back instance from and to the pool.</li>
<li>Embed the <code>KeySet * meta</code> directly in <code>struct _Key</code>. This may help with performance in cases we need metadata. It will, however, increase memory usage. This should only be considered after some benchmarking shows this is a real issue.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2278"></a>
Memory comparison of COW approaches</h1>
<p>The following calculations are based on the AMD64 platform. All results are in bytes unless stated otherwise.</p>
<p>Example key: <code>user:/hosts/ipv6/example.com = 2606:2800:220:1:248:1893:25c8:1946</code></p>
<p>We want to measure the following properties for the key:</p>
<ul>
<li>Empty Key: size of a simple malloc of the key struct</li>
<li>Empty Key (with name): size of simple malloc of all structs, so that the key has a name, but without including the size of the name</li>
<li>Empty Key (with name + data): size of a simple malloc of all structs, so that the key has a name and data, but without including the size of the name or data</li>
<li>Single Example Key: a single instance of the key defined above</li>
<li>Example Key + 1 Duplicate: two instances of the key defined above, one of them is a duplication of the first</li>
<li>Example Key + 2 Duplicates: three instances of the key defined above, two of them are duplications of the first</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Approach   </th><th class="markdownTableHeadRight">Empty Key   </th><th class="markdownTableHeadRight">Empty Key (with name)   </th><th class="markdownTableHeadRight">Empty Key (with name + data)   </th><th class="markdownTableHeadRight">Single Example Key   </th><th class="markdownTableHeadRight">Example Key + 1 Duplicate   </th><th class="markdownTableHeadRight">Example Key + 2 Duplicates    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Current Implementation   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">153   </td><td class="markdownTableBodyRight">306   </td><td class="markdownTableBodyRight">459    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">mmapstorage-like COW implementation (without additional pointers)   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">153   </td><td class="markdownTableBodyRight">217   </td><td class="markdownTableBodyRight">281    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">mmapstorage-like COW implementation (with additional pointers)   </td><td class="markdownTableBodyRight">80   </td><td class="markdownTableBodyRight">80   </td><td class="markdownTableBodyRight">80   </td><td class="markdownTableBodyRight">169   </td><td class="markdownTableBodyRight">249   </td><td class="markdownTableBodyRight">329    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Full-blown COW implementation   </td><td class="markdownTableBodyRight">32   </td><td class="markdownTableBodyRight">72   </td><td class="markdownTableBodyRight">96   </td><td class="markdownTableBodyRight">185   </td><td class="markdownTableBodyRight">217   </td><td class="markdownTableBodyRight">249    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Full-blown COW implementation - Variant 1 (RcBuffer)   </td><td class="markdownTableBodyRight">40   </td><td class="markdownTableBodyRight">88   </td><td class="markdownTableBodyRight">112   </td><td class="markdownTableBodyRight">201   </td><td class="markdownTableBodyRight">241   </td><td class="markdownTableBodyRight">281   </td></tr>
</table>
<p>We want to measure the following properties for the keyset:</p>
<ul>
<li>Empty KeySet: size of a simple malloc of the keyset struct</li>
<li>Empty KeySet (with data): size of a simple malloc of all structs</li>
<li>Example KeySet: size of a keyset with 15 keys + NULL byte</li>
<li>Example KeySet + 1 Duplicate: two instance of Example KeySet, one of them is a duplication</li>
<li>Example KeySet + 2 Duplicates: three instances of Example KeySet, two of them are duplications</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Approach   </th><th class="markdownTableHeadRight">Empty KeySet   </th><th class="markdownTableHeadRight">Empty KeySet (with data)   </th><th class="markdownTableHeadRight">Example KeySet   </th><th class="markdownTableHeadRight">Example KeySet + 1 Duplicate   </th><th class="markdownTableHeadRight">Example KeySet + 2 Duplicates    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Current Implementation   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">192   </td><td class="markdownTableBodyRight">384   </td><td class="markdownTableBodyRight">576    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">mmapstorage-like COW implementation (without additional pointers)   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">192   </td><td class="markdownTableBodyRight">384   </td><td class="markdownTableBodyRight">576    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">mmapstorage-like COW implementation (with additional pointers)   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">192   </td><td class="markdownTableBodyRight">384   </td><td class="markdownTableBodyRight">576    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Full-blown COW implementation   </td><td class="markdownTableBodyRight">16   </td><td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">192   </td><td class="markdownTableBodyRight">208   </td><td class="markdownTableBodyRight">224   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2279"></a>
Calculations</h2>
<p>Raw data size:</p>
<ul>
<li>keyname : <code>28 + 1</code> = <code>29</code></li>
<li>unescaped keyname (measured): <code>25</code></li>
<li>data: <code>34 + 1</code> = <code>35</code></li>
</ul>
<p>Current Implementation:</p>
<ul>
<li>Empty Key [measured via <code>sizeof</code>]: <code>64</code></li>
<li>Empty Key (with name): <code>64</code></li>
<li>Empty Key (with name + data): <code>64</code></li>
<li>Single Example Key = <code>Empty Key + keyname + unescaped keyname + data</code> = <code>64 + 29 + 25 + 35</code> = <code>153</code></li>
<li>Single Example Key + 1 Duplicate = <code>Single Example Key * 2</code> = <code>153 * 2</code> = <code>306</code></li>
<li>Single Example Key + 2 Duplicates = <code>Single Example Key * 3</code> = <code>153 * 3</code> = <code>459</code></li>
<li>Empty KeySet [measured via <code>sizeof</code>]: <code>64</code></li>
<li>Empty KeySet (with data): <code>64</code></li>
<li>Example KeySet: <code>Empty KeySet (with data) + 16 * pointer to keys</code> = <code>64 + 16 * 8</code> = <code>192</code></li>
<li>Example KeySet + 1 Duplicate: <code>Example KeySet * 2</code> = <code>192 * 2</code> = <code>384</code></li>
<li>Example KeySet + 2 Duplicates: <code>Example KeySet * 3</code> = <code>192 * 3</code> = <code>576</code></li>
</ul>
<p>mmapstorage-like COW implementation (without additional pointers):</p>
<ul>
<li>Empty Key [measured via <code>sizeof</code>]: <code>64</code></li>
<li>Empty Key (with name): <code>64</code></li>
<li>Empty Key (with name + data): <code>64</code></li>
<li>Single Example Key = <code>Empty Key + keyname + unescaped keyname + data</code> = <code>64 + 29 + 25 + 35</code> = <code>153</code></li>
<li>Single Example Key + 1 Duplicate = <code>Single Example Key + Empty Key</code> = <code>153 + 64</code> = <code>217</code></li>
<li>Single Example Key + 2 Duplicates = <code>Single Example Key + Empty Key * 2</code> = <code>153 + 64 * 2</code> = <code>281</code></li>
<li>KeySets are not COW in this approach --&gt; same as current implementation</li>
</ul>
<p>mmapstorage-like COW implementation (with additional pointers):</p>
<ul>
<li>Empty KeySet [measured via <code>sizeof</code>]: <code>64</code></li>
<li>Empty Key [measured via <code>sizeof</code>]: <code>80</code></li>
<li>Empty Key (with name): <code>80</code></li>
<li>Empty Key (with name + data): <code>80</code></li>
<li>Single Example Key = <code>Empty Key + keyname + unescaped keyname + data</code> = <code>80 + 29 + 25 + 35</code> = <code>169</code></li>
<li>Single Example Key + 1 Duplicate = <code>Single Example Key + Empty Key</code> = <code>169 + 80</code> = <code>249</code></li>
<li>Single Example Key + 2 Duplicates = <code>Single Example Key + Empty Key * 2</code> = <code>169 + 80 * 2</code> = <code>329</code></li>
<li>KeySets are not COW in this approach --&gt; same as current implementation</li>
</ul>
<p>Full-blown COW implementation:</p>
<ul>
<li>Empty Key [measured via <code>sizeof</code>]: <code>32</code></li>
<li>Empty Key (with name) [measured via <code>sizeof</code>]: <code>Empty Key + sizeof(KeyName)</code> = <code>32 + 40</code> = <code>72</code></li>
<li>Empty Key (with name + data) [measured via <code>sizeof</code>]: <code>Empty Key + sizeof(KeyName) + sizeof(KeyData)</code> = <code>32 + 40 + 24</code> = <code>96</code></li>
<li>Single Example Key = <code>Empty Key (with name + data) + keyname + unescaped keyname + data</code> = <code>96 + 29 + 25 + 35</code> = <code>185</code></li>
<li>Single Example Key + 1 Duplicate = <code>Single Example Key + Empty Key</code> = <code>185 + 32</code> = <code>217</code></li>
<li>Single Example Key + 2 Duplicates = <code>Single Example Key + Empty Key * 2</code> = <code>185 + 32 * 2</code> = <code>249</code></li>
<li>Empty KeySet [measured via <code>sizeof</code>]: <code>16</code></li>
<li>Empty KeySet (with data): <code>Empty KeySet + sizeof(KeySetData)</code> = <code>16 + 48</code> = <code>64</code></li>
<li>Example KeySet: <code>Empty KeySet (with data) + 16 * pointer to keys</code> = <code>64 + 16 * 8</code> = <code>192</code></li>
<li>Example KeySet + 1 Duplicate: <code>Example KeySet + Empty KeySet</code> = <code>192 + 16</code> = <code>208</code></li>
<li>Example KeySet + 2 Duplicates: <code>Example KeySet + Empty KeySet * 2</code> = <code>192 + 16 * 2</code> = <code>224</code></li>
</ul>
<p>Full-blown COW implementation - Variant 1 (RcBuffer):</p>
<ul>
<li>Empty Key [measured via <code>sizeof</code>]: <code>40</code></li>
<li>Empty Key (with name) [measured via <code>sizeof</code>]: <code>Empty Key + sizeof(RcBuffer)*2</code> = <code>40 + 24*2</code> = <code>88</code></li>
<li>Empty Key (with name + data) [measured via <code>sizeof</code>]: <code>Empty Key + sizeof(RcBuffer)*3</code> = <code>40 + 24*3</code> = <code>112</code></li>
<li>Single Example Key = <code>Empty Key (with name + data) + keyname + unescaped keyname + data</code> = <code>112 + 29 + 25 + 35</code> = <code>201</code></li>
<li>Single Example Key + 1 Duplicate = <code>Single Example Key + Empty Key</code> = <code>201 + 40</code> = <code>241</code></li>
<li>Single Example Key + 2 Duplicates = <code>Single Example Key + Empty Key * 2</code> = <code>201 + 40 * 2</code> = <code>281</code></li>
<li>Empty KeySet [measured via <code>sizeof</code>]: <code>16</code></li>
<li>Empty KeySet (with data): <code>Empty KeySet + sizeof(KeySetData)</code> = <code>16 + 48</code> = <code>64</code></li>
<li>Example KeySet: <code>Empty KeySet (with data) + 16 * pointer to keys</code> = <code>64 + 16 * 8</code> = <code>192</code></li>
<li>Example KeySet + 1 Duplicate: <code>Example KeySet + Empty KeySet</code> = <code>192 + 16</code> = <code>208</code></li>
<li>Example KeySet + 2 Duplicates: <code>Example KeySet + Empty KeySet * 2</code> = <code>192 + 16 * 2</code> = <code>224</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md2280"></a>
Allocations &amp; Indirections comparison of COW approaches</h2>
<p>For allocations want to measure the following properties:</p>
<ul>
<li>Empty key: how many objects to allocate for an empty key</li>
<li>Empty Key (with name): how many objects to allocate for an empty key + name</li>
<li>Empty Key (with name + data): how many objects to allocate for an empty key + name + data</li>
<li>Duplication: how many objects to allocate for a duplication</li>
<li>Key + 1 Duplication: how many objects to allocate for a full key + 1 duplication</li>
<li>Key + 2 Duplications: how many objects to allocate for a full key + 2 duplications</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Approach   </th><th class="markdownTableHeadRight">Empty Key   </th><th class="markdownTableHeadRight">Empty Key (with name)   </th><th class="markdownTableHeadRight">Empty Key (with name + data)   </th><th class="markdownTableHeadRight">Duplication   </th><th class="markdownTableHeadRight">Key + 1 Duplication   </th><th class="markdownTableHeadRight">Key + 2 Duplications    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Current Implementation   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">mmapstorage-like COW implementation (without additional pointers)   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">mmapstorage-like COW implementation (with additional pointers)   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Full-blown COW implementation   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">2   </td><td class="markdownTableBodyRight">3   </td><td class="markdownTableBodyRight">1   </td><td class="markdownTableBodyRight">4   </td><td class="markdownTableBodyRight">5   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2281"></a>
Decision</h1>
<p>Implement the full-blown COW approach.</p>
<h1><a class="anchor" id="autotoc_md2282"></a>
Rationale</h1>
<ul>
<li>It is the most versatile option.</li>
<li>No restrictions on the lifetime of <code>Key</code> and <code>KeySet</code> objects.</li>
<li>Completely transparent to developers using Elektra's public API.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2283"></a>
Implications</h1>
<ul>
<li>The <code>mmapstorage</code> plugins needs to be updated</li>
</ul>
<h1><a class="anchor" id="autotoc_md2284"></a>
Related Decisions</h1>
<ul>
<li><a class="el" href="doc_decisions_3_in_review_change_tracking_md.html">change tracking</a></li>
<li><a class="el" href="doc_decisions_4_decided_internal_cache_md.html">internal cache</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2285"></a>
Notes</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark'
  });
</script>
</body>
</html>
