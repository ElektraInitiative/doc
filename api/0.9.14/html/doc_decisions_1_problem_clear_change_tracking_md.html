<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Change Tracking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
$darkmode
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<!-- Add mermaid.js -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_color_doxygen.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Elektra<span id="projectnumber">&#160;0.9.14</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Change Tracking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_doc_decisions_1_problem_clear_change_tracking"></a> </p>
<h1><a class="anchor" id="autotoc_md1908"></a>
Problem</h1>
<p>Currently, a range of Elektra plugins are implementing some sort of change tracking for configuration data. This includes, but is not limited to, the <a class="el" href="md_src_plugins_internalnotification_README.html#src_plugins_internalnotification_README_md">internalnotification</a> and <a class="el" href="md_src_plugins_dbus_README.html#src_plugins_dbus_README_md">dbus</a> plugins. In the near future, Elektra shall also be extended with session recording.</p>
<p>KDB itself also has some rudimentary change tracking (via the <code>keyNeedsSync</code> flag) to determine whether <code>kdbSet</code> needs to actually do something.</p>
<p>These competing change tracking implementations create multiple problems:</p>
<ol type="1">
<li>pointless waste of resources, as data is duplicated in each plugin,</li>
<li>multiplication of code, generating a maintenance burden.</li>
<li>various subtle differences in change tracking behavior, e.g., <code>kdbSet</code> might write a config file but notification is not sent out</li>
<li>the current approach to change tracking in plugins is fragile, which is outlined in <a class="el" href="doc_decisions_0_drafts_operation_sequences_md.html">a separate decision about valid kdbGet/kdbSet sequences</a>.</li>
</ol>
<p>For <code>KeySet</code> we need to track which of the keys:</p>
<ul>
<li>have been removed</li>
<li>have been added</li>
</ul>
<p>For <code>Key</code> we need to track:</p>
<ul>
<li>original value of the key</li>
<li>size of the original value (for binary keys)</li>
<li>metadata, which is a combination of the tracking of keysets and keys</li>
<li>tracking should only be done on the following namespaces:<ul>
<li><code>system:/</code></li>
<li><code>user:/</code></li>
<li><code>dir:/</code></li>
<li><code>meta:/</code></li>
<li><code>spec:/</code></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1909"></a>
Constraints</h1>
<p>Change tracking must:</p>
<ul>
<li>be transparent for applications using the public Elektra API</li>
<li>be transparent to users changing configuration data</li>
<li>if overhead is not negligible: only do tracking as required, i.e., a plugin specifically requests it</li>
<li>have negligible overhead if disabled</li>
<li>not duplicate data for each plugin that wants change tracking</li>
<li>work with all allowed sequences of <code>kdbGet</code> and <code>kdbSet</code> as <a class="el" href="doc_decisions_0_drafts_operation_sequences_md.html">per this decision</a></li>
</ul>
<p>We only want to track changes that are done by the user, not changes that are done by plugins. I.e. the scope of change tracking is on what happens <em>outside</em> of <code>kdbGet</code> and <code>kdbSet</code>.</p>
<p>The library <code>libelektra-core</code> must be kept minimal.</p>
<h1><a class="anchor" id="autotoc_md1910"></a>
Assumptions</h1>
<ul>
<li>It is possible to do change tracking with reasonable memory and computation overhead</li>
<li>It is possible to design a single change tracking API that is useful for all existing and future plugins</li>
<li>False positivies are okay<ul>
<li>this may happend when some keys have been changed by the user, but have subsequentially been "unchanged" by a transformation plugin Scenario: plugin that converts <code>false</code>&lt;-&gt;<code>0</code> and <code>true</code>&lt;-&gt;<code>1</code><ul>
<li><code>system:/background</code> is stored with value <code>false</code></li>
<li>user gets key <code>system:/background</code> with value <code>0</code> (after conversion by plugin)</li>
<li>user changes it to <code>false</code></li>
<li>changetracking detects that value has been changed, because <code>false</code> != <code>0</code></li>
<li>plugin changes value from <code>false</code> to <code>0</code></li>
<li>consumers of the changetracking API will now get a false positive if they query whether <code>system:/background</code> has been changed</li>
<li>We assume consumers of the changetracking API have access to both the previous and the new value of a changed key. Therefore, they could detect these false positive cases, if the need to.</li>
</ul>
</li>
</ul>
</li>
<li>False negatives (missed changes) are not okay</li>
</ul>
<h1><a class="anchor" id="autotoc_md1911"></a>
Solutions - Storage</h1>
<h2><a class="anchor" id="autotoc_md1912"></a>
Utilize already existing &lt;tt&gt;backendData-&gt;keys&lt;/tt&gt;</h2>
<p>We already store which keys have been returned by <code>kdbGet</code> for each backend within KDB. Currently, those are shallow copies. To be useful for changetracking, we need to perform deep copies instead. As keys and keysets are already utilizing copy-on-write, this would not add too much memory overhead.</p>
<p>A problem with this approach is that the internally stored keys are recreated as new instances every time <code>kdbGet</code> is called.</p>
<h2><a class="anchor" id="autotoc_md1913"></a>
Combine with internal cache</h2>
<p>We already decided that we want to have an internal deep-duped keysets of all the keys we returned. See <a class="el" href="doc_decisions_4_decided_internal_cache_md.html">internal cache decision</a>.</p>
<p>The difference to <code>backendData-&gt;keys</code> is that this cache is not recreated each time <code>kdbGet</code> is called.</p>
<h2><a class="anchor" id="autotoc_md1914"></a>
Have a seperate storage for changetracking</h2>
<p>Have a global keyset with deep-duped keys that is purely used for changetracking and nothing else.</p>
<h2><a class="anchor" id="autotoc_md1915"></a>
Store changes as meta keys</h2>
<p>When something changes for the first time, store the original value as a metakey to every key. Not yet clear how we handle changes to metadata then. Also not really possible for keysets.</p>
<h2><a class="anchor" id="autotoc_md1916"></a>
Implement changetracking as a mechanismn on the &lt;tt&gt;Key&lt;/tt&gt; and &lt;tt&gt;KeySet&lt;/tt&gt; datastructures</h2>
<p>The idea here is that we extend the <code>KeySet</code> and <code>Key</code> structs with additional fields.</p>
<p>The tracking itself would be done within the <code>ks*</code> and <code>key*</code> methods, after checking if it is enabled. It would also transparently work for metadata, as metadata itself is implemented as a keyset with keys.</p>
<p>Downsides of this approach:</p>
<ul>
<li>It adds functionality to <code>libelektra-core</code> which may violate the constraint above. It may, however, be debatable whatever 'minimal' means in this context.</li>
<li>Adding fields to the structs causes a slight memory overhead, even with tracking turned off. While negligible for <code>KeySet</code> due to the low amount of keysets in typical applications, it may be noticable for <code>Key</code>. On a 64-bit system we'd add 16 bytes to it. 8 bytes for the pointer to the original value, 8 bytes for the size of the original value. To put this in perspective, the current size of the <code>Key</code> struct is 64 bytes, so we'd add 25% overhead to an empty key. However, this percentage will be much lower in a real-world application, as the usefulness of an empty key is very low.</li>
<li>Another downside here is that it is not so easy to determine what the "original" value is. Some part of <code>libelektra-kdb</code> would need to mark the keys as original (after transformations etc.)</li>
</ul>
<h1><a class="anchor" id="autotoc_md1917"></a>
Solutions - Implementation</h1>
<h2><a class="anchor" id="autotoc_md1918"></a>
Implement directly within &lt;tt&gt;libelektra-kdb&lt;/tt&gt;</h2>
<p>Implement all the logic for changetracking directly within <code>libelektra-kdb</code>.</p>
<h2><a class="anchor" id="autotoc_md1919"></a>
Implement as a seperate plugin</h2>
<p>Implement changetracking as a hooks plugin that will be called within <code>kdbGet</code> and <code>kdbSet</code> accordingly.</p>
<p>The following hooks will be needed:</p>
<ul>
<li><code>tracking/get</code>: will be called at the end of <code>kdbGet</code>, directly before the result is returned.</li>
<li><code>tracking/set</code>: will be called at the beginning of <code>kdbSet</code>.</li>
<li><code>tracking/changeset</code>: compute the changeset for the requested parent key and return it.</li>
</ul>
<p>As every hook plugin can define its own contract, in theory all storage forms mentioned in the previous chapter should be possible to implement. We could just point the plugin to <code>backendsData-&gt;keys</code> or the internal cache if we go down that route.</p>
<h1><a class="anchor" id="autotoc_md1920"></a>
Solutions - Query</h1>
<h2><a class="anchor" id="autotoc_md1921"></a>
Provide an API within &lt;tt&gt;libelektra-kdb&lt;/tt&gt;</h2>
<p>The API should be useable both by plugins and applications utilizing ELektra. It does not matter whether the changetracking is implemented as part of <code>libelektra-kdb</code> or as a seperate plugin. The API may look something like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> elektraChangeTrackingIsEnabled (KDB * <a class="code" href="namespacekdb.html">kdb</a>);</div>
<div class="line">ChangeTrackingContext * elektraChangeTrackingGetContext (KDB * <a class="code" href="namespacekdb.html">kdb</a>, Key * parentKey);</div>
<div class="line"> </div>
<div class="line">KeySet * elektraChangeTrackingGetAddedKeys (ChangeTrackingContext * context);</div>
<div class="line">KeySet * elektraChangeTrackingGetRemovedKeys (ChangeTrackingContext * context);</div>
<div class="line">KeySet * elektraChangeTrackingGetModifiedKeys (ChangeTrackingContext * context); <span class="comment">// Returns old keys (pre-modification)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> elektraChangeTrackingValueChanged (ChangeTrackingContext * context, Key * key);</div>
<div class="line"><span class="keywordtype">bool</span> elektraChangeTrackingMetaChanged (ChangeTrackingContext * context, Key * key);</div>
<div class="line"> </div>
<div class="line">KeySet * elektraChangeTrackingGetAddedMetaKeys (ChangeTrackingContext * context, Key * key);</div>
<div class="line">KeySet * elektraChangeTrackingGetRemovedMetaKeys (ChangeTrackingContext * context, Key * key);</div>
<div class="line">KeySet * elektraChangeTrackingGetModifiedMetaKeys (ChangeTrackingContext * context, Key * key); <span class="comment">// Returns old meta keys (pre-modification)</span></div>
<div class="ttc" id="anamespacekdb_html"><div class="ttname"><a href="namespacekdb.html">kdb</a></div><div class="ttdoc">This is the main namespace for the C++ binding and libraries.</div><div class="ttdef"><b>Definition:</b> backend.hpp:31</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1922"></a>
Provide query methods as part of a seperat plugin</h2>
<p>This solution only makes sense if changetrackig is implemented as part of a seperate plugin. It will be a bit challenging to use for applications, as it would require that applications have access to the plugin contracts.</p>
<p>The changetracking plugin needs to export at least functions for the following things in its contract:</p>
<ul>
<li>Get added keys</li>
<li>Get removed keys</li>
<li>Get modified keys</li>
<li>Get added meta keys for a key</li>
<li>Get removed meta keys for a key</li>
<li>Get modified meta keys for a key</li>
</ul>
<h1><a class="anchor" id="autotoc_md1923"></a>
Decision</h1>
<h1><a class="anchor" id="autotoc_md1924"></a>
Rationale</h1>
<h1><a class="anchor" id="autotoc_md1925"></a>
Implications</h1>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<h1><a class="anchor" id="autotoc_md1926"></a>
Related Decisions</h1>
<ul>
<li><a class="el" href="doc_decisions_0_drafts_operation_sequences_md.html">Valid kdbGet/kdbSet sequences</a> from <a href="https://github.com/ElektraInitiative/libelektra/pull/4574">#4574</a>.</li>
<li><a class="el" href="doc_decisions_6_implemented_copy_on_write_md.html">Copy On Write</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md1927"></a>
Notes</h1>
<ul>
<li>Issue <a href="https://issues.libelektra.org/4514">#4514</a> uncovered a problem in the current change tracking approach</li>
<li>Issue <a href="https://issues.libelektra.org/4520">#4520</a> already explored some of the considered alternatives </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
<script>
  mermaid.initialize({
    startOnLoad: true,
    theme: 'dark'
  });
</script>
</body>
</html>
