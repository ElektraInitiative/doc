<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Plugin: struct</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.22</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Plugin: struct </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>infos = Information about struct plugin is in keys below</li>
<li>infos/author = Markus Raab <a href="#" onclick="location.href='mai'+'lto:'+'ele'+'kt'+'ra@'+'li'+'bel'+'ek'+'tra'+'.o'+'rg'; return false;">elekt<span style="display: none;">.nosp@m.</span>ra@l<span style="display: none;">.nosp@m.</span>ibele<span style="display: none;">.nosp@m.</span>ktra<span style="display: none;">.nosp@m.</span>.org</a></li>
<li>infos/licence = BSD</li>
<li>infos/provides = apply check</li>
<li>infos/needs =</li>
<li>infos/ordering = check</li>
<li>infos/placements = presetstorage</li>
<li>infos/status = nodep unfinished concept</li>
<li>infos/description = Copies metadata to keys using struct</li>
</ul>
<p>This plugin is a check plugin which checks the structure and interrelations of Keys in order to verify that they represent a valid configuration.</p>
<h2>Purpose</h2>
<p>The glob plugin together with the check plugins create a good combination to check keys which are present in the KeySet. For some storage plugins like fstab, however, missing keys are as fatal as not validating keys – it is not possible to write a valid configuration file without them.</p>
<p>The problem can be described as a structure built with lists and other structures that must match with the key names of a KeySet. If a structure must have an element, contrary to glob, the plugin can yield an error if it is missing. During the matching, the plugin also applies metadata to the individual keys. Such plugins that check the structure and interrelations of keys are called structure checker. They can require that various subkeys have to or must not exist. This can happen recursively to specify any structure.</p>
<p>The struct plugin implements such a behavior. It allows enforcement of a strong consistency within the keys of one backend.</p>
<h2>Usage</h2>
<p>In order for the <code>struct</code> plugin to do its job, it needs a plugin configuration to know which structure it should check for. This configuration can be passed from a storage plugin’s <code>config/needs</code> clause.</p>
<h2>Example</h2>
<p>The <code>fstab</code> plugin uses the <code>struct</code> plugin to verify the correct structure. Here is a snippet from it's contract: </p><pre class="fragment">keyNew ("system/elektra/modules/fstab/config/needs/struct",
    KEY_VALUE, "list FStab",
    KEY_END),
keyNew ("system/elektra/modules/fstab/config/needs/struct/FStab",
    KEY_META, "check/type", "null empty",
    KEY_END),
keyNew ("system/elektra/modules/fstab/config/needs/struct/FStab/device",
    KEY_META, "check/type", "string",
    KEY_META, "check/path", "device",
    KEY_END),
keyNew ("system/elektra/modules/fstab/config/needs/struct/FStab/mpoint",
    KEY_META, "check/type", "string",
    KEY_META, "check/path", "directory",
    KEY_END),
keyNew ("system/elektra/modules/fstab/config/needs/struct/FStab/type",
    KEY_META, "check/type", "FSType",
    KEY_END),
keyNew ("system/elektra/modules/fstab/config/needs/struct/FStab/options",
    KEY_META, "check/type", "string",
    KEY_END),
keyNew ("system/elektra/modules/fstab/config/needs/struct/FStab/dumpfreq",
    KEY_META, "check/type", "unsigned_short",
    KEY_END), keyNew ("system/elektra/modules/fstab/config/needs/struct/FStab/passno",
    KEY_META, "check/type", "unsigned_short",
    KEY_END),
</pre><p>The key value of <code>needs/struct</code> within the plugin configuration marks the starting point. <code>list</code> describes the first structure to be generated. It is a built-in structure of the struct plugin that supports all subkeys in one level. It applies to every direct subkey the structure check received by the template parameter. The template parameter is, in this case, FStab. The rest of the configuration specifies how entries of FStab must look.</p>
<p>The information applied to the keys is given through metadata. This metadata is copied to each key during the structure check. If, however, a key is missing, the structure check will terminate with a failure. Any additional key will also lead to an error.</p>
<p>The metadata may be evaluated by subsequent checks. In the situation of fstab a typechecker and a path checker are both useful.</p>
<p>The purpose of such structure checks is that only a valid configuration can be stored and that neither applications nor storage plugins are surprised by configuration they do not understand.</p>
<p>The fstab plugin trusts the fact that no invalid configuration is passed. It does not check it again. Missing configuration would lead to partially set data structures. The internally used API <code>setmntent</code> crashes in that case. This leads us to the <b>purpose of contracts</b>: We want a guarantee that specific conditions are already met because we know that the code of the plugin cannot handle it.</p>
<p>Let us look at a different scenario with the same configuration. Instead of using the fstab plugin, we will use a general purpose storage plugin. For example, the dump plugin. Note that the metadata will be stored permanently in this situation. No plugin exports a <code>config/needs</code> clauses for the struct plugin in this situation. But the user can add the struct plugin and the plugin configuration, as shown in the code above, to the backend manually. Applications still can be sure that only a specific configuration will be stored and passed to them. The unwritten contract is between the application and the backend. No contract checker, however, would detect the missing configuration.</p>
<h2>Limitation</h2>
<p>This approach for defining the structure works recursively. Every element can have a value with a new structure check. Additionally, multiple template parameters can support even more generic data structures. This is, however, not yet implemented. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
