<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: kdbprivate.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.9.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kdbprivate.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Private declarations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="elektra_8h.html">elektra.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="error_8h.html">elektra/error.h</a>&gt;</code><br />
<code>#include &lt;kdb.h&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbextension_8h.html">kdbextension.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbhelper_8h.html">kdbhelper.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbio_8h.html">kdbio.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbmacros_8h.html">kdbmacros.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbnotificationinternal_8h.html">kdbnotificationinternal.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbplugin_8h.html">kdbplugin.h</a>&gt;</code><br />
<code>#include &lt;kdbtypes.h&gt;</code><br />
<code>#include &lt;<a class="el" href="kdbglobal_8h.html">kdbglobal.h</a>&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for kdbprivate.h:</div>
<div class="dyncontent">
<div class="center"><img src="kdbprivate_8h__incl.png" border="0" usemap="#akdbprivate_8h" alt=""/></div>
<map name="akdbprivate_8h" id="akdbprivate_8h">
<area shape="rect" title="Private declarations." alt="" coords="656,5,760,32"/>
<area shape="rect" href="elektra_8h.html" title="Elektra High Level API." alt="" coords="612,80,692,107"/>
<area shape="rect" href="error_8h.html" title="Elektra error." alt="" coords="5,155,120,181"/>
<area shape="rect" title=" " alt="" coords="391,229,449,256"/>
<area shape="rect" href="kdbmacros_8h.html" title="Macros by Elektra." alt="" coords="948,229,1055,256"/>
<area shape="rect" title=" " alt="" coords="825,229,919,256"/>
<area shape="rect" href="kdbextension_8h.html" title="Extension functionality." alt="" coords="137,80,260,107"/>
<area shape="rect" href="kdbhelper_8h.html" title="Helper for memory management." alt="" coords="1089,155,1188,181"/>
<area shape="rect" href="kdbio_8h.html" title="Elektra&#45;I/O structures for I/O bindings, plugins and applications." alt="" coords="261,155,331,181"/>
<area shape="rect" href="kdbnotificationinternal_8h.html" title="Elektra&#45;Notification structures and declarations for developing notification and transport plugins." alt="" coords="407,80,588,107"/>
<area shape="rect" href="kdbplugin_8h.html" title="Methods for plugin programing." alt="" coords="713,155,812,181"/>
<area shape="rect" href="kdbglobal_8h.html" title="Defines for global plugins." alt="" coords="716,80,815,107"/>
<area shape="rect" title=" " alt="" coords="1141,80,1211,107"/>
<area shape="rect" title=" " alt="" coords="21,229,104,256"/>
<area shape="rect" href="kdbmeta_8h.html" title="metadata functions" alt="" coords="145,155,237,181"/>
<area shape="rect" title=" " alt="" coords="1089,229,1164,256"/>
<area shape="rect" title=" " alt="" coords="1188,229,1263,256"/>
<area shape="rect" href="kdbnotification_8h.html" title="Elektra&#45;Notification structures and declarations for application developers." alt="" coords="508,155,639,181"/>
<area shape="rect" title=" " alt="" coords="730,229,798,256"/>
<area shape="rect" title=" " alt="" coords="635,229,706,256"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="kdbprivate_8h__dep__incl.png" border="0" usemap="#akdbprivate_8hdep" alt=""/></div>
<map name="akdbprivate_8hdep" id="akdbprivate_8hdep">
<area shape="rect" title="Private declarations." alt="" coords="1519,5,1623,32"/>
<area shape="rect" href="contracts_8c.html" title="Contract constructors for kdbOpen()" alt="" coords="93,80,187,107"/>
<area shape="rect" href="internal_8c.html" title="Internal methods for Elektra." alt="" coords="5,155,88,181"/>
<area shape="rect" href="key_8c.html" title="Methods for Key manipulation." alt="" coords="546,80,601,107"/>
<area shape="rect" href="keyhelpers_8c.html" title="Helpers for key manipulation." alt="" coords="625,80,729,107"/>
<area shape="rect" href="keymeta_8c.html" title="Methods to do various operations on Key metadata." alt="" coords="753,80,844,107"/>
<area shape="rect" href="elektra_2keyname_8c.html" title="Methods for Key name manipulation." alt="" coords="112,155,205,181"/>
<area shape="rect" href="keyset_8c.html" title="Methods for key sets." alt="" coords="230,155,306,181"/>
<area shape="rect" href="keytest_8c.html" title="Methods for making tests." alt="" coords="330,155,411,181"/>
<area shape="rect" href="keyvalue_8c.html" title="Methods for Key value manipulation." alt="" coords="869,80,961,107"/>
<area shape="rect" href="opmphm_8c.html" title="The Order Preserving Minimal Perfect Hash Map." alt="" coords="985,80,1076,107"/>
<area shape="rect" href="opmphmpredictor_8c.html" title="The Order Preserving Minimal Perfect Hash Map Predictor." alt="" coords="1101,80,1249,107"/>
<area shape="rect" href="proposal_8c.html" title="Implementation of proposed API enhancements." alt="" coords="1273,80,1362,107"/>
<area shape="rect" href="elektra_8c.html" title="Elektra High Level API." alt="" coords="1386,80,1465,107"/>
<area shape="rect" href="elektra__array__value_8c.html" title="Elektra High Level API." alt="" coords="1489,80,1652,107"/>
<area shape="rect" href="elektra__error_8c.html" title="The error module of the High level API." alt="" coords="1677,80,1793,107"/>
<area shape="rect" href="elektra__value_8c.html" title="Elektra High Level API." alt="" coords="1817,80,1940,107"/>
<area shape="rect" href="invoke_8c.html" title="Library for invoking exported plugin functions." alt="" coords="1965,80,2041,107"/>
<area shape="rect" href="io_8c.html" title="Implementation of I/O functions as defined in kdbio.h." alt="" coords="2065,80,2111,107"/>
<area shape="rect" href="meta_8c.html" title="Methods for metadata manipulation." alt="" coords="2135,80,2201,107"/>
<area shape="rect" href="notification_8c.html" title="Implementation of notification functions as defined in kdbnotification.h." alt="" coords="2225,80,2332,107"/>
<area shape="rect" href="pluginprocess_8c.html" title="Source for the pluginprocess library." alt="" coords="2356,80,2479,107"/>
<area shape="rect" href="testlib__pluginprocess_8c.html" title="Tests for pluginprocess library." alt="" coords="2503,80,2673,107"/>
<area shape="rect" href="src_2backend_8cpp.html" title="Implementation of backend." alt="" coords="2698,80,2801,107"/>
<area shape="rect" href="backendbuilder_8cpp.html" title="Implementation of backend builder." alt="" coords="2825,80,2972,107"/>
<area shape="rect" href="plugin_8cpp.html" title="Implementation of plugin." alt="" coords="2997,80,3086,107"/>
<area shape="rect" href="plugins_8cpp.html" title="Implementation of set/get/error plugins." alt="" coords="3111,80,3207,107"/>
<area shape="rect" href="mergetestutils_8cpp.html" title="Implements a helper class for merge related tests." alt="" coords="3459,80,3603,107"/>
<area shape="rect" href="testtool__mergecases_8cpp.html" title="Tests for the ThreeWayMerge." alt="" coords="3062,155,3247,181"/>
<area shape="rect" href="kdbinternal_8h.html" title="Includes most internal header files." alt="" coords="414,80,522,107"/>
<area shape="rect" href="testtool__automergestrategy_8cpp.html" title="Tests for the AutoMergeStrategy." alt="" coords="3505,155,3735,181"/>
<area shape="rect" href="testtool__metamergestrategy_8cpp.html" title="Tests for the MetaMergeStrategy." alt="" coords="3759,155,3993,181"/>
<area shape="rect" href="testtool__newkeystrategy_8cpp.html" title="Tests for the NewKeyStrategy." alt="" coords="4017,155,4225,181"/>
<area shape="rect" href="testtool__onesidestrategy_8cpp.html" title="Tests for the OneSideStrategy." alt="" coords="3271,155,3481,181"/>
<area shape="rect" href="backend_8c.html" title="Everything related to a backend." alt="" coords="895,155,982,181"/>
<area shape="rect" href="global_8c.html" title="Helpers for global plugins." alt="" coords="1006,155,1079,181"/>
<area shape="rect" href="kdb_8c.html" title="Low level functions for access the Key Database." alt="" coords="1103,155,1161,181"/>
<area shape="rect" href="mount_8c.html" title="Internals of mount functionality." alt="" coords="436,155,511,181"/>
<area shape="rect" href="elektra_2plugin_8c.html" title="Interna of plugin functionality." alt="" coords="535,155,609,181"/>
<area shape="rect" href="split_8c.html" title="Interna of splitting functionality." alt="" coords="633,155,695,181"/>
<area shape="rect" href="trie_8c.html" title="Interna of trie functionality." alt="" coords="719,155,774,181"/>
<area shape="rect" href="plugin_2plugin_8c.html" title="Access plugin handle." alt="" coords="798,155,871,181"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acf20140d9b29c3edc782e72b05b25bd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#acf20140d9b29c3edc782e72b05b25bd1">KEYSET_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:acf20140d9b29c3edc782e72b05b25bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimal allocation size of a keyset inclusive NULL byte.  <a href="kdbprivate_8h.html#acf20140d9b29c3edc782e72b05b25bd1">More...</a><br /></td></tr>
<tr class="separator:acf20140d9b29c3edc782e72b05b25bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05efd486827435a0e92220b69ae23519"><td class="memItemLeft" align="right" valign="top"><a id="a05efd486827435a0e92220b69ae23519"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a05efd486827435a0e92220b69ae23519">NR_OF_PLUGINS</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a05efd486827435a0e92220b69ae23519"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many plugins can exist in an backend. <br /></td></tr>
<tr class="separator:a05efd486827435a0e92220b69ae23519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05f21372b7a85668978778868e341f3"><td class="memItemLeft" align="right" valign="top"><a id="ae05f21372b7a85668978778868e341f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ae05f21372b7a85668978778868e341f3">COMMIT_PLUGIN</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:ae05f21372b7a85668978778868e341f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the commit plugin. <br /></td></tr>
<tr class="separator:ae05f21372b7a85668978778868e341f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88825343a6d2a664b06c61d0787132aa"><td class="memItemLeft" align="right" valign="top"><a id="a88825343a6d2a664b06c61d0787132aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a88825343a6d2a664b06c61d0787132aa">STORAGE_PLUGIN</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a88825343a6d2a664b06c61d0787132aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the storage plugin. <br /></td></tr>
<tr class="separator:a88825343a6d2a664b06c61d0787132aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ac7247e2adc4bfc9c4d5a41743cb4c"><td class="memItemLeft" align="right" valign="top"><a id="aa9ac7247e2adc4bfc9c4d5a41743cb4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#aa9ac7247e2adc4bfc9c4d5a41743cb4c">RESOLVER_PLUGIN</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa9ac7247e2adc4bfc9c4d5a41743cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of the resolver plugin. <br /></td></tr>
<tr class="separator:aa9ac7247e2adc4bfc9c4d5a41743cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9dd0e80f70ba8ad12cc00fedf52fb"><td class="memItemLeft" align="right" valign="top"><a id="a98a9dd0e80f70ba8ad12cc00fedf52fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a98a9dd0e80f70ba8ad12cc00fedf52fb">APPROXIMATE_NR_OF_BACKENDS</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a98a9dd0e80f70ba8ad12cc00fedf52fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trie optimization. <br /></td></tr>
<tr class="separator:a98a9dd0e80f70ba8ad12cc00fedf52fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f061df863d00deae4b596cb18b99f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a93f061df863d00deae4b596cb18b99f8">KDB_MAX_UCHAR</a>&#160;&#160;&#160;(UCHAR_MAX + 1)</td></tr>
<tr class="memdesc:a93f061df863d00deae4b596cb18b99f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum value of unsigned char+1, needed for iteration over trie children/values:  <a href="kdbprivate_8h.html#a93f061df863d00deae4b596cb18b99f8">More...</a><br /></td></tr>
<tr class="separator:a93f061df863d00deae4b596cb18b99f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b6deccf1a55a100f74d2e076036f37"><td class="memItemLeft" align="right" valign="top"><a id="a93b6deccf1a55a100f74d2e076036f37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a93b6deccf1a55a100f74d2e076036f37">MAX_LEN_INT</a>&#160;&#160;&#160;31</td></tr>
<tr class="memdesc:a93b6deccf1a55a100f74d2e076036f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum of how many characters an integer needs as decimal number. <br /></td></tr>
<tr class="separator:a93b6deccf1a55a100f74d2e076036f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8891eaf029de761514dca775f19d6e18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a8891eaf029de761514dca775f19d6e18">KDB_SYSTEM_ELEKTRA</a>&#160;&#160;&#160;&quot;system:/elektra&quot;</td></tr>
<tr class="memdesc:a8891eaf029de761514dca775f19d6e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend mounting information.  <a href="kdbprivate_8h.html#a8891eaf029de761514dca775f19d6e18">More...</a><br /></td></tr>
<tr class="separator:a8891eaf029de761514dca775f19d6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecff8814a02da83ec5d19d6bbac76de"><td class="memItemLeft" align="right" valign="top"><a id="abecff8814a02da83ec5d19d6bbac76de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#abecff8814a02da83ec5d19d6bbac76de">KDB_CACHE_PREFIX</a>&#160;&#160;&#160;&quot;system:/elektra/cache&quot;</td></tr>
<tr class="memdesc:abecff8814a02da83ec5d19d6bbac76de"><td class="mdescLeft">&#160;</td><td class="mdescRight">All keys below this are used for cache metadata in the global keyset. <br /></td></tr>
<tr class="separator:abecff8814a02da83ec5d19d6bbac76de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e02bbe80b6081a6485b3f3d2caec14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a22e02bbe80b6081a6485b3f3d2caec14">test_bit</a>(var,  bit)&#160;&#160;&#160;(((unsigned long long) (var)) &amp; ((unsigned long long) (bit)))</td></tr>
<tr class="memdesc:a22e02bbe80b6081a6485b3f3d2caec14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a bit.  <a href="kdbprivate_8h.html#a22e02bbe80b6081a6485b3f3d2caec14">More...</a><br /></td></tr>
<tr class="separator:a22e02bbe80b6081a6485b3f3d2caec14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4874f05226547f6afa54ed6d65dc54ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a4874f05226547f6afa54ed6d65dc54ae">set_bit</a>(var,  bit)&#160;&#160;&#160;((var) |= ((unsigned long long) (bit)))</td></tr>
<tr class="memdesc:a4874f05226547f6afa54ed6d65dc54ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bit.  <a href="kdbprivate_8h.html#a4874f05226547f6afa54ed6d65dc54ae">More...</a><br /></td></tr>
<tr class="separator:a4874f05226547f6afa54ed6d65dc54ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686cd59039c7112c10c8fbb82f9759e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a686cd59039c7112c10c8fbb82f9759e9">clear_bit</a>(var,  bit)&#160;&#160;&#160;((var) &amp;= ~((unsigned long long) (bit)))</td></tr>
<tr class="memdesc:a686cd59039c7112c10c8fbb82f9759e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a bit.  <a href="kdbprivate_8h.html#a686cd59039c7112c10c8fbb82f9759e9">More...</a><br /></td></tr>
<tr class="separator:a686cd59039c7112c10c8fbb82f9759e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a351bbaa6e81f4d1d956bb71929dc7285"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285">keyflag_t</a> { <br />
&#160;&#160;<a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285abedbc8b9c2dcfc51908d35aec7e7c756">KEY_FLAG_SYNC</a> = 1
, <a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285ab32b7424934246d1934c430408bd871f">KEY_FLAG_RO_NAME</a> = 1 &lt;&lt; 1
, <a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285abbd77cb92bacff89ef2694ec2cefb135">KEY_FLAG_RO_VALUE</a> = 1 &lt;&lt; 2
, <a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285a22971f649e6a7f6087a44e84ca0ff60d">KEY_FLAG_RO_META</a> = 1 &lt;&lt; 3
, <br />
&#160;&#160;<a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285a1778bfb5a0241719e0e04616442dbd88">KEY_FLAG_MMAP_STRUCT</a> = 1 &lt;&lt; 4
, <a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285a95b18d8c59062a4a0f2ef948db64b853">KEY_FLAG_MMAP_KEY</a> = 1 &lt;&lt; 5
, <a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285ac9ad82bd6821f6524e4a3c6c28671302">KEY_FLAG_MMAP_DATA</a> = 1 &lt;&lt; 6
<br />
 }</td></tr>
<tr class="memdesc:a351bbaa6e81f4d1d956bb71929dc7285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Flags.  <a href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285">More...</a><br /></td></tr>
<tr class="separator:a351bbaa6e81f4d1d956bb71929dc7285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf34e9cffb5c9382ad09f0f1811a61d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61d">ksflag_t</a> { <a class="el" href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61da60841484247805681f2555220aa13a6b">KS_FLAG_SYNC</a> = 1
, <a class="el" href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61da910edb310bc5b520345c34570b7e4e56">KS_FLAG_MMAP_STRUCT</a> = 1 &lt;&lt; 2
, <a class="el" href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61da1244394c87ed042c2d8aaa57f4d0ce4b">KS_FLAG_MMAP_ARRAY</a> = 1 &lt;&lt; 3
 }</td></tr>
<tr class="memdesc:afaf34e9cffb5c9382ad09f0f1811a61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced KS Flags.  <a href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61d">More...</a><br /></td></tr>
<tr class="separator:afaf34e9cffb5c9382ad09f0f1811a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad6ca41444a51395350791dbb2a0f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af7ad6ca41444a51395350791dbb2a0f8">splitflag_t</a> { <a class="el" href="kdbprivate_8h.html#af7ad6ca41444a51395350791dbb2a0f8a26d34995557a981ce39558eae0c516f9">SPLIT_FLAG_SYNC</a> = 1
, <a class="el" href="kdbprivate_8h.html#af7ad6ca41444a51395350791dbb2a0f8a10600b1b4223a2f0d3938f8bbc48be06">SPLIT_FLAG_CASCADING</a> = 1 &lt;&lt; 1
 }</td></tr>
<tr class="separator:af7ad6ca41444a51395350791dbb2a0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa17259b07015cf6c06f14814f52d01fb"><td class="memItemLeft" align="right" valign="top">Split *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#aa17259b07015cf6c06f14814f52d01fb">splitNew</a> (void)</td></tr>
<tr class="memdesc:aa17259b07015cf6c06f14814f52d01fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new split object.  <a href="kdbprivate_8h.html#aa17259b07015cf6c06f14814f52d01fb">More...</a><br /></td></tr>
<tr class="separator:aa17259b07015cf6c06f14814f52d01fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455004883f0e5afccc5c78308060d70d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a455004883f0e5afccc5c78308060d70d">splitDel</a> (Split *keysets)</td></tr>
<tr class="memdesc:a455004883f0e5afccc5c78308060d70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a split object.  <a href="kdbprivate_8h.html#a455004883f0e5afccc5c78308060d70d">More...</a><br /></td></tr>
<tr class="separator:a455004883f0e5afccc5c78308060d70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fff7d9e737c42074ab661a1cd136b4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a1fff7d9e737c42074ab661a1cd136b4c">splitRemove</a> (Split *split, size_t where)</td></tr>
<tr class="memdesc:a1fff7d9e737c42074ab661a1cd136b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove one part of split.  <a href="kdbprivate_8h.html#a1fff7d9e737c42074ab661a1cd136b4c">More...</a><br /></td></tr>
<tr class="separator:a1fff7d9e737c42074ab661a1cd136b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0850f1eb48f9f3cf6298c588b92246"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#afa0850f1eb48f9f3cf6298c588b92246">splitAppend</a> (Split *split, Backend *backend, Key *parentKey, int syncbits)</td></tr>
<tr class="memdesc:afa0850f1eb48f9f3cf6298c588b92246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the size of split and appends a new empty keyset.  <a href="kdbprivate_8h.html#afa0850f1eb48f9f3cf6298c588b92246">More...</a><br /></td></tr>
<tr class="separator:afa0850f1eb48f9f3cf6298c588b92246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcf76a5a8d1e3f93daf9e76d888e1af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a9dcf76a5a8d1e3f93daf9e76d888e1af">splitBuildup</a> (Split *split, KDB *handle, Key *parentKey)</td></tr>
<tr class="memdesc:a9dcf76a5a8d1e3f93daf9e76d888e1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks through kdb-&gt;split and adds all backends below parentKey to split.  <a href="kdbprivate_8h.html#a9dcf76a5a8d1e3f93daf9e76d888e1af">More...</a><br /></td></tr>
<tr class="separator:a9dcf76a5a8d1e3f93daf9e76d888e1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5bcc3cf34af26d3d8c69bb3cc9dadb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a9c5bcc3cf34af26d3d8c69bb3cc9dadb">splitUpdateFileName</a> (Split *split, KDB *handle, Key *key)</td></tr>
<tr class="memdesc:a9c5bcc3cf34af26d3d8c69bb3cc9dadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the (configuration) file name for the parent key.  <a href="kdbprivate_8h.html#a9c5bcc3cf34af26d3d8c69bb3cc9dadb">More...</a><br /></td></tr>
<tr class="separator:a9c5bcc3cf34af26d3d8c69bb3cc9dadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8e79fdbec5faf611bbd26df137343e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#abd8e79fdbec5faf611bbd26df137343e">splitAppoint</a> (Split *split, KDB *handle, KeySet *ks)</td></tr>
<tr class="memdesc:abd8e79fdbec5faf611bbd26df137343e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appoints all keys from ks to yet unsynced splits.  <a href="kdbprivate_8h.html#abd8e79fdbec5faf611bbd26df137343e">More...</a><br /></td></tr>
<tr class="separator:abd8e79fdbec5faf611bbd26df137343e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbeff288abf59244ddd44d82cb8d93d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#afbeff288abf59244ddd44d82cb8d93d2">splitGet</a> (Split *split, Key *warningKey, KDB *handle)</td></tr>
<tr class="memdesc:afbeff288abf59244ddd44d82cb8d93d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some work after getting of backends is finished.  <a href="kdbprivate_8h.html#afbeff288abf59244ddd44d82cb8d93d2">More...</a><br /></td></tr>
<tr class="separator:afbeff288abf59244ddd44d82cb8d93d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40883cc9699f727c1a31ba283b1d67ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a40883cc9699f727c1a31ba283b1d67ae">splitMergeBackends</a> (Split *split, KeySet *dest)</td></tr>
<tr class="memdesc:a40883cc9699f727c1a31ba283b1d67ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges together the backend based parts of split into dest, but bypasses the default split.  <a href="kdbprivate_8h.html#a40883cc9699f727c1a31ba283b1d67ae">More...</a><br /></td></tr>
<tr class="separator:a40883cc9699f727c1a31ba283b1d67ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79a6dc0ae814dad704b7b442394287d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ad79a6dc0ae814dad704b7b442394287d">splitMergeDefault</a> (Split *split, KeySet *dest)</td></tr>
<tr class="memdesc:ad79a6dc0ae814dad704b7b442394287d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the default split into dest.  <a href="kdbprivate_8h.html#ad79a6dc0ae814dad704b7b442394287d">More...</a><br /></td></tr>
<tr class="separator:ad79a6dc0ae814dad704b7b442394287d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fcdbb3d58fb0baba1459e0d8b0a94b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ae4fcdbb3d58fb0baba1459e0d8b0a94b">splitDivide</a> (Split *split, KDB *handle, KeySet *ks)</td></tr>
<tr class="memdesc:ae4fcdbb3d58fb0baba1459e0d8b0a94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits up the keysets and search for a sync bit in every key.  <a href="kdbprivate_8h.html#ae4fcdbb3d58fb0baba1459e0d8b0a94b">More...</a><br /></td></tr>
<tr class="separator:ae4fcdbb3d58fb0baba1459e0d8b0a94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fb30481571a63cfb7745adaa02d526"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af6fb30481571a63cfb7745adaa02d526">splitSync</a> (Split *split)</td></tr>
<tr class="memdesc:af6fb30481571a63cfb7745adaa02d526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add sync bits everywhere keys were removed/added.  <a href="kdbprivate_8h.html#af6fb30481571a63cfb7745adaa02d526">More...</a><br /></td></tr>
<tr class="separator:af6fb30481571a63cfb7745adaa02d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a0571065ace2b371e017cabdb9eca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af8a0571065ace2b371e017cabdb9eca7">splitPrepare</a> (Split *split)</td></tr>
<tr class="memdesc:af8a0571065ace2b371e017cabdb9eca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> mainloop afterwards.  <a href="kdbprivate_8h.html#af8a0571065ace2b371e017cabdb9eca7">More...</a><br /></td></tr>
<tr class="separator:af8a0571065ace2b371e017cabdb9eca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1938ac64ef0c120c69c6c8c3943080"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a7e1938ac64ef0c120c69c6c8c3943080">splitUpdateSize</a> (Split *split)</td></tr>
<tr class="memdesc:a7e1938ac64ef0c120c69c6c8c3943080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Also update sizes after <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> to recognize multiple <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> attempts.  <a href="kdbprivate_8h.html#a7e1938ac64ef0c120c69c6c8c3943080">More...</a><br /></td></tr>
<tr class="separator:a7e1938ac64ef0c120c69c6c8c3943080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2336c14e88bae9c48bd2f42720920d"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#aef2336c14e88bae9c48bd2f42720920d">backendOpen</a> (KeySet *elektra_config, KeySet *modules, KeySet *global, Key *errorKey)</td></tr>
<tr class="memdesc:aef2336c14e88bae9c48bd2f42720920d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a backend out of the configuration supplied from:  <a href="kdbprivate_8h.html#aef2336c14e88bae9c48bd2f42720920d">More...</a><br /></td></tr>
<tr class="separator:aef2336c14e88bae9c48bd2f42720920d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5227608d302910f25fc3a5c8968ab542"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a5227608d302910f25fc3a5c8968ab542">backendOpenDefault</a> (KeySet *modules, KeySet *global, const char *file, Key *errorKey)</td></tr>
<tr class="memdesc:a5227608d302910f25fc3a5c8968ab542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a default backend using the plugin named KDB_RESOLVER and KDB_STORAGE.  <a href="kdbprivate_8h.html#a5227608d302910f25fc3a5c8968ab542">More...</a><br /></td></tr>
<tr class="separator:a5227608d302910f25fc3a5c8968ab542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b936115b7d8c09c1905315839848c92"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a1b936115b7d8c09c1905315839848c92">backendOpenModules</a> (KeySet *modules, KeySet *global, Key *errorKey, elektraCursor pos)</td></tr>
<tr class="separator:a1b936115b7d8c09c1905315839848c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17f21b41a12609232573971823089e0"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ad17f21b41a12609232573971823089e0">backendOpenVersion</a> (KeySet *global, Key *errorKey)</td></tr>
<tr class="memdesc:ad17f21b41a12609232573971823089e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the internal version backend.  <a href="kdbprivate_8h.html#ad17f21b41a12609232573971823089e0">More...</a><br /></td></tr>
<tr class="separator:ad17f21b41a12609232573971823089e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051ae3b70fe43b1632b975fb4c26535c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a051ae3b70fe43b1632b975fb4c26535c">backendUpdateSize</a> (Backend *backend, Key *parent, int size)</td></tr>
<tr class="memdesc:a051ae3b70fe43b1632b975fb4c26535c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update internal size in backend.  <a href="kdbprivate_8h.html#a051ae3b70fe43b1632b975fb4c26535c">More...</a><br /></td></tr>
<tr class="separator:a051ae3b70fe43b1632b975fb4c26535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853bd9e11745f72b944d56e0c521e454"><td class="memItemLeft" align="right" valign="top">Plugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a853bd9e11745f72b944d56e0c521e454">elektraPluginOpen</a> (const char *backendname, KeySet *modules, KeySet *config, Key *errorKey)</td></tr>
<tr class="memdesc:a853bd9e11745f72b944d56e0c521e454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a plugin.  <a href="kdbprivate_8h.html#a853bd9e11745f72b944d56e0c521e454">More...</a><br /></td></tr>
<tr class="separator:a853bd9e11745f72b944d56e0c521e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab524d910d9cd6f040d1673589a217df2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ab524d910d9cd6f040d1673589a217df2">elektraProcessPlugin</a> (const Key *cur, int *pluginNumber, char **pluginName, char **referenceName, Key *errorKey)</td></tr>
<tr class="separator:ab524d910d9cd6f040d1673589a217df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7f402a564d2164783890d3e742b319"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a2d7f402a564d2164783890d3e742b319">elektraProcessPlugins</a> (Plugin **plugins, KeySet *modules, KeySet *referencePlugins, KeySet *config, KeySet *systemConfig, KeySet *global, Key *errorKey)</td></tr>
<tr class="memdesc:a2d7f402a564d2164783890d3e742b319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a plugin.  <a href="kdbprivate_8h.html#a2d7f402a564d2164783890d3e742b319">More...</a><br /></td></tr>
<tr class="separator:a2d7f402a564d2164783890d3e742b319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c44a58fa46e132d04a513ff9c453201"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a9c44a58fa46e132d04a513ff9c453201">elektraPluginGetFunction</a> (Plugin *plugin, const char *name)</td></tr>
<tr class="memdesc:a9c44a58fa46e132d04a513ff9c453201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a function exported by a plugin.  <a href="kdbprivate_8h.html#a9c44a58fa46e132d04a513ff9c453201">More...</a><br /></td></tr>
<tr class="separator:a9c44a58fa46e132d04a513ff9c453201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3681aca8accc06b86d25a31cc82643"><td class="memItemLeft" align="right" valign="top">Plugin *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a7b3681aca8accc06b86d25a31cc82643">elektraPluginFindGlobal</a> (KDB *handle, const char *pluginName)</td></tr>
<tr class="memdesc:a7b3681aca8accc06b86d25a31cc82643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the global plugins for a given plugin name.  <a href="kdbprivate_8h.html#a7b3681aca8accc06b86d25a31cc82643">More...</a><br /></td></tr>
<tr class="separator:a7b3681aca8accc06b86d25a31cc82643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ada1ad09f79a80df86949991dba3cb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a2ada1ad09f79a80df86949991dba3cb7">trieClose</a> (Trie *trie, Key *errorKey)</td></tr>
<tr class="memdesc:a2ada1ad09f79a80df86949991dba3cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the trie and all opened backends within.  <a href="kdbprivate_8h.html#a2ada1ad09f79a80df86949991dba3cb7">More...</a><br /></td></tr>
<tr class="separator:a2ada1ad09f79a80df86949991dba3cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675eaba21b1311eb20920e6880de7052"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a675eaba21b1311eb20920e6880de7052">trieLookup</a> (Trie *trie, const char *name)</td></tr>
<tr class="memdesc:a675eaba21b1311eb20920e6880de7052"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Trie structure.  <a href="kdbprivate_8h.html#a675eaba21b1311eb20920e6880de7052">More...</a><br /></td></tr>
<tr class="separator:a675eaba21b1311eb20920e6880de7052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab957bbaadb387f0dd73d998e4fdb5d86"><td class="memItemLeft" align="right" valign="top">Trie *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#ab957bbaadb387f0dd73d998e4fdb5d86">trieInsert</a> (Trie *trie, const char *name, Backend *value)</td></tr>
<tr class="memdesc:ab957bbaadb387f0dd73d998e4fdb5d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert into trie.  <a href="kdbprivate_8h.html#ab957bbaadb387f0dd73d998e4fdb5d86">More...</a><br /></td></tr>
<tr class="separator:ab957bbaadb387f0dd73d998e4fdb5d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff489dcf9cab7c95f88bb5a89242d9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a1ff489dcf9cab7c95f88bb5a89242d9d">mountOpen</a> (KDB *kdb, KeySet *config, KeySet *modules, Key *errorKey)</td></tr>
<tr class="memdesc:a1ff489dcf9cab7c95f88bb5a89242d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a trie from a given configuration.  <a href="kdbprivate_8h.html#a1ff489dcf9cab7c95f88bb5a89242d9d">More...</a><br /></td></tr>
<tr class="separator:a1ff489dcf9cab7c95f88bb5a89242d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30835e0251609a411eea1d629f5f1729"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a30835e0251609a411eea1d629f5f1729">mountDefault</a> (KDB *kdb, KeySet *modules, int inFallback, Key *errorKey)</td></tr>
<tr class="memdesc:a30835e0251609a411eea1d629f5f1729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopens the default backend and mounts the default backend if needed.  <a href="kdbprivate_8h.html#a30835e0251609a411eea1d629f5f1729">More...</a><br /></td></tr>
<tr class="separator:a30835e0251609a411eea1d629f5f1729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6fc92aedac3c04188c89e8a54f3c5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#aef6fc92aedac3c04188c89e8a54f3c5f">mountModules</a> (KDB *kdb, KeySet *modules, Key *errorKey)</td></tr>
<tr class="memdesc:aef6fc92aedac3c04188c89e8a54f3c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount all module configurations.  <a href="kdbprivate_8h.html#aef6fc92aedac3c04188c89e8a54f3c5f">More...</a><br /></td></tr>
<tr class="separator:aef6fc92aedac3c04188c89e8a54f3c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23024da76a37a7d29b95d052ba17644e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a23024da76a37a7d29b95d052ba17644e">mountVersion</a> (KDB *kdb, Key *errorKey)</td></tr>
<tr class="memdesc:a23024da76a37a7d29b95d052ba17644e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount the version backend.  <a href="kdbprivate_8h.html#a23024da76a37a7d29b95d052ba17644e">More...</a><br /></td></tr>
<tr class="separator:a23024da76a37a7d29b95d052ba17644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae740f9dc4ff807f236a78a443c66524"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#aae740f9dc4ff807f236a78a443c66524">mountBackend</a> (KDB *kdb, Backend *backend, Key *errorKey)</td></tr>
<tr class="memdesc:aae740f9dc4ff807f236a78a443c66524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a backend into the trie.  <a href="kdbprivate_8h.html#aae740f9dc4ff807f236a78a443c66524">More...</a><br /></td></tr>
<tr class="separator:aae740f9dc4ff807f236a78a443c66524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af951e2745e17d7b716632362199f3a30"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af951e2745e17d7b716632362199f3a30">mountGetMountpoint</a> (KDB *handle, const char *where)</td></tr>
<tr class="memdesc:af951e2745e17d7b716632362199f3a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a mountpoint in a handle for a specific key.  <a href="kdbprivate_8h.html#af951e2745e17d7b716632362199f3a30">More...</a><br /></td></tr>
<tr class="separator:af951e2745e17d7b716632362199f3a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af949f28a2f16cff516f8b1db88010fbe"><td class="memItemLeft" align="right" valign="top">Backend *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#af949f28a2f16cff516f8b1db88010fbe">mountGetBackend</a> (KDB *handle, const char *where)</td></tr>
<tr class="memdesc:af949f28a2f16cff516f8b1db88010fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup a backend handle for a specific key.  <a href="kdbprivate_8h.html#af949f28a2f16cff516f8b1db88010fbe">More...</a><br /></td></tr>
<tr class="separator:af949f28a2f16cff516f8b1db88010fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22037aad3f76f4454de4e6400637b39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#gae22037aad3f76f4454de4e6400637b39">keyReplacePrefix</a> (Key *key, const Key *oldPrefix, const Key *newPrefix)</td></tr>
<tr class="memdesc:gae22037aad3f76f4454de4e6400637b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a prefix of the key name of <code>key</code>.  <a href="group__keyname.html#gae22037aad3f76f4454de4e6400637b39">More...</a><br /></td></tr>
<tr class="separator:gae22037aad3f76f4454de4e6400637b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edeebda49ef1ad7c054411a36a9bf38"><td class="memItemLeft" align="right" valign="top">Key *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a0edeebda49ef1ad7c054411a36a9bf38">elektraKsPopAtCursor</a> (KeySet *ks, elektraCursor pos)</td></tr>
<tr class="memdesc:a0edeebda49ef1ad7c054411a36a9bf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop key at given cursor position.  <a href="kdbprivate_8h.html#a0edeebda49ef1ad7c054411a36a9bf38">More...</a><br /></td></tr>
<tr class="separator:a0edeebda49ef1ad7c054411a36a9bf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6360a1271f6410f25fbb9b95e346da1a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a6360a1271f6410f25fbb9b95e346da1a">elektraMemcpy</a> (Key **array1, Key **array2, size_t size)</td></tr>
<tr class="memdesc:a6360a1271f6410f25fbb9b95e346da1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Methods for Elektra.  <a href="kdbprivate_8h.html#a6360a1271f6410f25fbb9b95e346da1a">More...</a><br /></td></tr>
<tr class="separator:a6360a1271f6410f25fbb9b95e346da1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc60bdbe5d252a99734b0122687560be"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#abc60bdbe5d252a99734b0122687560be">elektraMemmove</a> (Key **array1, Key **array2, size_t size)</td></tr>
<tr class="memdesc:abc60bdbe5d252a99734b0122687560be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the key array2 into where array1 points.  <a href="kdbprivate_8h.html#abc60bdbe5d252a99734b0122687560be">More...</a><br /></td></tr>
<tr class="separator:abc60bdbe5d252a99734b0122687560be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba80a565f54490f362df95f401bcb29"><td class="memItemLeft" align="right" valign="top">KeySet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kdb.html#ga1ba80a565f54490f362df95f401bcb29">ksRenameKeys</a> (KeySet *config, const char *name)</td></tr>
<tr class="memdesc:ga1ba80a565f54490f362df95f401bcb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the first key and cuts off this common part for all other keys, instead name will be prepended.  <a href="group__kdb.html#ga1ba80a565f54490f362df95f401bcb29">More...</a><br /></td></tr>
<tr class="separator:ga1ba80a565f54490f362df95f401bcb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b59d3a7ccd58511b562755454d1fae"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gaa9b59d3a7ccd58511b562755454d1fae">ksRename</a> (KeySet *ks, const Key *root, const Key *newRoot)</td></tr>
<tr class="memdesc:gaa9b59d3a7ccd58511b562755454d1fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all keys below <code>root</code> to below <code>newRoot</code>.  <a href="group__keyset.html#gaa9b59d3a7ccd58511b562755454d1fae">More...</a><br /></td></tr>
<tr class="separator:gaa9b59d3a7ccd58511b562755454d1fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29e567a3a733160303a452cc2366e69"><td class="memItemLeft" align="right" valign="top">elektraCursor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyset.html#gaf29e567a3a733160303a452cc2366e69">ksFindHierarchy</a> (const KeySet *ks, const Key *root, elektraCursor *end)</td></tr>
<tr class="memdesc:gaf29e567a3a733160303a452cc2366e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the start and optionally end of the key hierachy rooted at <code>root</code> in <code>ks</code>.  <a href="group__keyset.html#gaf29e567a3a733160303a452cc2366e69">More...</a><br /></td></tr>
<tr class="separator:gaf29e567a3a733160303a452cc2366e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26bacb092ebca8f69f3fee72069733d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga26bacb092ebca8f69f3fee72069733d8">elektraKeyNameValidate</a> (const char *name, bool isComplete)</td></tr>
<tr class="memdesc:ga26bacb092ebca8f69f3fee72069733d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an escaped key name and validates it.  <a href="group__keyname.html#ga26bacb092ebca8f69f3fee72069733d8">More...</a><br /></td></tr>
<tr class="separator:ga26bacb092ebca8f69f3fee72069733d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ef3765a0ea0887c8ab72859ae2592e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga99ef3765a0ea0887c8ab72859ae2592e">elektraKeyNameCanonicalize</a> (const char *name, char **canonicalName, size_t *canonicalSizePtr, size_t offset, size_t *usizePtr)</td></tr>
<tr class="memdesc:ga99ef3765a0ea0887c8ab72859ae2592e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a valid (non-)canonical key name and produces its canonical form.  <a href="group__keyname.html#ga99ef3765a0ea0887c8ab72859ae2592e">More...</a><br /></td></tr>
<tr class="separator:ga99ef3765a0ea0887c8ab72859ae2592e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dd2a5169e900c6c8371c54c7944edb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga85dd2a5169e900c6c8371c54c7944edb">elektraKeyNameUnescape</a> (const char *name, char *unescapedName)</td></tr>
<tr class="memdesc:ga85dd2a5169e900c6c8371c54c7944edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a canonical key name and unescapes it.  <a href="group__keyname.html#ga85dd2a5169e900c6c8371c54c7944edb">More...</a><br /></td></tr>
<tr class="separator:ga85dd2a5169e900c6c8371c54c7944edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ac22f466de1a74ca72b05e8252980d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__keyname.html#ga35ac22f466de1a74ca72b05e8252980d">elektraKeyNameEscapePart</a> (const char *part, char **escapedPart)</td></tr>
<tr class="memdesc:ga35ac22f466de1a74ca72b05e8252980d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a single key name part and produces its escaped form.  <a href="group__keyname.html#ga35ac22f466de1a74ca72b05e8252980d">More...</a><br /></td></tr>
<tr class="separator:ga35ac22f466de1a74ca72b05e8252980d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0affd2cf7caf29441bf7cdf1d7cbb351"><td class="memItemLeft" align="right" valign="top">ElektraError *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a0affd2cf7caf29441bf7cdf1d7cbb351">elektraErrorCreate</a> (const char *code, const char *description, const char *module, const char *file, kdb_long_t line)</td></tr>
<tr class="memdesc:a0affd2cf7caf29441bf7cdf1d7cbb351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new ElektraError using the provided values.  <a href="kdbprivate_8h.html#a0affd2cf7caf29441bf7cdf1d7cbb351">More...</a><br /></td></tr>
<tr class="separator:a0affd2cf7caf29441bf7cdf1d7cbb351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b397979459c52ed2031d7b997679fca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a5b397979459c52ed2031d7b997679fca">elektraErrorAddWarning</a> (ElektraError *error, ElektraError *warning)</td></tr>
<tr class="memdesc:a5b397979459c52ed2031d7b997679fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a warning to an existing ElektraError struct.  <a href="kdbprivate_8h.html#a5b397979459c52ed2031d7b997679fca">More...</a><br /></td></tr>
<tr class="separator:a5b397979459c52ed2031d7b997679fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8634e58bc4cda4babdc73247fc55e25a"><td class="memItemLeft" align="right" valign="top">ElektraError *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a8634e58bc4cda4babdc73247fc55e25a">elektraErrorFromKey</a> (Key *key)</td></tr>
<tr class="memdesc:a8634e58bc4cda4babdc73247fc55e25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the error and all warnings from the given key.  <a href="kdbprivate_8h.html#a8634e58bc4cda4babdc73247fc55e25a">More...</a><br /></td></tr>
<tr class="separator:a8634e58bc4cda4babdc73247fc55e25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02947b47c6ddd80d97f76a52677aac4a"><td class="memItemLeft" align="right" valign="top">ElektraError *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a02947b47c6ddd80d97f76a52677aac4a">elektraErrorKeyNotFound</a> (const char *keyname)</td></tr>
<tr class="memdesc:a02947b47c6ddd80d97f76a52677aac4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a "Key not found" error.  <a href="kdbprivate_8h.html#a02947b47c6ddd80d97f76a52677aac4a">More...</a><br /></td></tr>
<tr class="separator:a02947b47c6ddd80d97f76a52677aac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4925bb1b9eb65b1be0cc46982888b4c4"><td class="memItemLeft" align="right" valign="top">ElektraError *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a4925bb1b9eb65b1be0cc46982888b4c4">elektraErrorWrongType</a> (const char *keyname, KDBType expectedType, KDBType actualType)</td></tr>
<tr class="memdesc:a4925bb1b9eb65b1be0cc46982888b4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a "Wrong type" error.  <a href="kdbprivate_8h.html#a4925bb1b9eb65b1be0cc46982888b4c4">More...</a><br /></td></tr>
<tr class="separator:a4925bb1b9eb65b1be0cc46982888b4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e23143abcac7e05dd2d1d9d42ddc66"><td class="memItemLeft" align="right" valign="top">ElektraError *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kdbprivate_8h.html#a69e23143abcac7e05dd2d1d9d42ddc66">elektraErrorNullError</a> (const char *function)</td></tr>
<tr class="memdesc:a69e23143abcac7e05dd2d1d9d42ddc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a "Null error argument" error.  <a href="kdbprivate_8h.html#a69e23143abcac7e05dd2d1d9d42ddc66">More...</a><br /></td></tr>
<tr class="separator:a69e23143abcac7e05dd2d1d9d42ddc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private declarations. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>BSD License (see LICENSE.md or <a href="https://www.libelektra.org">https://www.libelektra.org</a>) </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a686cd59039c7112c10c8fbb82f9759e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686cd59039c7112c10c8fbb82f9759e9">&#9670;&nbsp;</a></span>clear_bit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define clear_bit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((var) &amp;= ~((unsigned long long) (bit)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a bit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kdbprivate_8h.html#a4874f05226547f6afa54ed6d65dc54ae" title="Set a bit.">set_bit()</a> </dd></dl>

</div>
</div>
<a id="a93f061df863d00deae4b596cb18b99f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f061df863d00deae4b596cb18b99f8">&#9670;&nbsp;</a></span>KDB_MAX_UCHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KDB_MAX_UCHAR&#160;&#160;&#160;(UCHAR_MAX + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum value of unsigned char+1, needed for iteration over trie children/values: </p>
<p>for (i=0; i&lt;KDB_MAX_UCHAR; ++i) </p>

</div>
</div>
<a id="a8891eaf029de761514dca775f19d6e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8891eaf029de761514dca775f19d6e18">&#9670;&nbsp;</a></span>KDB_SYSTEM_ELEKTRA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KDB_SYSTEM_ELEKTRA&#160;&#160;&#160;&quot;system:/elektra&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backend mounting information. </p>
<p>This key directory tells you where each backend is mounted to which mountpoint. </p>

</div>
</div>
<a id="acf20140d9b29c3edc782e72b05b25bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf20140d9b29c3edc782e72b05b25bd1">&#9670;&nbsp;</a></span>KEYSET_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KEYSET_SIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimal allocation size of a keyset inclusive NULL byte. </p>
<p>ksGetAlloc() will return one less because it says how much can actually be stored. </p>

</div>
</div>
<a id="a4874f05226547f6afa54ed6d65dc54ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4874f05226547f6afa54ed6d65dc54ae">&#9670;&nbsp;</a></span>set_bit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define set_bit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((var) |= ((unsigned long long) (bit)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a bit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kdbprivate_8h.html#a686cd59039c7112c10c8fbb82f9759e9" title="Clear a bit.">clear_bit()</a> </dd></dl>

</div>
</div>
<a id="a22e02bbe80b6081a6485b3f3d2caec14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e02bbe80b6081a6485b3f3d2caec14">&#9670;&nbsp;</a></span>test_bit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define test_bit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">var, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((unsigned long long) (var)) &amp; ((unsigned long long) (bit)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test a bit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kdbprivate_8h.html#a4874f05226547f6afa54ed6d65dc54ae" title="Set a bit.">set_bit()</a>, <a class="el" href="kdbprivate_8h.html#a686cd59039c7112c10c8fbb82f9759e9" title="Clear a bit.">clear_bit()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a351bbaa6e81f4d1d956bb71929dc7285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351bbaa6e81f4d1d956bb71929dc7285">&#9670;&nbsp;</a></span>keyflag_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kdbprivate_8h.html#a351bbaa6e81f4d1d956bb71929dc7285">keyflag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key Flags. </p>
<p>Store a synchronizer state so that the Elektra knows if something has changed or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a351bbaa6e81f4d1d956bb71929dc7285abedbc8b9c2dcfc51908d35aec7e7c756"></a>KEY_FLAG_SYNC&#160;</td><td class="fielddoc"><p>Key need sync. If name, value or metadata are changed this flag will be set, so that the backend will sync the key to database. </p>
</td></tr>
<tr><td class="fieldname"><a id="a351bbaa6e81f4d1d956bb71929dc7285ab32b7424934246d1934c430408bd871f"></a>KEY_FLAG_RO_NAME&#160;</td><td class="fielddoc"><p>Read only flag for name. Key name is read only and not allowed to be changed. All attempts to change the name will lead to an error. Needed for metakeys and keys that are in a data structure that depends on name ordering. </p>
</td></tr>
<tr><td class="fieldname"><a id="a351bbaa6e81f4d1d956bb71929dc7285abbd77cb92bacff89ef2694ec2cefb135"></a>KEY_FLAG_RO_VALUE&#160;</td><td class="fielddoc"><p>Read only flag for value. Key value is read only and not allowed to be changed. All attempts to change the value will lead to an error. Needed for metakeys </p>
</td></tr>
<tr><td class="fieldname"><a id="a351bbaa6e81f4d1d956bb71929dc7285a22971f649e6a7f6087a44e84ca0ff60d"></a>KEY_FLAG_RO_META&#160;</td><td class="fielddoc"><p>Read only flag for meta. Key meta is read only and not allowed to be changed. All attempts to change the value will lead to an error. Needed for metakeys. </p>
</td></tr>
<tr><td class="fieldname"><a id="a351bbaa6e81f4d1d956bb71929dc7285a1778bfb5a0241719e0e04616442dbd88"></a>KEY_FLAG_MMAP_STRUCT&#160;</td><td class="fielddoc"><p>Key struct lies inside a mmap region. This flag is set for Keys inside a mapped region. It prevents erroneous free() calls on these keys. </p>
</td></tr>
<tr><td class="fieldname"><a id="a351bbaa6e81f4d1d956bb71929dc7285a95b18d8c59062a4a0f2ef948db64b853"></a>KEY_FLAG_MMAP_KEY&#160;</td><td class="fielddoc"><p>Key name lies inside a mmap region. This flag is set once a Key name has been moved to a mapped region, and is removed if the name moves out of the mapped region. It prevents erroneous free() calls on these keys. </p>
</td></tr>
<tr><td class="fieldname"><a id="a351bbaa6e81f4d1d956bb71929dc7285ac9ad82bd6821f6524e4a3c6c28671302"></a>KEY_FLAG_MMAP_DATA&#160;</td><td class="fielddoc"><p>Key value lies inside a mmap region. This flag is set once a Key value has been moved to a mapped region, and is removed if the value moves out of the mapped region. It prevents erroneous free() calls on these keys. </p>
</td></tr>
</table>

</div>
</div>
<a id="afaf34e9cffb5c9382ad09f0f1811a61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf34e9cffb5c9382ad09f0f1811a61d">&#9670;&nbsp;</a></span>ksflag_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kdbprivate_8h.html#afaf34e9cffb5c9382ad09f0f1811a61d">ksflag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced KS Flags. </p>
<p>Store a synchronizer state so that the Elektra knows if something has changed or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afaf34e9cffb5c9382ad09f0f1811a61da60841484247805681f2555220aa13a6b"></a>KS_FLAG_SYNC&#160;</td><td class="fielddoc"><p>KeySet need sync. If keys were popped from the Keyset this flag will be set, so that the backend will sync the keys to database. </p>
</td></tr>
<tr><td class="fieldname"><a id="afaf34e9cffb5c9382ad09f0f1811a61da910edb310bc5b520345c34570b7e4e56"></a>KS_FLAG_MMAP_STRUCT&#160;</td><td class="fielddoc"><p>KeySet struct lies inside a mmap region. This flag is set for KeySets inside a mapped region. It prevents erroneous free() calls on these KeySets. </p>
</td></tr>
<tr><td class="fieldname"><a id="afaf34e9cffb5c9382ad09f0f1811a61da1244394c87ed042c2d8aaa57f4d0ce4b"></a>KS_FLAG_MMAP_ARRAY&#160;</td><td class="fielddoc"><p>Array of the KeySet lies inside a mmap region. This flag is set for KeySets where the array is in a mapped region, and is removed if the array is moved out from the mapped region. It prevents erroneous free() calls on these arrays. </p>
</td></tr>
</table>

</div>
</div>
<a id="af7ad6ca41444a51395350791dbb2a0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ad6ca41444a51395350791dbb2a0f8">&#9670;&nbsp;</a></span>splitflag_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kdbprivate_8h.html#af7ad6ca41444a51395350791dbb2a0f8">splitflag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af7ad6ca41444a51395350791dbb2a0f8a26d34995557a981ce39558eae0c516f9"></a>SPLIT_FLAG_SYNC&#160;</td><td class="fielddoc"><p>KeySet in Split need sync. Is there any key in there which need to be synced? If keys were popped from the Keyset this flag will be set, so that the backend will sync the keys to database. </p>
</td></tr>
<tr><td class="fieldname"><a id="af7ad6ca41444a51395350791dbb2a0f8a10600b1b4223a2f0d3938f8bbc48be06"></a>SPLIT_FLAG_CASCADING&#160;</td><td class="fielddoc"><p>Do we need relative checks? Is this a cascading backend? </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aef2336c14e88bae9c48bd2f42720920d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2336c14e88bae9c48bd2f42720920d">&#9670;&nbsp;</a></span>backendOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* backendOpen </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>elektraConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a backend out of the configuration supplied from: </p>
<pre class="fragment">system:/elektra/mountpoints/&lt;name&gt;
</pre><p>The root key must be like the above example. You do not need to rewind the keyset. But every key must be below the root key.</p>
<p>The internal consistency will be checked in this function. If necessary parts are missing, like no plugins, they cant be loaded or similar 0 will be returned.</p>
<p><a class="el" href="group__keyset.html#ga6b00cf82b59af4d883a9bad6cf4a4a4a" title="Cuts out all Keys from KeySet ks that are below or at cutpoint.">ksCut()</a> is perfectly suitable for cutting out the configuration like needed.</p>
<dl class="section note"><dt>Note</dt><dd>The given KeySet will be deleted within the function, don't use it afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elektraConfig</td><td>the configuration to work with. It is used to build up this backend. </td></tr>
    <tr><td class="paramname">modules</td><td>used to load new modules or get references to existing one </td></tr>
    <tr><td class="paramname">global</td><td>the global keyset of the KDB instance </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key where an error and warnings are added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a freshly allocated backend this could be the requested backend or a so called "missing backend". </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if out of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5227608d302910f25fc3a5c8968ab542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5227608d302910f25fc3a5c8968ab542">&#9670;&nbsp;</a></span>backendOpenDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* backendOpenDefault </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a default backend using the plugin named KDB_RESOLVER and KDB_STORAGE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modules</td><td>the modules to work with </td></tr>
    <tr><td class="paramname">global</td><td>the global keyset of the KDB instance </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key to issue warnings and errors to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fresh allocated default backend or 0 if it failed </dd></dl>

</div>
</div>
<a id="a1b936115b7d8c09c1905315839848c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b936115b7d8c09c1905315839848c92">&#9670;&nbsp;</a></span>backendOpenModules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* backendOpenModules </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">elektraCursor&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a backend which gives plugin configuration of the module which is currently point to.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modules</td><td>the modules to work with </td></tr>
    <tr><td class="paramname">global</td><td>the global keyset of the KDB instance </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key to issue warnings and errors to </td></tr>
    <tr><td class="paramname">pos</td><td>the position of plugin the use in <code>modules</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad17f21b41a12609232573971823089e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17f21b41a12609232573971823089e0">&#9670;&nbsp;</a></span>backendOpenVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* backendOpenVersion </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the internal version backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global</td><td>the global keyset of the KDB instance </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key to issue warnings and errors to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the fresh allocated default backend or 0 if it failed </dd></dl>

</div>
</div>
<a id="a051ae3b70fe43b1632b975fb4c26535c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051ae3b70fe43b1632b975fb4c26535c">&#9670;&nbsp;</a></span>backendUpdateSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int backendUpdateSize </td>
          <td>(</td>
          <td class="paramtype">Backend *&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update internal size in backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backend</td><td>the backend to update </td></tr>
    <tr><td class="paramname">parent</td><td>for parent </td></tr>
    <tr><td class="paramname">size</td><td>to update (-1 default, 0 empty, &gt;0 otherwise)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>parent must be serializable namespace</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if invalid parent (assert) </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b397979459c52ed2031d7b997679fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b397979459c52ed2031d7b997679fca">&#9670;&nbsp;</a></span>elektraErrorAddWarning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraErrorAddWarning </td>
          <td>(</td>
          <td class="paramtype">ElektraError *&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElektraError *&#160;</td>
          <td class="paramname"><em>warning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a warning to an existing ElektraError struct. </p>
<p>If you want to report a warning without an error, create a dummy error with <a class="el" href="group__highlevel.html#ga4895fb4c40822a11219846b189395db0" title="Creates a dummy ElektraError struct to store warnings in.">elektraErrorPureWarning()</a> and then add a warning to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>The error to which <code>warning</code> shall be added. </td></tr>
    <tr><td class="paramname">warning</td><td>The warning to add. Once added it is owned by <code>error</code>. DO NOT call <a class="el" href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693" title="Frees the memory used by the error and sets the referenced error variable to NULL.">elektraErrorReset()</a> on it afterwards. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0affd2cf7caf29441bf7cdf1d7cbb351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0affd2cf7caf29441bf7cdf1d7cbb351">&#9670;&nbsp;</a></span>elektraErrorCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ElektraError* elektraErrorCreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kdb_long_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new ElektraError using the provided values. </p>
<p>The returned value will be allocated with <a class="el" href="internal_8c.html#a848ed030434c76176167fac6ab79429c" title="Allocate memory for Elektra.">elektraCalloc()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The error code of the error. Will be copied and stored in the struct. </td></tr>
    <tr><td class="paramname">description</td><td>The description of the error. Will be copied and stored in the struct. </td></tr>
    <tr><td class="paramname">module</td><td>The module that raised the error. Will be copied and stored in the struct. </td></tr>
    <tr><td class="paramname">file</td><td>The file that raised the error. Will be copied and stored in the struct. </td></tr>
    <tr><td class="paramname">line</td><td>The line in which the error was raised.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated ElektraError (free with <a class="el" href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693" title="Frees the memory used by the error and sets the referenced error variable to NULL.">elektraErrorReset()</a>). </dd></dl>

</div>
</div>
<a id="a8634e58bc4cda4babdc73247fc55e25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8634e58bc4cda4babdc73247fc55e25a">&#9670;&nbsp;</a></span>elektraErrorFromKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ElektraError* elektraErrorFromKey </td>
          <td>(</td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the error and all warnings from the given key. </p>
<p>If no error exists, a pure warning error will be used. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__highlevel.html#ga4895fb4c40822a11219846b189395db0" title="Creates a dummy ElektraError struct to store warnings in.">elektraErrorPureWarning</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use the functions in <a class="el" href="errors_8c.html" title="Used for writing the error/warning information into a key to be used for emitting messages to the use...">src/libs/elektra/errors.c</a> to add errors to a key.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The to extract error and warnings from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated ElektraError (free with <a class="el" href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693" title="Frees the memory used by the error and sets the referenced error variable to NULL.">elektraErrorReset()</a>). </dd></dl>

</div>
</div>
<a id="a02947b47c6ddd80d97f76a52677aac4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02947b47c6ddd80d97f76a52677aac4a">&#9670;&nbsp;</a></span>elektraErrorKeyNotFound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ElektraError* elektraErrorKeyNotFound </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a "Key not found" error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyname</td><td>The name of the key that wasn't found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated ElektraError (free with <a class="el" href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693" title="Frees the memory used by the error and sets the referenced error variable to NULL.">elektraErrorReset()</a>). </dd></dl>

</div>
</div>
<a id="a69e23143abcac7e05dd2d1d9d42ddc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e23143abcac7e05dd2d1d9d42ddc66">&#9670;&nbsp;</a></span>elektraErrorNullError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ElektraError* elektraErrorNullError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a "Null error argument" error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The name of the function that was called with a null pointer error argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated ElektraError (free with <a class="el" href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693" title="Frees the memory used by the error and sets the referenced error variable to NULL.">elektraErrorReset()</a>). </dd></dl>

</div>
</div>
<a id="a4925bb1b9eb65b1be0cc46982888b4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4925bb1b9eb65b1be0cc46982888b4c4">&#9670;&nbsp;</a></span>elektraErrorWrongType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ElektraError* elektraErrorWrongType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDBType&#160;</td>
          <td class="paramname"><em>expectedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDBType&#160;</td>
          <td class="paramname"><em>actualType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a "Wrong type" error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyname</td><td>The name of the key that had the wrong type. </td></tr>
    <tr><td class="paramname">expectedType</td><td>The type that was expected. </td></tr>
    <tr><td class="paramname">actualType</td><td>The type that was actually found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated ElektraError (free with <a class="el" href="group__highlevel.html#ga591f7ed4b57a341928bf7bb3d7adb693" title="Frees the memory used by the error and sets the referenced error variable to NULL.">elektraErrorReset()</a>). </dd></dl>

</div>
</div>
<a id="a0edeebda49ef1ad7c054411a36a9bf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edeebda49ef1ad7c054411a36a9bf38">&#9670;&nbsp;</a></span>elektraKsPopAtCursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* elektraKsPopAtCursor </td>
          <td>(</td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">elektraCursor&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop key at given cursor position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ks</td><td>the keyset to pop key from </td></tr>
    <tr><td class="paramname">c</td><td>where to pop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the popped key </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ks is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6360a1271f6410f25fbb9b95e346da1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6360a1271f6410f25fbb9b95e346da1a">&#9670;&nbsp;</a></span>elektraMemcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t elektraMemcpy </td>
          <td>(</td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal Methods for Elektra. </p>
<p>To use them: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kdbinternal_8h.html">kdbinternal.h</a>&gt;</span></div>
<div class="ttc" id="akdbinternal_8h_html"><div class="ttname"><a href="kdbinternal_8h.html">kdbinternal.h</a></div><div class="ttdoc">Includes most internal header files.</div></div>
</div><!-- fragment --><p>There are some areas where libraries have to reimplement some basic functions to archive support for non-standard systems, for testing purposes or to provide a little more convenience. Copies the key array2 into where array1 points. It copies size elements.</p>
<p>Overlapping is prohibited, use <a class="el" href="internal_8c.html#abc60bdbe5d252a99734b0122687560be" title="Copies the key array2 into where array1 points.">elektraMemmove()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array1</td><td>the destination </td></tr>
    <tr><td class="paramname">array2</td><td>the source </td></tr>
    <tr><td class="paramname">size</td><td>how many pointer to Keys to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointers </td></tr>
    <tr><td class="paramname">0</td><td>if nothing was done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size how many keys were copied </dd></dl>

</div>
</div>
<a id="abc60bdbe5d252a99734b0122687560be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc60bdbe5d252a99734b0122687560be">&#9670;&nbsp;</a></span>elektraMemmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t elektraMemmove </td>
          <td>(</td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key **&#160;</td>
          <td class="paramname"><em>array2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the key array2 into where array1 points. </p>
<p>It copies size elements.</p>
<p>Overlapping is ok. If they do not overlap consider <a class="el" href="internal_8c.html#a6360a1271f6410f25fbb9b95e346da1a" title="Internal Methods for Elektra.">elektraMemcpy()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array1</td><td>the destination </td></tr>
    <tr><td class="paramname">array2</td><td>the source </td></tr>
    <tr><td class="paramname">size</td><td>how many pointer to Keys to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on null pointers </td></tr>
    <tr><td class="paramname">0</td><td>if nothing was done </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size how many keys were copied </dd></dl>

</div>
</div>
<a id="a7b3681aca8accc06b86d25a31cc82643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3681aca8accc06b86d25a31cc82643">&#9670;&nbsp;</a></span>elektraPluginFindGlobal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Plugin* elektraPluginFindGlobal </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pluginName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the global plugins for a given plugin name. </p>
<p>NOTE: if the list plugin occupies the prerollback position, this queries the list plugin first, and only if we don't find anything there, we look directly in the global plugins array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The KDB handle to search </td></tr>
    <tr><td class="paramname">pluginName</td><td>The plugin name to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plugin handle, if found or NULL otherwise </dd></dl>

</div>
</div>
<a id="a9c44a58fa46e132d04a513ff9c453201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c44a58fa46e132d04a513ff9c453201">&#9670;&nbsp;</a></span>elektraPluginGetFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t elektraPluginGetFunction </td>
          <td>(</td>
          <td class="paramtype">Plugin *&#160;</td>
          <td class="paramname"><em>plugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a function exported by a plugin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plugin</td><td>Plugin handle </td></tr>
    <tr><td class="paramname">name</td><td>Function name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to function. NULL if function not found or not enough memory available </dd></dl>

</div>
</div>
<a id="a853bd9e11745f72b944d56e0c521e454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853bd9e11745f72b944d56e0c521e454">&#9670;&nbsp;</a></span>elektraPluginOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Plugin* elektraPluginOpen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a plugin. </p>
<p>The config will be used as is. So be sure to transfer ownership of the config to it, with e.g. <a class="el" href="group__keyset.html#gac59e4b328245463f1451f68d5106151c" title="Return a duplicate of a KeySet.">ksDup()</a>. elektraPluginClose() will delete the config.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new created plugin or 0 on error </dd></dl>

</div>
</div>
<a id="ab524d910d9cd6f040d1673589a217df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab524d910d9cd6f040d1673589a217df2">&#9670;&nbsp;</a></span>elektraProcessPlugin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraProcessPlugin </td>
          <td>(</td>
          <td class="paramtype">const Key *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pluginNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>referenceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>and an allocated string of the pluginName if a new plugins should be created. </td></tr>
    <tr><td class="paramname">2</td><td>and an allocated string of the referenceName if an old plugin should be used </td></tr>
    <tr><td class="paramname">3</td><td>and both if a new plugin should be created and made available for later back referencing. </td></tr>
    <tr><td class="paramname">-1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d7f402a564d2164783890d3e742b319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7f402a564d2164783890d3e742b319">&#9670;&nbsp;</a></span>elektraProcessPlugins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraProcessPlugins </td>
          <td>(</td>
          <td class="paramtype">Plugin **&#160;</td>
          <td class="paramname"><em>plugins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>referencePlugins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>systemConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a plugin. </p>
<p>The array of plugins must be set to 0. Its length is NR_OF_PLUGINS.</p>
<p>systemConfig will only be used, not deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>the config with the information how the plugins should be put together </td></tr>
    <tr><td class="paramname">systemConfig</td><td>the shared (system) config for the plugins. Every plugin additional get this config. </td></tr>
    <tr><td class="paramname">global</td><td>the global keyset of the KDB instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae740f9dc4ff807f236a78a443c66524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae740f9dc4ff807f236a78a443c66524">&#9670;&nbsp;</a></span>mountBackend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mountBackend </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Backend *&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a backend into the trie. </p>
<dl class="section pre"><dt>Precondition</dt><dd>user must pass correctly allocated backend </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>sets reference counter of backend</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>in case of init and default backends, the reference counter needs to be modified <em>after</em> calling mountBackend.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">backend</td><td>the backend to mount </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on failure </td></tr>
    <tr><td class="paramname">1</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30835e0251609a411eea1d629f5f1729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30835e0251609a411eea1d629f5f1729">&#9670;&nbsp;</a></span>mountDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mountDefault </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inFallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reopens the default backend and mounts the default backend if needed. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Default Backend is closed. mountOpen was executed before.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">modules</td><td>the current list of loaded modules </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af949f28a2f16cff516f8b1db88010fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af949f28a2f16cff516f8b1db88010fbe">&#9670;&nbsp;</a></span>mountGetBackend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* mountGetBackend </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup a backend handle for a specific key. </p>
<p>The required canonical name is ensured by using a key as parameter, which will transform the key to canonical representation.</p>
<p>Will return handle when no more specific KDB could be found.</p>
<p>If key is 0 or invalid the default backend will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>is the data structure, where the mounted directories are saved. </td></tr>
    <tr><td class="paramname">where</td><td>the key name, that should be looked up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the backend handle associated with the key </dd></dl>

</div>
</div>
<a id="af951e2745e17d7b716632362199f3a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af951e2745e17d7b716632362199f3a30">&#9670;&nbsp;</a></span>mountGetMountpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key* mountGetMountpoint </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup a mountpoint in a handle for a specific key. </p>
<p>Will return a key representing the mountpoint or null if there is no appropriate mountpoint e.g. its the root mountpoint.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">KDB * handle = <a class="code" href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5">kdbOpen</a>();</div>
<div class="line">Key *mountpoint=0;</div>
<div class="line">mountpoint=kdbGetMountpoint(handle, <span class="stringliteral">&quot;system:/template&quot;</span>);</div>
<div class="line"> </div>
<div class="line">printf(<span class="stringliteral">&quot;The backend I am using is %s mounted in %s\n&quot;</span>,</div>
<div class="line">        <a class="code" href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a>(mountpoint),</div>
<div class="line">        <a class="code" href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a>(mountpoint));</div>
<div class="line"><a class="code" href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f">kdbClose</a> (handle);</div>
<div class="ttc" id="agroup__kdb_html_ga844e1299a84c3fbf1d3a905c5c893ba5"><div class="ttname"><a href="group__kdb.html#ga844e1299a84c3fbf1d3a905c5c893ba5">kdbOpen</a></div><div class="ttdeci">KDB * kdbOpen(const KeySet *contract, Key *errorKey)</div><div class="ttdoc">Opens the session with the Key database.</div><div class="ttdef"><b>Definition:</b> kdb.c:413</div></div>
<div class="ttc" id="agroup__kdb_html_gadb54dc9fda17ee07deb9444df745c96f"><div class="ttname"><a href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f">kdbClose</a></div><div class="ttdeci">int kdbClose(KDB *handle, Key *errorKey)</div><div class="ttdoc">Closes the session with the Key database.</div><div class="ttdef"><b>Definition:</b> kdb.c:585</div></div>
<div class="ttc" id="agroup__keyname_html_ga8e805c726a60da921d3736cda7813513"><div class="ttname"><a href="group__keyname.html#ga8e805c726a60da921d3736cda7813513">keyName</a></div><div class="ttdeci">const char * keyName(const Key *key)</div><div class="ttdoc">Returns a pointer to the abbreviated real internal key name.</div><div class="ttdef"><b>Definition:</b> elektra/keyname.c:256</div></div>
<div class="ttc" id="agroup__keyvalue_html_ga6f29609c5da53c6dc26a98678d5752af"><div class="ttname"><a href="group__keyvalue.html#ga6f29609c5da53c6dc26a98678d5752af">keyValue</a></div><div class="ttdeci">const void * keyValue(const Key *key)</div><div class="ttdoc">Return a pointer to the real internal key value.</div><div class="ttdef"><b>Definition:</b> keyvalue.c:163</div></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>is the data structure, where the mounted directories are saved. </td></tr>
    <tr><td class="paramname">where</td><td>the key name, that should be looked up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mountpoint associated with the key </dd></dl>

</div>
</div>
<a id="aef6fc92aedac3c04188c89e8a54f3c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6fc92aedac3c04188c89e8a54f3c5f">&#9670;&nbsp;</a></span>mountModules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mountModules </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount all module configurations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">modules</td><td>the current list of loaded modules </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if not rootkey was found </td></tr>
    <tr><td class="paramname">0</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ff489dcf9cab7c95f88bb5a89242d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff489dcf9cab7c95f88bb5a89242d9d">&#9670;&nbsp;</a></span>mountOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mountOpen </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a trie from a given configuration. </p>
<p>The config will be deleted within this function.</p>
<dl class="section note"><dt>Note</dt><dd>mountDefault is not allowed to be executed before</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">modules</td><td>the current list of loaded modules </td></tr>
    <tr><td class="paramname">config</td><td>the configuration which should be used to build up the trie. </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on failure </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23024da76a37a7d29b95d052ba17644e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23024da76a37a7d29b95d052ba17644e">&#9670;&nbsp;</a></span>mountVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mountVersion </td>
          <td>(</td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount the version backend. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kdb</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa0850f1eb48f9f3cf6298c588b92246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0850f1eb48f9f3cf6298c588b92246">&#9670;&nbsp;</a></span>splitAppend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t splitAppend </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Backend *&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>parentKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>syncbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the size of split and appends a new empty keyset. </p>
<p>Initializes the element with the given parameters at size-1 to be used.</p>
<p>Will automatically resize split if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">backend</td><td>the backend which should be appended </td></tr>
    <tr><td class="paramname">parentKey</td><td>the parentKey which should be appended </td></tr>
    <tr><td class="paramname">syncbits</td><td>the initial syncstate which should be appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if no split is found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the new element: size-1 </dd></dl>

</div>
</div>
<a id="abd8e79fdbec5faf611bbd26df137343e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e79fdbec5faf611bbd26df137343e">&#9670;&nbsp;</a></span>splitAppoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int splitAppoint </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appoints all keys from ks to yet unsynced splits. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="split_8c.html#ad04a357eb6e46aa889e7f72f063e0263" title="Walks through kdb-&gt;split and adds all backends below parentKey to split.">splitBuildup()</a> need to be executed before.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">handle</td><td>to determine to which backend a key belongs </td></tr>
    <tr><td class="paramname">ks</td><td>the keyset to appoint to split</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>if no backend was found for a key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dcf76a5a8d1e3f93daf9e76d888e1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcf76a5a8d1e3f93daf9e76d888e1af">&#9670;&nbsp;</a></span>splitBuildup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int splitBuildup </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>kdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>parentKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walks through kdb-&gt;split and adds all backends below parentKey to split. </p>
<p>Sets syncbits to 2 if it is a default or root backend (which needs splitting). The information is copied from kdb-&gt;split.</p>
<dl class="section pre"><dt>Precondition</dt><dd>split needs to be empty, directly after creation with <a class="el" href="split_8c.html#aa17259b07015cf6c06f14814f52d01fb" title="Allocates a new split object.">splitNew()</a>.</dd>
<dd>
there needs to be a valid defaultBackend but its ok not to have a trie inside KDB.</dd>
<dd>
parentKey must be a valid key! (could be implemented more generally, but that would require splitting up of keysets of the same backend)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>will get all backends appended </td></tr>
    <tr><td class="paramname">kdb</td><td>the handle to get information about backends </td></tr>
    <tr><td class="paramname">parentKey</td><td>the information below which key the backends are from interest</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a455004883f0e5afccc5c78308060d70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455004883f0e5afccc5c78308060d70d">&#9670;&nbsp;</a></span>splitDel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splitDel </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>keysets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a split object. </p>
<p>Will free all allocated resources of a split keyset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysets</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4fcdbb3d58fb0baba1459e0d8b0a94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fcdbb3d58fb0baba1459e0d8b0a94b">&#9670;&nbsp;</a></span>splitDivide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int splitDivide </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>ks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits up the keysets and search for a sync bit in every key. </p>
<p>It does not check if there were removed keys, see <a class="el" href="split_8c.html#af6fb30481571a63cfb7745adaa02d526" title="Add sync bits everywhere keys were removed/added.">splitSync()</a> for the next step.</p>
<p>It does not create new backends, this has to be done by buildup before.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="split_8c.html#ad04a357eb6e46aa889e7f72f063e0263" title="Walks through kdb-&gt;split and adds all backends below parentKey to split.">splitBuildup()</a> need to be executed before.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">handle</td><td>to get information where the individual keys belong </td></tr>
    <tr><td class="paramname">ks</td><td>the keyset to divide</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if there were no sync bits </td></tr>
    <tr><td class="paramname">1</td><td>if there were sync bits </td></tr>
    <tr><td class="paramname">-1</td><td>if no backend was found for any key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbeff288abf59244ddd44d82cb8d93d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbeff288abf59244ddd44d82cb8d93d2">&#9670;&nbsp;</a></span>splitGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int splitGet </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>warningKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does some work after getting of backends is finished. </p>
<ul>
<li>Update sizes</li>
<li>Removal of wrong keys</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="split_8c.html#abd8e79fdbec5faf611bbd26df137343e" title="Appoints all keys from ks to yet unsynced splits.">splitAppoint()</a> needs to be executed before.</dd></dl>
<ul>
<li>check if keys are in correct backend</li>
<li>remove syncbits</li>
<li>update sizes in the backends</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">warningKey</td><td>postcondition violations are reported here </td></tr>
    <tr><td class="paramname">handle</td><td>the handle to preprocess the keys </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>if no backend was found for a key or split-&gt;parents has invalid namespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40883cc9699f727c1a31ba283b1d67ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40883cc9699f727c1a31ba283b1d67ae">&#9670;&nbsp;</a></span>splitMergeBackends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int splitMergeBackends </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges together the backend based parts of split into dest, but bypasses the default split. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">dest</td><td>the destination keyset where all keysets are appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad79a6dc0ae814dad704b7b442394287d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79a6dc0ae814dad704b7b442394287d">&#9670;&nbsp;</a></span>splitMergeDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int splitMergeDefault </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the default split into dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">dest</td><td>the destination keyset where all keysets are appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa17259b07015cf6c06f14814f52d01fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17259b07015cf6c06f14814f52d01fb">&#9670;&nbsp;</a></span>splitNew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Split* splitNew </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new split object. </p>
<p>Splits up a keyset into multiple keysets where each of them will passed to the correct <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a>.</p>
<p>Initially the size is 0 and alloc is APPROXIMATE_NR_OF_BACKENDS.</p>
<dl class="section return"><dt>Returns</dt><dd>a fresh allocated split object</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="split_8c.html#a455004883f0e5afccc5c78308060d70d" title="Delete a split object.">splitDel()</a> </dd></dl>

</div>
</div>
<a id="af8a0571065ace2b371e017cabdb9eca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a0571065ace2b371e017cabdb9eca7">&#9670;&nbsp;</a></span>splitPrepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splitPrepare </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> mainloop afterwards. </p>
<p>All splits which do not need sync are removed and a deep copy of the remaining keysets is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fff7d9e737c42074ab661a1cd136b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fff7d9e737c42074ab661a1cd136b4c">&#9670;&nbsp;</a></span>splitRemove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splitRemove </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove one part of split. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
    <tr><td class="paramname">where</td><td>the position to cut away</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>where must be within the size of the split </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>split will be removed </dd></dl>

</div>
</div>
<a id="af6fb30481571a63cfb7745adaa02d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fb30481571a63cfb7745adaa02d526">&#9670;&nbsp;</a></span>splitSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int splitSync </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add sync bits everywhere keys were removed/added. </p>
<ul>
<li>checks if the size of a previous <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> is unchanged.</li>
<li>checks if in correct state (<a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> needs to be executed before)</li>
</ul>
<p>Only <a class="el" href="split_8c.html#ae4fcdbb3d58fb0baba1459e0d8b0a94b" title="Splits up the keysets and search for a sync bit in every key.">splitDivide()</a> together with this function can really decide if sync is needed or not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>split needs to be processed with <a class="el" href="split_8c.html#ae4fcdbb3d58fb0baba1459e0d8b0a94b" title="Splits up the keysets and search for a sync bit in every key.">splitDivide()</a> before.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> is not needed </td></tr>
    <tr><td class="paramname">1</td><td>if <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> is needed </td></tr>
    <tr><td class="paramname">-1</td><td>on wrong keys (also has assert, should not happen) </td></tr>
    <tr><td class="paramname">-2</td><td>wrong spec state: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> was not executed before </td></tr>
    <tr><td class="paramname">-3</td><td>wrong dir state: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> was not executed before </td></tr>
    <tr><td class="paramname">-4</td><td>wrong user state: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> was not executed before </td></tr>
    <tr><td class="paramname">-5</td><td>wrong system state: <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve Keys from a Key database in an atomic and universal way.">kdbGet()</a> was not executed before </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>user:/system was split before. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split object to work with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c5bcc3cf34af26d3d8c69bb3cc9dadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5bcc3cf34af26d3d8c69bb3cc9dadb">&#9670;&nbsp;</a></span>splitUpdateFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void splitUpdateFileName </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KDB *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the (configuration) file name for the parent key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split</td><td>the split to work with </td></tr>
    <tr><td class="paramname">handle</td><td>the handle to work with </td></tr>
    <tr><td class="paramname">key</td><td>the parentKey that should be updated (name must be correct) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e1938ac64ef0c120c69c6c8c3943080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1938ac64ef0c120c69c6c8c3943080">&#9670;&nbsp;</a></span>splitUpdateSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int splitUpdateSize </td>
          <td>(</td>
          <td class="paramtype">Split *&#160;</td>
          <td class="paramname"><em>split</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Also update sizes after <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> to recognize multiple <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a> attempts. </p>
<dl class="section warning"><dt>Warning</dt><dd>cant use the same code with splitGet because there is no default split part for <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set Keys to a Key database in an atomic and universal way.">kdbSet()</a>. </dd></dl>

</div>
</div>
<a id="a2ada1ad09f79a80df86949991dba3cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ada1ad09f79a80df86949991dba3cb7">&#9670;&nbsp;</a></span>trieClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int trieClose </td>
          <td>(</td>
          <td class="paramtype">Trie *&#160;</td>
          <td class="paramname"><em>trie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key *&#160;</td>
          <td class="paramname"><em>errorKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the trie and all opened backends within. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trie</td><td>the trie to close </td></tr>
    <tr><td class="paramname">errorKey</td><td>the key used to report warnings</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab957bbaadb387f0dd73d998e4fdb5d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab957bbaadb387f0dd73d998e4fdb5d86">&#9670;&nbsp;</a></span>trieInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Trie* trieInsert </td>
          <td>(</td>
          <td class="paramtype">Trie *&#160;</td>
          <td class="paramname"><em>trie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Backend *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert into trie. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trie</td><td>the trie to insert to (0 to create a new trie) </td></tr>
    <tr><td class="paramname">name</td><td>the key's name to insert </td></tr>
    <tr><td class="paramname">value</td><td>the value to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">trie</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a675eaba21b1311eb20920e6880de7052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675eaba21b1311eb20920e6880de7052">&#9670;&nbsp;</a></span>trieLookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Backend* trieLookup </td>
          <td>(</td>
          <td class="paramtype">Trie *&#160;</td>
          <td class="paramname"><em>trie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Trie structure. </p>
<p>Lookups a backend inside the trie.</p>
<dl class="section return"><dt>Returns</dt><dd>the backend if found </dd>
<dd>
0 otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trie</td><td>the trie object to work with </td></tr>
    <tr><td class="paramname">key</td><td>the name of this key will be looked up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
