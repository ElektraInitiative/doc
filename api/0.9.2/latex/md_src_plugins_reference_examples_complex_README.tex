\hypertarget{md_src_plugins_reference_examples_complex_README_src_plugins_reference_examples_complex_README_md}{}\doxysection{Example\+: Validating Complex Recursive Structures}\label{md_src_plugins_reference_examples_complex_README_src_plugins_reference_examples_complex_README_md}
Suppose you have some mutually recursive {\ttfamily struct}s in C. You want to map this structure onto a hierarchy inside your K\+DB. This by itself was always possible, but the reference plugin in combination with the spec plugin, now allows for this in a way that can be validated and checked by Elektra.

The structure we will use for this example is easily defined in C code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct }typeA \{}
\DoxyCodeLine{  \textcolor{keywordtype}{char} *name;}
\DoxyCodeLine{  \textcolor{keyword}{struct }typeB *ref;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }typeB \{}
\DoxyCodeLine{  \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} id;}
\DoxyCodeLine{  \textcolor{keyword}{struct }typeA *ref;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }typeA *rootkey\_ref;}
\end{DoxyCode}


Starting with a reference to an element of type {\ttfamily typeA}, we except an alternating chain of {\ttfamily typeA} and {\ttfamily typeB}. In this chain each element of type {\ttfamily typeA} shall have a string attached to it, while elements of type {\ttfamily typeB} shall contain an integer.

The specification used for such a structure is as follows (using the syntax of the {\ttfamily ni} plugin)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[rootkey/ref]}
\DoxyCodeLine{check/reference = recursive}
\DoxyCodeLine{check/reference/restrict = ../typeA/\_}
\DoxyCodeLine{}
\DoxyCodeLine{[typeA/\_]}
\DoxyCodeLine{default = ""}
\DoxyCodeLine{}
\DoxyCodeLine{[typeA/\_/name]}
\DoxyCodeLine{check/type = string}
\DoxyCodeLine{}
\DoxyCodeLine{[typeA/\_/ref]}
\DoxyCodeLine{check/reference/restrict = ../../typeB/\_}
\DoxyCodeLine{}
\DoxyCodeLine{[typeB/\_]}
\DoxyCodeLine{default = ""}
\DoxyCodeLine{}
\DoxyCodeLine{[typeB/\_/id]}
\DoxyCodeLine{check/type = long}
\DoxyCodeLine{}
\DoxyCodeLine{[typeB/\_/ref]}
\DoxyCodeLine{check/reference/restrict = ../../typeA/\_}
\end{DoxyCode}


The basic idea is to use the keys {\ttfamily typeA} and {\ttfamily typeB} as a sort of \textquotesingle{}directory\textquotesingle{}, in which every \textquotesingle{}file\textquotesingle{} represent an element of type {\ttfamily typeA} or type {\ttfamily typeB} respectively.

To achieve our goals of type validation, we specify {\ttfamily rootkey/ref} to be the root of our reference graph, but also restrict the possible reference to keys directly below {\ttfamily typeA}. That way we ensure that any reference set in {\ttfamily rootkey/ref} will refer to a key which is, validated to be compatible with our {\ttfamily struct typeA} by the spec and type plugins.

Using the spec plugin we then specify all direct children of {\ttfamily typeA} to have a default value of {\ttfamily \char`\"{}\char`\"{}}. This ensures that these keys exist and therefore can be referenced. \href{\#note-empty-val}{\texttt{ ยน}} Then we simply specify the {\ttfamily name} sub-\/key for all of these children to be a string, and restrict the possible reference to direct children of {\ttfamily typeB}. From there we proceed similarly for the children of {\ttfamily typeB} and we are done.

\DoxyHorRuler{0}


\label{_note-empty-val}%
ยน It would actually be better to only give these keys a value, if the {\ttfamily name} sub-\/key exists, but there is currently no good way to do that in Elektra. An alternative would be to use the keys themselves, i.\+e. give them an actual value. 