\hypertarget{opmphmpredictor_8c}{}\section{opmphmpredictor.\+c File Reference}
\label{opmphmpredictor_8c}\index{opmphmpredictor.c@{opmphmpredictor.c}}


The Order Preserving Minimal Perfect Hash Map Predictor.  


{\ttfamily \#include $<$kdbassert.\+h$>$}\newline
{\ttfamily \#include $<$kdbhelper.\+h$>$}\newline
{\ttfamily \#include $<$kdblogger.\+h$>$}\newline
{\ttfamily \#include $<$kdbopmphmpredictor.\+h$>$}\newline
{\ttfamily \#include $<$kdbprivate.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
Include dependency graph for opmphmpredictor.\+c\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{opmphmpredictor_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t \mbox{\hyperlink{opmphmpredictor_8c_af9c730ba754c0b164555b85e2bf9f097}{opmphm\+Predictor\+Worth\+Opmphm}} (size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Heuristic function above the O\+P\+M\+P\+HM usage is worth. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{opmphmpredictor_8c_a31b9dd2f3c89816f5674f2261faf6224}{opmphm\+Predictor\+Inc\+Count\+Opmphm}} (Opmphm\+Predictor $\ast$op)
\begin{DoxyCompactList}\small\item\em Increases the counter when the O\+P\+M\+P\+HM was used for the ks\+Lookup (...) . \end{DoxyCompactList}\item 
int \mbox{\hyperlink{opmphmpredictor_8c_a47e4441629a4de43e45387560052066f}{opmphm\+Predictor\+Inc\+Count\+Binary\+Search}} (Opmphm\+Predictor $\ast$op, size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Increases the counter when the Binary Search was used for the ks\+Lookup (...) . \end{DoxyCompactList}\item 
int \mbox{\hyperlink{opmphmpredictor_8c_a6dab3e7c921f8adc655bd893cfbfb4cb}{opmphm\+Predictor}} (Opmphm\+Predictor $\ast$op, size\+\_\+t n)
\begin{DoxyCompactList}\small\item\em Predictcs at the first ks\+Lookup (...) after a Key\+Set changed if it will be worth using the O\+P\+M\+P\+HM. \end{DoxyCompactList}\item 
Opmphm\+Predictor $\ast$ \mbox{\hyperlink{opmphmpredictor_8c_af86a5206b22f957f33aba0f3d5207146}{opmphm\+Predictor\+New}} (void)
\begin{DoxyCompactList}\small\item\em Allocates and initializes the Opmphm\+Predictor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{opmphmpredictor_8c_a0fdf217cbfc0c6601113327cfdfc90ee}{opmphm\+Predictor\+Copy}} (Opmphm\+Predictor $\ast$dest, Opmphm\+Predictor $\ast$source)
\begin{DoxyCompactList}\small\item\em Make a copy of the Opmphm\+Predictor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{opmphmpredictor_8c_a8e2b941eecc192cf894b2490fcfbf2b5}{opmphm\+Predictor\+Del}} (Opmphm\+Predictor $\ast$op)
\begin{DoxyCompactList}\small\item\em Deletes the Opmphm\+Predictor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const uint16\+\_\+t \mbox{\hyperlink{opmphmpredictor_8c_a2609ca09a3d8479b15140795fe915f1e}{opmphm\+Predictor\+History\+Mask}} = 0x1\+FF
\begin{DoxyCompactList}\small\item\em The benchmarked and evaluated values of the predictors configuration. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{opmphmpredictor_8c_aca6e420bdc1b2730db1ed6685cc14519}\label{opmphmpredictor_8c_aca6e420bdc1b2730db1ed6685cc14519}} 
const size\+\_\+t \mbox{\hyperlink{opmphmpredictor_8c_aca6e420bdc1b2730db1ed6685cc14519}{opmphm\+Predictor\+Action\+Limit}} = 599
\begin{DoxyCompactList}\small\item\em The opmphm\+Predictor\+Action\+Limit define the minimum Key\+Set size necessary for predictor actions. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The Order Preserving Minimal Perfect Hash Map Predictor. 

\begin{DoxyCopyright}{Copyright}
B\+SD License (see L\+I\+C\+E\+N\+S\+E.\+md or \href{https://www.libelektra.org}{\texttt{ https\+://www.\+libelektra.\+org}}) 
\end{DoxyCopyright}


\subsection{Function Documentation}
\mbox{\Hypertarget{opmphmpredictor_8c_a6dab3e7c921f8adc655bd893cfbfb4cb}\label{opmphmpredictor_8c_a6dab3e7c921f8adc655bd893cfbfb4cb}} 
\index{opmphmpredictor.c@{opmphmpredictor.c}!opmphmPredictor@{opmphmPredictor}}
\index{opmphmPredictor@{opmphmPredictor}!opmphmpredictor.c@{opmphmpredictor.c}}
\subsubsection{\texorpdfstring{opmphmPredictor()}{opmphmPredictor()}}
{\footnotesize\ttfamily int opmphm\+Predictor (\begin{DoxyParamCaption}\item[{Opmphm\+Predictor $\ast$}]{op,  }\item[{size\+\_\+t}]{n }\end{DoxyParamCaption})}



Predictcs at the first ks\+Lookup (...) after a Key\+Set changed if it will be worth using the O\+P\+M\+P\+HM. 

Predictor functions.

Uses the opmphm\+Predictor\+Worth\+Opmphm (...) to check if the previous sequence of ks\+Lookup (...) invocations without alteration was worth using the O\+P\+M\+P\+HM. Updates the state with the prediction\+Automata and the worth information of the previous history. Alters the history with the worth information and makes the prediction for the next sequence of ks\+Lookup (...) invocations.


\begin{DoxyParams}{Parameters}
{\em op} & the Predictor \\
\hline
{\em n} & the number of elements in the Key\+Set\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & it is worth using the O\+P\+M\+P\+HM \\
\hline
{\em 0} & it is not worth using the O\+P\+M\+P\+HM \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{opmphmpredictor_8c_a0fdf217cbfc0c6601113327cfdfc90ee}\label{opmphmpredictor_8c_a0fdf217cbfc0c6601113327cfdfc90ee}} 
\index{opmphmpredictor.c@{opmphmpredictor.c}!opmphmPredictorCopy@{opmphmPredictorCopy}}
\index{opmphmPredictorCopy@{opmphmPredictorCopy}!opmphmpredictor.c@{opmphmpredictor.c}}
\subsubsection{\texorpdfstring{opmphmPredictorCopy()}{opmphmPredictorCopy()}}
{\footnotesize\ttfamily void opmphm\+Predictor\+Copy (\begin{DoxyParamCaption}\item[{Opmphm\+Predictor $\ast$}]{dest,  }\item[{Opmphm\+Predictor $\ast$}]{source }\end{DoxyParamCaption})}



Make a copy of the Opmphm\+Predictor. 


\begin{DoxyParams}{Parameters}
{\em source} & the Opmphm\+Predictor source \\
\hline
{\em dest} & the Opmphm\+Predictor destination \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{opmphmpredictor_8c_a8e2b941eecc192cf894b2490fcfbf2b5}\label{opmphmpredictor_8c_a8e2b941eecc192cf894b2490fcfbf2b5}} 
\index{opmphmpredictor.c@{opmphmpredictor.c}!opmphmPredictorDel@{opmphmPredictorDel}}
\index{opmphmPredictorDel@{opmphmPredictorDel}!opmphmpredictor.c@{opmphmpredictor.c}}
\subsubsection{\texorpdfstring{opmphmPredictorDel()}{opmphmPredictorDel()}}
{\footnotesize\ttfamily void opmphm\+Predictor\+Del (\begin{DoxyParamCaption}\item[{Opmphm\+Predictor $\ast$}]{op }\end{DoxyParamCaption})}



Deletes the Opmphm\+Predictor. 

Clears and frees all memory in Opmphm\+Predictor.


\begin{DoxyParams}{Parameters}
{\em op} & the Opmphm\+Predictor \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{opmphmpredictor_8c_a47e4441629a4de43e45387560052066f}\label{opmphmpredictor_8c_a47e4441629a4de43e45387560052066f}} 
\index{opmphmpredictor.c@{opmphmpredictor.c}!opmphmPredictorIncCountBinarySearch@{opmphmPredictorIncCountBinarySearch}}
\index{opmphmPredictorIncCountBinarySearch@{opmphmPredictorIncCountBinarySearch}!opmphmpredictor.c@{opmphmpredictor.c}}
\subsubsection{\texorpdfstring{opmphmPredictorIncCountBinarySearch()}{opmphmPredictorIncCountBinarySearch()}}
{\footnotesize\ttfamily int opmphm\+Predictor\+Inc\+Count\+Binary\+Search (\begin{DoxyParamCaption}\item[{Opmphm\+Predictor $\ast$}]{op,  }\item[{size\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Increases the counter when the Binary Search was used for the ks\+Lookup (...) . 

Prevents also an endless Binary Search usage by a simple heuristic.


\begin{DoxyParams}{Parameters}
{\em op} & the Predictor \\
\hline
{\em n} & the number of elements in the Key\+Set\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 1} & it is worth using the O\+P\+M\+P\+HM \\
\hline
{\em 0} & it is not worth using the O\+P\+M\+P\+HM \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{opmphmpredictor_8c_a31b9dd2f3c89816f5674f2261faf6224}\label{opmphmpredictor_8c_a31b9dd2f3c89816f5674f2261faf6224}} 
\index{opmphmpredictor.c@{opmphmpredictor.c}!opmphmPredictorIncCountOpmphm@{opmphmPredictorIncCountOpmphm}}
\index{opmphmPredictorIncCountOpmphm@{opmphmPredictorIncCountOpmphm}!opmphmpredictor.c@{opmphmpredictor.c}}
\subsubsection{\texorpdfstring{opmphmPredictorIncCountOpmphm()}{opmphmPredictorIncCountOpmphm()}}
{\footnotesize\ttfamily void opmphm\+Predictor\+Inc\+Count\+Opmphm (\begin{DoxyParamCaption}\item[{Opmphm\+Predictor $\ast$}]{op }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Increases the counter when the O\+P\+M\+P\+HM was used for the ks\+Lookup (...) . 


\begin{DoxyParams}{Parameters}
{\em op} & the Predictor \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{opmphmpredictor_8c_af86a5206b22f957f33aba0f3d5207146}\label{opmphmpredictor_8c_af86a5206b22f957f33aba0f3d5207146}} 
\index{opmphmpredictor.c@{opmphmpredictor.c}!opmphmPredictorNew@{opmphmPredictorNew}}
\index{opmphmPredictorNew@{opmphmPredictorNew}!opmphmpredictor.c@{opmphmpredictor.c}}
\subsubsection{\texorpdfstring{opmphmPredictorNew()}{opmphmPredictorNew()}}
{\footnotesize\ttfamily Opmphm\+Predictor$\ast$ opmphm\+Predictor\+New (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Allocates and initializes the Opmphm\+Predictor. 

Basic functions.

Reserves for all possible values of opmphm\+Predictor\+History\+Mask two bits to store all 4 states of the Prediction Automata A2. Sets the initial state to 0.


\begin{DoxyRetVals}{Return values}
{\em Opmphm\+Predictor} & $\ast$ success \\
\hline
{\em N\+U\+LL} & memory error \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{opmphmpredictor_8c_af9c730ba754c0b164555b85e2bf9f097}\label{opmphmpredictor_8c_af9c730ba754c0b164555b85e2bf9f097}} 
\index{opmphmpredictor.c@{opmphmpredictor.c}!opmphmPredictorWorthOpmphm@{opmphmPredictorWorthOpmphm}}
\index{opmphmPredictorWorthOpmphm@{opmphmPredictorWorthOpmphm}!opmphmpredictor.c@{opmphmpredictor.c}}
\subsubsection{\texorpdfstring{opmphmPredictorWorthOpmphm()}{opmphmPredictorWorthOpmphm()}}
{\footnotesize\ttfamily size\+\_\+t opmphm\+Predictor\+Worth\+Opmphm (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Heuristic function above the O\+P\+M\+P\+HM usage is worth. 

Heuristic function.

This easy and fast computable heuristic function tells how many ks\+Lookup (...) invocations without alteration of the Key\+Set need to be made to justify the O\+P\+M\+P\+HM usage. This heuristic function is developed and measured by benchmarks.


\begin{DoxyParams}{Parameters}
{\em n} & the number of elements in the Key\+Set\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em size\+\_\+t} & the heuristic value \\
\hline
\end{DoxyRetVals}


\subsection{Variable Documentation}
\mbox{\Hypertarget{opmphmpredictor_8c_a2609ca09a3d8479b15140795fe915f1e}\label{opmphmpredictor_8c_a2609ca09a3d8479b15140795fe915f1e}} 
\index{opmphmpredictor.c@{opmphmpredictor.c}!opmphmPredictorHistoryMask@{opmphmPredictorHistoryMask}}
\index{opmphmPredictorHistoryMask@{opmphmPredictorHistoryMask}!opmphmpredictor.c@{opmphmpredictor.c}}
\subsubsection{\texorpdfstring{opmphmPredictorHistoryMask}{opmphmPredictorHistoryMask}}
{\footnotesize\ttfamily const uint16\+\_\+t opmphm\+Predictor\+History\+Mask = 0x1\+FF}



The benchmarked and evaluated values of the predictors configuration. 

Order Preserving Minimal Perfect Hash Map Predictor. 