<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: 0.8.11 Release</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.21</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">0.8.11 Release </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>guid: 7d4647d4-4131-411e-9c2a-2aca39446e18</li>
<li>author: Markus Raab</li>
<li>pubDate: Fri, 03 Apr 2015 02:39:37 +0200</li>
<li>shortDesc: adds specification namespace &amp; numerous improvements</li>
</ul>
<p>From the beginning of the Elektra Initiative, Elektra aimed at avoiding hard coded information in the application and to make the application's configuration more transparent. While avoiding any paths to files was reality from the first released Elektra version, now also hard coding default values, fallback mechanisms and even Elektraâ€™s paths to keys can be avoided.</p>
<h2>How does that work?</h2>
<p>Elektra 0.8.11 introduces a so called specification for the application's configuration. It is located below its own namespace <code>spec</code> (next to user and system).</p>
<p>Once the base path is known, the user can find out all Elektra paths used by an application, using: </p><pre class="fragment">kdb ls spec/basepath
</pre><p>Keys in <code>spec</code> allow us to specify which keys are read by the application, which fallback it might have and which is the default value using metadata. The implementation of these features happened in <code>ksLookup</code>. When cascading keys (those starting with <code>/</code>) are used following features are now available (in the metadata of respective <code>spec</code>-keys):</p>
<ul>
<li><code>override/#</code>: use these keys <em>in favour</em> of the key itself (note that <code>#</code> is the syntax for arrays, e.g. <code>#0</code> for the first element, <code>#_10</code> for the 11th and so on)</li>
<li><code>namespace/#</code>: instead of using all namespaces in the predefined order, one can specify which namespaces should be searched in which order</li>
<li><code>fallback/#</code>: when no key was found in any of the (specified) namespaces the <code>fallback</code>-keys will be searched</li>
<li><code>default</code>: this value will be used if nothing else was found</li>
</ul>
<p>This technique does not only give you the obvious advantages, but also provides complete transparency how a program will fetch a configuration value. In practice that means that: </p><pre class="fragment">kdb get "/sw/app/#0/promise"
</pre><p>will give you the <em>exact same value</em> as the application uses when it lookups the key <code>promise</code>. Many <code>if</code>s and hard coded values are avoided, we simply fetch and lookup the configuration by following code: </p><pre class="fragment">Key *parentKey = keyNew("/sw/app/#0", KEY_CASCADING_NAME, KEY_END);
kdbGet(kdb, ks, parentKey);

ksLookupByName(ks, "/sw/app/#0/promise", 0);
</pre><p>We see in that example that only Elektra paths are hard coded in the application. But those can be found out easily, completely without looking in the source code. The technique is simple: append a logger plugin and the KDB base path is printed to:</p>
<ul>
<li>stdout in the case of the plugin tracer</li>
<li>syslog in the case of the plugin syslog</li>
<li>journald in the case of the plugin journald</li>
</ul>
<p>What we do not see in the program above are the default values and fallbacks. They are only present in the so specification (namespace <code>spec</code>). Luckily, the specification are key-value pairs, too. So we do not have to learn something new, e.g. using the ni plugin we can specify: </p><pre class="fragment">[promise]
default=20
fallback/#0=/somewhere/else
namespace/#0=user
</pre><p>1.) When this file is mounted to <code>spec/sw/app/#0</code> we specify, that for the key <code>/sw/app/#0/promise</code> only the namespace <code>user</code> should be used. 2.) If this key was not found, but <code>/somewhere/else</code> is present, we will use this key instead. The <code>fallback</code> technique is very powerful: it allows us to have (recursive) links between applications. In the example above, the application is tricked in receiving e.g. the key <code>user/somewhere/else</code> when <code>promise</code> was not available. 3.) The value <code>20</code> will be used as default, even if no configuration file is found.</p>
<p>Note that the fallback, override and cascading works on <em>key level</em>, and not like most other systems have implemented, on configuration <em>file level</em>.</p>
<h2>Namespaces</h2>
<p>The specification gives the namespaces clearer semantics and purpose. Key names starting with a namespace are connected to a configuration source. E.g. keys starting with:</p>
<ul>
<li><code>user</code> are keys from the home directory of the current user</li>
<li><code>system</code> are keys from the <code>/etc</code> directory of the current system</li>
<li><code>spec</code> are keys from the specification directory (configurable with KDB_DB_SPEC, typically <code>/usr/share/elektra/specification</code>)</li>
</ul>
<p>When a key name starts with an <code>/</code> it means that it is looked up by specification. Such a cascading key is not really present in the keyset (except when a default value was found). They are neither received nor stored by <code>kdbGet</code> and <code>kdbSet</code>.</p>
<p>Applications shall only lookup using cascading keys (starting with <code>/</code>). If no specification is present, cascading of all namespaces is used as before.</p>
<p>Elektra will (always) continue to work for applications that do not have a specification. We strongly encourage you, however, to write such a specification, because:</p>
<ul>
<li>it helps the administrator to know which keys exist</li>
<li>it documents the keys (including lookup behaviour and default value)</li>
<li>and many more advantages to come in future releases..</li>
</ul>
<p>For a tutorial how to actually elektrify an application and for more background to Elektra, https://github.com/ElektraInitiative/libelektra/blob/master/doc/tutorials/application-integration.md "read this document".</p>
<p>For a full list of proposed and implemented metadata, https://github.com/ElektraInitiative/libelektra/blob/master/doc/help/elektra-namespaces.md "read this document".</p>
<h2>Simplification in the merging framework</h2>
<p>As it turned out the concept of very granular merge strategies was hard to understand for users of the three-way merging framework that emerged in the last year's GSoC. While this granularity is desirable for flexibility, we additionally wanted something easy to use. For that reason merge configurations were introduced. These are simply preconfigured configurations for a merger that arrange required strategies for the most common merging scenarios. Especially they make sure that meta merging is handled correctly.</p>
<p>Have a look at the changes in the example <a href="https://github.com/ElektraInitiative/libelektra/blob/master/src/libs/tools/examples/merging.cpp">/src/libs/tools/examples/merging.cpp</a> for an glimpse of the simplifications.</p>
<p>A big thanks to Felix Berlakovich!</p>
<p>The header files will be installed to /usr/include/elektra/merging, but they are subject to be changed in the future (e.g. as they did in this release).</p>
<p>From the merging improvements some minor incompatibility happened in <code>kdb import</code>. Not all merging strategies that worked in 0.8.10 work anymore. Luckily, now its much simpler to choose the strategies.</p>
<h2>API</h2>
<p>The main API kdb.h has two added lines. First a new method was added: </p><pre class="fragment">ssize_t keyAddName(Key *key, const char *addName);
</pre><p>This method is already used heavily in many parts. Contrary to <code>keySetBaseName</code> and <code>keyAddBaseName</code> it allows us to extend the path with more than one Element at once, i.e. <code>/</code> are not escaped.</p>
<p>The other new line is the new enum value <code>KEY_FLAGS</code>. This feature allows bindings to use any flags in keyNew without actually building up variable argument lists. (Thanks to Manuel Mausz)</p>
<p>As always, API+ABI is stable and compatible.</p>
<h2>Proposed</h2>
<p>Many new functions are proposed and can be found in <a href="https://doc.libelektra.org/api/0.8.11/html">the doxygen docu</a> and in <a href="https://github.com/ElektraInitiative/libelektra/blob/master/src/include/kdbproposal.h">kdbproposal.h</a>.</p>
<p>Noteworthy is the method <code>keyGetNamespace</code> which allows us to query all namespaces. Since this release we changed every occurrence of namespaces (except documentation) with switch-statements around <code>keyGetNamespace</code>. This allows us to add new more namespaces more easily. (Although its currently not planned to add further namespaces.)</p>
<p>Finally, a bunch of new lookup options were added, which might not be useful for the public API (they allow us to disable the specification-aware features mentioned in the beginning).</p>
<h2>Obsolete and removed concepts</h2>
<h3>umount</h3>
<p>The concept that backends have a name (other than their mountpoint) is now gone. Backends will simply be named with their escaped mountpath below system/elektra/mountpoints without any confusing additional name.</p>
<p>Unmounting still works with the mountpath.</p>
<p>Removing this concept makes Elektra easier to understand and it also removes some bugs. E.g. having mountpoints which do not differ except having a <code>_</code> instead of a <code>/</code> would have caused problems with the automatic name generation of Elektra 0.8.10.</p>
<p>Old mountpoints need to be removed with their 0.8.10 name (<code>_</code> instead of <code>/</code>).</p>
<h3>directory keys</h3>
<p>Additionally, the so called directory keys were also removed. Elektra was and still is completely key-value based. The <code>/</code> separator is only used for mountpoints.</p>
<h3>fstab</h3>
<p>The plugin fstab is also improved: Slashes in mountpoints are escaped properly with the internal escaping engine of <a class="el" href="group__keyname.html#gaa942091fc4bd5c2699e49ddc50829524" title="Adds baseName (that will be escaped) to the current key name. ">keyAddBaseName()</a> (i.e. without any problematic <code>/</code> replacements).</p>
<h3>dirname</h3>
<p>getDirName() was removed from C++, gi-lua, gi-python2, gi-python3, swig-lua, swig-python2 and swig-python3. It was never present in C and did not fit well with <a class="el" href="group__keyname.html#gaaff35e7ca8af5560c47e662ceb9465f5" title="Returns a pointer to the internal unescaped key name where the basename starts. ">keyBaseName()</a> (which returns an unescaped name, which is not possible for the dirname). (Thanks to Manuel Mausz)</p>
<h3>invalid parent names</h3>
<p>While empty (=invalid) names are still accepted as parentName to <code>kdbGet</code> and <code>kdbSet</code> for compatibility reasons, but the parentKey </p><pre class="fragment">Key *parentKey = keyNew("/", KEY_END);
</pre><p>should be used instead (if you want to get or store everything). They have identical behaviour, except that invalid names (that cannot be distinguished from empty names) will produce a warning. In the next major version invalid parentNames will produce an error.</p>
<h2>KDB Behaviour</h2>
<p>It is now enforced that before a <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf" title="Set keys in an atomic and universal way. ">kdbSet()</a> on a specific path a <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a> on that path needs to be done. This was always documented that way and is the only way to correctly detect conflicts, updates and missing configuration files. Error #107 will be reported on violations.</p>
<p>Additionally, the handling with missing files was improved. Empty keysets for a mountpoint now will remove a file. Such an empty file is always up-to-date. Removing files has the same atomicity guarantees as other operations.</p>
<p>The concurrency behaviour is at a very high level: as expected many processes with many threads can each concurrently write to the key database, without any inconsistent states: This is noted here because Elektra works on standard configuration files without any guarding processes.</p>
<p>Filesystem problems, e.g. permission, now always lead to the same errors (#9, #75, #109, #110), regardless of the storage plugin.</p>
<h2>Qt-Gui 0.0.6</h2>
<p>Raffael Pancheri was very busy and did a lot of stabilizing work:</p>
<ul>
<li>Added markdown converter functionality for plugin documentation</li>
<li>Integrated help (Whats this?)</li>
<li>Added credits to other authors</li>
<li>do not show storage/resolver plugins if a plugin of that kind has been selected</li>
<li>added menu to newkey toolbar button to allow new array entries</li>
<li>added option to include a configuration keyset when adding a plugin</li>
<li>show included keys when creating the plugin configuration</li>
<li>Added all storageplugins to namefilters</li>
<li>Reimplement ErrorDialog</li>
<li>Added undo/redo of all commands and correctly update the view</li>
<li>modified ToolTip size</li>
<li>Color animation on search results</li>
<li>Refactored Buttons to accept shortcuts</li>
<li>Updated Translations</li>
<li>Colors are now customizeable</li>
<li>Many small fixes</li>
</ul>
<p>The gui is already used and the remaining small bugs (see github) are going to be fixed soon. One of the highlights is undo for nearly every action, so nothing prevents you from trying it out!</p>
<p>A huge thanks to Raffael Pancheri for his contributions. His thesis can be found at <a href="https://www.libelektra.org/ftp/elektra/pancheri2015gui.pdf">here</a>.</p>
<h2>Bug fixing</h2>
<ul>
<li>fix issues with escaped backslashes in front of slashes</li>
<li>atomic commits across namespaces work again</li>
<li>memleak on ReadFile error in ni plugin</li>
<li><code>kdb getmeta</code> reports errorcode if key, but no meta was found</li>
<li><code>ksLookup</code> now will also work if a key of the keyset is used as search-key (aliasing problem fixed by dup() on namelock)</li>
<li>resolver regex does not match to wrongly written plugins</li>
<li>jna plugin is now named libelektra-0.8.11.jar, with proper symbolic link to current version, for every CMake version</li>
<li>fix bashism ($RANDOM)</li>
<li>new keys are correctly renamed, fixes OpenICC (thanks to Felix Berlakovich)</li>
<li>comments in host keys are correctly restored (thanks to Felix Berlakovich)</li>
<li>output stream in type checking is no longer locale dependent (thanks to Manuel Mausz)</li>
<li>cmake uninstall works again</li>
<li>simplify CMAKE_DL_LIBS (thanks to Manuel Mausz)</li>
</ul>
<h2>Further gems</h2>
<ul>
<li>Examples were improved, added (e.g. cascading, namespace) and included in <a href="https://doc.libelektra.org/api/0.8.11/html">Doxygen docu</a>.</li>
<li><a href="https://github.com/ElektraInitiative/libelektra/blob/master/doc/METADATA.ini">METADATA specification</a> was nearly completely rewritten (thanks to Felix Berlakovich)</li>
<li>benchmarks were greatly enhanced (run-time+heap profiling), and some important performance improvements were done</li>
<li>All plugins now use the cmake function <code>add_plugin</code> (thanks to Ian Donnelly for most of the work)</li>
<li>data directory (keysets as C-files) is now shared between different kinds of test suites.</li>
<li>many more tests were added, e.g. distribution tests, KDB API tests; and allocation tests were readded</li>
<li>now all kdb commands accept cascading keys.</li>
<li>More compiler warning-flags are added and many warnings are fixed</li>
<li>cleanup of old unused <code>keyName</code> methods</li>
<li>The key <code>system/elektra/mountpoints</code> itself was always created and a left-over on a freshly installed system after the unit tests run the first time. The physical presence of the key is now irrelevant and it won't be created automatically.</li>
<li>Bash completion was greatly improved (thanks to Manuel Mausz)</li>
<li>Configure scripts were refactored and are now much shorter (thanks to Manuel Mausz)</li>
<li>New Debian build agents were added that are magnitutes faster than the old ones (a big thanks to Manuel Mausz)</li>
<li>Many KDB tests, written in C, lua and python were added (thanks to Manuel Mausz)</li>
<li>SWIG3 is preferred when available</li>
<li>add the plugin counter that counts how often the methods of a plugin are called</li>
<li><code>kdb list-tools</code> is now advertised in <code>kdb --help</code></li>
<li>macOS support was greatly improved, thanks to Peter Nirschl and Kai-Uwe Behrmann. The feature rich resolver, now also works for macOS. wresolver is now only needed for mingw.</li>
<li>Elektra still compiles with gcc (also mingw variants), icc and clang.</li>
</ul>
<h2>Further Notes</h2>
<p>With 471 files changed, 27978 insertions(+), 11512 deletions(-) this release is huge. With 773 commits over four month much more changes happened which did not find their place in these release notes, even though the notes are much less detailed than usual.</p>
<p>Thanks for all contributions that are not enlisted here!</p>
<p>For any questions and comments, please contact the <a href="https://lists.sourceforge.net/lists/listinfo/registry-list">Mailing List</a> or <a href="#" onclick="location.href='mai'+'lto:'+'ele'+'kt'+'ra@'+'ma'+'rku'+'s-'+'raa'+'b.'+'org'; return false;">elekt<span style="display: none;">.nosp@m.</span>ra@m<span style="display: none;">.nosp@m.</span>arkus<span style="display: none;">.nosp@m.</span>-raa<span style="display: none;">.nosp@m.</span>b.org</a>.</p>
<h2>Get It!</h2>
<p>You can download the release from <a href="http://www.markus-raab.org/ftp/elektra/releases/elektra-0.8.11.tar.gz">here</a></p>
<ul>
<li>name: elektra-0.8.11.tar.gz</li>
<li>size: 2022129</li>
<li>md5sum: c53a8151aab760851842d745e904a4f8</li>
<li>sha1: d7929d17d1a6529089d156f1910d87f678b84998</li>
<li>sha256: c20fefcfba62cc906228f9b55d1f411ef8f884ff9d75774a0dd4f8eb8f5b48f6</li>
</ul>
<p>This release tarball now is also available <a href="http://www.markus-raab.org/ftp/elektra/releases/elektra-0.8.11.tar.gz.gpg">signed by me using gpg</a></p>
<p>already built API-Docu can be found <a href="https://doc.libelektra.org/api/0.8.11/html/">here</a></p>
<h2>Stay tuned!</h2>
<p>Subscribe to the <a href="https://doc.libelektra.org/news/feed.rss">new RSS feed</a> to always get the release notifications.</p>
<p><a href="https://doc.libelektra.org/news/7d4647d4-4131-411e-9c2a-2aca39446e18.html">Permalink to this NEWS entry</a></p>
<p>For more information, see <a href="https://www.libelektra.org">https://www.libelektra.org</a></p>
<p>Best regards, Markus </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
