\label{doc_decisions_3_decided_elixir_bindings_md_md_doc_decisions_3_decided_elixir_bindings}%
\Hypertarget{doc_decisions_3_decided_elixir_bindings_md_md_doc_decisions_3_decided_elixir_bindings}%
 \hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2026}{}\doxysection{Problem}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2026}
When creating Elixir bindings one needs a way to use some kind of foreign function interface. In Erlang (which is the basis for Elixir) such a foreign function interface exists in the form of NIFs (native implemented functions). The question is how this NIF interface should be implemented.\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2027}{}\doxysection{Constraints}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2027}

\begin{DoxyEnumerate}
\item Elektra\textquotesingle{}s C API is given.
\item The implementation should be completed in a given time frame of around 20 to 40 person-\/hours.
\end{DoxyEnumerate}\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2028}{}\doxysection{Assumptions}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2028}

\begin{DoxyEnumerate}
\item The compatibility of the Elixir bindings is not very important.
\end{DoxyEnumerate}\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2029}{}\doxysection{Solutions}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2029}
\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2030}{}\doxysubsection{By hand}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2030}
Implement the NIFs by hand. That is, every function of the Elektra C API which one wishes to expose to the Elixir binding has to be explicitly implemented as a NIF. The big disadvantage is, of course, that this process is error-\/prone. Furthermore, any change in the C API has to be manually carried over to the NIF.\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2031}{}\doxysubsection{Use Nifty code generation tool}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2031}
Use the existing code generation tool \href{http://parapluu.github.io/nifty/}{\texttt{ Nifty}}.

Reasons for not choosing this approach are\+:


\begin{DoxyItemize}
\item Installation process required several patches of Nifty.
\item Resource management is not that supplied by the Erlang NIF library but a custom one.
\end{DoxyItemize}\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2032}{}\doxysubsection{Write own code generation tool}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2032}
Write a custom generation tool.

In principle one should be able to take a C header file and convert this to a NIF in an automatic fashion.

Solving this problem in general clearly would be a daunting task. However, when restricting oneself to the use case for creating an interface for, say, Elektra\textquotesingle{}s KDB this might actually have been feasible.

The main difference to Nifty would be that one could adopt the memory management tools provided by the Erlang NIF library directly. Furthermore, it would be possible to write an improved interface for the types, e.\+g. binary and string.

The main reson for not choosing this approach were time constraints.\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2033}{}\doxysection{Decision}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2033}
The chosen approach was to use \char`\"{}\+Alternative A\char`\"{}, i.\+e., to implement the NIFs by hand.\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2034}{}\doxysection{Rationale}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2034}
The main reason for this choice were time constraints.

Since I have assumed that the compatiblity of the Elixir bindings is not very important, it is acceptable if future changes break these bindings.\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2035}{}\doxysection{Implications}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2035}

\begin{DoxyItemize}
\item Every incompatible change in the C API needs manual changes in the Elixir binding.
\end{DoxyItemize}\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2036}{}\doxysection{Related Decisions}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2036}

\begin{DoxyItemize}
\item \href{https://github.com/ElektraInitiative/libelektra/pull/4623}{\texttt{ Git\+Hub PR\+: Elixir Bindings}}
\end{DoxyItemize}\hypertarget{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2037}{}\doxysection{Notes}\label{doc_decisions_3_decided_elixir_bindings_md_autotoc_md2037}

\begin{DoxyItemize}
\item If there were a guarantee that the C API does not change, then the chosen approach would be unproblematic. 
\end{DoxyItemize}