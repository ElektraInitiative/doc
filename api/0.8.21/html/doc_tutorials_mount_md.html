<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Elektra: Mounting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.21</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Mounting </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Elektra provides a global key database, that can integrate configuration in various formats.</p>
<p>Conversely configuration managed by Elektra can be integrated into applications. The best way of integrating Elektra into applications is to <a class="el" href="md_doc_help_elektra-glossary.html#doc_help_elektra-glossary_md">elektrify</a> them.</p>
<p>A simpler form of integration is to let Elektra directly use configuration files as they are present on the system. Thus applications can read the configuration files and changes in the key database will be picked up by applications.</p>
<p>The heart of the approach is the so called <em>mounting</em> of configuration files into the key database.</p>
<p>Let us start with a motivating example first:</p>
<h2>Mount the Lookup Table for Hostnames</h2>
<p>We mount the lookup table with the following command:</p>
<div class="fragment"><div class="line">sudo kdb mount --with-recommends /etc/hosts system/hosts hosts</div></div><!-- fragment --><ol type="1">
<li><code>/etc/hosts</code> is the configuration file we want to mount</li>
<li><code>system/hosts</code> is the path it should have in the key database, also known as <b>mountpoint</b></li>
<li><code>hosts</code> is the <em>storage plugin</em> that can read and write this configuration format.</li>
</ol>
<blockquote class="doxtable">
<p>Consider using mount with the option <code>--with-recommends</code>, which loads all plugins recommended by the <em>hosts</em> plugin. You can see the recommended plugins of <em>hosts</em> if you look at the output of <code>kdb info hosts</code>. Hosts recommends the <em>glob</em>, <em>network</em> and <em>error</em> plugins. Using <code>--with-recommends</code>, more validation is done when modifying keys in <code>system/hosts</code>. </p>
</blockquote>
<p>Now we use <code>kdb file</code>, to verify that all configuration below <code>system/hosts</code> is stored in <code>/etc/hosts</code>:</p>
<div class="fragment"><div class="line">kdb file system/hosts</div><div class="line">#&gt; /etc/hosts</div></div><!-- fragment --><p>After mounting a file, we can modify keys below <code>system/hosts</code>. We need to be root, because we modify <code>/etc/hosts</code>.</p>
<div class="fragment"><div class="line">sudo kdb set system/hosts/ipv4/mylocalhost 127.0.0.33</div></div><!-- fragment --><p>These changes are reflected in <code>/etc/hosts</code> instantly:</p>
<div class="fragment"><div class="line">cat /etc/hosts | grep mylocalhost</div><div class="line">#&gt; 127.0.0.33   mylocalhost</div></div><!-- fragment --><p>Applications will now pick up these changes:</p>
<div class="fragment"><div class="line">ping -c 1 mylocalhost</div><div class="line"># RET:2</div></div><!-- fragment --><p>We are also safe against wrong changes:</p>
<div class="fragment"><div class="line">sudo kdb set system/hosts/ipv4/mylocalhost ::1</div><div class="line"># RET:5</div><div class="line"># ERROR:51</div><div class="line">sudo kdb set system/hosts/ipv4/mylocalhost 300.0.0.1</div><div class="line"># RET:5</div><div class="line"># ERROR:51</div></div><!-- fragment --><p>We can undo these changes with:</p>
<div class="fragment"><div class="line"># remove the key ...</div><div class="line">sudo kdb rm system/hosts/ipv4/mylocalhost</div><div class="line"></div><div class="line"># ... and unmount</div><div class="line">sudo kdb umount system/hosts</div></div><!-- fragment --><blockquote class="doxtable">
<h6>Why do you Need Superuser Privileges to Mount Files?</h6>
<p></p>
<p>Elektra manages its mountpoints in configuration below <b>system/elektra/mountpoints</b>. The file that holds this configuration is, in the same way as <code>/etc/hosts</code> before, only writable by administrators: </p><pre class="fragment">$ kdb file system/elektra/mountpoints
/etc/kdb/elektra.ecf
</pre><p>Because of that only root can mount files. </p>
</blockquote>
<h2>Resolver</h2>
<p>The configuration file path you supplied to <code>kdb mount</code> above is actually not an absolute or relative path in your file system, but gets resolved to one by Elektra. The plugin that is responsible for this is the <a class="el" href="md_src_plugins_resolver_README.html#src_plugins_resolver_README_md">_Resolver_</a>.</p>
<p>When you mount a configuration file the resolver first looks at the namespace of your mountpoint. Based on that namespace and if the supplied path was relative or absolute the resolver then resolves the supplied path to a path in the file system. The resolving happens dynamically for every <code>kdb</code> invocation.</p>
<p>You can display the mounted configuration files with <code>kdb mount</code>. Also here you only see the unresolved paths.</p>
<p>If you supplied an absolute path (e.g. <code>/example.ini</code>) it gets resolved to this:</p>
<table class="doxtable">
<tr>
<th>namespace </th><th>resolved path  </th></tr>
<tr>
<td><code>spec</code> </td><td><code>/example.ini</code> </td></tr>
<tr>
<td><code>dir</code> </td><td><code>${PWD}/example.ini</code> </td></tr>
<tr>
<td><code>user</code> </td><td><code>${HOME}/example.ini</code> </td></tr>
<tr>
<td><code>system</code> </td><td><code>/example.ini</code> </td></tr>
</table>
<p>If you supplied a relative path (e.g. <code>example.ini</code>) it gets resolved to this:</p>
<table class="doxtable">
<tr>
<th>namespace </th><th>resolved path  </th></tr>
<tr>
<td><code>spec</code> </td><td><code>/usr/share/elektra/specification/example.ini</code> </td></tr>
<tr>
<td><code>dir</code> </td><td><code>${PWD}/.dir/example.ini</code> </td></tr>
<tr>
<td><code>user</code> </td><td><code>${HOME}/.config/example.ini</code> </td></tr>
<tr>
<td><code>system</code> </td><td><code>/etc/kdb/example.ini</code> </td></tr>
</table>
<p>If this differs on your system, the resolver has a different configuration. Type <code>kdb info resolver</code> for more information about the resolvers.</p>
<p>There are different resolvers. For instance on non-POSIX systems paths must be resolved differently. In this case one might want to use the wresolver plugin. Another useful resolver is the <a class="el" href="md_src_plugins_blockresolver_README.html#src_plugins_blockresolver_README_md">blockresolver</a>, which integrates only a block of a configuration file into Elektra.</p>
<p>But resolvers are not the only plugins Elektra uses:</p>
<h2>Plugins</h2>
<p>Configuration files can have many different formats (<code>ini</code>, <code>json</code>, <code>yaml</code>, <code>xml</code>, <code>csv</code>, ... to name but a few).</p>
<p>One of the goals of Elektra is to provide users with a unified interface to all those formats. Elektra accomplishes this task with <em>storage plugins</em>.</p>
<blockquote class="doxtable">
<p>In Elektra <a class="el" href="doc_tutorials_plugins_md.html">Plugins</a> are the units that encapsulate functionality. There are not only plugins that handle storage of data, but also plugins that modify your values (<a class="el" href="md_src_plugins_iconv_README.html#src_plugins_iconv_README_md">iconv</a>). Furthermore there are plugins that validate your values (<a class="el" href="md_src_plugins_validation_README.html#src_plugins_validation_README_md">validation</a>, <a class="el" href="md_src_plugins_enum_README.html#src_plugins_enum_README_md">enum</a>, <a class="el" href="md_src_plugins_boolean_README.html#src_plugins_boolean_README_md">boolean</a>, <a class="el" href="md_src_plugins_mathcheck_README.html#src_plugins_mathcheck_README_md">mathcheck</a>, ...), log changes in the key set (<a class="el" href="md_src_plugins_logchange_README.html#src_plugins_logchange_README_md">logchange</a>) or do things like executing commands on the shell (<a class="el" href="md_src_plugins_shell_README.html#src_plugins_shell_README_md">shell</a>). You can get a complete list of all available plugins with <code>kdb list</code>. Although an individual plugin does not provide much functionality, plugins are powerful because they are designed to be used together. </p>
</blockquote>
<p>When you mount a file you can tell Elektra which plugins it should use for reading and writing to configuration files.</p>
<p>Let us mount a projects git configuration into the dir namespace:</p>
<div class="fragment"><div class="line"># create a directory for our demonstration</div><div class="line">mkdir -p example &amp;&amp; cd $_</div><div class="line"></div><div class="line"># this creates the .git/config file</div><div class="line">git init</div><div class="line"></div><div class="line"># mount gitâ€™s configuration into Elektra</div><div class="line">sudo kdb mount /.git/config dir/git ini multiline=0</div></div><!-- fragment --><p>As git uses the <code>ini</code> format for its configuration we use the <a class="el" href="md_src_plugins_ini_README.html#src_plugins_ini_README_md">ini plugin</a>. You can pass parameters to plugins during the mount process. This is what we did with <code>multiline=0</code>. Git intents the entries in its configuration files and the default behavior of the <code>ini</code> plugin is to interpret these indented entries as values that span multiple lines. The passed parameter disables this behavior and makes the ini-plugin compatible with git configuration.</p>
<p>Now let us see how smoothly the ini plugin sets and gets the git configuration.</p>
<div class="fragment"><div class="line"># set a user name ...</div><div class="line">git config user.name &quot;Rob Banks&quot;</div><div class="line"></div><div class="line"># ... and read it with kdb</div><div class="line">kdb get dir/git/user/name</div><div class="line">#&gt; Rob Banks</div><div class="line"></div><div class="line"># set a user email with kdb ...</div><div class="line">kdb set dir/git/user/email &quot;rob.banks@dot.com&quot;</div><div class="line"></div><div class="line"># and read it with git</div><div class="line">git config --get user.email</div><div class="line">#&gt; rob.banks@dot.com</div></div><!-- fragment --><h4>Meta Data</h4>
<p>Elektra is able to store <a class="el" href="md_doc_help_elektra-metadata.html#doc_help_elektra-metadata_md">metadata</a> of keys, provided the format of the file that holds the configuration supports this feature. The ini plugin does support this feature, and so does the <a class="el" href="md_src_plugins_ni_README.html#src_plugins_ni_README_md">ni</a> and the <a class="el" href="md_src_plugins_dump_README.html#src_plugins_dump_README_md">dump</a> plugin among others.</p>
<blockquote class="doxtable">
<p>Actually the ini plugin creates some metadata on its own. This metadata contains information about the ordering of keys or comments, if a key has some. But unlike the ni and the dump plugin we can't store arbitrary metadata with the ini plugin. </p>
</blockquote>
<p>Meta data comes in handy if we use other plugins, than just the ones that store and retrieve data. I chose the <code>ni</code> plugin for this demonstration, because it supports metadata and is human readable. So let us have a look at the <a class="el" href="md_src_plugins_enum_README.html#src_plugins_enum_README_md">enum</a> and <a class="el" href="md_src_plugins_mathcheck_README.html#src_plugins_mathcheck_README_md">mathcheck</a> plugins.</p>
<div class="fragment"><div class="line"># mount the backend with the plugins ...</div><div class="line">kdb mount example.ni user/example ni enum</div><div class="line"></div><div class="line"># ... and set a value for the demonstration</div><div class="line">kdb set user/example/enumtest/fruit apple</div><div class="line">#&gt; Create a new key user/example/enumtest/fruit with string &quot;apple&quot;</div></div><!-- fragment --><p>By entering <code>kdb info enum</code> in the commandline, we can find out how to use this plugin. It turns out that this plugin allows us to define a list of valid values for our keys via the metavalue <code>check/enum</code>.</p>
<div class="fragment"><div class="line">kdb setmeta user/example/enumtest/fruit check/enum &quot;&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;&quot;</div><div class="line">kdb set user/example/enumtest/fruit tomato</div><div class="line"># RET:5</div><div class="line"># this fails because tomato is not in the list of valid values</div></div><!-- fragment --><p>You can have a look or even edit the configuration file with <code>kdb editor user/example ni</code> to see how the value and metadata is stored:</p>
<div class="fragment"><div class="line">enumtest/fruit = apple</div><div class="line"></div><div class="line">[enumtest/fruit]</div><div class="line">check/enum = &#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;</div></div><!-- fragment --><p>The example shows an important problem: the configuration file is now changed in ways that might not be acceptable for applications. We have at least two ways to avoid that:</p>
<ol type="1">
<li>Encode metadata as comments</li>
<li>Encode metadata in its own <code>spec</code> namespace, completely separate to the configuration files the application will see</li>
</ol>
<p>If you want to find out more about validation I recommend reading <a class="el" href="md_doc_tutorials_validation.html#doc_tutorials_validation_md">this</a> tutorial next.</p>
<h4>Backends</h4>
<p>The plugins together with the configuration file form a <em>backend</em>. The backend determines how Elektra stores data below a mountpoint. You can examine every mountpoints backend by looking at the configuration below <code>system/elektra/mountpoints/&lt;mountpoint&gt;/</code>.</p>
<h2>Limitations</h2>
<p>One drawback of this approach is, that an application can bypass Elektra and change configuration files directly. If for example Elektra is configured to <a class="el" href="md_doc_tutorials_validation.html#doc_tutorials_validation_md">validate</a> new configuration values before updating them, this is something you do not want to happen.</p>
<p>Another drawback is that mounting is static. In a previous example we mounted the <code>/.git/config</code> file into <code>dir/git</code>. Now the <code>dir</code> namespace of every directory stores the configuration below <code>dir/git</code> in this directories <code>/.git/config</code> file. And this mountpoint is the same for all users and all directories. So you can't have different configuration files for the same mountpoints in other directories. Because of the same reason you cannot have different configuration file names or syntax for the same mountpoint in the <code>user</code> namespace.</p>
<p>This is one of the reasons why Elektra promotes this <a class="el" href="md_doc_help_elektra-key-names.html#doc_help_elektra-key-names_md">naming convention</a> for keys:</p>
<blockquote class="doxtable">
<p>Key names of software-applications should always start with: <code>/&lt;type&gt;/&lt;org&gt;/&lt;name&gt;/&lt;version&gt;/&lt;profile&gt;</code> </p>
</blockquote>
<blockquote class="doxtable">
<ul>
<li><b>type</b> can be <code>sw</code> (software), <code>hw</code> (hardware) or <code>elektra</code> (for internal configuration)</li>
<li><b>org</b> is an URL/organization name. E.g. <code>kde</code></li>
<li><b>name</b> the name of the component that has this configuration</li>
<li><b>version</b> is the major version number. E.g. If you version is 6.3.8 than this would be <code>#6</code></li>
<li><b>profile</b> is the name of the profile to be used. E.g.: <code>production</code>, <code>development</code>, <code>testing</code>, ... </li>
</ul>
</blockquote>
<p>Furthermore, one cannot simply change the configuration file format, because it must be one the application understands. Thus one loses quite some flexibility (for instance if this file format doesn't support meta keys, as already mentioned).</p>
<p>These limitations are the reasons why <a class="el" href="md_doc_help_elektra-glossary.html#doc_help_elektra-glossary_md">elektrifing</a> applications provides even better integration. Go on reading <a class="el" href="doc_tutorials_application-integration_md.html">how to elektrify your application</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
