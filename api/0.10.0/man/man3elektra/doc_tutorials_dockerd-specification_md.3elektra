.TH "doc_tutorials_dockerd-specification_md" 3elektra "Tue May 23 2023" "Version 0.10.0" "Elektra" \" -*- nroff -*-
.ad l
.nh
.SH NAME
doc_tutorials_dockerd-specification_md \- How to Write a Specification in Elektra for dockerd 
 
.SH "Overview"
.PP
.SS "Introduction"
In this tutorial you will learn how to interactively use the \fCSpecElektra\fP specification language and \fCkdb\fP to write a configuration specification for \fCdockerd\fP\&.
.SS "What you should already know"
.IP "\(bu" 2
Already know how to write a \fBspecification\fP
.PP
.SS "What youâ€™ll learn"
.IP "\(bu" 2
how to create and mount a specification using \fCkdb\fP
.IP "\(bu" 2
how to add keys with different types, defaults, enums, array specifications, wildcard specifications and examples to your specification and how to validate them
.PP
.SS "What you'll do"
.IP "\(bu" 2
use \fCkdb\fP to create and mount a specification for \fCdockerd\fP
.IP "\(bu" 2
define defaults, array / wildcard specifications, examples and checks for keys in the validation
.IP "\(bu" 2
use the specification as a starting point for customizing the configuration of installed applications
.PP
.SS "Scope"
In this tutorial we will introduce a possible specification for \fCdockerd\fP\&. Using \fCkdb\fP we will configure the specification\&.
.PP
.RS 4
NOTE: As the specification for dockerd is quite big we will only present a sample for the above mentioned metakeys and link to a full specification \fCdockerd-full-spec\fP\&. 
.RE
.PP
.SH "Getting Started"
.PP
Before we start just an overview of the structure:
.PP
.IP "\(bu" 2
Specification file location: \fC/docker/daemon\&.json\fP
.IP "\(bu" 2
Parent specification key: \fCspec:/sw/dockerd/dockerd/#0/current\fP
.PP
.SH "Specification Types (values)"
.PP
\fCElektra\fP supports multiple types which leads to a more flexible specification\&. See \fBtype plugin\fP for information about all the types that are supported\&.
.SH "Mount Setup"
.PP
We will be mounting an existing example \fCdockerd-spec\fP\&.
.SS "Step 1: Mount dockerd specification"
First you need to mount a specification file, in this case \fCdockerd\&.ini\fP to the \fCspec:/\fP namespace\&. You can define the path inside the \fCspec:/\fP namespace as \fC/sw/docker/dockerd/#0/current\fP, refer to \fCthe documentation\fP to find out more about constructing the name\&.
.PP
.PP
.nf
sudo kdb mount "$PWD/examples/spec/dockerd\&.ini" spec:/sw/docker/dockerd/#0/current ni
# RET: 0
.fi
.PP
.PP
.RS 4
NOTE: If you encounter any error saying that you have already mounted some specification with the same name you can run \fCsudo kdb umount spec:/sw/docker/dockerd/#0/current\fP and rerun the above command\&. 
.RE
.PP
.RS 4
Note: ni is the format which is used for the specification in the file\&. You can also choose to use json, then you need use yajl instead of ni\&. 
.RE
.PP
.SS "Step 2: Define a mountpoint"
Next you can define, that this specification uses a specific mountpoint for a concrete application configuration\&. So you can say the concrete configuration should be written to \fCdockerd\&.ini\fP\&.
.PP
.PP
.nf
kdb meta-set spec:/sw/dockerd/dockerd/#0/current mountpoint /docker/daemon\&.json
# RET: 0
.fi
.PP
.PP
Your \fCdockerd\&.ini\fP file should now contain the \fCmountpoint\fP metakey:
.PP
.RS 4
NOTE: Excerpt of \fCcat $(kdb file spec:/sw/docker/dockerd/#0/current)\fP\&. 
.RE
.PP
.PP
.nf
# ;Ni1
# ; Generated by the ni plugin using Elektra (see libelektra\&.org)\&.

# =

# []
#  meta:/mountpoint = /dockerd/daemon\&.json
.fi
.PP
.SS "Step 3: Define <tt>json</tt> as plugin"
Next we will define that our configuration should be written \fCjson\fP\&.
.PP
We can do this by running:
.PP
.PP
.nf
kdb meta-set spec:/sw/dockerd/dockerd/#0/current infos/plugin "yajl"
# RET: 0
.fi
.PP
.SS "Step 4: Do a specification mount"
.PP
.nf
sudo kdb spec-mount "/sw/docker/dockerd/#0/current" ni
# RET: 0
.fi
.PP
.PP
This specification mount makes sure that the paths where the concrete configuration should be (\fCdaemon\&.json\fP) are ready to fulfill our specification (\fCdockerd\&.ini\fP)\&. Be aware that different files get mounted for different namespaces\&. You've a specification file (\fCdockerd\&.ini\fP) for the \fCspec\fP-namespace and three files (\fCdaemon\&.json\fP) on different locations for the \fCdir\fP- \fCuser\fP- and \fCsystem\fP-namespaces\&.
.PP
You can see the files by providing the namespace as prefix to the \fCkdb file\fP command (each shows a different path):
.PP
.PP
.nf
kdb file system:/sw/docker/dockerd/#0/current
# /dockerd/daemon\&.json
.fi
.PP
.PP
.PP
.nf
kdb file user:/sw/docker/dockerd/#0/current
# STDOUT-REGEX: /dockerd/daemon\&.json
.fi
.PP
.PP
.PP
.nf
kdb file dir:/sw/docker/dockerd/#0/current
# STDOUT-REGEX: /dockerd/daemon\&.json
.fi
.PP
.PP
.RS 4
NOTE: The $PWD should equal the PWD where you run \fCsudo kdb mount '$PWD/examples/spec/dockerd\&.ini' spec:/sw/docker/dockerd/#0/current ni\fP\&. 
.RE
.PP
.RS 4
**_Note_**: The files only exist, when configuration values are stored there, i\&.e\&. they are created on the first \fCkdb set\fP and removed with the last \fCkdb rm\fP\&. 
.RE
.PP
For more information about namespaces in Elektra please see \fChere\fP, a tutorial about the topic is available \fChere\fP\&.
.SH "Writing specification for keys (manually)"
.PP
.RS 4
NOTE: All output we display for \fCcat $(kdb file spec:/sw/docker/dockerd/#0/current)\fP is an excerpt of the whole file output\&. 
.RE
.PP
In this example for \fCdockerd\fP we will be using 3 types of specifications:
.PP
.IP "\(bu" 2
Simple specification (type and description)
.IP "\(bu" 2
Enum specifications (for keys were only a set of possible options can be used)
.IP "\(bu" 2
Array and wildcard specifications (for keys where a list of possible options can be used)
.PP
.PP
As the \fCdockerd\fP specification is big we will just present one of each of the above mentioned specification types\&.
.PP
.RS 4
NOTE: In Elektra we use \fC/\fP instead of \fC-\fP to seperate key names\&. This results in a hierarchical structure of key names\&. This commands will automatically store the specification in the \fCdockerd-daemon\&.ni\fP specification file\&. 
.RE
.PP
.SS "Array specification"
.PP
.nf
[data/root]
meta:/type = string
meta:/description = Root directory of persistent Docker state
meta:/default = /var/lib/docker
.fi
.PP
.PP
In order to get the above specification we will need the following commands:
.PP
.PP
.nf
kdb meta-set spec:/sw/docker/dockerd/#0/current/data/root type "string"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/data/root description "Root directory of persistent Docker state"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/data/root default "/var/lib/docker"
# RET: 0
.fi
.PP
.PP
In case no \fCdata/root\fP key gets configured the value \fC/var/lib/docker\fP is used\&.
.PP
Let us verify that the metakeys have been set correctly:
.PP
.RS 4
NOTE: Excerpt of \fCcat $(kdb file spec:/sw/docker/dockerd/#0/current)\fP\&. 
.RE
.PP
.PP
.nf
cat $(kdb file spec:/sw/docker/dockerd/#0/current)

# [data/root]
#  meta:/type = string
#  meta:/description = Root directory of persistent Docker state
#  meta:/default = /var/lib/docker
.fi
.PP
.SS "Enum specification (for keys were only a set of possible options can be used)"
.PP
.nf
[default/cgroupns/mode]
meta:/description = Default mode for containers cgroup namespace
meta:/default = private
meta:/check/enum = #1
meta:/check/enum/#0 = host
meta:/check/enum/#1 = private
.fi
.PP
.PP
In order to get the above specification we will need the following commands:
.PP
.PP
.nf
kdb meta-set spec:/sw/docker/dockerd/#0/current/default/cgroupns/mode description "Default mode for containers cgroup namespace"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/cgroupns/mode default "private"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/cgroupns/mode check/enum "#1"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/cgroupns/mode check/enum/#0 "host"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/cgroupns/mode check/enum/#1 "private"
# RET: 0
.fi
.PP
.PP
With this configuration we have managed to allow two possible values for \fCdefault/cgroupns/mode\fP\&. The values are \fChost\fP and \fCprivate\fP\&. The default value if we do not set any configuration is \fCprivate\fP\&.
.PP
Let us verify that the metakeys have been set correctly:
.PP
.RS 4
NOTE: Excerpt of \fCcat $(kdb file spec:/sw/docker/dockerd/#0/current)\fP\&. 
.RE
.PP
.PP
.nf
cat $(kdb file spec:/sw/docker/dockerd/#0/current)

# [default/cgroupns/mode]
#  meta:/check/enum/#0 = host
#  meta:/check/enum/#1 = private
#  meta:/description = Default mode for containers cgroup namespace
#  meta:/default = private
#  meta:/check/enum = #1

# [data/root]
#  meta:/type = string
#  meta:/description = Root directory of persistent Docker state
#  meta:/default = /var/lib/docker
.fi
.PP
.SS "Wildcard specifications (for keys where a list of possible options can be used)"
.PP
.nf
[default/ulimits/_]
meta:/type = long
meta:/description = Default ulimits for containers
meta:/example = 64000
.fi
.PP
.PP
For this specification we want to allow an arbitrary number of \fCdefault ulimits\fP\&. The name of the \fCulimits\fP does not matter but all should have the same metakeys\&.
.PP
In order to get the above specification we will need following commands:
.PP
.PP
.nf
kdb meta-set spec:/sw/docker/dockerd/#0/current/default/ulimits/_ type "long"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/ulimits/_ description "Default ulimits for containers"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/ulimits/_ example "64000"
# RET: 0
.fi
.PP
.PP
The above specification will allow us to create any name below the \fCdefault/ulimits\fP key\&. The value needs to be a string\&. The sample value is \fC64000\fP\&.
.PP
Let us verify that the metakeys have been set correctly:
.PP
.RS 4
NOTE: Excerpt of \fCcat $(kdb file spec:/sw/docker/dockerd/#0/current)\fP\&. 
.RE
.PP
.PP
.nf
cat $(kdb file spec:/sw/docker/dockerd/#0/current)

# [default/ulimits/_]
#  meta:/type = long
#  meta:/example = 64000
#  meta:/description = Default ulimits for containers

# [default/cgroupns/mode]
#  meta:/check/enum/#0 = host
#  meta:/check/enum/#1 = private
#  meta:/description = Default mode for containers cgroup namespace
#  meta:/default = private
#  meta:/check/enum = #1

# [data/root]
#  meta:/type = string
#  meta:/description = Root directory of persistent Docker state
#  meta:/default = /var/lib/docker
.fi
.PP
.SS "Array specifications (for keys where a list of possible options can be used)"
.PP
.nf
[default/address/pools]
meta:/array/min = 0
meta:/description = Default address pools for node specific local networks (list)

[default/address/pools/#/base]
meta:/type = string
meta:/description = Ip address (ipv4) + subnet
meta:/example = 172\&.30\&.0\&.0/16

[default/address/pools/#/size]
meta:/type = short
meta:/description = Number of ip addresses in this pool with base
meta:/example = 24
.fi
.PP
.PP
The specification above shows the use of an array specification with the \fC#\fP character\&. We define the array to have a minimum value of \fC0\fP and arbitrary max length\&. We use \fCtype\fP, \fCdescription\fP and \fCexample\fP as metakeys on the keys beneath each array element\&.
.PP
This configuration above assures that we can configure \fCpools\fP with \fCbase\fP and \fCsize\fP\&.
.PP
It prevents a configuration like:
.PP
.PP
.nf
default/address/pools/#0/size = "test"
.fi
.PP
.PP
It will fail as \fCdefault/address/pools/#/size\fP is required to be of type \fCshort\fP when set\&.
.PP
In order to get the above specification we will need following commands:
.PP
.PP
.nf
kdb meta-set spec:/sw/docker/dockerd/#0/current/default/address/pools array/min "0"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/address/pools description "Default address pools for node specific local networks (list)"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/address/pools/#/base type "string"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/address/pools/#/base description "Ip address (ipv4) + subnet"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/address/pools/#/base example "172\&.30\&.0\&.0/16"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/address/pools/#/size type "short"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/address/pools/#/size description "Number of ip addresses in this pool with base"
# RET: 0

kdb meta-set spec:/sw/docker/dockerd/#0/current/default/address/pools/#/size example "24"
# RET: 0
.fi
.PP
.PP
The above specification defines that we can create array elements and each can have \fCbase\fP or \fCsize\fP\&.
.SH "Final specification code"
.PP
Your specification should be complete now! After adding all the keys that are necessary for our application, you can verify that all specification keys are contained by running:
.PP
.PP
.nf
cat $(kdb file spec:/sw/docker/dockerd/#0/current)
.fi
.PP
.PP
.RS 4
NOTE: We want display the output because it is too long to display (~ 400-500 lines)\&. 
.RE
.PP
.SH "Adding full example specification (with kdb import)"
.PP
The above tutorial has given a good overview of how to write a specification\&. You might want to add a full example specification for \fCdockerd\fP using \fCkdb import\fP\&. To do so, follow the next steps\&.
.PP
To make sure we don't run into errors we will clean up everything we have done by now\&.
.PP
.IP "1." 4
\fCsudo kdb rm -r spec:/sw/docker/dockerd/#0/current\fP
.IP "2." 4
\fCsudo kdb umount spec:/sw/docker/dockerd/#0/current\fP
.IP "3." 4
\fCrm -rf $PWD/dockerd\fP (make sure that you are in the same PWD as when you run the \fCsudo kdb mount\fP)
.PP
.PP
Now we are going to add an example of \fCdockerd-full-spec\fP\&.
.PP
Make sure you are in the root of the cloned \fClibelektra\fP repository:
.PP
.IP "1." 4
\fCsudo kdb mount '$PWD/dockerd/dockerd-daemon\&.ni' spec:/sw/docker/dockerd/#0/current ni\fP
.IP "2." 4
\fCkdb meta-set spec:/sw/dockerd/dockerd/#0/current mountpoint /dockerd/daemon\&.ni\fP
.IP "3." 4
\fCkdb meta-set spec:/sw/dockerd/dockerd/#0/current infos/plugin 'yajl'\fP
.IP "4." 4
\fCsudo kdb spec-mount '/sw/docker/dockerd/#0/current'\fP
.IP "5." 4
\fCsudo kdb import spec:/sw/docker/dockerd/#0/current ni < \&./examples/spec/dockerd\&.ini\fP
.PP
.PP
To verify that everything was created successfully, run:
.PP
.PP
.nf
cat $(kdb file spec:/sw/docker/dockerd/#0/current)
.fi
.PP
.PP
.RS 4
NOTE: We want display the output because it is too long to display (~ 400-500 lines)\&. 
.RE
.PP
.SH "Appendix (full specification)"
.PP
The full specification can be viewed at \fCdockerd-full-spec\fP\&. 
