<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Elektra: Understanding Namespaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Elektra
   &#160;<span id="projectnumber">0.8.19</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Understanding Namespaces </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Structure of the key database</h2>
<p>The <em>key database</em> of Elektra is <em>hierarchically structured</em>. This means that keys are organized similar to directories in a file system.</p>
<p>Lets add some keys to the database. To add a key we can use this command: </p><pre class="fragment">    kdb set &lt;key&gt; &lt;value&gt;
</pre><p>Now add the the key **/a** with the Value <b>Value 1</b> and the key **/b/c** with the Value <b>Value 2</b>: </p><pre class="fragment">    kdb set /a 'Value 1'
    kdb set /b/c 'Value 2'
</pre><div class="image">
<img src="tutorial_namespaces_hierarchy.svg" alt="tutorial_namespaces_hierarchy.svg"/>
<div class="caption">
Hierarchical structure of key database</div></div>
<p> Here you see the internal structure of the database after adding the keys **/a** and **/b/c**. For instance the key **/b/c** has the path **/** -&gt; <b>b</b> -&gt; <b>c</b>.</p>
<p>Note how the name of the key determines the path to its value.</p>
<p>You can use the file system analogy as a mnemonic to remember these commands (like the file system commands in your favorite operating system):</p><ul>
<li><code>kdb ls &lt;path&gt;</code> lists keys below <em>path</em></li>
<li><code>kdb rm &lt;key&gt;</code> removes a <em>key</em></li>
<li><code>kdb cp &lt;source&gt; &lt;dest&gt;</code> copies a key to another path</li>
<li><code>kdb get &lt;key&gt;</code> gets the value of <em>key</em></li>
</ul>
<p>For example <code>kdb get /b/c</code> should return <code>Value 2</code> now, if you set the values before.</p>
<h2>Namespaces</h2>
<p>Now we abandon the file system analogy and introduce the concept of <em>namespaces</em>.</p>
<p>Every key in Elektra belongs to one of these namespaces:</p><ul>
<li><b>spec</b> for specification of other keys</li>
<li><b>proc</b> for in-memory keys (e.g. command-line)</li>
<li><b>dir</b> for dir keys in current working directory</li>
<li><b>user</b> for user keys in home directory</li>
<li><b>system</b> for system keys in /etc or /</li>
</ul>
<p>All namespaces save their keys in a <em>separate hierarchical structure</em> from the other namespaces.</p>
<p>But when we set the keys **/a** and **/b/c** before we didn't provide a namespace. So I hear you asking, if every key has to belong to a namespace, where are the keys? They are in the <em>user</em> namespace, as you can verify with: </p><pre class="fragment">    kdb ls user
    # user/a
    # user/b/c
</pre><p>When we don't provide a namespace Elektra assumes a default namespace, which should be <b>user</b> for non-root users. So if you are a normal user the command <code>kdb set /b/c 'Value 2'</code> was synonymous to <code>kdb set user/b/c 'Value 2'</code>.</p>
<p>At this point the key database should have this structure: </p><div class="image">
<img src="tutorial_namespaces_namespaces.svg" alt="tutorial_namespaces_namespaces.svg"/>
<div class="caption">
Elektras namespaces</div></div>
 <h4>Cascading keys</h4>
<p>Another question you may ask yourself now is, what happens if we lookup a key without providing a namespace. So let us retrieve the key **/b/c** with the -v flag in order to make <em>kdb</em> more talkative. </p><pre class="fragment">    kdb get -v /b/c
    # got 3 keys
    #  searching spec/b/c, found: &lt;nothing&gt;, options: KDB_O_CALLBACK
    #  searching proc/b/c, found: &lt;nothing&gt;, options:
    #  searching dir/b/c, found: &lt;nothing&gt;, options:
    #  searching user/b/c, found: user/b/c, options:
    # The resulting keyname is user/b/c
    # Value 2
</pre><p>Here you see how Elektra searches all namespaces for matching keys in this order: <b>spec</b>, <b>proc</b>, <b>dir</b>, <b>user</b> and finally <b>system</b></p>
<p>If a key is found in a namespace, it masks the key in all subsequent namespaces, which is the reason why the system namespace isn't searched. Finally the virtual key **/b/c** gets resolved to the real key <b>user/b/c</b>. Because of the way a key without a namespace is retrieved, we call keys, that start with '**/**' <b>cascading keys</b>. You can find out more about cascading lookups <a class="el" href="doc_tutorials_cascading_md.html">here</a>.</p>
<p>Having namespaces enables both admins and users to set specific parts of the application's configuration, as you will see in the following example.</p>
<h2>How it works on the command line (kdb)</h2>
<p>Let's say your app requires the following configuration data:</p>
<ul>
<li>**/sw/org/myapp/policy** - a security policy to be applied</li>
<li>**/sw/org/myapp/default_dir** - a place where the application stores its data per default</li>
</ul>
<p>We now want to enter this configuration by using the <b>kdb</b> tool.</p>
<p>The security policy will most probably be set by your system administrator. So she enters </p><pre class="fragment">    sudo kdb set "system/sw/org/myapp/policy" "super-high-secure"
</pre><p>The key <b>system/app/policy</b> will be stored in the system namespace (probably at /etc/kdb on a Linux/UNIX system).</p>
<p>Then the user sets his app directory by issuing: </p><pre class="fragment">    kdb set "user/sw/org/myapp/default_dir" "/home/user/.myapp"
</pre><p>This key will be stored in the user namespace (at the home directory) and thus may vary from user to user. Elektra loads the value for the current user and passes it to the application.</p>
<p>You can also retrieve the values in the command line by using the <b>kdb</b> tool: </p><pre class="fragment">    kdb get system/sw/org/maypp
</pre><p><em>Cascading keys</em> are keys that start with **/** and are a way of making key lookups much easier. Let's say you want to load the configuration from the example above. You do not need to search every namespace by yourself. Just make a lookup for **/sw/org/myapp**, like this: </p><pre class="fragment">    kdb get /sw/org/myapp/policy
    kdb get /sw/org/myapp/default_dir
</pre><p>When using cascading key the best key will be searched at runtime. If you are only interested in the system key, you would use: </p><pre class="fragment">    kdb get system/sw/org/myapp/policy
</pre><h2>How it works in C</h2>
<p>The idea is to call <b><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1" title="Retrieve keys in an atomic and universal way. ">kdbGet()</a></b> to retrieve the root key for the application. Looking for a specific part of the configuration is done by <b><a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a></b>.</p>
<p>The documentation provides the following example to illustrate the intended usage. If you want to use a <em>cascading key</em> (starting with /), you use the <b><a class="el" href="group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004" title="Look for a Key contained in ks that matches the name of the key. ">ksLookup()</a></b> or <b><a class="el" href="group__keyset.html#gad2e30fb6d4739d917c5abb2ac2f9c1a1" title="Convenience method to look for a Key contained in ks that matches name. ">ksLookupByName()</a></b> function (also see <a href="http://doc.libelektra.org/api/current/html/group__keyset.html#gaa34fc43a081e6b01e4120daa6c112004">doxygen</a> ): </p><pre class="fragment">    if (kdbGet(handle, myConfig,  p=keyNew("/sw/org/myapp", KEY_END)) == -1)
            errorHandler ("Could not get Keys", parentKey);
    if ((myKey = ksLookupByName (myConfig, "/sw/org/myapp/mykey", 0)) == NULL)
            errorHandler ("Could not Lookup Key");</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
