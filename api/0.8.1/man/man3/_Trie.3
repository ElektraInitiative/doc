.TH "_Trie" 3 "Sat Jun 9 2012" "Version 0.8.1" "Elektra" \" -*- nroff -*-
.ad l
.nh
.SH NAME
_Trie \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <kdbprivate.h>\fP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "struct \fB_Trie\fP * \fBchildren\fP [MAX_UCHAR]"
.br
.ti -1c
.RI "char * \fBtext\fP [MAX_UCHAR]"
.br
.ti -1c
.RI "size_t \fBtextlen\fP [MAX_UCHAR]"
.br
.ti -1c
.RI "\fBBackend\fP * \fBvalue\fP [MAX_UCHAR]"
.br
.ti -1c
.RI "\fBBackend\fP * \fBempty_value\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The private trie structure.
.PP
A trie is a data structure which can handle the longest prefix matching very fast. This is exactly what needs to be done when using \fBkdbGet()\fP and \fBkdbSet()\fP in a hierachy where backends are mounted - you need the backend mounted closest to the parentKey. 
.SH "Field Documentation"
.PP 
.SS "struct \fB_Trie\fP* \fB_Trie::children\fP[MAX_UCHAR]"The children building up the trie recursively 
.SS "\fBBackend\fP* \fB_Trie::empty_value\fP"Pointer to a backend for the empty string '' 
.SS "char* \fB_Trie::text\fP[MAX_UCHAR]"Text identifying this node 
.SS "size_t \fB_Trie::textlen\fP[MAX_UCHAR]"Length of the text 
.SS "\fBBackend\fP* \fB_Trie::value\fP[MAX_UCHAR]"Pointer to a backend 

.SH "Author"
.PP 
Generated automatically by Doxygen for Elektra from the source code.
