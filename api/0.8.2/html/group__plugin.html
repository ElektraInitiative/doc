<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Elektra: Plugins :: Elektra framework for plugins</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Plugins :: Elektra framework for plugins</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#ga8dd092048e972a3f0c9c9f54eb41576e">elektraPluginExport</a> (const char *pluginName,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__KeySet.html">KeySet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#ga644bead796506c172817724051c977c9">elektraPluginGetConfig</a> (<a class="el" href="struct__Plugin.html">Plugin</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#gaf4b941a52ff55d0ca2a9158d90208ef2">elektraPluginSetData</a> (<a class="el" href="struct__Plugin.html">Plugin</a> *plugin, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#gaafcf3216b46292f222b8cc7828b4dd20">elektraPluginGetData</a> (<a class="el" href="struct__Plugin.html">Plugin</a> *plugin)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#ga1e2cbea1275fc0d39a00a74eb69e12d8">elektraDocOpen</a> (<a class="el" href="struct__Plugin.html">Plugin</a> *handle, <a class="el" href="struct__Key.html">Key</a> *errorKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#gafb66a15abe15f79c9c5b3a928b42147d">elektraDocClose</a> (<a class="el" href="struct__Plugin.html">Plugin</a> *handle, <a class="el" href="struct__Key.html">Key</a> *errorKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#gacb69f3441c6d84241b4362f958fbe313">elektraDocGet</a> (<a class="el" href="struct__Plugin.html">Plugin</a> *handle, <a class="el" href="struct__KeySet.html">KeySet</a> *returned, <a class="el" href="struct__Key.html">Key</a> *parentKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#gae65781a1deb34efc79c8cb9d9174842c">elektraDocSet</a> (<a class="el" href="struct__Plugin.html">Plugin</a> *handle, <a class="el" href="struct__KeySet.html">KeySet</a> *returned, <a class="el" href="struct__Key.html">Key</a> *parentKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__plugin.html#gabe78724d2d477eef39997fd9b85bff16">ELEKTRA_PLUGIN_EXPORT</a> (doc)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" id="history"></a>
History</h2>
<dl class="since"><dt><b>Since:</b></dt><dd>Since version 0.4.9, Elektra can dynamically load different key storage plugins.</dd>
<dd>
Since version 0.7.0 Elektra can have multiple backends, mounted at any place in the key database.</dd>
<dd>
Since version 0.8.0 Elektra backends are composed out of multiple plugins.</dd></dl>
<h2><a class="anchor" id="overview"></a>
Overview</h2>
<p>There are different types of plugins for different concerns. The types of plugins handled in this document:</p>
<ul>
<li>file storage plugins (also called just storage plugins here)</li>
<li>filter plugins</li>
</ul>
<p>See <a href="http://www.libelektra.org/ftp/elektra/thesis.pdf">http://www.libelektra.org/ftp/elektra/thesis.pdf</a> for an detailed explanation and description of other types of plugins.</p>
<p>A plugin can implement anything related to configuration. There are 5 possible entry points, as described in this document:</p>
<ul>
<li><a class="el" href="group__plugin.html#ga1e2cbea1275fc0d39a00a74eb69e12d8">elektraDocOpen()</a></li>
<li><a class="el" href="group__plugin.html#gafb66a15abe15f79c9c5b3a928b42147d">elektraDocClose()</a></li>
<li><a class="el" href="group__plugin.html#gacb69f3441c6d84241b4362f958fbe313">elektraDocGet()</a></li>
<li><a class="el" href="group__plugin.html#gae65781a1deb34efc79c8cb9d9174842c">elektraDocSet()</a></li>
<li>elektraDocError() (not needed by storage or filter plugins)</li>
</ul>
<p>Depending of the type of plugin you need not to implement all of them.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>that the Doc within the name is just because the plugin described here is called doc (see src/plugins/doc/doc.c). Always replace Doc with the name of the plugin you are going to implement.</dd></dl>
<p>See the descriptions below what each of them is supposed to do.</p>
<h3><a class="anchor" id="storage"></a>
Storage Plugins</h3>
<p>A filter plugin is a plugin which already receives some keys. It may process or change the keyset. Or it may reject specific keysets which do not meet some criteria.</p>
<h3><a class="anchor" id="filter"></a>
Filter Plugins</h3>
<p>A storage plugin gets an empty keyset and constructs the information out from a file.</p>
<p>Other persistent storage then a file is not handled within this document because it involves many other issues. For files the resolver plugin already takes care for transactions and rollback.</p>
<h2><a class="anchor" id="error"></a>
Error and Wanrings</h2>
<p>In any case of trouble, use ELEKTRA_SET_ERROR and return with -1. You might add warnings with ELEKTRA_ADD_WARNING if you think it is appropriate. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabe78724d2d477eef39997fd9b85bff16"></a><!-- doxytag: member="plugins/doc/doc.c::ELEKTRA_PLUGIN_EXPORT" ref="gabe78724d2d477eef39997fd9b85bff16" args="(doc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Plugin.html">Plugin</a>* ELEKTRA_PLUGIN_EXPORT </td>
          <td>(</td>
          <td class="paramtype">doc&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All KDB methods implemented by the plugin can have random names, except ELEKTRA_PLUGIN_EXPORT. This is the single symbol that will be looked up when loading the plugin, and the first method of the backend implementation that will be called.</p>
<p>You need to use a macro so that both dynamic and static loading of the plugin works.</p>
<p>The first paramter is the name of the plugin. Then every plugin should have: <code>ELEKTRA_PLUGIN_OPEN</code>, <code>ELEKTRA_PLUGIN_CLOSE</code>, <code>ELEKTRA_PLUGIN_GET</code>, <code>ELEKTRA_PLUGIN_SET</code> and optionally <code>ELEKTRA_PLUGIN_ERROR</code>.</p>
<p>The list is terminated with <code>ELEKTRA_PLUGIN_END</code>.</p>
<p>You must use static "char arrays" in a read only segment. Don't allocate storage, it won't be freed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Plugin </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__plugin.html#ga8dd092048e972a3f0c9c9f54eb41576e">elektraPluginExport()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafb66a15abe15f79c9c5b3a928b42147d"></a><!-- doxytag: member="plugins/doc/doc.c::elektraDocClose" ref="gafb66a15abe15f79c9c5b3a928b42147d" args="(Plugin *handle, Key *errorKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraDocClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>errorKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finalize the plugin.</p>
<p>Called prior to unloading the plugin dynamic module. Should ensure that no functions or static/global variables from the module will ever be accessed again.</p>
<p>Make sure to free all memory that your plugin requested at runtime.</p>
<p>After this call, libelektra.so will unload the plugin library, so this is the point to shutdown any affairs with the storage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>contains internal information of the plugin </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorKey</em>&nbsp;</td><td>is needed to add warnings using ELEKTRA_ADD_WARNING</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__kdb.html#gadb54dc9fda17ee07deb9444df745c96f">kdbClose()</a> </dd>
<dd>
<a class="el" href="group__plugin.html#gaafcf3216b46292f222b8cc7828b4dd20">elektraPluginGetData()</a>, <a class="el" href="group__plugin.html#gaf4b941a52ff55d0ca2a9158d90208ef2">elektraPluginSetData()</a> and <a class="el" href="group__plugin.html#ga644bead796506c172817724051c977c9">elektraPluginGetConfig()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacb69f3441c6d84241b4362f958fbe313"></a><!-- doxytag: member="plugins/doc/doc.c::elektraDocGet" ref="gacb69f3441c6d84241b4362f958fbe313" args="(Plugin *handle, KeySet *returned, Key *parentKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraDocGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KeySet.html">KeySet</a> *&nbsp;</td>
          <td class="paramname"> <em>returned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>parentKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve information from a permanent storage to construct a keyset.</p>
<h2><a class="anchor" id="intro"></a>
Introduction</h2>
<p>The <a class="el" href="group__plugin.html#gacb69f3441c6d84241b4362f958fbe313">elektraDocGet()</a> function handle everything related to receiving keys.</p>
<h3><a class="anchor" id="storage"></a>
Storage Plugins</h3>
<p>For storage plugins the filename is written in the value of the parentKey. So the first task of the plugin is to open that file. Then it should parse its content and construct a keyset with all information of that file.</p>
<p>You need to be able to reconstruct the same file with the information of the keyset. So be sure to copy all comments, whitespaces and so on into some metadata of the keys. Otherwise the information is lost after writing the file the next time.</p>
<p>Now lets look at an example how the typical <a class="el" href="group__plugin.html#gacb69f3441c6d84241b4362f958fbe313">elektraDocGet()</a> might be implemented. To explain we introduce some pseudo functions which do all the work with the storage (which is of course 90% of the work for a real plugin):</p>
<ul>
<li>parse_key will parse a key and a value from an open file handle</li>
</ul>
<p>The typical loop for a storage plugin will be like: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="group__plugin.html#gacb69f3441c6d84241b4362f958fbe313">elektraDocGet</a>(<a class="code" href="struct__Plugin.html">Plugin</a> *handle, <a class="code" href="struct__KeySet.html">KeySet</a> *returned, <span class="keyword">const</span> <a class="code" href="struct__Key.html">Key</a> *parentKey)
{
        <span class="comment">// contract handling, see below</span>

        FILE *fp = fopen (keyString(parentKey), <span class="stringliteral">&quot;r&quot;</span>);
        <span class="keywordtype">char</span> *key;
        <span class="keywordtype">char</span> *value;

        <span class="keywordflow">while</span> ((n = parse_key(fp, &amp;key, &amp;value)) &gt;= 1)
        {
                <a class="code" href="struct__Key.html">Key</a> *read = <a class="code" href="group__key.html#gaf6893c038b3ebee90c73a9ea8356bebf">keyNew</a>(0);
                <span class="keywordflow">if</span> (<a class="code" href="group__keyname.html#ga7699091610e7f3f43d2949514a4b35d9">keySetName</a>(read, key) == -1)
                {
                        fclose (fp);
                        <a class="code" href="group__key.html#ga3df95bbc2494e3e6703ece5639be5bb1">keyDel</a> (read);
                        ELEKTRA_SET_ERROR(59, parentKey, key);
                        <span class="keywordflow">return</span> -1;
                }
                <a class="code" href="group__keyvalue.html#ga622bde1eb0e0c4994728331326340ef2">keySetString</a>(read, value);

                <a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a> (returned, read);
                free (key);
                free (value);
        }

        <span class="keywordflow">if</span> (feof(fp) == 0)
        {
                fclose (fp);
                ELEKTRA_SET_ERROR(60, parentKey, <span class="stringliteral">&quot;not at the end of file&quot;</span>);
                <span class="keywordflow">return</span> -1;
        }

        fclose (fp);

        <span class="keywordflow">return</span> 1; <span class="comment">// success</span>
}
</pre></div><h3><a class="anchor" id="filter"></a>
Filter Plugins</h3>
<p>For filter plugins the actual task is rather unspecified. You basically can do anything with the keyset. To get roundtrip properties you might want to undo any changes you did in <a class="el" href="group__plugin.html#gae65781a1deb34efc79c8cb9d9174842c">elektraDocSet()</a>.</p>
<p>The pseudo functions (which do the real work) are:</p>
<ul>
<li>do_action() which processes every key in this filter</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="group__plugin.html#gacb69f3441c6d84241b4362f958fbe313">elektraDocGet</a>(<a class="code" href="struct__Plugin.html">Plugin</a> *handle, <a class="code" href="struct__KeySet.html">KeySet</a> *returned, <a class="code" href="struct__Key.html">Key</a> *parentKey)
{
        <span class="comment">// contract handling</span>

        <a class="code" href="struct__Key.html">Key</a> *k;
        <a class="code" href="group__keyset.html#gabe793ff51f1728e3429c84a8a9086b70">ksRewind</a> (returned);
        <span class="keywordflow">while</span> ((k = <a class="code" href="group__keyset.html#ga317321c9065b5a4b3e33fe1c399bcec9">ksNext</a> (returned)) != 0)
        {
                do_action(k);
        }

        <span class="keywordflow">return</span> 1; <span class="comment">// success</span>
}
</pre></div><h2><a class="anchor" id="conditions"></a>
Conditions</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>needs some updates</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The caller <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet()</a> will make sure before you are called that the parentKey:<ul>
<li>is a valid key (means that it is a system or user key).</li>
<li>is below (see <a class="el" href="group__keytest.html#ga03332b5d97c76a4fd2640aca4762b8df">keyIsBelow()</a>) your mountpoint and that your plugin is responsible for it. and that the returned:</li>
<li>is a valid keyset.</li>
<li>has <code>all</code> keys with the flag KEY_FLAG_SYNC set.</li>
<li>contains only valid keys direct below (see <a class="el" href="group__keytest.html#ga4f175aafd98948ce6c774f3bd92b72ca">keyIsDirectBelow()</a>) your parentKey. That also means, that the parentKey will not be in that keyset.</li>
<li>is in a sorted order, see ksSort(). and that the handle:<ul>
<li>is a valid KDB for your plugin.</li>
<li>that elektraPluginhGetBackendHandle() contains the same handle for lifetime <a class="el" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca">kdbOpen()</a> until elektraPluginClose() was called.</li>
</ul>
</li>
</ul>
</dd>
<dd>
The caller <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet()</a> will make sure that afterwards you were called, whenever the user requested it with the options, that:<ul>
<li>hidden keys they will be thrown away.</li>
<li>dirs or only dirs <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet()</a> will remove the other.</li>
<li>you will be called again recursively with all subdirectories.</li>
<li>the keyset will be sorted when needed.</li>
<li>the keys in returned having KEY_FLAG_SYNC will be sorted out.</li>
</ul>
</dd></dl>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>There are no global variables and <a class="el" href="group__plugin.html#gaf4b941a52ff55d0ca2a9158d90208ef2">elektraPluginSetData()</a> stores all information. The handle is to be guaranteed to be the same if it is the same plugin.</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The keyset <code>returned</code> has the <code>parentKey</code> and all keys direct below (<a class="el" href="group__keytest.html#ga4f175aafd98948ce6c774f3bd92b72ca">keyIsDirectBelow()</a>) with all information from the storage. Make sure to return all keys, all directories and also all hidden keys. If some of them are not wished, the caller <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet()</a> will drop these keys, see above.</dd></dl>
<h2><a class="anchor" id="updating"></a>
Updating</h2>
<p>To get all keys out of the storage over and over again can be very inefficient. You might know a more efficient method to know if the key needs update or not, e.g. by stating it or by an external time stamp info. For file storage plugins this is automatically done for you. For other types (e.g. databases) you need to implement your own resolver doing this.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If any calls you use change errno, make sure to restore the old errno.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet()</a> for caller.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>contains internal information of <a class="el" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca">opened </a> key database </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>returned</em>&nbsp;</td><td>contains a keyset where the function need to append the keys got from the storage. There might be also some keys inside it, see conditions. You may use them to support efficient updating of keys, see <a class="el" href="group__plugin.html#updating">Updating</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentKey</em>&nbsp;</td><td>contains the information below which key the keys should be gotten.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success </dd>
<dd>
0 when nothing was to do </dd>
<dd>
-1 on failure, the current key in returned shows the position. use ELEKTRA_SET_ERROR of kdberrors.h to define the error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e2cbea1275fc0d39a00a74eb69e12d8"></a><!-- doxytag: member="plugins/doc/doc.c::elektraDocOpen" ref="ga1e2cbea1275fc0d39a00a74eb69e12d8" args="(Plugin *handle, Key *errorKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraDocOpen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>errorKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the plugin.</p>
<p>This is the first method called after dynamically loading this plugin.</p>
<p>This method is responsible for:</p>
<ul>
<li>plugin's specific configuration gathering</li>
<li>all plugin's internal structs initialization</li>
<li>if unavoidable initial setup of all I/O details such as opening a file, connecting to a database, setup connection to a server, etc.</li>
</ul>
<p>You may also read the configuration you can get with <a class="el" href="group__plugin.html#ga644bead796506c172817724051c977c9">elektraPluginGetConfig()</a> and transform it into other structures used by your plugin.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The plugin must not have any global variables. If you do Elektra will not be threadsafe. It is not a good assumption that your plugin will be opened only once.</dd></dl>
<p>Instead you can use <a class="el" href="group__plugin.html#gaafcf3216b46292f222b8cc7828b4dd20">elektraPluginGetData()</a> and <a class="el" href="group__plugin.html#gaf4b941a52ff55d0ca2a9158d90208ef2">elektraPluginSetData()</a> to store and get any information related to your plugin.</p>
<p>The correct substitute for global variables will be: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>_GlobalData{ <span class="keywordtype">int</span> global; };
<span class="keyword">typedef</span> <span class="keyword">struct </span>_GlobalData GlobalData;
<span class="keywordtype">int</span> <a class="code" href="group__plugin.html#ga1e2cbea1275fc0d39a00a74eb69e12d8">elektraDocOpen</a>(<a class="code" href="struct__Plugin.html">Plugin</a> *handle, <a class="code" href="struct__Key.html">Key</a> *errorKey)
{
        GlobalData *data;
        data=malloc(<span class="keyword">sizeof</span>(GlobalData));
        data.global = 20;
        <a class="code" href="group__plugin.html#gaf4b941a52ff55d0ca2a9158d90208ef2">elektraPluginSetData</a>(handle,data);
}
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Make sure to free everything you allocate here within <a class="el" href="group__plugin.html#gafb66a15abe15f79c9c5b3a928b42147d">elektraDocClose()</a>.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>contains internal information of <a class="el" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca">opened </a> key database </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorKey</em>&nbsp;</td><td>defines an errorKey </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca">kdbOpen()</a> which will call <a class="el" href="group__plugin.html#ga1e2cbea1275fc0d39a00a74eb69e12d8">elektraDocOpen()</a> </dd>
<dd>
<a class="el" href="group__plugin.html#gaafcf3216b46292f222b8cc7828b4dd20">elektraPluginGetData()</a>, <a class="el" href="group__plugin.html#gaf4b941a52ff55d0ca2a9158d90208ef2">elektraPluginSetData()</a> and <a class="el" href="group__plugin.html#ga644bead796506c172817724051c977c9">elektraPluginGetConfig()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae65781a1deb34efc79c8cb9d9174842c"></a><!-- doxytag: member="plugins/doc/doc.c::elektraDocSet" ref="gae65781a1deb34efc79c8cb9d9174842c" args="(Plugin *handle, KeySet *returned, Key *parentKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int elektraDocSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__KeySet.html">KeySet</a> *&nbsp;</td>
          <td class="paramname"> <em>returned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Key.html">Key</a> *&nbsp;</td>
          <td class="paramname"> <em>parentKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Store a keyset permanently.</p>
<p>This function does everything related to set and remove keys in a plugin. There is only one function for that purpose to make implementation and locking much easier.</p>
<p>The keyset <code>returned</code> was filled in with information from the application using elektra and the task of this function is to store it in a permanent way so that a subsequent call of elektraPluginGet() can rebuild the keyset as it was before. See the live cycle of a comment to understand: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> usercode (<a class="code" href="struct__Key.html">Key</a> *key)
{
        <a class="code" href="group__keyvalue.html#ga8863a877a84fa46e6017fe72e49b89c1">keySetComment</a> (key, <span class="stringliteral">&quot;mycomment&quot;</span>); <span class="comment">// the usercode stores a comment for the key</span>
        <a class="code" href="group__keyset.html#gaa5a1d467a4d71041edce68ea7748ce45">ksAppendKey</a>(keyset, key); <span class="comment">// append the key to the keyset</span>
        <a class="code" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet</a> (handle, keyset, 0, 0);
}

<span class="comment">// so now kdbSet is called</span>
<span class="keywordtype">int</span> <a class="code" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet</a>(<a class="code" href="struct__KDB.html">KDB</a> *handle, <a class="code" href="struct__KeySet.html">KeySet</a> *keyset, <a class="code" href="struct__Key.html">Key</a> *parentKey, options)
{
        <span class="comment">// find appropriate plugin</span>
        elektraPluginSet (handle, keyset, 0); <span class="comment">// the keyset with the key will be passed to this function</span>
}

<span class="comment">// so now elektraPluginSet(), which is the function described here, is called</span>
elektraPluginSet(<a class="code" href="struct__KDB.html">KDB</a> *handle, <a class="code" href="struct__KeySet.html">KeySet</a> *keyset, <a class="code" href="struct__Key.html">Key</a> *parentKey)
{
        <span class="comment">// the task of elektraPluginSet is now to store the comment</span>
        <a class="code" href="struct__Key.html">Key</a> *key = <a class="code" href="group__keyset.html#ga4287b9416912c5f2ab9c195cb74fb094">ksCurrent</a> (keyset); <span class="comment">// get out the key where the user set the comment before</span>
        <span class="keywordtype">char</span> *comment = allocate(size);
        <a class="code" href="group__keyvalue.html#gafb89735689929ff717cc9f2d0d0b46a2">keyGetComment</a> (key, comment, size);
        savetodisc (comment);
}
</pre></div><p> Of course not only the comment, but all information of every key in the keyset <code>returned</code> need to be stored permanetly. So this specification needs to give an exhaustive list of information present in a key.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The keyset <code>returned</code> holds all keys which must be saved permanently for this keyset. The keyset is sorted and rewinded. All keys having children must be true for <a class="el" href="group__keytest.html#gac0a10c602d52a35f81347e8a32312017">keyIsDir()</a>.</dd>
<dd>
The <code>parentKey</code> is the key which is the ancestor for all other keys in the keyset. The first key of the keyset <code>returned</code> has the same keyname. The parentKey is below the mountpoint, see kdbhGetMountpoint().</dd>
<dd>
The caller kdbSet will fulfill following parts:<ul>
<li>If the user does not want hidden keys they will be thrown away. All keys in <code>returned</code> need to be stored permanently.</li>
<li>If the user does not want dirs or only dirs <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet()</a> will remove the other.</li>
<li>Sorting of the keyset. It is not important in which order the keys are appended. So make sure to set all keys, all directories and also all hidden keys. If some of them are not wished, the caller <a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> will sort them out.</li>
</ul>
</dd></dl>
<dl class="invariant"><dt><b>Invariant:</b></dt><dd>There are no global variables and kdbhGetBackendData() only stores information which can be regenerated any time. The handle is the same when it is the same plugin.</dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The information of the keyset <code>returned</code> is stored permanently.</dd></dl>
<p>Lock your permanent storage in an exclusive way, no access of a concurrent elektraPluginSet_plugin() or <a class="el" href="group__kdb.html#ga28e385fd9cb7ccfe0b2f1ed2f62453a1">kdbGet()</a> is possible and these methods block until the function has finished. Otherwise declare kdbcGetnoLock().</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__kdb.html#ga11436b058408f83d303ca5e996832bcf">kdbSet()</a> for caller.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>contains internal information of <a class="el" href="group__kdb.html#ga6808defe5870f328dd17910aacbdc6ca">opened </a> key database </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>returned</em>&nbsp;</td><td>contains a keyset with relevant keys </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parentKey</em>&nbsp;</td><td>contains the information where to set the keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>When everything works gracefully return the number of keys you set. The cursor position and the keys remaining in the keyset are not important.</dd>
<dd>
Return 0 on success with no changed key in database</dd>
<dd>
Return -1 on failure.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If any calls you use change errno, make sure to restore the old errno.</dd></dl>
<dl class="err"><dt><b><a class="el" href="err.html#_err000001">Error:</a></b></dt><dd>In normal execution cases a positive value will be returned. But in some cases you are not able to set keys and have to return -1. If you declare kdbcGetnoError() you are done, but otherwise you have to set the cause of the error. (Will be added with 0.7.1)</dd></dl>
<p>You also have to make sure that <a class="el" href="group__keyset.html#gaffe507ab9281c322eb16c3e992075d29">ksGetCursor()</a> shows to the position where the error appeared. </p>

</div>
</div>
<a class="anchor" id="ga8dd092048e972a3f0c9c9f54eb41576e"></a><!-- doxytag: member="plugin.c::elektraPluginExport" ref="ga8dd092048e972a3f0c9c9f54eb41576e" args="(const char *pluginName,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Plugin.html">Plugin</a>* elektraPluginExport </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pluginName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function must be called by a plugin's elektraPluginSymbol() to define the plugin's methods that will be exported.</p>
<p>See <a class="el" href="group__plugin.html#gabe78724d2d477eef39997fd9b85bff16">ELEKTRA_PLUGIN_EXPORT()</a> how to use it for plugins.</p>
<p>The order and number of arguments are flexible (as in <a class="el" href="group__key.html#gaf6893c038b3ebee90c73a9ea8356bebf">keyNew()</a> and <a class="el" href="group__keyset.html#ga671e1aaee3ae9dc13b4834a4ddbd2c3c">ksNew()</a>) to let libelektra.so evolve without breaking its ABI compatibility with plugins. So for each method a plugin must export, there is a flag defined by plugin_t. Each flag tells kdbPluginExport() which method comes next. A plugin can have no implementation for a few methods that have default inefficient high-level implementations and to use these defaults, simply don't pass anything to kdbPluginExport() about them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pluginName</em>&nbsp;</td><td>a simple name for this plugin </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an object that contains all plugin informations needed by libelektra.so </dd></dl>

</div>
</div>
<a class="anchor" id="ga644bead796506c172817724051c977c9"></a><!-- doxytag: member="plugin.c::elektraPluginGetConfig" ref="ga644bead796506c172817724051c977c9" args="(Plugin *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__KeySet.html">KeySet</a>* elektraPluginGetConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the configuration of that plugin.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>a pointer to the plugin</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>keyset to the configuration for that plugin </dd></dl>

</div>
</div>
<a class="anchor" id="gaafcf3216b46292f222b8cc7828b4dd20"></a><!-- doxytag: member="plugin.c::elektraPluginGetData" ref="gaafcf3216b46292f222b8cc7828b4dd20" args="(Plugin *plugin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* elektraPluginGetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td>
          <td class="paramname"> <em>plugin</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a pointer to any plugin related data stored before.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin</em>&nbsp;</td><td>a pointer to the plugin </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the data </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4b941a52ff55d0ca2a9158d90208ef2"></a><!-- doxytag: member="plugin.c::elektraPluginSetData" ref="gaf4b941a52ff55d0ca2a9158d90208ef2" args="(Plugin *plugin, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void elektraPluginSetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__Plugin.html">Plugin</a> *&nbsp;</td>
          <td class="paramname"> <em>plugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Store a pointer to any plugin related data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plugin</em>&nbsp;</td><td>a pointer to the plugin </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the pointer to the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Jun 18 2012 12:41:41 for Elektra by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
